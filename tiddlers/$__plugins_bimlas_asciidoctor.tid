author: bimlas
core-version: >=5.0.0
created: 20190411172159326
dependents: 
description: Asciidoctor parser
list: readme usage
modified: 20190411172159326
plugin-type: plugin
source: https://gitlab.com/bimlas/tw5-asciidoctor
title: $:/plugins/bimlas/asciidoctor
type: application/json
version: 1.0.0

{
    "tiddlers": {
        "$:/plugins/bimlas/asciidoctor/EditorToolbar/bold": {
            "title": "$:/plugins/bimlas/asciidoctor/EditorToolbar/bold",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/bold",
            "caption": "{{$:/language/Buttons/Bold/Caption}} (Asciidoctor)",
            "description": "{{$:/language/Buttons/Bold/Hint}}",
            "condition": "[<targetTiddler>type[text/asciidoc]]",
            "shortcuts": "((bold))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"wrap-selection\"\n\tprefix=\"*\"\n\tsuffix=\"*\"\n/>\n"
        },
        "$:/plugins/bimlas/asciidoctor/EditorToolbar/heading-2": {
            "title": "$:/plugins/bimlas/asciidoctor/EditorToolbar/heading-2",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/heading-2",
            "caption": "{{$:/language/Buttons/Heading2/Caption}} (Asciidoctor)",
            "description": "{{$:/language/Buttons/Heading2/Hint}}",
            "condition": "[<targetTiddler>type[text/asciidoc]]",
            "shortcuts": "((heading-2))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"prefix-lines\"\n\tcharacter=\"=\"\n\tcount=\"2\"\n/>\n"
        },
        "$:/plugins/bimlas/asciidoctor/EditorToolbar/heading-3": {
            "title": "$:/plugins/bimlas/asciidoctor/EditorToolbar/heading-3",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/heading-3",
            "caption": "{{$:/language/Buttons/Heading3/Caption}} (Asciidoctor)",
            "description": "{{$:/language/Buttons/Heading3/Hint}}",
            "condition": "[<targetTiddler>type[text/asciidoc]]",
            "shortcuts": "((heading-3))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"prefix-lines\"\n\tcharacter=\"=\"\n\tcount=\"3\"\n/>\n"
        },
        "$:/plugins/bimlas/asciidoctor/EditorToolbar/heading-4": {
            "title": "$:/plugins/bimlas/asciidoctor/EditorToolbar/heading-4",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/heading-4",
            "caption": "{{$:/language/Buttons/Heading4/Caption}} (Asciidoctor)",
            "description": "{{$:/language/Buttons/Heading4/Hint}}",
            "condition": "[<targetTiddler>type[text/asciidoc]]",
            "shortcuts": "((heading-4))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"prefix-lines\"\n\tcharacter=\"=\"\n\tcount=\"4\"\n/>\n"
        },
        "$:/plugins/bimlas/asciidoctor/EditorToolbar/heading-5": {
            "title": "$:/plugins/bimlas/asciidoctor/EditorToolbar/heading-5",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/heading-5",
            "caption": "{{$:/language/Buttons/Heading5/Caption}} (Asciidoctor)",
            "description": "{{$:/language/Buttons/Heading5/Hint}}",
            "condition": "[<targetTiddler>type[text/asciidoc]]",
            "shortcuts": "((heading-5))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"prefix-lines\"\n\tcharacter=\"=\"\n\tcount=\"5\"\n/>\n"
        },
        "$:/plugins/bimlas/asciidoctor/EditorToolbar/heading-6": {
            "title": "$:/plugins/bimlas/asciidoctor/EditorToolbar/heading-6",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/heading-6",
            "caption": "{{$:/language/Buttons/Heading6/Caption}} (Asciidoctor)",
            "description": "{{$:/language/Buttons/Heading6/Hint}}",
            "condition": "[<targetTiddler>type[text/asciidoc]]",
            "shortcuts": "((heading-6))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"prefix-lines\"\n\tcharacter=\"=\"\n\tcount=\"6\"\n/>\n"
        },
        "$:/plugins/bimlas/asciidoctor/EditorToolbar/italic": {
            "title": "$:/plugins/bimlas/asciidoctor/EditorToolbar/italic",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/italic",
            "caption": "{{$:/language/Buttons/Italic/Caption}} (Asciidoctor)",
            "description": "{{$:/language/Buttons/Italic/Hint}}",
            "condition": "[<targetTiddler>type[text/asciidoc]]",
            "shortcuts": "((italic))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"wrap-selection\"\n\tprefix=\"_\"\n\tsuffix=\"_\"\n/>\n"
        },
        "$:/plugins/bimlas/asciidoctor/EditorToolbar/linkify": {
            "title": "$:/plugins/bimlas/asciidoctor/EditorToolbar/linkify",
            "caption": "{{$:/language/Buttons/Linkify/Caption}} (Asciidoctor)",
            "condition": "[<targetTiddler>type[text/asciidoc]]",
            "description": "{{$:/language/Buttons/Linkify/Hint}}",
            "icon": "$:/core/images/linkify",
            "list-before": "$:/plugins/bimlas/asciidoctor/EditorToolbar/mono-block",
            "shortcuts": "((linkify))",
            "tags": "$:/tags/EditorToolbar",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"wrap-selection\"\n\tprefix=\"link:#\"\n\tsuffix=\"[]\"\n/>\n"
        },
        "$:/plugins/bimlas/asciidoctor/EditorToolbar/list-bullet": {
            "title": "$:/plugins/bimlas/asciidoctor/EditorToolbar/list-bullet",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/list-bullet",
            "caption": "{{$:/language/Buttons/ListBullet/Caption}} (Asciidoctor)",
            "description": "{{$:/language/Buttons/ListBullet/Hint}}",
            "condition": "[<targetTiddler>type[text/asciidoc]]",
            "shortcuts": "((list-bullet))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"prefix-lines\"\n\tcharacter=\"*\"\n\tcount=\"1\"\n/>\n"
        },
        "$:/plugins/bimlas/asciidoctor/EditorToolbar/list-number": {
            "title": "$:/plugins/bimlas/asciidoctor/EditorToolbar/list-number",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/list-number",
            "caption": "{{$:/language/Buttons/ListNumber/Caption}} (Asciidoctor)",
            "description": "{{$:/language/Buttons/ListNumber/Hint}}",
            "condition": "[<targetTiddler>type[text/asciidoc]]",
            "shortcuts": "((list-number))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"prefix-lines\"\n\tcharacter=\".\"\n\tcount=\"1\"\n/>\n"
        },
        "$:/plugins/bimlas/asciidoctor/EditorToolbar/mono-block": {
            "title": "$:/plugins/bimlas/asciidoctor/EditorToolbar/mono-block",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/mono-block",
            "caption": "{{$:/language/Buttons/MonoBlock/Caption}} (Asciidoctor)",
            "description": "{{$:/language/Buttons/MonoBlock/Hint}}",
            "condition": "[<targetTiddler>type[text/asciidoc]]",
            "button-classes": "tc-text-editor-toolbar-item-start-group",
            "shortcuts": "((mono-block))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"wrap-lines\"\n\tprefix=\"\n[source]\n----\"\n\tsuffix=\"----\"\n/>\n"
        },
        "$:/plugins/bimlas/asciidoctor/EditorToolbar/mono-line": {
            "title": "$:/plugins/bimlas/asciidoctor/EditorToolbar/mono-line",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/mono-line",
            "caption": "{{$:/language/Buttons/MonoLine/Caption}} (Asciidoctor)",
            "description": "{{$:/language/Buttons/MonoLine/Hint}}",
            "condition": "[<targetTiddler>type[text/asciidoc]]",
            "shortcuts": "((mono-line))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"wrap-selection\"\n\tprefix=\"`\"\n\tsuffix=\"`\"\n/>\n"
        },
        "$:/plugins/bimlas/asciidoctor/EditorToolbar/picture-dropdown": {
            "title": "$:/plugins/bimlas/asciidoctor/EditorToolbar/picture-dropdown",
            "text": "\\define replacement-text()\nimage::$(imageTitle)$[]\n\\end\n\n''{{$:/language/Buttons/Picture/Hint}}''\n\n<$macrocall $name=\"image-picker\" actions=\"\"\"\n\n<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"replace-selection\"\n\ttext=<<replacement-text>>\n/>\n\n<$action-deletetiddler\n\t$tiddler=<<dropdown-state>>\n/>\n\n\"\"\"/>\n"
        },
        "$:/plugins/bimlas/asciidoctor/EditorToolbar/picture": {
            "title": "$:/plugins/bimlas/asciidoctor/EditorToolbar/picture",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/picture",
            "caption": "{{$:/language/Buttons/Picture/Caption}} (Asciidoctor)",
            "description": "{{$:/language/Buttons/Picture/Hint}}",
            "condition": "[<targetTiddler>type[text/asciidoc]]",
            "shortcuts": "((picture))",
            "dropdown": "$:/plugins/bimlas/asciidoctor/EditorToolbar/picture-dropdown"
        },
        "$:/plugins/bimlas/asciidoctor/EditorToolbar/quote": {
            "title": "$:/plugins/bimlas/asciidoctor/EditorToolbar/quote",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/quote",
            "caption": "{{$:/language/Buttons/Quote/Caption}} (Asciidoctor)",
            "description": "{{$:/language/Buttons/Quote/Hint}}",
            "condition": "[<targetTiddler>type[text/asciidoc]]",
            "shortcuts": "((quote))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"wrap-lines\"\n\tprefix=\"\n____\"\n\tsuffix=\"____\"\n/>\n"
        },
        "$:/plugins/bimlas/asciidoctor/EditorToolbar/strikethrough": {
            "title": "$:/plugins/bimlas/asciidoctor/EditorToolbar/strikethrough",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/strikethrough",
            "caption": "{{$:/language/Buttons/Strikethrough/Caption}} (Asciidoctor)",
            "description": "{{$:/language/Buttons/Strikethrough/Hint}}",
            "condition": "[<targetTiddler>type[text/asciidoc]]",
            "shortcuts": "((strikethrough))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"wrap-selection\"\n\tprefix=\"+++<strike>\"\n\tsuffix=\"</strike>+++\"\n/>\n"
        },
        "$:/plugins/bimlas/asciidoctor/EditorToolbar/subscript": {
            "title": "$:/plugins/bimlas/asciidoctor/EditorToolbar/subscript",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/subscript",
            "caption": "{{$:/language/Buttons/Subscript/Caption}} (Asciidoctor)",
            "description": "{{$:/language/Buttons/Subscript/Hint}}",
            "condition": "[<targetTiddler>type[text/asciidoc]]",
            "shortcuts": "((subscript))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"wrap-selection\"\n\tprefix=\"~\"\n\tsuffix=\"~\"\n/>\n"
        },
        "$:/plugins/bimlas/asciidoctor/EditorToolbar/superscript": {
            "title": "$:/plugins/bimlas/asciidoctor/EditorToolbar/superscript",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/superscript",
            "caption": "{{$:/language/Buttons/Superscript/Caption}} (Asciidoctor)",
            "description": "{{$:/language/Buttons/Superscript/Hint}}",
            "condition": "[<targetTiddler>type[text/asciidoc]]",
            "shortcuts": "((superscript))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"wrap-selection\"\n\tprefix=\"^\"\n\tsuffix=\"^\"\n/>\n"
        },
        "$:/plugins/bimlas/asciidoctor/EditorToolbar/underline": {
            "title": "$:/plugins/bimlas/asciidoctor/EditorToolbar/underline",
            "tags": "$:/tags/EditorToolbar",
            "icon": "$:/core/images/underline",
            "caption": "{{$:/language/Buttons/Underline/Caption}} (Asciidoctor)",
            "description": "{{$:/language/Buttons/Underline/Hint}}",
            "condition": "[<targetTiddler>type[text/asciidoc]]",
            "shortcuts": "((underline))",
            "text": "<$action-sendmessage\n\t$message=\"tm-edit-text-operation\"\n\t$param=\"wrap-selection\"\n\tprefix=\"+++<u>\"\n\tsuffix=\"</u>+++\"\n/>\n"
        },
        "$:/language/Docs/Types/text/asciidoc": {
            "title": "$:/language/Docs/Types/text/asciidoc",
            "description": "Asciidoctor",
            "name": "text/asciidoc",
            "group": "Text"
        },
        "$:/plugins/bimlas/asciidoctor/asciidoctor.js": {
            "text": "// if (typeof Opal === 'undefined' && typeof module === 'object' && module.exports) {\n//   Opal = require('opal-runtime').Opal;\n// }\n\nif (typeof Opal === 'undefined') {\n(function(undefined) {\n  // @note\n  //   A few conventions for the documentation of this file:\n  //   1. Always use \"//\" (in contrast with \"/**/\")\n  //   2. The syntax used is Yardoc (yardoc.org), which is intended for Ruby (se below)\n  //   3. `@param` and `@return` types should be preceded by `JS.` when referring to\n  //      JavaScript constructors (e.g. `JS.Function`) otherwise Ruby is assumed.\n  //   4. `nil` and `null` being unambiguous refer to the respective\n  //      objects/values in Ruby and JavaScript\n  //   5. This is still WIP :) so please give feedback and suggestions on how\n  //      to improve or for alternative solutions\n  //\n  //   The way the code is digested before going through Yardoc is a secret kept\n  //   in the docs repo (https://github.com/opal/docs/tree/master).\n\n  var global_object = this, console;\n\n  // Detect the global object\n  if (typeof(global) !== 'undefined') { global_object = global; }\n  if (typeof(window) !== 'undefined') { global_object = window; }\n\n  // Setup a dummy console object if missing\n  if (typeof(global_object.console) === 'object') {\n    console = global_object.console;\n  } else if (global_object.console == null) {\n    console = global_object.console = {};\n  } else {\n    console = {};\n  }\n\n  if (!('log' in console)) { console.log = function () {}; }\n  if (!('warn' in console)) { console.warn = console.log; }\n\n  if (typeof(this.Opal) !== 'undefined') {\n    console.warn('Opal already loaded. Loading twice can cause troubles, please fix your setup.');\n    return this.Opal;\n  }\n\n  var nil;\n\n  // The actual class for BasicObject\n  var BasicObject;\n\n  // The actual Object class.\n  // The leading underscore is to avoid confusion with window.Object()\n  var _Object;\n\n  // The actual Module class\n  var Module;\n\n  // The actual Class class\n  var Class;\n\n  // Constructor for instances of BasicObject\n  function BasicObject_alloc(){}\n\n  // Constructor for instances of Object\n  function Object_alloc(){}\n\n  // Constructor for instances of Class\n  function Class_alloc(){}\n\n  // Constructor for instances of Module\n  function Module_alloc(){}\n\n  // Constructor for instances of NilClass (nil)\n  function NilClass_alloc(){}\n\n  // The Opal object that is exposed globally\n  var Opal = this.Opal = {};\n\n  // All bridged classes - keep track to donate methods from Object\n  var BridgedClasses = {};\n\n  // This is a useful reference to global object inside ruby files\n  Opal.global = global_object;\n  global_object.Opal = Opal;\n\n  // Configure runtime behavior with regards to require and unsupported fearures\n  Opal.config = {\n    missing_require_severity: 'error',        // error, warning, ignore\n    unsupported_features_severity: 'warning', // error, warning, ignore\n    enable_stack_trace: true                  // true, false\n  }\n\n  // Minify common function calls\n  var $hasOwn = Object.hasOwnProperty;\n  var $slice  = Opal.slice = Array.prototype.slice;\n\n  // Nil object id is always 4\n  var nil_id = 4;\n\n  // Generates even sequential numbers greater than 4\n  // (nil_id) to serve as unique ids for ruby objects\n  var unique_id = nil_id;\n\n  // Return next unique id\n  Opal.uid = function() {\n    unique_id += 2;\n    return unique_id;\n  };\n\n  // Retrieve or assign the id of an object\n  Opal.id = function(obj) {\n    if (obj.$$is_number) return (obj * 2)+1;\n    return obj.$$id || (obj.$$id = Opal.uid());\n  };\n\n  // Globals table\n  Opal.gvars = {};\n\n  // Exit function, this should be replaced by platform specific implementation\n  // (See nodejs and chrome for examples)\n  Opal.exit = function(status) { if (Opal.gvars.DEBUG) console.log('Exited with status '+status); };\n\n  // keeps track of exceptions for $!\n  Opal.exceptions = [];\n\n  // @private\n  // Pops an exception from the stack and updates `$!`.\n  Opal.pop_exception = function() {\n    Opal.gvars[\"!\"] = Opal.exceptions.pop() || nil;\n  }\n\n  // Inspect any kind of object, including non Ruby ones\n  Opal.inspect = function(obj) {\n    if (obj === undefined) {\n      return \"undefined\";\n    }\n    else if (obj === null) {\n      return \"null\";\n    }\n    else if (!obj.$$class) {\n      return obj.toString();\n    }\n    else {\n      return obj.$inspect();\n    }\n  }\n\n\n  // Truth\n  // -----\n\n  Opal.truthy = function(val) {\n    return (val !== nil && val != null && (!val.$$is_boolean || val == true));\n  };\n\n  Opal.falsy = function(val) {\n    return (val === nil || val == null || (val.$$is_boolean && val == false))\n  };\n\n\n  // Constants\n  // ---------\n  //\n  // For future reference:\n  // - The Rails autoloading guide (http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html)\n  // - @ConradIrwin's 2012 post on “Everything you ever wanted to know about constant lookup in Ruby” (http://cirw.in/blog/constant-lookup.html)\n  //\n  // Legend of MRI concepts/names:\n  // - constant reference (cref): the module/class that acts as a namespace\n  // - nesting: the namespaces wrapping the current scope, e.g. nesting inside\n  //            `module A; module B::C; end; end` is `[B::C, A]`\n\n  // Get the constant in the scope of the current cref\n  function const_get_name(cref, name) {\n    if (cref) return cref.$$const[name];\n  }\n\n  // Walk up the nesting array looking for the constant\n  function const_lookup_nesting(nesting, name) {\n    var i, ii, result, constant;\n\n    if (nesting.length === 0) return;\n\n    // If the nesting is not empty the constant is looked up in its elements\n    // and in order. The ancestors of those elements are ignored.\n    for (i = 0, ii = nesting.length; i < ii; i++) {\n      constant = nesting[i].$$const[name];\n      if (constant != null) return constant;\n    }\n  }\n\n  // Walk up the ancestors chain looking for the constant\n  function const_lookup_ancestors(cref, name) {\n    var i, ii, result, ancestors;\n\n    if (cref == null) return;\n\n    ancestors = Opal.ancestors(cref);\n\n    for (i = 0, ii = ancestors.length; i < ii; i++) {\n      if (ancestors[i].$$const && $hasOwn.call(ancestors[i].$$const, name)) {\n        return ancestors[i].$$const[name];\n      }\n    }\n  }\n\n  // Walk up Object's ancestors chain looking for the constant,\n  // but only if cref is missing or a module.\n  function const_lookup_Object(cref, name) {\n    if (cref == null || cref.$$is_module) {\n      return const_lookup_ancestors(_Object, name);\n    }\n  }\n\n  // Call const_missing if nothing else worked\n  function const_missing(cref, name, skip_missing) {\n    if (!skip_missing) {\n      return (cref || _Object).$const_missing(name);\n    }\n  }\n\n  // Look for the constant just in the current cref or call `#const_missing`\n  Opal.const_get_local = function(cref, name, skip_missing) {\n    var result;\n\n    if (cref == null) return;\n\n    if (cref === '::') cref = _Object;\n\n    if (!cref.$$is_a_module) {\n      throw new Opal.TypeError(cref.toString() + \" is not a class/module\");\n    }\n\n    result = const_get_name(cref, name);              if (result != null) return result;\n    result = const_missing(cref, name, skip_missing); if (result != null) return result;\n  }\n\n  // Look for the constant relative to a cref or call `#const_missing` (when the\n  // constant is prefixed by `::`).\n  Opal.const_get_qualified = function(cref, name, skip_missing) {\n    var result, cache, cached, current_version = Opal.const_cache_version;\n\n    if (cref == null) return;\n\n    if (cref === '::') cref = _Object;\n\n    if (!cref.$$is_a_module) {\n      throw new Opal.TypeError(cref.toString() + \" is not a class/module\");\n    }\n\n    if ((cache = cref.$$const_cache) == null) {\n      cache = cref.$$const_cache = Object.create(null);\n    }\n    cached = cache[name];\n\n    if (cached == null || cached[0] !== current_version) {\n      ((result = const_get_name(cref, name))              != null) ||\n      ((result = const_lookup_ancestors(cref, name))      != null);\n      cache[name] = [current_version, result];\n    } else {\n      result = cached[1];\n    }\n\n    return result != null ? result : const_missing(cref, name, skip_missing);\n  };\n\n  // Initialize the top level constant cache generation counter\n  Opal.const_cache_version = 1;\n\n  // Look for the constant in the open using the current nesting and the nearest\n  // cref ancestors or call `#const_missing` (when the constant has no :: prefix).\n  Opal.const_get_relative = function(nesting, name, skip_missing) {\n    var cref = nesting[0], result, current_version = Opal.const_cache_version, cache, cached;\n\n    if ((cache = nesting.$$const_cache) == null) {\n      cache = nesting.$$const_cache = Object.create(null);\n    }\n    cached = cache[name];\n\n    if (cached == null || cached[0] !== current_version) {\n      ((result = const_get_name(cref, name))              != null) ||\n      ((result = const_lookup_nesting(nesting, name))     != null) ||\n      ((result = const_lookup_ancestors(cref, name))      != null) ||\n      ((result = const_lookup_Object(cref, name))         != null);\n\n      cache[name] = [current_version, result];\n    } else {\n      result = cached[1];\n    }\n\n    return result != null ? result : const_missing(cref, name, skip_missing);\n  };\n\n  // Register the constant on a cref and opportunistically set the name of\n  // unnamed classes/modules.\n  Opal.const_set = function(cref, name, value) {\n    if (cref == null || cref === '::') cref = _Object;\n\n    if (value.$$is_a_module) {\n      if (value.$$name == null || value.$$name === nil) value.$$name = name;\n      if (value.$$base_module == null) value.$$base_module = cref;\n    }\n\n    cref.$$const = (cref.$$const || Object.create(null));\n    cref.$$const[name] = value;\n\n    // Add a short helper to navigate constants manually.\n    // @example\n    //   Opal.$$.Regexp.$$.IGNORECASE\n    cref.$$ = cref.$$const;\n\n    Opal.const_cache_version++;\n\n    // Expose top level constants onto the Opal object\n    if (cref === _Object) Opal[name] = value;\n\n    return value;\n  };\n\n  // Get all the constants reachable from a given cref, by default will include\n  // inherited constants.\n  Opal.constants = function(cref, inherit) {\n    if (inherit == null) inherit = true;\n\n    var module, modules = [cref], module_constants, i, ii, constants = {}, constant;\n\n    if (inherit) modules = modules.concat(Opal.ancestors(cref));\n    if (inherit && cref.$$is_module) modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));\n\n    for (i = 0, ii = modules.length; i < ii; i++) {\n      module = modules[i];\n\n      // Don not show Objects constants unless we're querying Object itself\n      if (cref !== _Object && module == _Object) break;\n\n      for (constant in module.$$const) {\n        constants[constant] = true;\n      }\n    }\n\n    return Object.keys(constants);\n  };\n\n  // Remove a constant from a cref.\n  Opal.const_remove = function(cref, name) {\n    Opal.const_cache_version++;\n\n    if (cref.$$const[name] != null) {\n      var old = cref.$$const[name];\n      delete cref.$$const[name];\n      return old;\n    }\n\n    if (cref.$$autoload != null && cref.$$autoload[name] != null) {\n      delete cref.$$autoload[name];\n      return nil;\n    }\n\n    throw Opal.NameError.$new(\"constant \"+cref+\"::\"+cref.$name()+\" not defined\");\n  };\n\n\n  // Modules & Classes\n  // -----------------\n\n  // A `class Foo; end` expression in ruby is compiled to call this runtime\n  // method which either returns an existing class of the given name, or creates\n  // a new class in the given `base` scope.\n  //\n  // If a constant with the given name exists, then we check to make sure that\n  // it is a class and also that the superclasses match. If either of these\n  // fail, then we raise a `TypeError`. Note, `superclass` may be null if one\n  // was not specified in the ruby code.\n  //\n  // We pass a constructor to this method of the form `function ClassName() {}`\n  // simply so that classes show up with nicely formatted names inside debuggers\n  // in the web browser (or node/sprockets).\n  //\n  // The `base` is the current `self` value where the class is being created\n  // from. We use this to get the scope for where the class should be created.\n  // If `base` is an object (not a class/module), we simple get its class and\n  // use that as the base instead.\n  //\n  // @param base        [Object] where the class is being created\n  // @param superclass  [Class,null] superclass of the new class (may be null)\n  // @param id          [String] the name of the class to be created\n  // @param constructor [JS.Function] function to use as constructor\n  //\n  // @return new [Class]  or existing ruby class\n  //\n  Opal.klass = function(base, superclass, name, constructor) {\n    var klass, bridged, alloc;\n\n    if (base == null) {\n      base = _Object;\n    }\n\n    // If base is an object, use its class\n    if (!base.$$is_class && !base.$$is_module) {\n      base = base.$$class;\n    }\n\n    // If the superclass is a function then we're bridging a native JS class\n    if (typeof(superclass) === 'function') {\n      bridged = superclass;\n      superclass = _Object;\n    }\n\n    // Try to find the class in the current scope\n    klass = const_get_name(base, name);\n\n    // If the class exists in the scope, then we must use that\n    if (klass) {\n      // Make sure the existing constant is a class, or raise error\n      if (!klass.$$is_class) {\n        throw Opal.TypeError.$new(name + \" is not a class\");\n      }\n\n      // Make sure existing class has same superclass\n      if (superclass && klass.$$super !== superclass) {\n        throw Opal.TypeError.$new(\"superclass mismatch for class \" + name);\n      }\n\n      return klass;\n    }\n\n    // Class doesnt exist, create a new one with given superclass...\n\n    // Not specifying a superclass means we can assume it to be Object\n    if (superclass == null) {\n      superclass = _Object;\n    }\n\n    // If bridged the JS class will also be the alloc function\n    alloc = bridged || Opal.boot_class_alloc(name, constructor, superclass);\n\n    // Create the class object (instance of Class)\n    klass = Opal.setup_class_object(name, alloc, superclass.$$name, superclass.constructor);\n\n    // @property $$super the superclass, doesn't get changed by module inclusions\n    klass.$$super = superclass;\n\n    // @property $$parent direct parent class\n    //                    starts with the superclass, after klass inclusion is\n    //                    the last included klass\n    klass.$$parent = superclass;\n\n    Opal.const_set(base, name, klass);\n\n    // Name new class directly onto current scope (Opal.Foo.Baz = klass)\n    base[name] = klass;\n\n    if (bridged) {\n      Opal.bridge(klass, alloc);\n    }\n    else {\n      // Call .inherited() hook with new class on the superclass\n      if (superclass.$inherited) {\n        superclass.$inherited(klass);\n      }\n    }\n\n    return klass;\n  };\n\n  // Boot a base class (makes instances).\n  //\n  // @param name [String,null] the class name\n  // @param constructor [JS.Function] the class' instances constructor/alloc function\n  // @param superclass  [Class,null] the superclass object\n  // @return [JS.Function] the consturctor holding the prototype for the class' instances\n  Opal.boot_class_alloc = function(name, constructor, superclass) {\n    if (superclass) {\n      var alloc_proxy = function() {};\n      alloc_proxy.prototype = superclass.$$proto || superclass.prototype;\n      constructor.prototype = new alloc_proxy();\n    }\n\n    if (name) {\n      constructor.displayName = name+'_alloc';\n    }\n\n    constructor.prototype.constructor = constructor;\n\n    return constructor;\n  };\n\n  Opal.setup_module_or_class = function(module) {\n    // @property $$id Each class/module is assigned a unique `id` that helps\n    //                comparation and implementation of `#object_id`\n    module.$$id = Opal.uid();\n\n    // @property $$is_a_module Will be true for Module and its subclasses\n    //                         instances (namely: Class).\n    module.$$is_a_module = true;\n\n    // @property $$inc included modules\n    module.$$inc = [];\n\n    // initialize the name with nil\n    module.$$name = nil;\n\n    // Initialize the constants table\n    module.$$const = Object.create(null);\n\n    // @property $$cvars class variables defined in the current module\n    module.$$cvars = Object.create(null);\n  }\n\n\n\n  // Adds common/required properties to class object (as in `Class.new`)\n  //\n  // @param name  [String,null] The name of the class\n  //\n  // @param alloc [JS.Function] The constructor of the class' instances\n  //\n  // @param superclass_name [String,null]\n  //   The name of the super class, this is\n  //   usefule to build the `.displayName` of the singleton class\n  //\n  // @param superclass_alloc [JS.Function]\n  //   The constructor of the superclass from which the singleton_class is\n  //   derived.\n  //\n  // @return [Class]\n  Opal.setup_class_object = function(name, alloc, superclass_name, superclass_alloc) {\n    // Grab the superclass prototype and use it to build an intermediary object\n    // in the prototype chain.\n    var superclass_alloc_proxy = function() {};\n        superclass_alloc_proxy.prototype = superclass_alloc.prototype;\n        superclass_alloc_proxy.displayName = superclass_name;\n\n    var singleton_class_alloc = function() {}\n        singleton_class_alloc.prototype = new superclass_alloc_proxy();\n\n    // The built class is the only instance of its singleton_class\n    var klass = new singleton_class_alloc();\n\n    Opal.setup_module_or_class(klass);\n\n    // @property $$alloc This is the constructor of instances of the current\n    //                   class. Its prototype will be used for method lookup\n    klass.$$alloc = alloc;\n\n    klass.$$name = name || nil;\n\n    // Set a displayName for the singleton_class\n    singleton_class_alloc.displayName = \"#<Class:\"+(name || (\"#<Class:\"+klass.$$id+\">\"))+\">\";\n\n    // @property $$proto This is the prototype on which methods will be defined\n    klass.$$proto = alloc.prototype;\n\n    // @property $$proto.$$class Make available to instances a reference to the\n    //                           class they belong to.\n    klass.$$proto.$$class = klass;\n\n    // @property constructor keeps a ref to the constructor, but apparently the\n    //                       constructor is already set on:\n    //\n    //                          `var klass = new constructor` is called.\n    //\n    //                       Maybe there are some browsers not abiding (IE6?)\n    klass.constructor = singleton_class_alloc;\n\n    // @property $$is_class Clearly mark this as a class\n    klass.$$is_class = true;\n\n    // @property $$class Classes are instances of the class Class\n    klass.$$class    = Class;\n\n    return klass;\n  };\n\n  // Define new module (or return existing module). The given `base` is basically\n  // the current `self` value the `module` statement was defined in. If this is\n  // a ruby module or class, then it is used, otherwise if the base is a ruby\n  // object then that objects real ruby class is used (e.g. if the base is the\n  // main object, then the top level `Object` class is used as the base).\n  //\n  // If a module of the given name is already defined in the base, then that\n  // instance is just returned.\n  //\n  // If there is a class of the given name in the base, then an error is\n  // generated instead (cannot have a class and module of same name in same base).\n  //\n  // Otherwise, a new module is created in the base with the given name, and that\n  // new instance is returned back (to be referenced at runtime).\n  //\n  // @param  base [Module, Class] class or module this definition is inside\n  // @param  id   [String] the name of the new (or existing) module\n  //\n  // @return [Module]\n  Opal.module = function(base, name) {\n    var module;\n\n    if (base == null) {\n      base = _Object;\n    }\n\n    if (!base.$$is_class && !base.$$is_module) {\n      base = base.$$class;\n    }\n\n    module = const_get_name(base, name);\n    if (module == null && base === _Object) module = const_lookup_ancestors(_Object, name);\n\n    if (module) {\n      if (!module.$$is_module && module !== _Object) {\n        throw Opal.TypeError.$new(name + \" is not a module\");\n      }\n    }\n    else {\n      module = Opal.module_allocate(Module);\n      Opal.const_set(base, name, module);\n    }\n\n    return module;\n  };\n\n  // The implementation for Module#initialize\n  // @param module [Module]\n  // @param block [Proc,nil]\n  // @return nil\n  Opal.module_initialize = function(module, block) {\n    if (block !== nil) {\n      var block_self = block.$$s;\n      block.$$s = null;\n      block.call(module);\n      block.$$s = block_self;\n    }\n    return nil;\n  };\n\n  // Internal function to create a new module instance. This simply sets up\n  // the prototype hierarchy and method tables.\n  //\n  Opal.module_allocate = function(superclass) {\n    var mtor = function() {};\n    mtor.prototype = superclass.$$alloc.prototype;\n\n    var module_constructor = function() {};\n    module_constructor.prototype = new mtor();\n\n    var module = new module_constructor();\n    var module_prototype = {};\n\n    Opal.setup_module_or_class(module);\n\n    // initialize dependency tracking\n    module.$$included_in = [];\n\n    // Set the display name of the singleton prototype holder\n    module_constructor.displayName = \"#<Class:#<Module:\"+module.$$id+\">>\"\n\n    // @property $$proto This is the prototype on which methods will be defined\n    module.$$proto = module_prototype;\n\n    // @property constructor\n    //   keeps a ref to the constructor, but apparently the\n    //   constructor is already set on:\n    //\n    //      `var module = new constructor` is called.\n    //\n    //   Maybe there are some browsers not abiding (IE6?)\n    module.constructor = module_constructor;\n\n    // @property $$is_module Clearly mark this as a module\n    module.$$is_module = true;\n    module.$$class     = Module;\n\n    // @property $$super\n    //   the superclass, doesn't get changed by module inclusions\n    module.$$super = superclass;\n\n    // @property $$parent\n    //   direct parent class or module\n    //   starts with the superclass, after module inclusion is\n    //   the last included module\n    module.$$parent = superclass;\n\n    return module;\n  };\n\n  // Return the singleton class for the passed object.\n  //\n  // If the given object alredy has a singleton class, then it will be stored on\n  // the object as the `$$meta` property. If this exists, then it is simply\n  // returned back.\n  //\n  // Otherwise, a new singleton object for the class or object is created, set on\n  // the object at `$$meta` for future use, and then returned.\n  //\n  // @param object [Object] the ruby object\n  // @return [Class] the singleton class for object\n  Opal.get_singleton_class = function(object) {\n    if (object.$$meta) {\n      return object.$$meta;\n    }\n\n    if (object.$$is_class || object.$$is_module) {\n      return Opal.build_class_singleton_class(object);\n    }\n\n    return Opal.build_object_singleton_class(object);\n  };\n\n  // Build the singleton class for an existing class. Class object are built\n  // with their singleton class already in the prototype chain and inheriting\n  // from their superclass object (up to `Class` itself).\n  //\n  // NOTE: Actually in MRI a class' singleton class inherits from its\n  // superclass' singleton class which in turn inherits from Class.\n  //\n  // @param klass [Class]\n  // @return [Class]\n  Opal.build_class_singleton_class = function(object) {\n    var alloc, superclass, klass;\n\n    if (object.$$meta) {\n      return object.$$meta;\n    }\n\n    // The constructor and prototype of the singleton_class instances is the\n    // current class constructor and prototype.\n    alloc = object.constructor;\n\n    // The singleton_class superclass is the singleton_class of its superclass;\n    // but BasicObject has no superclass (its `$$super` is null), thus we\n    // fallback on `Class`.\n    superclass = object === BasicObject ? Class : Opal.build_class_singleton_class(object.$$super);\n\n    klass = Opal.setup_class_object(null, alloc, superclass.$$name, superclass.constructor);\n    klass.$$super  = superclass;\n    klass.$$parent = superclass;\n\n    klass.$$is_singleton = true;\n    klass.$$singleton_of = object;\n\n    return object.$$meta = klass;\n  };\n\n  // Build the singleton class for a Ruby (non class) Object.\n  //\n  // @param object [Object]\n  // @return [Class]\n  Opal.build_object_singleton_class = function(object) {\n    var superclass = object.$$class,\n        name = \"#<Class:#<\" + superclass.$$name + \":\" + superclass.$$id + \">>\";\n\n    var alloc = Opal.boot_class_alloc(name, function(){}, superclass)\n    var klass = Opal.setup_class_object(name, alloc, superclass.$$name, superclass.constructor);\n\n    klass.$$super  = superclass;\n    klass.$$parent = superclass;\n    klass.$$class  = superclass.$$class;\n    klass.$$proto  = object;\n\n    klass.$$is_singleton = true;\n    klass.$$singleton_of = object;\n\n    return object.$$meta = klass;\n  };\n\n  // Returns an object containing all pairs of names/values\n  // for all class variables defined in provided +module+\n  // and its ancestors.\n  //\n  // @param module [Module]\n  // @return [Object]\n  Opal.class_variables = function(module) {\n    var ancestors = Opal.ancestors(module),\n        i, length = ancestors.length,\n        result = {};\n\n    for (i = length - 1; i >= 0; i--) {\n      var ancestor = ancestors[i];\n\n      for (var cvar in ancestor.$$cvars) {\n        result[cvar] = ancestor.$$cvars[cvar];\n      }\n    }\n\n    return result;\n  }\n\n  // Sets class variable with specified +name+ to +value+\n  // in provided +module+\n  //\n  // @param module [Module]\n  // @param name [String]\n  // @param value [Object]\n  Opal.class_variable_set = function(module, name, value) {\n    var ancestors = Opal.ancestors(module),\n        i, length = ancestors.length;\n\n    for (i = length - 2; i >= 0; i--) {\n      var ancestor = ancestors[i];\n\n      if ($hasOwn.call(ancestor.$$cvars, name)) {\n        ancestor.$$cvars[name] = value;\n        return value;\n      }\n    }\n\n    module.$$cvars[name] = value;\n\n    return value;\n  }\n\n  // Bridges a single method.\n  //\n  // @param target [JS::Function] the constructor of the bridged class\n  // @param from [Module] the module/class we are importing the method from\n  // @param name [String] the method name in JS land (i.e. starting with $)\n  // @param body [JS::Function] the body of the method\n  Opal.bridge_method = function(target_constructor, from, name, body) {\n    var ancestors, i, ancestor, length;\n\n    ancestors = target_constructor.$$bridge.$ancestors();\n\n    // order important here, we have to check for method presence in\n    // ancestors from the bridged class to the last ancestor\n    for (i = 0, length = ancestors.length; i < length; i++) {\n      ancestor = ancestors[i];\n\n      if ($hasOwn.call(ancestor.$$proto, name) &&\n          ancestor.$$proto[name] &&\n          !ancestor.$$proto[name].$$donated &&\n          !ancestor.$$proto[name].$$stub &&\n          ancestor !== from) {\n        break;\n      }\n\n      if (ancestor === from) {\n        target_constructor.prototype[name] = body\n        break;\n      }\n    }\n  };\n\n  // Bridges from *donator* to a *target*.\n  //\n  // @param target [Module] the potentially associated with bridged classes module\n  // @param donator [Module] the module/class source of the methods that should be bridged\n  Opal.bridge_methods = function(target, donator) {\n    var i,\n        bridged = BridgedClasses[target.$__id__()],\n        donator_id = donator.$__id__();\n\n    if (bridged) {\n      BridgedClasses[donator_id] = bridged.slice();\n\n      for (i = bridged.length - 1; i >= 0; i--) {\n        Opal_bridge_methods_to_constructor(bridged[i], donator)\n      }\n    }\n  };\n\n  // Actually bridge methods to the bridged (shared) prototype.\n  function Opal_bridge_methods_to_constructor(target_constructor, donator) {\n    var i,\n        method,\n        methods = donator.$instance_methods();\n\n    for (i = methods.length - 1; i >= 0; i--) {\n      method = '$' + methods[i];\n      Opal.bridge_method(target_constructor, donator, method, donator.$$proto[method]);\n    }\n  }\n\n  // Associate the target as a bridged class for the current \"donator\"\n  function Opal_add_bridged_constructor(target_constructor, donator) {\n    var donator_id = donator.$__id__();\n\n    if (!BridgedClasses[donator_id]) {\n      BridgedClasses[donator_id] = [];\n    }\n    BridgedClasses[donator_id].push(target_constructor);\n  }\n\n  // Walks the dependency tree detecting the presence of the base among its\n  // own dependencies.\n  //\n  // @param [Integer] base_id The id of the base module (eg. the \"includer\")\n  // @param [Array<Module>] deps The array of dependencies (eg. the included module, included.$$deps)\n  // @param [String] prop The property that holds dependencies (eg. \"$$deps\")\n  // @param [JS::Object] seen A JS object holding the cache of already visited objects\n  // @return [Boolean] true if a cyclic dependency is present\n  Opal.has_cyclic_dep = function has_cyclic_dep(base_id, deps, prop, seen) {\n    var i, dep_id, dep;\n\n    for (i = deps.length - 1; i >= 0; i--) {\n      dep = deps[i];\n      dep_id = dep.$$id;\n\n      if (seen[dep_id]) {\n        continue;\n      }\n      seen[dep_id] = true;\n\n      if (dep_id === base_id) {\n        return true;\n      }\n\n      if (has_cyclic_dep(base_id, dep[prop], prop, seen)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // The actual inclusion of a module into a class.\n  //\n  // ## Class `$$parent` and `iclass`\n  //\n  // To handle `super` calls, every class has a `$$parent`. This parent is\n  // used to resolve the next class for a super call. A normal class would\n  // have this point to its superclass. However, if a class includes a module\n  // then this would need to take into account the module. The module would\n  // also have to then point its `$$parent` to the actual superclass. We\n  // cannot modify modules like this, because it might be included in more\n  // then one class. To fix this, we actually insert an `iclass` as the class'\n  // `$$parent` which can then point to the superclass. The `iclass` acts as\n  // a proxy to the actual module, so the `super` chain can then search it for\n  // the required method.\n  //\n  // @param module [Module] the module to include\n  // @param includer [Module] the target class to include module into\n  // @return [null]\n  Opal.append_features = function(module, includer) {\n    var iclass, donator, prototype, methods, id, i;\n\n    // check if this module is already included in the class\n    for (i = includer.$$inc.length - 1; i >= 0; i--) {\n      if (includer.$$inc[i] === module) {\n        return;\n      }\n    }\n\n    // Check that the base module is not also a dependency, classes can't be\n    // dependencies so we have a special case for them.\n    if (!includer.$$is_class && Opal.has_cyclic_dep(includer.$$id, [module], '$$inc', {})) {\n      throw Opal.ArgumentError.$new('cyclic include detected')\n    }\n\n    Opal.const_cache_version++;\n    includer.$$inc.push(module);\n    module.$$included_in.push(includer);\n    Opal.bridge_methods(includer, module);\n\n    // iclass\n    iclass = {\n      $$name:   module.$$name,\n      $$proto:  module.$$proto,\n      $$parent: includer.$$parent,\n      $$module: module,\n      $$iclass: true\n    };\n\n    includer.$$parent = iclass;\n\n    methods = module.$instance_methods();\n\n    for (i = methods.length - 1; i >= 0; i--) {\n      Opal.update_includer(module, includer, '$' + methods[i])\n    }\n  };\n\n  // Table that holds all methods that have been defined on all objects\n  // It is used for defining method stubs for new coming native classes\n  Opal.stubs = {};\n\n  // For performance, some core Ruby classes are toll-free bridged to their\n  // native JavaScript counterparts (e.g. a Ruby Array is a JavaScript Array).\n  //\n  // This method is used to setup a native constructor (e.g. Array), to have\n  // its prototype act like a normal Ruby class. Firstly, a new Ruby class is\n  // created using the native constructor so that its prototype is set as the\n  // target for th new class. Note: all bridged classes are set to inherit\n  // from Object.\n  //\n  // Example:\n  //\n  //    Opal.bridge(self, Function);\n  //\n  // @param klass       [Class] the Ruby class to bridge\n  // @param constructor [JS.Function] native JavaScript constructor to use\n  // @return [Class] returns the passed Ruby class\n  //\n  Opal.bridge = function(klass, constructor) {\n    if (constructor.$$bridge) {\n      throw Opal.ArgumentError.$new(\"already bridged\");\n    }\n\n    Opal.stub_subscribers.push(constructor.prototype);\n\n    // Populate constructor with previously stored stubs\n    for (var method_name in Opal.stubs) {\n      if (!(method_name in constructor.prototype)) {\n        constructor.prototype[method_name] = Opal.stub_for(method_name);\n      }\n    }\n\n    constructor.prototype.$$class = klass;\n    constructor.$$bridge          = klass;\n\n    var ancestors = klass.$ancestors();\n\n    // order important here, we have to bridge from the last ancestor to the\n    // bridged class\n    for (var i = ancestors.length - 1; i >= 0; i--) {\n      Opal_add_bridged_constructor(constructor, ancestors[i]);\n      Opal_bridge_methods_to_constructor(constructor, ancestors[i]);\n    }\n\n    for (var name in BasicObject_alloc.prototype) {\n      var method = BasicObject_alloc.prototype[method];\n\n      if (method && method.$$stub && !(name in constructor.prototype)) {\n        constructor.prototype[name] = method;\n      }\n    }\n\n    return klass;\n  };\n\n  // Update `jsid` method cache of all classes / modules including `module`.\n  Opal.update_includer = function(module, includer, jsid) {\n    var dest, current, body,\n        klass_includees, j, jj, current_owner_index, module_index;\n\n    body    = module.$$proto[jsid];\n    dest    = includer.$$proto;\n    current = dest[jsid];\n\n    if (dest.hasOwnProperty(jsid) && !current.$$donated && !current.$$stub) {\n      // target class has already defined the same method name - do nothing\n    }\n    else if (dest.hasOwnProperty(jsid) && !current.$$stub) {\n      // target class includes another module that has defined this method\n      klass_includees = includer.$$inc;\n\n      for (j = 0, jj = klass_includees.length; j < jj; j++) {\n        if (klass_includees[j] === current.$$donated) {\n          current_owner_index = j;\n        }\n        if (klass_includees[j] === module) {\n          module_index = j;\n        }\n      }\n\n      // only redefine method on class if the module was included AFTER\n      // the module which defined the current method body. Also make sure\n      // a module can overwrite a method it defined before\n      if (current_owner_index <= module_index) {\n        dest[jsid] = body;\n        dest[jsid].$$donated = module;\n      }\n    }\n    else {\n      // neither a class, or module included by class, has defined method\n      dest[jsid] = body;\n      dest[jsid].$$donated = module;\n    }\n\n    // if the includer is a module, recursively update all of its includres.\n    if (includer.$$included_in) {\n      Opal.update_includers(includer, jsid);\n    }\n  };\n\n  // Update `jsid` method cache of all classes / modules including `module`.\n  Opal.update_includers = function(module, jsid) {\n    var i, ii, includee, included_in;\n\n    included_in = module.$$included_in;\n\n    if (!included_in) {\n      return;\n    }\n\n    for (i = 0, ii = included_in.length; i < ii; i++) {\n      includee = included_in[i];\n      Opal.update_includer(module, includee, jsid);\n    }\n  };\n\n  // The Array of ancestors for a given module/class\n  Opal.ancestors = function(module_or_class) {\n    var parent = module_or_class,\n        result = [],\n        modules, i, ii, j, jj;\n\n    while (parent) {\n      result.push(parent);\n      for (i = parent.$$inc.length-1; i >= 0; i--) {\n        modules = Opal.ancestors(parent.$$inc[i]);\n\n        for(j = 0, jj = modules.length; j < jj; j++) {\n          result.push(modules[j]);\n        }\n      }\n\n      // only the actual singleton class gets included in its ancestry\n      // after that, traverse the normal class hierarchy\n      if (parent.$$is_singleton && parent.$$singleton_of.$$is_module) {\n        parent = parent.$$singleton_of.$$super;\n      }\n      else {\n        parent = parent.$$is_class ? parent.$$super : null;\n      }\n    }\n\n    return result;\n  };\n\n\n  // Method Missing\n  // --------------\n\n  // Methods stubs are used to facilitate method_missing in opal. A stub is a\n  // placeholder function which just calls `method_missing` on the receiver.\n  // If no method with the given name is actually defined on an object, then it\n  // is obvious to say that the stub will be called instead, and then in turn\n  // method_missing will be called.\n  //\n  // When a file in ruby gets compiled to javascript, it includes a call to\n  // this function which adds stubs for every method name in the compiled file.\n  // It should then be safe to assume that method_missing will work for any\n  // method call detected.\n  //\n  // Method stubs are added to the BasicObject prototype, which every other\n  // ruby object inherits, so all objects should handle method missing. A stub\n  // is only added if the given property name (method name) is not already\n  // defined.\n  //\n  // Note: all ruby methods have a `$` prefix in javascript, so all stubs will\n  // have this prefix as well (to make this method more performant).\n  //\n  //    Opal.add_stubs([\"$foo\", \"$bar\", \"$baz=\"]);\n  //\n  // All stub functions will have a private `$$stub` property set to true so\n  // that other internal methods can detect if a method is just a stub or not.\n  // `Kernel#respond_to?` uses this property to detect a methods presence.\n  //\n  // @param stubs [Array] an array of method stubs to add\n  // @return [undefined]\n  Opal.add_stubs = function(stubs) {\n    var subscriber, subscribers = Opal.stub_subscribers,\n        i, ilength = stubs.length,\n        j, jlength = subscribers.length,\n        method_name, stub,\n        opal_stubs = Opal.stubs;\n\n    for (i = 0; i < ilength; i++) {\n      method_name = stubs[i];\n\n      if(!opal_stubs.hasOwnProperty(method_name)) {\n        // Save method name to populate other subscribers with this stub\n        opal_stubs[method_name] = true;\n        stub = Opal.stub_for(method_name);\n\n        for (j = 0; j < jlength; j++) {\n          subscriber = subscribers[j];\n\n          if (!(method_name in subscriber)) {\n            subscriber[method_name] = stub;\n          }\n        }\n      }\n    }\n  };\n\n  // Keep a list of prototypes that want method_missing stubs to be added.\n  //\n  // @default [Prototype List] BasicObject_alloc.prototype\n  //\n  Opal.stub_subscribers = [BasicObject_alloc.prototype];\n\n  // Add a method_missing stub function to the given prototype for the\n  // given name.\n  //\n  // @param prototype [Prototype] the target prototype\n  // @param stub [String] stub name to add (e.g. \"$foo\")\n  // @return [undefined]\n  Opal.add_stub_for = function(prototype, stub) {\n    var method_missing_stub = Opal.stub_for(stub);\n    prototype[stub] = method_missing_stub;\n  };\n\n  // Generate the method_missing stub for a given method name.\n  //\n  // @param method_name [String] The js-name of the method to stub (e.g. \"$foo\")\n  // @return [undefined]\n  Opal.stub_for = function(method_name) {\n    function method_missing_stub() {\n      // Copy any given block onto the method_missing dispatcher\n      this.$method_missing.$$p = method_missing_stub.$$p;\n\n      // Set block property to null ready for the next call (stop false-positives)\n      method_missing_stub.$$p = null;\n\n      // call method missing with correct args (remove '$' prefix on method name)\n      var args_ary = new Array(arguments.length);\n      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = arguments[i]; }\n\n      return this.$method_missing.apply(this, [method_name.slice(1)].concat(args_ary));\n    }\n\n    method_missing_stub.$$stub = true;\n\n    return method_missing_stub;\n  };\n\n\n  // Methods\n  // -------\n\n  // Arity count error dispatcher for methods\n  //\n  // @param actual [Fixnum] number of arguments given to method\n  // @param expected [Fixnum] expected number of arguments\n  // @param object [Object] owner of the method +meth+\n  // @param meth [String] method name that got wrong number of arguments\n  // @raise [ArgumentError]\n  Opal.ac = function(actual, expected, object, meth) {\n    var inspect = '';\n    if (object.$$is_class || object.$$is_module) {\n      inspect += object.$$name + '.';\n    }\n    else {\n      inspect += object.$$class.$$name + '#';\n    }\n    inspect += meth;\n\n    throw Opal.ArgumentError.$new('[' + inspect + '] wrong number of arguments(' + actual + ' for ' + expected + ')');\n  };\n\n  // Arity count error dispatcher for blocks\n  //\n  // @param actual [Fixnum] number of arguments given to block\n  // @param expected [Fixnum] expected number of arguments\n  // @param context [Object] context of the block definition\n  // @raise [ArgumentError]\n  Opal.block_ac = function(actual, expected, context) {\n    var inspect = \"`block in \" + context + \"'\";\n\n    throw Opal.ArgumentError.$new(inspect + ': wrong number of arguments (' + actual + ' for ' + expected + ')');\n  };\n\n  // Super dispatcher\n  Opal.find_super_dispatcher = function(obj, mid, current_func, defcheck, defs) {\n    var dispatcher, super_method;\n\n    if (defs) {\n      if (obj.$$is_class || obj.$$is_module) {\n        dispatcher = defs.$$super;\n      }\n      else {\n        dispatcher = obj.$$class.$$proto;\n      }\n    }\n    else {\n      dispatcher = Opal.find_obj_super_dispatcher(obj, mid, current_func);\n    }\n\n    super_method = dispatcher['$' + mid];\n\n    if (!defcheck && super_method.$$stub && Opal.Kernel.$method_missing === obj.$method_missing) {\n      // method_missing hasn't been explicitly defined\n      throw Opal.NoMethodError.$new('super: no superclass method `'+mid+\"' for \"+obj, mid);\n    }\n\n    return super_method;\n  };\n\n  // Iter dispatcher for super in a block\n  Opal.find_iter_super_dispatcher = function(obj, jsid, current_func, defcheck, implicit) {\n    var call_jsid = jsid;\n\n    if (!current_func) {\n      throw Opal.RuntimeError.$new(\"super called outside of method\");\n    }\n\n    if (implicit && current_func.$$define_meth) {\n      throw Opal.RuntimeError.$new(\"implicit argument passing of super from method defined by define_method() is not supported. Specify all arguments explicitly\");\n    }\n\n    if (current_func.$$def) {\n      call_jsid = current_func.$$jsid;\n    }\n\n    return Opal.find_super_dispatcher(obj, call_jsid, current_func, defcheck);\n  };\n\n  Opal.find_obj_super_dispatcher = function(obj, mid, current_func) {\n    var klass = obj.$$meta || obj.$$class;\n\n    // first we need to find the class/module current_func is located on\n    klass = Opal.find_owning_class(klass, current_func);\n\n    if (!klass) {\n      throw new Error(\"could not find current class for super()\");\n    }\n\n    return Opal.find_super_func(klass, '$' + mid, current_func);\n  };\n\n  Opal.find_owning_class = function(klass, current_func) {\n    var owner = current_func.$$owner;\n\n    while (klass) {\n      // repeating for readability\n\n      if (klass.$$iclass && klass.$$module === current_func.$$donated) {\n        // this klass was the last one the module donated to\n        // case is also hit with multiple module includes\n        break;\n      }\n      else if (klass.$$iclass && klass.$$module === owner) {\n        // module has donated to other classes but klass isn't one of those\n        break;\n      }\n      else if (owner.$$is_singleton && klass === owner.$$singleton_of.$$class) {\n        // cases like stdlib `Singleton::included` that use a singleton of a singleton\n        break;\n      }\n      else if (klass === owner) {\n        // no modules, pure class inheritance\n        break;\n      }\n\n      klass = klass.$$parent;\n    }\n\n    return klass;\n  };\n\n  Opal.find_super_func = function(owning_klass, jsid, current_func) {\n    var klass = owning_klass.$$parent;\n\n    // now we can find the super\n    while (klass) {\n      var working = klass.$$proto[jsid];\n\n      if (working && working !== current_func) {\n        // ok\n        break;\n      }\n\n      klass = klass.$$parent;\n    }\n\n    return klass.$$proto;\n  };\n\n  // Used to return as an expression. Sometimes, we can't simply return from\n  // a javascript function as if we were a method, as the return is used as\n  // an expression, or even inside a block which must \"return\" to the outer\n  // method. This helper simply throws an error which is then caught by the\n  // method. This approach is expensive, so it is only used when absolutely\n  // needed.\n  //\n  Opal.ret = function(val) {\n    Opal.returner.$v = val;\n    throw Opal.returner;\n  };\n\n  // Used to break out of a block.\n  Opal.brk = function(val, breaker) {\n    breaker.$v = val;\n    throw breaker;\n  };\n\n  // Builds a new unique breaker, this is to avoid multiple nested breaks to get\n  // in the way of each other.\n  Opal.new_brk = function() {\n    return new Error('unexpected break');\n  };\n\n  // handles yield calls for 1 yielded arg\n  Opal.yield1 = function(block, arg) {\n    if (typeof(block) !== \"function\") {\n      throw Opal.LocalJumpError.$new(\"no block given\");\n    }\n\n    var has_mlhs = block.$$has_top_level_mlhs_arg,\n        has_trailing_comma = block.$$has_trailing_comma_in_args;\n\n    if (block.length > 1 || ((has_mlhs || has_trailing_comma) && block.length === 1)) {\n      arg = Opal.to_ary(arg);\n    }\n\n    if ((block.length > 1 || (has_trailing_comma && block.length === 1)) && arg.$$is_array) {\n      return block.apply(null, arg);\n    }\n    else {\n      return block(arg);\n    }\n  };\n\n  // handles yield for > 1 yielded arg\n  Opal.yieldX = function(block, args) {\n    if (typeof(block) !== \"function\") {\n      throw Opal.LocalJumpError.$new(\"no block given\");\n    }\n\n    if (block.length > 1 && args.length === 1) {\n      if (args[0].$$is_array) {\n        return block.apply(null, args[0]);\n      }\n    }\n\n    if (!args.$$is_array) {\n      var args_ary = new Array(args.length);\n      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }\n\n      return block.apply(null, args_ary);\n    }\n\n    return block.apply(null, args);\n  };\n\n  // Finds the corresponding exception match in candidates.  Each candidate can\n  // be a value, or an array of values.  Returns null if not found.\n  Opal.rescue = function(exception, candidates) {\n    for (var i = 0; i < candidates.length; i++) {\n      var candidate = candidates[i];\n\n      if (candidate.$$is_array) {\n        var result = Opal.rescue(exception, candidate);\n\n        if (result) {\n          return result;\n        }\n      }\n      else if (candidate === Opal.JS.Error) {\n        return candidate;\n      }\n      else if (candidate['$==='](exception)) {\n        return candidate;\n      }\n    }\n\n    return null;\n  };\n\n  Opal.is_a = function(object, klass) {\n    if (object.$$meta === klass || object.$$class === klass) {\n      return true;\n    }\n\n    if (object.$$is_number && klass.$$is_number_class) {\n      return true;\n    }\n\n    var i, length, ancestors = Opal.ancestors(object.$$is_class ? Opal.get_singleton_class(object) : (object.$$meta || object.$$class));\n\n    for (i = 0, length = ancestors.length; i < length; i++) {\n      if (ancestors[i] === klass) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  // Helpers for extracting kwsplats\n  // Used for: { **h }\n  Opal.to_hash = function(value) {\n    if (value.$$is_hash) {\n      return value;\n    }\n    else if (value['$respond_to?']('to_hash', true)) {\n      var hash = value.$to_hash();\n      if (hash.$$is_hash) {\n        return hash;\n      }\n      else {\n        throw Opal.TypeError.$new(\"Can't convert \" + value.$$class +\n          \" to Hash (\" + value.$$class + \"#to_hash gives \" + hash.$$class + \")\");\n      }\n    }\n    else {\n      throw Opal.TypeError.$new(\"no implicit conversion of \" + value.$$class + \" into Hash\");\n    }\n  };\n\n  // Helpers for implementing multiple assignment\n  // Our code for extracting the values and assigning them only works if the\n  // return value is a JS array.\n  // So if we get an Array subclass, extract the wrapped JS array from it\n\n  // Used for: a, b = something (no splat)\n  Opal.to_ary = function(value) {\n    if (value.$$is_array) {\n      return value;\n    }\n    else if (value['$respond_to?']('to_ary', true)) {\n      var ary = value.$to_ary();\n      if (ary === nil) {\n        return [value];\n      }\n      else if (ary.$$is_array) {\n        return ary;\n      }\n      else {\n        throw Opal.TypeError.$new(\"Can't convert \" + value.$$class +\n          \" to Array (\" + value.$$class + \"#to_ary gives \" + ary.$$class + \")\");\n      }\n    }\n    else {\n      return [value];\n    }\n  };\n\n  // Used for: a, b = *something (with splat)\n  Opal.to_a = function(value) {\n    if (value.$$is_array) {\n      // A splatted array must be copied\n      return value.slice();\n    }\n    else if (value['$respond_to?']('to_a', true)) {\n      var ary = value.$to_a();\n      if (ary === nil) {\n        return [value];\n      }\n      else if (ary.$$is_array) {\n        return ary;\n      }\n      else {\n        throw Opal.TypeError.$new(\"Can't convert \" + value.$$class +\n          \" to Array (\" + value.$$class + \"#to_a gives \" + ary.$$class + \")\");\n      }\n    }\n    else {\n      return [value];\n    }\n  };\n\n  // Used for extracting keyword arguments from arguments passed to\n  // JS function. If provided +arguments+ list doesn't have a Hash\n  // as a last item, returns a blank Hash.\n  //\n  // @param parameters [Array]\n  // @return [Hash]\n  //\n  Opal.extract_kwargs = function(parameters) {\n    var kwargs = parameters[parameters.length - 1];\n    if (kwargs != null && kwargs['$respond_to?']('to_hash', true)) {\n      Array.prototype.splice.call(parameters, parameters.length - 1, 1);\n      return kwargs.$to_hash();\n    }\n    else {\n      return Opal.hash2([], {});\n    }\n  }\n\n  // Used to get a list of rest keyword arguments. Method takes the given\n  // keyword args, i.e. the hash literal passed to the method containing all\n  // keyword arguemnts passed to method, as well as the used args which are\n  // the names of required and optional arguments defined. This method then\n  // just returns all key/value pairs which have not been used, in a new\n  // hash literal.\n  //\n  // @param given_args [Hash] all kwargs given to method\n  // @param used_args [Object<String: true>] all keys used as named kwargs\n  // @return [Hash]\n  //\n  Opal.kwrestargs = function(given_args, used_args) {\n    var keys      = [],\n        map       = {},\n        key       = null,\n        given_map = given_args.$$smap;\n\n    for (key in given_map) {\n      if (!used_args[key]) {\n        keys.push(key);\n        map[key] = given_map[key];\n      }\n    }\n\n    return Opal.hash2(keys, map);\n  };\n\n  // Calls passed method on a ruby object with arguments and block:\n  //\n  // Can take a method or a method name.\n  //\n  // 1. When method name gets passed it invokes it by its name\n  //    and calls 'method_missing' when object doesn't have this method.\n  //    Used internally by Opal to invoke method that takes a block or a splat.\n  // 2. When method (i.e. method body) gets passed, it doesn't trigger 'method_missing'\n  //    because it doesn't know the name of the actual method.\n  //    Used internally by Opal to invoke 'super'.\n  //\n  // @example\n  //   var my_array = [1, 2, 3, 4]\n  //   Opal.send(my_array, 'length')                    # => 4\n  //   Opal.send(my_array, my_array.$length)            # => 4\n  //\n  //   Opal.send(my_array, 'reverse!')                  # => [4, 3, 2, 1]\n  //   Opal.send(my_array, my_array['$reverse!']')      # => [4, 3, 2, 1]\n  //\n  // @param recv [Object] ruby object\n  // @param method [Function, String] method body or name of the method\n  // @param args [Array] arguments that will be passed to the method call\n  // @param block [Function] ruby block\n  // @return [Object] returning value of the method call\n  Opal.send = function(recv, method, args, block) {\n    var body = (typeof(method) === 'string') ? recv['$'+method] : method;\n\n    if (body != null) {\n      body.$$p = block;\n      return body.apply(recv, args);\n    }\n\n    return recv.$method_missing.apply(recv, [method].concat(args));\n  }\n\n  Opal.lambda = function(block) {\n    block.$$is_lambda = true;\n    return block;\n  }\n\n  // Used to define methods on an object. This is a helper method, used by the\n  // compiled source to define methods on special case objects when the compiler\n  // can not determine the destination object, or the object is a Module\n  // instance. This can get called by `Module#define_method` as well.\n  //\n  // ## Modules\n  //\n  // Any method defined on a module will come through this runtime helper.\n  // The method is added to the module body, and the owner of the method is\n  // set to be the module itself. This is used later when choosing which\n  // method should show on a class if more than 1 included modules define\n  // the same method. Finally, if the module is in `module_function` mode,\n  // then the method is also defined onto the module itself.\n  //\n  // ## Classes\n  //\n  // This helper will only be called for classes when a method is being\n  // defined indirectly; either through `Module#define_method`, or by a\n  // literal `def` method inside an `instance_eval` or `class_eval` body. In\n  // either case, the method is simply added to the class' prototype. A special\n  // exception exists for `BasicObject` and `Object`. These two classes are\n  // special because they are used in toll-free bridged classes. In each of\n  // these two cases, extra work is required to define the methods on toll-free\n  // bridged class' prototypes as well.\n  //\n  // ## Objects\n  //\n  // If a simple ruby object is the object, then the method is simply just\n  // defined on the object as a singleton method. This would be the case when\n  // a method is defined inside an `instance_eval` block.\n  //\n  // @param obj  [Object, Class] the actual obj to define method for\n  // @param jsid [String] the JavaScript friendly method name (e.g. '$foo')\n  // @param body [JS.Function] the literal JavaScript function used as method\n  // @return [null]\n  //\n  Opal.def = function(obj, jsid, body) {\n    // Special case for a method definition in the\n    // top-level namespace\n    if (obj === Opal.top) {\n      Opal.defn(Opal.Object, jsid, body)\n    }\n    // if instance_eval is invoked on a module/class, it sets inst_eval_mod\n    else if (!obj.$$eval && (obj.$$is_class || obj.$$is_module)) {\n      Opal.defn(obj, jsid, body);\n    }\n    else {\n      Opal.defs(obj, jsid, body);\n    }\n  };\n\n  // Define method on a module or class (see Opal.def).\n  Opal.defn = function(obj, jsid, body) {\n    obj.$$proto[jsid] = body;\n    // for super dispatcher, etc.\n    body.$$owner = obj;\n    if (body.displayName == null) body.displayName = jsid.substr(1);\n\n    // is it a module?\n    if (obj.$$is_module) {\n      Opal.update_includers(obj, jsid);\n\n      if (obj.$$module_function) {\n        Opal.defs(obj, jsid, body);\n      }\n    }\n\n    // is it a bridged class?\n    var bridged = obj.$__id__ && !obj.$__id__.$$stub && BridgedClasses[obj.$__id__()];\n    if (bridged) {\n      for (var i = bridged.length - 1; i >= 0; i--) {\n        Opal.bridge_method(bridged[i], obj, jsid, body);\n      }\n    }\n\n    // method_added/singleton_method_added hooks\n    var singleton_of = obj.$$singleton_of;\n    if (obj.$method_added && !obj.$method_added.$$stub && !singleton_of) {\n      obj.$method_added(jsid.substr(1));\n    }\n    else if (singleton_of && singleton_of.$singleton_method_added && !singleton_of.$singleton_method_added.$$stub) {\n      singleton_of.$singleton_method_added(jsid.substr(1));\n    }\n\n    return nil;\n  };\n\n  // Define a singleton method on the given object (see Opal.def).\n  Opal.defs = function(obj, jsid, body) {\n    Opal.defn(Opal.get_singleton_class(obj), jsid, body)\n  };\n\n  // Called from #remove_method.\n  Opal.rdef = function(obj, jsid) {\n    // TODO: remove from BridgedClasses as well\n\n    if (!$hasOwn.call(obj.$$proto, jsid)) {\n      throw Opal.NameError.$new(\"method '\" + jsid.substr(1) + \"' not defined in \" + obj.$name());\n    }\n\n    delete obj.$$proto[jsid];\n\n    if (obj.$$is_singleton) {\n      if (obj.$$proto.$singleton_method_removed && !obj.$$proto.$singleton_method_removed.$$stub) {\n        obj.$$proto.$singleton_method_removed(jsid.substr(1));\n      }\n    }\n    else {\n      if (obj.$method_removed && !obj.$method_removed.$$stub) {\n        obj.$method_removed(jsid.substr(1));\n      }\n    }\n  };\n\n  // Called from #undef_method.\n  Opal.udef = function(obj, jsid) {\n    if (!obj.$$proto[jsid] || obj.$$proto[jsid].$$stub) {\n      throw Opal.NameError.$new(\"method '\" + jsid.substr(1) + \"' not defined in \" + obj.$name());\n    }\n\n    Opal.add_stub_for(obj.$$proto, jsid);\n\n    if (obj.$$is_singleton) {\n      if (obj.$$proto.$singleton_method_undefined && !obj.$$proto.$singleton_method_undefined.$$stub) {\n        obj.$$proto.$singleton_method_undefined(jsid.substr(1));\n      }\n    }\n    else {\n      if (obj.$method_undefined && !obj.$method_undefined.$$stub) {\n        obj.$method_undefined(jsid.substr(1));\n      }\n    }\n  };\n\n  Opal.alias = function(obj, name, old) {\n    var id     = '$' + name,\n        old_id = '$' + old,\n        body   = obj.$$proto['$' + old],\n        alias;\n\n    // When running inside #instance_eval the alias refers to class methods.\n    if (obj.$$eval) {\n      return Opal.alias(Opal.get_singleton_class(obj), name, old);\n    }\n\n    if (typeof(body) !== \"function\" || body.$$stub) {\n      var ancestor = obj.$$super;\n\n      while (typeof(body) !== \"function\" && ancestor) {\n        body     = ancestor[old_id];\n        ancestor = ancestor.$$super;\n      }\n\n      if (typeof(body) !== \"function\" || body.$$stub) {\n        throw Opal.NameError.$new(\"undefined method `\" + old + \"' for class `\" + obj.$name() + \"'\")\n      }\n    }\n\n    // If the body is itself an alias use the original body\n    // to keep the max depth at 1.\n    if (body.$$alias_of) body = body.$$alias_of;\n\n    // We need a wrapper because otherwise method $$owner and other properties\n    // would be ovrewritten on the original body.\n    alias = function() {\n      var block = alias.$$p, args, i, ii;\n\n      args = new Array(arguments.length);\n      for(i = 0, ii = arguments.length; i < ii; i++) {\n        args[i] = arguments[i];\n      }\n\n      if (block != null) { alias.$$p = null }\n\n      return Opal.send(this, body, args, block);\n    };\n\n    // Try to make the browser pick the right name\n    alias.displayName       = name;\n    alias.length            = body.length;\n    alias.$$arity           = body.$$arity;\n    alias.$$parameters      = body.$$parameters;\n    alias.$$source_location = body.$$source_location;\n    alias.$$alias_of        = body;\n    alias.$$alias_name      = name;\n\n    Opal.defn(obj, id, alias);\n\n    return obj;\n  };\n\n  Opal.alias_native = function(obj, name, native_name) {\n    var id   = '$' + name,\n        body = obj.$$proto[native_name];\n\n    if (typeof(body) !== \"function\" || body.$$stub) {\n      throw Opal.NameError.$new(\"undefined native method `\" + native_name + \"' for class `\" + obj.$name() + \"'\")\n    }\n\n    Opal.defn(obj, id, body);\n\n    return obj;\n  };\n\n\n  // Hashes\n  // ------\n\n  Opal.hash_init = function(hash) {\n    hash.$$smap = Object.create(null);\n    hash.$$map  = Object.create(null);\n    hash.$$keys = [];\n  };\n\n  Opal.hash_clone = function(from_hash, to_hash) {\n    to_hash.$$none = from_hash.$$none;\n    to_hash.$$proc = from_hash.$$proc;\n\n    for (var i = 0, keys = from_hash.$$keys, smap = from_hash.$$smap, len = keys.length, key, value; i < len; i++) {\n      key = keys[i];\n\n      if (key.$$is_string) {\n        value = smap[key];\n      } else {\n        value = key.value;\n        key = key.key;\n      }\n\n      Opal.hash_put(to_hash, key, value);\n    }\n  };\n\n  Opal.hash_put = function(hash, key, value) {\n    if (key.$$is_string) {\n      if (!$hasOwn.call(hash.$$smap, key)) {\n        hash.$$keys.push(key);\n      }\n      hash.$$smap[key] = value;\n      return;\n    }\n\n    var key_hash, bucket, last_bucket;\n    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();\n\n    if (!$hasOwn.call(hash.$$map, key_hash)) {\n      bucket = {key: key, key_hash: key_hash, value: value};\n      hash.$$keys.push(bucket);\n      hash.$$map[key_hash] = bucket;\n      return;\n    }\n\n    bucket = hash.$$map[key_hash];\n\n    while (bucket) {\n      if (key === bucket.key || key['$eql?'](bucket.key)) {\n        last_bucket = undefined;\n        bucket.value = value;\n        break;\n      }\n      last_bucket = bucket;\n      bucket = bucket.next;\n    }\n\n    if (last_bucket) {\n      bucket = {key: key, key_hash: key_hash, value: value};\n      hash.$$keys.push(bucket);\n      last_bucket.next = bucket;\n    }\n  };\n\n  Opal.hash_get = function(hash, key) {\n    if (key.$$is_string) {\n      if ($hasOwn.call(hash.$$smap, key)) {\n        return hash.$$smap[key];\n      }\n      return;\n    }\n\n    var key_hash, bucket;\n    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();\n\n    if ($hasOwn.call(hash.$$map, key_hash)) {\n      bucket = hash.$$map[key_hash];\n\n      while (bucket) {\n        if (key === bucket.key || key['$eql?'](bucket.key)) {\n          return bucket.value;\n        }\n        bucket = bucket.next;\n      }\n    }\n  };\n\n  Opal.hash_delete = function(hash, key) {\n    var i, keys = hash.$$keys, length = keys.length, value;\n\n    if (key.$$is_string) {\n      if (!$hasOwn.call(hash.$$smap, key)) {\n        return;\n      }\n\n      for (i = 0; i < length; i++) {\n        if (keys[i] === key) {\n          keys.splice(i, 1);\n          break;\n        }\n      }\n\n      value = hash.$$smap[key];\n      delete hash.$$smap[key];\n      return value;\n    }\n\n    var key_hash = key.$hash();\n\n    if (!$hasOwn.call(hash.$$map, key_hash)) {\n      return;\n    }\n\n    var bucket = hash.$$map[key_hash], last_bucket;\n\n    while (bucket) {\n      if (key === bucket.key || key['$eql?'](bucket.key)) {\n        value = bucket.value;\n\n        for (i = 0; i < length; i++) {\n          if (keys[i] === bucket) {\n            keys.splice(i, 1);\n            break;\n          }\n        }\n\n        if (last_bucket && bucket.next) {\n          last_bucket.next = bucket.next;\n        }\n        else if (last_bucket) {\n          delete last_bucket.next;\n        }\n        else if (bucket.next) {\n          hash.$$map[key_hash] = bucket.next;\n        }\n        else {\n          delete hash.$$map[key_hash];\n        }\n\n        return value;\n      }\n      last_bucket = bucket;\n      bucket = bucket.next;\n    }\n  };\n\n  Opal.hash_rehash = function(hash) {\n    for (var i = 0, length = hash.$$keys.length, key_hash, bucket, last_bucket; i < length; i++) {\n\n      if (hash.$$keys[i].$$is_string) {\n        continue;\n      }\n\n      key_hash = hash.$$keys[i].key.$hash();\n\n      if (key_hash === hash.$$keys[i].key_hash) {\n        continue;\n      }\n\n      bucket = hash.$$map[hash.$$keys[i].key_hash];\n      last_bucket = undefined;\n\n      while (bucket) {\n        if (bucket === hash.$$keys[i]) {\n          if (last_bucket && bucket.next) {\n            last_bucket.next = bucket.next;\n          }\n          else if (last_bucket) {\n            delete last_bucket.next;\n          }\n          else if (bucket.next) {\n            hash.$$map[hash.$$keys[i].key_hash] = bucket.next;\n          }\n          else {\n            delete hash.$$map[hash.$$keys[i].key_hash];\n          }\n          break;\n        }\n        last_bucket = bucket;\n        bucket = bucket.next;\n      }\n\n      hash.$$keys[i].key_hash = key_hash;\n\n      if (!$hasOwn.call(hash.$$map, key_hash)) {\n        hash.$$map[key_hash] = hash.$$keys[i];\n        continue;\n      }\n\n      bucket = hash.$$map[key_hash];\n      last_bucket = undefined;\n\n      while (bucket) {\n        if (bucket === hash.$$keys[i]) {\n          last_bucket = undefined;\n          break;\n        }\n        last_bucket = bucket;\n        bucket = bucket.next;\n      }\n\n      if (last_bucket) {\n        last_bucket.next = hash.$$keys[i];\n      }\n    }\n  };\n\n  Opal.hash = function() {\n    var arguments_length = arguments.length, args, hash, i, length, key, value;\n\n    if (arguments_length === 1 && arguments[0].$$is_hash) {\n      return arguments[0];\n    }\n\n    hash = new Opal.Hash.$$alloc();\n    Opal.hash_init(hash);\n\n    if (arguments_length === 1 && arguments[0].$$is_array) {\n      args = arguments[0];\n      length = args.length;\n\n      for (i = 0; i < length; i++) {\n        if (args[i].length !== 2) {\n          throw Opal.ArgumentError.$new(\"value not of length 2: \" + args[i].$inspect());\n        }\n\n        key = args[i][0];\n        value = args[i][1];\n\n        Opal.hash_put(hash, key, value);\n      }\n\n      return hash;\n    }\n\n    if (arguments_length === 1) {\n      args = arguments[0];\n      for (key in args) {\n        if ($hasOwn.call(args, key)) {\n          value = args[key];\n\n          Opal.hash_put(hash, key, value);\n        }\n      }\n\n      return hash;\n    }\n\n    if (arguments_length % 2 !== 0) {\n      throw Opal.ArgumentError.$new(\"odd number of arguments for Hash\");\n    }\n\n    for (i = 0; i < arguments_length; i += 2) {\n      key = arguments[i];\n      value = arguments[i + 1];\n\n      Opal.hash_put(hash, key, value);\n    }\n\n    return hash;\n  };\n\n  // A faster Hash creator for hashes that just use symbols and\n  // strings as keys. The map and keys array can be constructed at\n  // compile time, so they are just added here by the constructor\n  // function.\n  //\n  Opal.hash2 = function(keys, smap) {\n    var hash = new Opal.Hash.$$alloc();\n\n    hash.$$smap = smap;\n    hash.$$map  = Object.create(null);\n    hash.$$keys = keys;\n\n    return hash;\n  };\n\n  // Create a new range instance with first and last values, and whether the\n  // range excludes the last value.\n  //\n  Opal.range = function(first, last, exc) {\n    var range         = new Opal.Range.$$alloc();\n        range.begin   = first;\n        range.end     = last;\n        range.excl    = exc;\n\n    return range;\n  };\n\n  // Get the ivar name for a given name.\n  // Mostly adds a trailing $ to reserved names.\n  //\n  Opal.ivar = function(name) {\n    if (\n        // properties\n        name === \"constructor\" ||\n        name === \"displayName\" ||\n        name === \"__count__\" ||\n        name === \"__noSuchMethod__\" ||\n        name === \"__parent__\" ||\n        name === \"__proto__\" ||\n\n        // methods\n        name === \"hasOwnProperty\" ||\n        name === \"valueOf\"\n       )\n    {\n      return name + \"$\";\n    }\n\n    return name;\n  };\n\n\n  // Regexps\n  // -------\n\n  // Escape Regexp special chars letting the resulting string be used to build\n  // a new Regexp.\n  //\n  Opal.escape_regexp = function(str) {\n    return str.replace(/([-[\\]\\/{}()*+?.^$\\\\| ])/g, '\\\\$1')\n              .replace(/[\\n]/g, '\\\\n')\n              .replace(/[\\r]/g, '\\\\r')\n              .replace(/[\\f]/g, '\\\\f')\n              .replace(/[\\t]/g, '\\\\t');\n  }\n\n\n  // Require system\n  // --------------\n\n  Opal.modules         = {};\n  Opal.loaded_features = ['corelib/runtime'];\n  Opal.current_dir     = '.'\n  Opal.require_table   = {'corelib/runtime': true};\n\n  Opal.normalize = function(path) {\n    var parts, part, new_parts = [], SEPARATOR = '/';\n\n    if (Opal.current_dir !== '.') {\n      path = Opal.current_dir.replace(/\\/*$/, '/') + path;\n    }\n\n    path = path.replace(/^\\.\\//, '');\n    path = path.replace(/\\.(rb|opal|js)$/, '');\n    parts = path.split(SEPARATOR);\n\n    for (var i = 0, ii = parts.length; i < ii; i++) {\n      part = parts[i];\n      if (part === '') continue;\n      (part === '..') ? new_parts.pop() : new_parts.push(part)\n    }\n\n    return new_parts.join(SEPARATOR);\n  };\n\n  Opal.loaded = function(paths) {\n    var i, l, path;\n\n    for (i = 0, l = paths.length; i < l; i++) {\n      path = Opal.normalize(paths[i]);\n\n      if (Opal.require_table[path]) {\n        return;\n      }\n\n      Opal.loaded_features.push(path);\n      Opal.require_table[path] = true;\n    }\n  };\n\n  Opal.load = function(path) {\n    path = Opal.normalize(path);\n\n    Opal.loaded([path]);\n\n    var module = Opal.modules[path];\n\n    if (module) {\n      module(Opal);\n    }\n    else {\n      var severity = Opal.config.missing_require_severity;\n      var message  = 'cannot load such file -- ' + path;\n\n      if (severity === \"error\") {\n        if (Opal.LoadError) {\n          throw Opal.LoadError.$new(message)\n        } else {\n          throw message\n        }\n      }\n      else if (severity === \"warning\") {\n        console.warn('WARNING: LoadError: ' + message);\n      }\n    }\n\n    return true;\n  };\n\n  Opal.require = function(path) {\n    path = Opal.normalize(path);\n\n    if (Opal.require_table[path]) {\n      return false;\n    }\n\n    return Opal.load(path);\n  };\n\n\n  // Initialization\n  // --------------\n\n  // Constructors for *instances* of core objects\n  Opal.boot_class_alloc('BasicObject', BasicObject_alloc);\n  Opal.boot_class_alloc('Object',      Object_alloc,       BasicObject_alloc);\n  Opal.boot_class_alloc('Module',      Module_alloc,       Object_alloc);\n  Opal.boot_class_alloc('Class',       Class_alloc,        Module_alloc);\n\n  // Constructors for *classes* of core objects\n  Opal.BasicObject = BasicObject = Opal.setup_class_object('BasicObject', BasicObject_alloc, 'Class',       Class_alloc);\n  Opal.Object      = _Object     = Opal.setup_class_object('Object',      Object_alloc,      'BasicObject', BasicObject.constructor);\n  Opal.Module      = Module      = Opal.setup_class_object('Module',      Module_alloc,      'Object',      _Object.constructor);\n  Opal.Class       = Class       = Opal.setup_class_object('Class',       Class_alloc,       'Module',      Module.constructor);\n\n  // BasicObject can reach itself, avoid const_set to skip the $$base_module logic\n  BasicObject.$$const[\"BasicObject\"] = BasicObject;\n\n  // Assign basic constants\n  Opal.const_set(_Object, \"BasicObject\",  BasicObject);\n  Opal.const_set(_Object, \"Object\",       _Object);\n  Opal.const_set(_Object, \"Module\",       Module);\n  Opal.const_set(_Object, \"Class\",        Class);\n\n\n  // Fix booted classes to use their metaclass\n  BasicObject.$$class = Class;\n  _Object.$$class     = Class;\n  Module.$$class      = Class;\n  Class.$$class       = Class;\n\n  // Fix superclasses of booted classes\n  BasicObject.$$super = null;\n  _Object.$$super     = BasicObject;\n  Module.$$super      = _Object;\n  Class.$$super       = Module;\n\n  BasicObject.$$parent = null;\n  _Object.$$parent     = BasicObject;\n  Module.$$parent      = _Object;\n  Class.$$parent       = Module;\n\n  // Forward .toString() to #to_s\n  _Object.$$proto.toString = function() {\n    var to_s = this.$to_s();\n    if (to_s.$$is_string && typeof(to_s) === 'object') {\n      // a string created using new String('string')\n      return to_s.valueOf();\n    } else {\n      return to_s;\n    }\n  };\n\n  // Make Kernel#require immediately available as it's needed to require all the\n  // other corelib files.\n  _Object.$$proto.$require = Opal.require;\n\n  // Add a short helper to navigate constants manually.\n  // @example\n  //   Opal.$$.Regexp.$$.IGNORECASE\n  Opal.$$ = _Object.$$;\n\n  // Instantiate the main object\n  Opal.top = new _Object.$$alloc();\n  Opal.top.$to_s = Opal.top.$inspect = function() { return 'main' };\n\n  // Nil\n  Opal.klass(_Object, _Object, 'NilClass', NilClass_alloc);\n  nil = Opal.nil = new NilClass_alloc();\n  nil.$$id = nil_id;\n  nil.call = nil.apply = function() { throw Opal.LocalJumpError.$new('no block given'); };\n\n  // Errors\n  Opal.breaker  = new Error('unexpected break (old)');\n  Opal.returner = new Error('unexpected return');\n  TypeError.$$super = Error;\n}).call(this);\nOpal.loaded([\"corelib/runtime\"]);\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/helpers\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$new', '$class', '$===', '$respond_to?', '$raise', '$type_error', '$__send__', '$coerce_to', '$nil?', '$<=>', '$coerce_to!', '$!=', '$[]', '$upcase']);\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Opal_bridge_1, TMP_Opal_type_error_2, TMP_Opal_coerce_to_3, TMP_Opal_coerce_to$B_4, TMP_Opal_coerce_to$q_5, TMP_Opal_try_convert_6, TMP_Opal_compare_7, TMP_Opal_destructure_8, TMP_Opal_respond_to$q_9, TMP_Opal_inspect_obj_10, TMP_Opal_instance_variable_name$B_11, TMP_Opal_class_variable_name$B_12, TMP_Opal_const_name$B_13, TMP_Opal_pristine_14;\n\n    \n    Opal.defs(self, '$bridge', TMP_Opal_bridge_1 = function $$bridge(klass, constructor) {\n      var self = this;\n\n      return Opal.bridge(klass, constructor);\n    }, TMP_Opal_bridge_1.$$arity = 2);\n    Opal.defs(self, '$type_error', TMP_Opal_type_error_2 = function $$type_error(object, type, method, coerced) {\n      var $a, self = this;\n\n      if (method == null) {\n        method = nil;\n      }\n      if (coerced == null) {\n        coerced = nil;\n      }\n      if ($truthy(($truthy($a = method) ? coerced : $a))) {\n        return $$($nesting, 'TypeError').$new(\"\" + \"can't convert \" + (object.$class()) + \" into \" + (type) + \" (\" + (object.$class()) + \"#\" + (method) + \" gives \" + (coerced.$class()) + \")\")\n      } else {\n        return $$($nesting, 'TypeError').$new(\"\" + \"no implicit conversion of \" + (object.$class()) + \" into \" + (type))\n      }\n    }, TMP_Opal_type_error_2.$$arity = -3);\n    Opal.defs(self, '$coerce_to', TMP_Opal_coerce_to_3 = function $$coerce_to(object, type, method) {\n      var self = this;\n\n      \n      if ($truthy(type['$==='](object))) {\n        return object};\n      if ($truthy(object['$respond_to?'](method))) {\n      } else {\n        self.$raise(self.$type_error(object, type))\n      };\n      return object.$__send__(method);\n    }, TMP_Opal_coerce_to_3.$$arity = 3);\n    Opal.defs(self, '$coerce_to!', TMP_Opal_coerce_to$B_4 = function(object, type, method) {\n      var self = this, coerced = nil;\n\n      \n      coerced = self.$coerce_to(object, type, method);\n      if ($truthy(type['$==='](coerced))) {\n      } else {\n        self.$raise(self.$type_error(object, type, method, coerced))\n      };\n      return coerced;\n    }, TMP_Opal_coerce_to$B_4.$$arity = 3);\n    Opal.defs(self, '$coerce_to?', TMP_Opal_coerce_to$q_5 = function(object, type, method) {\n      var self = this, coerced = nil;\n\n      \n      if ($truthy(object['$respond_to?'](method))) {\n      } else {\n        return nil\n      };\n      coerced = self.$coerce_to(object, type, method);\n      if ($truthy(coerced['$nil?']())) {\n        return nil};\n      if ($truthy(type['$==='](coerced))) {\n      } else {\n        self.$raise(self.$type_error(object, type, method, coerced))\n      };\n      return coerced;\n    }, TMP_Opal_coerce_to$q_5.$$arity = 3);\n    Opal.defs(self, '$try_convert', TMP_Opal_try_convert_6 = function $$try_convert(object, type, method) {\n      var self = this;\n\n      \n      if ($truthy(type['$==='](object))) {\n        return object};\n      if ($truthy(object['$respond_to?'](method))) {\n        return object.$__send__(method)\n      } else {\n        return nil\n      };\n    }, TMP_Opal_try_convert_6.$$arity = 3);\n    Opal.defs(self, '$compare', TMP_Opal_compare_7 = function $$compare(a, b) {\n      var self = this, compare = nil;\n\n      \n      compare = a['$<=>'](b);\n      if ($truthy(compare === nil)) {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (a.$class()) + \" with \" + (b.$class()) + \" failed\")};\n      return compare;\n    }, TMP_Opal_compare_7.$$arity = 2);\n    Opal.defs(self, '$destructure', TMP_Opal_destructure_8 = function $$destructure(args) {\n      var self = this;\n\n      \n      if (args.length == 1) {\n        return args[0];\n      }\n      else if (args.$$is_array) {\n        return args;\n      }\n      else {\n        var args_ary = new Array(args.length);\n        for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }\n\n        return args_ary;\n      }\n    \n    }, TMP_Opal_destructure_8.$$arity = 1);\n    Opal.defs(self, '$respond_to?', TMP_Opal_respond_to$q_9 = function(obj, method, include_all) {\n      var self = this;\n\n      if (include_all == null) {\n        include_all = false;\n      }\n      \n      \n      if (obj == null || !obj.$$class) {\n        return false;\n      }\n    ;\n      return obj['$respond_to?'](method, include_all);\n    }, TMP_Opal_respond_to$q_9.$$arity = -3);\n    Opal.defs(self, '$inspect_obj', TMP_Opal_inspect_obj_10 = function $$inspect_obj(obj) {\n      var self = this;\n\n      return Opal.inspect(obj);\n    }, TMP_Opal_inspect_obj_10.$$arity = 1);\n    Opal.defs(self, '$instance_variable_name!', TMP_Opal_instance_variable_name$B_11 = function(name) {\n      var self = this;\n\n      \n      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), \"to_str\");\n      if ($truthy(/^@[a-zA-Z_][a-zA-Z0-9_]*?$/.test(name))) {\n      } else {\n        self.$raise($$($nesting, 'NameError').$new(\"\" + \"'\" + (name) + \"' is not allowed as an instance variable name\", name))\n      };\n      return name;\n    }, TMP_Opal_instance_variable_name$B_11.$$arity = 1);\n    Opal.defs(self, '$class_variable_name!', TMP_Opal_class_variable_name$B_12 = function(name) {\n      var self = this;\n\n      \n      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), \"to_str\");\n      if ($truthy(name.length < 3 || name.slice(0,2) !== '@@')) {\n        self.$raise($$($nesting, 'NameError').$new(\"\" + \"`\" + (name) + \"' is not allowed as a class variable name\", name))};\n      return name;\n    }, TMP_Opal_class_variable_name$B_12.$$arity = 1);\n    Opal.defs(self, '$const_name!', TMP_Opal_const_name$B_13 = function(const_name) {\n      var self = this;\n\n      \n      const_name = $$($nesting, 'Opal')['$coerce_to!'](const_name, $$($nesting, 'String'), \"to_str\");\n      if ($truthy(const_name['$[]'](0)['$!='](const_name['$[]'](0).$upcase()))) {\n        self.$raise($$($nesting, 'NameError'), \"\" + \"wrong constant name \" + (const_name))};\n      return const_name;\n    }, TMP_Opal_const_name$B_13.$$arity = 1);\n    Opal.defs(self, '$pristine', TMP_Opal_pristine_14 = function $$pristine(owner_class, $a_rest) {\n      var self = this, method_names;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      method_names = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        method_names[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      \n      \n      var method_name, method;\n      for (var i = method_names.length - 1; i >= 0; i--) {\n        method_name = method_names[i];\n        method = owner_class.$$proto['$'+method_name];\n\n        if (method && !method.$$stub) {\n          method.$$pristine = true;\n        }\n      }\n    ;\n      return nil;\n    }, TMP_Opal_pristine_14.$$arity = -2);\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/module\"] = function(Opal) {\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $lambda = Opal.lambda, $range = Opal.range, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$===', '$raise', '$equal?', '$<', '$>', '$nil?', '$attr_reader', '$attr_writer', '$class_variable_name!', '$new', '$const_name!', '$=~', '$inject', '$split', '$const_get', '$==', '$!~', '$start_with?', '$to_proc', '$bind', '$call', '$class', '$append_features', '$included', '$name', '$cover?', '$size', '$merge', '$compile', '$proc', '$any?', '$to_s', '$__id__', '$constants', '$include?', '$copy_class_variables', '$copy_constants']);\n  return (function($base, $super, $parent_nesting) {\n    function $Module(){};\n    var self = $Module = $klass($base, $super, 'Module', $Module);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Module_allocate_1, TMP_Module_initialize_2, TMP_Module_$eq$eq$eq_3, TMP_Module_$lt_4, TMP_Module_$lt$eq_5, TMP_Module_$gt_6, TMP_Module_$gt$eq_7, TMP_Module_$lt$eq$gt_8, TMP_Module_alias_method_9, TMP_Module_alias_native_10, TMP_Module_ancestors_11, TMP_Module_append_features_12, TMP_Module_attr_accessor_13, TMP_Module_attr_reader_14, TMP_Module_attr_writer_15, TMP_Module_autoload_16, TMP_Module_class_variables_17, TMP_Module_class_variable_get_18, TMP_Module_class_variable_set_19, TMP_Module_class_variable_defined$q_20, TMP_Module_remove_class_variable_21, TMP_Module_constants_22, TMP_Module_constants_23, TMP_Module_nesting_24, TMP_Module_const_defined$q_25, TMP_Module_const_get_27, TMP_Module_const_missing_28, TMP_Module_const_set_29, TMP_Module_public_constant_30, TMP_Module_define_method_31, TMP_Module_remove_method_33, TMP_Module_singleton_class$q_34, TMP_Module_include_35, TMP_Module_included_modules_36, TMP_Module_include$q_37, TMP_Module_instance_method_38, TMP_Module_instance_methods_39, TMP_Module_included_40, TMP_Module_extended_41, TMP_Module_extend_object_42, TMP_Module_method_added_43, TMP_Module_method_removed_44, TMP_Module_method_undefined_45, TMP_Module_module_eval_46, TMP_Module_module_exec_48, TMP_Module_method_defined$q_49, TMP_Module_module_function_50, TMP_Module_name_51, TMP_Module_remove_const_52, TMP_Module_to_s_53, TMP_Module_undef_method_54, TMP_Module_instance_variables_55, TMP_Module_dup_56, TMP_Module_copy_class_variables_57, TMP_Module_copy_constants_58;\n\n    \n    Opal.defs(self, '$allocate', TMP_Module_allocate_1 = function $$allocate() {\n      var self = this;\n\n      \n      var module;\n\n      module = Opal.module_allocate(self);\n      return module;\n    \n    }, TMP_Module_allocate_1.$$arity = 0);\n    \n    Opal.def(self, '$initialize', TMP_Module_initialize_2 = function $$initialize() {\n      var self = this, $iter = TMP_Module_initialize_2.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Module_initialize_2.$$p = null;\n      return Opal.module_initialize(self, block);\n    }, TMP_Module_initialize_2.$$arity = 0);\n    \n    Opal.def(self, '$===', TMP_Module_$eq$eq$eq_3 = function(object) {\n      var self = this;\n\n      \n      if ($truthy(object == null)) {\n        return false};\n      return Opal.is_a(object, self);;\n    }, TMP_Module_$eq$eq$eq_3.$$arity = 1);\n    \n    Opal.def(self, '$<', TMP_Module_$lt_4 = function(other) {\n      var self = this;\n\n      \n      if ($truthy($$($nesting, 'Module')['$==='](other))) {\n      } else {\n        self.$raise($$($nesting, 'TypeError'), \"compared with non class/module\")\n      };\n      \n      var working = self,\n          ancestors,\n          i, length;\n\n      if (working === other) {\n        return false;\n      }\n\n      for (i = 0, ancestors = Opal.ancestors(self), length = ancestors.length; i < length; i++) {\n        if (ancestors[i] === other) {\n          return true;\n        }\n      }\n\n      for (i = 0, ancestors = Opal.ancestors(other), length = ancestors.length; i < length; i++) {\n        if (ancestors[i] === self) {\n          return false;\n        }\n      }\n\n      return nil;\n    ;\n    }, TMP_Module_$lt_4.$$arity = 1);\n    \n    Opal.def(self, '$<=', TMP_Module_$lt$eq_5 = function(other) {\n      var $a, self = this;\n\n      return ($truthy($a = self['$equal?'](other)) ? $a : $rb_lt(self, other))\n    }, TMP_Module_$lt$eq_5.$$arity = 1);\n    \n    Opal.def(self, '$>', TMP_Module_$gt_6 = function(other) {\n      var self = this;\n\n      \n      if ($truthy($$($nesting, 'Module')['$==='](other))) {\n      } else {\n        self.$raise($$($nesting, 'TypeError'), \"compared with non class/module\")\n      };\n      return $rb_lt(other, self);\n    }, TMP_Module_$gt_6.$$arity = 1);\n    \n    Opal.def(self, '$>=', TMP_Module_$gt$eq_7 = function(other) {\n      var $a, self = this;\n\n      return ($truthy($a = self['$equal?'](other)) ? $a : $rb_gt(self, other))\n    }, TMP_Module_$gt$eq_7.$$arity = 1);\n    \n    Opal.def(self, '$<=>', TMP_Module_$lt$eq$gt_8 = function(other) {\n      var self = this, lt = nil;\n\n      \n      \n      if (self === other) {\n        return 0;\n      }\n    ;\n      if ($truthy($$($nesting, 'Module')['$==='](other))) {\n      } else {\n        return nil\n      };\n      lt = $rb_lt(self, other);\n      if ($truthy(lt['$nil?']())) {\n        return nil};\n      if ($truthy(lt)) {\n        return -1\n      } else {\n        return 1\n      };\n    }, TMP_Module_$lt$eq$gt_8.$$arity = 1);\n    \n    Opal.def(self, '$alias_method', TMP_Module_alias_method_9 = function $$alias_method(newname, oldname) {\n      var self = this;\n\n      \n      Opal.alias(self, newname, oldname);\n      return self;\n    }, TMP_Module_alias_method_9.$$arity = 2);\n    \n    Opal.def(self, '$alias_native', TMP_Module_alias_native_10 = function $$alias_native(mid, jsid) {\n      var self = this;\n\n      if (jsid == null) {\n        jsid = mid;\n      }\n      \n      Opal.alias_native(self, mid, jsid);\n      return self;\n    }, TMP_Module_alias_native_10.$$arity = -2);\n    \n    Opal.def(self, '$ancestors', TMP_Module_ancestors_11 = function $$ancestors() {\n      var self = this;\n\n      return Opal.ancestors(self);\n    }, TMP_Module_ancestors_11.$$arity = 0);\n    \n    Opal.def(self, '$append_features', TMP_Module_append_features_12 = function $$append_features(includer) {\n      var self = this;\n\n      \n      Opal.append_features(self, includer);\n      return self;\n    }, TMP_Module_append_features_12.$$arity = 1);\n    \n    Opal.def(self, '$attr_accessor', TMP_Module_attr_accessor_13 = function $$attr_accessor($a_rest) {\n      var self = this, names;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      names = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        names[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      $send(self, 'attr_reader', Opal.to_a(names));\n      return $send(self, 'attr_writer', Opal.to_a(names));\n    }, TMP_Module_attr_accessor_13.$$arity = -1);\n    Opal.alias(self, \"attr\", \"attr_accessor\");\n    \n    Opal.def(self, '$attr_reader', TMP_Module_attr_reader_14 = function $$attr_reader($a_rest) {\n      var self = this, names;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      names = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        names[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      \n      var proto = self.$$proto;\n\n      for (var i = names.length - 1; i >= 0; i--) {\n        var name = names[i],\n            id   = '$' + name,\n            ivar = Opal.ivar(name);\n\n        // the closure here is needed because name will change at the next\n        // cycle, I wish we could use let.\n        var body = (function(ivar) {\n          return function() {\n            if (this[ivar] == null) {\n              return nil;\n            }\n            else {\n              return this[ivar];\n            }\n          };\n        })(ivar);\n\n        // initialize the instance variable as nil\n        proto[ivar] = nil;\n\n        body.$$parameters = [];\n        body.$$arity = 0;\n\n        if (self.$$is_singleton) {\n          proto.constructor.prototype[id] = body;\n        }\n        else {\n          Opal.defn(self, id, body);\n        }\n      }\n    ;\n      return nil;\n    }, TMP_Module_attr_reader_14.$$arity = -1);\n    \n    Opal.def(self, '$attr_writer', TMP_Module_attr_writer_15 = function $$attr_writer($a_rest) {\n      var self = this, names;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      names = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        names[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      \n      var proto = self.$$proto;\n\n      for (var i = names.length - 1; i >= 0; i--) {\n        var name = names[i],\n            id   = '$' + name + '=',\n            ivar = Opal.ivar(name);\n\n        // the closure here is needed because name will change at the next\n        // cycle, I wish we could use let.\n        var body = (function(ivar){\n          return function(value) {\n            return this[ivar] = value;\n          }\n        })(ivar);\n\n        body.$$parameters = [['req']];\n        body.$$arity = 1;\n\n        // initialize the instance variable as nil\n        proto[ivar] = nil;\n\n        if (self.$$is_singleton) {\n          proto.constructor.prototype[id] = body;\n        }\n        else {\n          Opal.defn(self, id, body);\n        }\n      }\n    ;\n      return nil;\n    }, TMP_Module_attr_writer_15.$$arity = -1);\n    \n    Opal.def(self, '$autoload', TMP_Module_autoload_16 = function $$autoload(const$, path) {\n      var self = this;\n\n      \n      if (self.$$autoload == null) self.$$autoload = {};\n      Opal.const_cache_version++;\n      self.$$autoload[const$] = path;\n      return nil;\n    \n    }, TMP_Module_autoload_16.$$arity = 2);\n    \n    Opal.def(self, '$class_variables', TMP_Module_class_variables_17 = function $$class_variables() {\n      var self = this;\n\n      return Object.keys(Opal.class_variables(self));\n    }, TMP_Module_class_variables_17.$$arity = 0);\n    \n    Opal.def(self, '$class_variable_get', TMP_Module_class_variable_get_18 = function $$class_variable_get(name) {\n      var self = this;\n\n      \n      name = $$($nesting, 'Opal')['$class_variable_name!'](name);\n      \n      var value = Opal.class_variables(self)[name];\n      if (value == null) {\n        self.$raise($$($nesting, 'NameError').$new(\"\" + \"uninitialized class variable \" + (name) + \" in \" + (self), name))\n      }\n      return value;\n    ;\n    }, TMP_Module_class_variable_get_18.$$arity = 1);\n    \n    Opal.def(self, '$class_variable_set', TMP_Module_class_variable_set_19 = function $$class_variable_set(name, value) {\n      var self = this;\n\n      \n      name = $$($nesting, 'Opal')['$class_variable_name!'](name);\n      return Opal.class_variable_set(self, name, value);;\n    }, TMP_Module_class_variable_set_19.$$arity = 2);\n    \n    Opal.def(self, '$class_variable_defined?', TMP_Module_class_variable_defined$q_20 = function(name) {\n      var self = this;\n\n      \n      name = $$($nesting, 'Opal')['$class_variable_name!'](name);\n      return Opal.class_variables(self).hasOwnProperty(name);;\n    }, TMP_Module_class_variable_defined$q_20.$$arity = 1);\n    \n    Opal.def(self, '$remove_class_variable', TMP_Module_remove_class_variable_21 = function $$remove_class_variable(name) {\n      var self = this;\n\n      \n      name = $$($nesting, 'Opal')['$class_variable_name!'](name);\n      \n      if (Opal.hasOwnProperty.call(self.$$cvars, name)) {\n        var value = self.$$cvars[name];\n        delete self.$$cvars[name];\n        return value;\n      } else {\n        self.$raise($$($nesting, 'NameError'), \"\" + \"cannot remove \" + (name) + \" for \" + (self))\n      }\n    ;\n    }, TMP_Module_remove_class_variable_21.$$arity = 1);\n    \n    Opal.def(self, '$constants', TMP_Module_constants_22 = function $$constants(inherit) {\n      var self = this;\n\n      if (inherit == null) {\n        inherit = true;\n      }\n      return Opal.constants(self, inherit);\n    }, TMP_Module_constants_22.$$arity = -1);\n    Opal.defs(self, '$constants', TMP_Module_constants_23 = function $$constants(inherit) {\n      var self = this;\n\n      \n      if (inherit == null) {\n        var nesting = (self.$$nesting || []).concat(Opal.Object),\n            constant, constants = {},\n            i, ii;\n\n        for(i = 0, ii = nesting.length; i < ii; i++) {\n          for (constant in nesting[i].$$const) {\n            constants[constant] = true;\n          }\n        }\n        return Object.keys(constants);\n      } else {\n        return Opal.constants(self, inherit)\n      }\n    \n    }, TMP_Module_constants_23.$$arity = -1);\n    Opal.defs(self, '$nesting', TMP_Module_nesting_24 = function $$nesting() {\n      var self = this;\n\n      return self.$$nesting || [];\n    }, TMP_Module_nesting_24.$$arity = 0);\n    \n    Opal.def(self, '$const_defined?', TMP_Module_const_defined$q_25 = function(name, inherit) {\n      var self = this;\n\n      if (inherit == null) {\n        inherit = true;\n      }\n      \n      name = $$($nesting, 'Opal')['$const_name!'](name);\n      if ($truthy(name['$=~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {\n      } else {\n        self.$raise($$($nesting, 'NameError').$new(\"\" + \"wrong constant name \" + (name), name))\n      };\n      \n      var module, modules = [self], module_constants, i, ii;\n\n      // Add up ancestors if inherit is true\n      if (inherit) {\n        modules = modules.concat(Opal.ancestors(self));\n\n        // Add Object's ancestors if it's a module – modules have no ancestors otherwise\n        if (self.$$is_module) {\n          modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));\n        }\n      }\n\n      for (i = 0, ii = modules.length; i < ii; i++) {\n        module = modules[i];\n        if (module.$$const[name] != null) {\n          return true;\n        }\n      }\n\n      return false;\n    ;\n    }, TMP_Module_const_defined$q_25.$$arity = -2);\n    \n    Opal.def(self, '$const_get', TMP_Module_const_get_27 = function $$const_get(name, inherit) {\n      var TMP_26, self = this;\n\n      if (inherit == null) {\n        inherit = true;\n      }\n      \n      name = $$($nesting, 'Opal')['$const_name!'](name);\n      \n      if (name.indexOf('::') === 0 && name !== '::'){\n        name = name.slice(2);\n      }\n    ;\n      if ($truthy(name.indexOf('::') != -1 && name != '::')) {\n        return $send(name.$split(\"::\"), 'inject', [self], (TMP_26 = function(o, c){var self = TMP_26.$$s || this;\nif (o == null) o = nil;if (c == null) c = nil;\n        return o.$const_get(c)}, TMP_26.$$s = self, TMP_26.$$arity = 2, TMP_26))};\n      if ($truthy(name['$=~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {\n      } else {\n        self.$raise($$($nesting, 'NameError').$new(\"\" + \"wrong constant name \" + (name), name))\n      };\n      \n      if (inherit) {\n        return $$([self], name);\n      } else {\n        return Opal.const_get_local(self, name);\n      }\n    ;\n    }, TMP_Module_const_get_27.$$arity = -2);\n    \n    Opal.def(self, '$const_missing', TMP_Module_const_missing_28 = function $$const_missing(name) {\n      var self = this, full_const_name = nil;\n\n      \n      \n      if (self.$$autoload) {\n        var file = self.$$autoload[name];\n\n        if (file) {\n          self.$require(file);\n\n          return self.$const_get(name);\n        }\n      }\n    ;\n      full_const_name = (function() {if (self['$==']($$($nesting, 'Object'))) {\n        return name\n      } else {\n        return \"\" + (self) + \"::\" + (name)\n      }; return nil; })();\n      return self.$raise($$($nesting, 'NameError').$new(\"\" + \"uninitialized constant \" + (full_const_name), name));\n    }, TMP_Module_const_missing_28.$$arity = 1);\n    \n    Opal.def(self, '$const_set', TMP_Module_const_set_29 = function $$const_set(name, value) {\n      var $a, self = this;\n\n      \n      name = $$($nesting, 'Opal')['$const_name!'](name);\n      if ($truthy(($truthy($a = name['$!~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP'))) ? $a : name['$start_with?'](\"::\")))) {\n        self.$raise($$($nesting, 'NameError').$new(\"\" + \"wrong constant name \" + (name), name))};\n      Opal.const_set(self, name, value);\n      return value;\n    }, TMP_Module_const_set_29.$$arity = 2);\n    \n    Opal.def(self, '$public_constant', TMP_Module_public_constant_30 = function $$public_constant(const_name) {\n      var self = this;\n\n      return nil\n    }, TMP_Module_public_constant_30.$$arity = 1);\n    \n    Opal.def(self, '$define_method', TMP_Module_define_method_31 = function $$define_method(name, method) {\n      var $a, TMP_32, self = this, $iter = TMP_Module_define_method_31.$$p, block = $iter || nil, $case = nil;\n\n      if ($iter) TMP_Module_define_method_31.$$p = null;\n      \n      if ($truthy(method === undefined && block === nil)) {\n        self.$raise($$($nesting, 'ArgumentError'), \"tried to create a Proc object without a block\")};\n      block = ($truthy($a = block) ? $a : (function() {$case = method;\n      if ($$($nesting, 'Proc')['$===']($case)) {return method}\n      else if ($$($nesting, 'Method')['$===']($case)) {return method.$to_proc().$$unbound}\n      else if ($$($nesting, 'UnboundMethod')['$===']($case)) {return $lambda((TMP_32 = function($b_rest){var self = TMP_32.$$s || this, args, bound = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n      \n        bound = method.$bind(self);\n        return $send(bound, 'call', Opal.to_a(args));}, TMP_32.$$s = self, TMP_32.$$arity = -1, TMP_32))}\n      else {return self.$raise($$($nesting, 'TypeError'), \"\" + \"wrong argument type \" + (block.$class()) + \" (expected Proc/Method)\")}})());\n      \n      var id = '$' + name;\n\n      block.$$jsid        = name;\n      block.$$s           = null;\n      block.$$def         = block;\n      block.$$define_meth = true;\n\n      Opal.defn(self, id, block);\n\n      return name;\n    ;\n    }, TMP_Module_define_method_31.$$arity = -2);\n    \n    Opal.def(self, '$remove_method', TMP_Module_remove_method_33 = function $$remove_method($a_rest) {\n      var self = this, names;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      names = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        names[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      \n      for (var i = 0, length = names.length; i < length; i++) {\n        Opal.rdef(self, \"$\" + names[i]);\n      }\n    ;\n      return self;\n    }, TMP_Module_remove_method_33.$$arity = -1);\n    \n    Opal.def(self, '$singleton_class?', TMP_Module_singleton_class$q_34 = function() {\n      var self = this;\n\n      return !!self.$$is_singleton;\n    }, TMP_Module_singleton_class$q_34.$$arity = 0);\n    \n    Opal.def(self, '$include', TMP_Module_include_35 = function $$include($a_rest) {\n      var self = this, mods;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      mods = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        mods[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      \n      for (var i = mods.length - 1; i >= 0; i--) {\n        var mod = mods[i];\n\n        if (!mod.$$is_module) {\n          self.$raise($$($nesting, 'TypeError'), \"\" + \"wrong argument type \" + ((mod).$class()) + \" (expected Module)\");\n        }\n\n        (mod).$append_features(self);\n        (mod).$included(self);\n      }\n    ;\n      return self;\n    }, TMP_Module_include_35.$$arity = -1);\n    \n    Opal.def(self, '$included_modules', TMP_Module_included_modules_36 = function $$included_modules() {\n      var self = this;\n\n      \n      var results;\n\n      var module_chain = function(klass) {\n        var included = [];\n\n        for (var i = 0, ii = klass.$$inc.length; i < ii; i++) {\n          var mod_or_class = klass.$$inc[i];\n          included.push(mod_or_class);\n          included = included.concat(module_chain(mod_or_class));\n        }\n\n        return included;\n      };\n\n      results = module_chain(self);\n\n      // need superclass's modules\n      if (self.$$is_class) {\n        for (var cls = self; cls; cls = cls.$$super) {\n          results = results.concat(module_chain(cls));\n        }\n      }\n\n      return results;\n    \n    }, TMP_Module_included_modules_36.$$arity = 0);\n    \n    Opal.def(self, '$include?', TMP_Module_include$q_37 = function(mod) {\n      var self = this;\n\n      \n      if (!mod.$$is_module) {\n        self.$raise($$($nesting, 'TypeError'), \"\" + \"wrong argument type \" + ((mod).$class()) + \" (expected Module)\");\n      }\n\n      var i, ii, mod2, ancestors = Opal.ancestors(self);\n\n      for (i = 0, ii = ancestors.length; i < ii; i++) {\n        mod2 = ancestors[i];\n        if (mod2 === mod && mod2 !== self) {\n          return true;\n        }\n      }\n\n      return false;\n    \n    }, TMP_Module_include$q_37.$$arity = 1);\n    \n    Opal.def(self, '$instance_method', TMP_Module_instance_method_38 = function $$instance_method(name) {\n      var self = this;\n\n      \n      var meth = self.$$proto['$' + name];\n\n      if (!meth || meth.$$stub) {\n        self.$raise($$($nesting, 'NameError').$new(\"\" + \"undefined method `\" + (name) + \"' for class `\" + (self.$name()) + \"'\", name));\n      }\n\n      return $$($nesting, 'UnboundMethod').$new(self, meth.$$owner || self, meth, name);\n    \n    }, TMP_Module_instance_method_38.$$arity = 1);\n    \n    Opal.def(self, '$instance_methods', TMP_Module_instance_methods_39 = function $$instance_methods(include_super) {\n      var self = this;\n\n      if (include_super == null) {\n        include_super = true;\n      }\n      \n      var value,\n          methods = [],\n          proto   = self.$$proto;\n\n      for (var prop in proto) {\n        if (prop.charAt(0) !== '$' || prop.charAt(1) === '$') {\n          continue;\n        }\n\n        value = proto[prop];\n\n        if (typeof(value) !== \"function\") {\n          continue;\n        }\n\n        if (value.$$stub) {\n          continue;\n        }\n\n        if (!self.$$is_module) {\n          if (self !== Opal.BasicObject && value === Opal.BasicObject.$$proto[prop]) {\n            continue;\n          }\n\n          if (!include_super && !proto.hasOwnProperty(prop)) {\n            continue;\n          }\n\n          if (!include_super && value.$$donated) {\n            continue;\n          }\n        }\n\n        methods.push(prop.substr(1));\n      }\n\n      return methods;\n    \n    }, TMP_Module_instance_methods_39.$$arity = -1);\n    \n    Opal.def(self, '$included', TMP_Module_included_40 = function $$included(mod) {\n      var self = this;\n\n      return nil\n    }, TMP_Module_included_40.$$arity = 1);\n    \n    Opal.def(self, '$extended', TMP_Module_extended_41 = function $$extended(mod) {\n      var self = this;\n\n      return nil\n    }, TMP_Module_extended_41.$$arity = 1);\n    \n    Opal.def(self, '$extend_object', TMP_Module_extend_object_42 = function $$extend_object(object) {\n      var self = this;\n\n      return nil\n    }, TMP_Module_extend_object_42.$$arity = 1);\n    \n    Opal.def(self, '$method_added', TMP_Module_method_added_43 = function $$method_added($a_rest) {\n      var self = this;\n\n      return nil\n    }, TMP_Module_method_added_43.$$arity = -1);\n    \n    Opal.def(self, '$method_removed', TMP_Module_method_removed_44 = function $$method_removed($a_rest) {\n      var self = this;\n\n      return nil\n    }, TMP_Module_method_removed_44.$$arity = -1);\n    \n    Opal.def(self, '$method_undefined', TMP_Module_method_undefined_45 = function $$method_undefined($a_rest) {\n      var self = this;\n\n      return nil\n    }, TMP_Module_method_undefined_45.$$arity = -1);\n    \n    Opal.def(self, '$module_eval', TMP_Module_module_eval_46 = function $$module_eval($a_rest) {\n      var $b, TMP_47, self = this, args, $iter = TMP_Module_module_eval_46.$$p, block = $iter || nil, string = nil, file = nil, _lineno = nil, default_eval_options = nil, compiling_options = nil, compiled = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Module_module_eval_46.$$p = null;\n      \n      if ($truthy(($truthy($b = block['$nil?']()) ? !!Opal.compile : $b))) {\n        \n        if ($truthy($range(1, 3, false)['$cover?'](args.$size()))) {\n        } else {\n          $$($nesting, 'Kernel').$raise($$($nesting, 'ArgumentError'), \"wrong number of arguments (0 for 1..3)\")\n        };\n        $b = [].concat(Opal.to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;\n        default_eval_options = $hash2([\"file\", \"eval\"], {\"file\": ($truthy($b = file) ? $b : \"(eval)\"), \"eval\": true});\n        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);\n        compiled = $$($nesting, 'Opal').$compile(string, compiling_options);\n        block = $send($$($nesting, 'Kernel'), 'proc', [], (TMP_47 = function(){var self = TMP_47.$$s || this;\n\n        \n          return (function(self) {\n            return eval(compiled);\n          })(self)\n        }, TMP_47.$$s = self, TMP_47.$$arity = 0, TMP_47));\n      } else if ($truthy(args['$any?']())) {\n        $$($nesting, 'Kernel').$raise($$($nesting, 'ArgumentError'), \"\" + (\"\" + \"wrong number of arguments (\" + (args.$size()) + \" for 0)\") + \"\\n\\n  NOTE:If you want to enable passing a String argument please add \\\"require 'opal-parser'\\\" to your script\\n\")};\n      \n      var old = block.$$s,\n          result;\n\n      block.$$s = null;\n      result = block.apply(self, [self]);\n      block.$$s = old;\n\n      return result;\n    ;\n    }, TMP_Module_module_eval_46.$$arity = -1);\n    Opal.alias(self, \"class_eval\", \"module_eval\");\n    \n    Opal.def(self, '$module_exec', TMP_Module_module_exec_48 = function $$module_exec($a_rest) {\n      var self = this, args, $iter = TMP_Module_module_exec_48.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Module_module_exec_48.$$p = null;\n      \n      if (block === nil) {\n        self.$raise($$($nesting, 'LocalJumpError'), \"no block given\")\n      }\n\n      var block_self = block.$$s, result;\n\n      block.$$s = null;\n      result = block.apply(self, args);\n      block.$$s = block_self;\n\n      return result;\n    \n    }, TMP_Module_module_exec_48.$$arity = -1);\n    Opal.alias(self, \"class_exec\", \"module_exec\");\n    \n    Opal.def(self, '$method_defined?', TMP_Module_method_defined$q_49 = function(method) {\n      var self = this;\n\n      \n      var body = self.$$proto['$' + method];\n      return (!!body) && !body.$$stub;\n    \n    }, TMP_Module_method_defined$q_49.$$arity = 1);\n    \n    Opal.def(self, '$module_function', TMP_Module_module_function_50 = function $$module_function($a_rest) {\n      var self = this, methods;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      methods = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        methods[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      if (methods.length === 0) {\n        self.$$module_function = true;\n      }\n      else {\n        for (var i = 0, length = methods.length; i < length; i++) {\n          var meth = methods[i],\n              id   = '$' + meth,\n              func = self.$$proto[id];\n\n          Opal.defs(self, id, func);\n        }\n      }\n\n      return self;\n    \n    }, TMP_Module_module_function_50.$$arity = -1);\n    \n    Opal.def(self, '$name', TMP_Module_name_51 = function $$name() {\n      var self = this;\n\n      \n      if (self.$$full_name) {\n        return self.$$full_name;\n      }\n\n      var result = [], base = self;\n\n      while (base) {\n        // Give up if any of the ancestors is unnamed\n        if (base.$$name === nil || base.$$name == null) return nil;\n\n        result.unshift(base.$$name);\n\n        base = base.$$base_module;\n\n        if (base === Opal.Object) {\n          break;\n        }\n      }\n\n      if (result.length === 0) {\n        return nil;\n      }\n\n      return self.$$full_name = result.join('::');\n    \n    }, TMP_Module_name_51.$$arity = 0);\n    \n    Opal.def(self, '$remove_const', TMP_Module_remove_const_52 = function $$remove_const(name) {\n      var self = this;\n\n      return Opal.const_remove(self, name);\n    }, TMP_Module_remove_const_52.$$arity = 1);\n    \n    Opal.def(self, '$to_s', TMP_Module_to_s_53 = function $$to_s() {\n      var $a, self = this;\n\n      return ($truthy($a = Opal.Module.$name.call(self)) ? $a : \"\" + \"#<\" + (self.$$is_module ? 'Module' : 'Class') + \":0x\" + (self.$__id__().$to_s(16)) + \">\")\n    }, TMP_Module_to_s_53.$$arity = 0);\n    \n    Opal.def(self, '$undef_method', TMP_Module_undef_method_54 = function $$undef_method($a_rest) {\n      var self = this, names;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      names = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        names[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      \n      for (var i = 0, length = names.length; i < length; i++) {\n        Opal.udef(self, \"$\" + names[i]);\n      }\n    ;\n      return self;\n    }, TMP_Module_undef_method_54.$$arity = -1);\n    \n    Opal.def(self, '$instance_variables', TMP_Module_instance_variables_55 = function $$instance_variables() {\n      var self = this, consts = nil;\n\n      \n      consts = (Opal.Module.$$nesting = $nesting, self.$constants());\n      \n      var result = [];\n\n      for (var name in self) {\n        if (self.hasOwnProperty(name) && name.charAt(0) !== '$' && name !== 'constructor' && !consts['$include?'](name)) {\n          result.push('@' + name);\n        }\n      }\n\n      return result;\n    ;\n    }, TMP_Module_instance_variables_55.$$arity = 0);\n    \n    Opal.def(self, '$dup', TMP_Module_dup_56 = function $$dup() {\n      var self = this, $iter = TMP_Module_dup_56.$$p, $yield = $iter || nil, copy = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Module_dup_56.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      \n      copy = $send(self, Opal.find_super_dispatcher(self, 'dup', TMP_Module_dup_56, false), $zuper, $iter);\n      copy.$copy_class_variables(self);\n      copy.$copy_constants(self);\n      return copy;\n    }, TMP_Module_dup_56.$$arity = 0);\n    \n    Opal.def(self, '$copy_class_variables', TMP_Module_copy_class_variables_57 = function $$copy_class_variables(other) {\n      var self = this;\n\n      \n      for (var name in other.$$cvars) {\n        self.$$cvars[name] = other.$$cvars[name];\n      }\n    \n    }, TMP_Module_copy_class_variables_57.$$arity = 1);\n    return (Opal.def(self, '$copy_constants', TMP_Module_copy_constants_58 = function $$copy_constants(other) {\n      var self = this;\n\n      \n      var name, other_constants = other.$$const;\n\n      for (name in other_constants) {\n        Opal.const_set(self, name, other_constants[name]);\n      }\n    \n    }, TMP_Module_copy_constants_58.$$arity = 1), nil) && 'copy_constants';\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/class\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$initialize_copy', '$allocate', '$name', '$to_s']);\n  \n  self.$require(\"corelib/module\");\n  return (function($base, $super, $parent_nesting) {\n    function $Class(){};\n    var self = $Class = $klass($base, $super, 'Class', $Class);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Class_new_1, TMP_Class_allocate_2, TMP_Class_inherited_3, TMP_Class_initialize_dup_4, TMP_Class_new_5, TMP_Class_superclass_6, TMP_Class_to_s_7;\n\n    \n    Opal.defs(self, '$new', TMP_Class_new_1 = function(superclass) {\n      var self = this, $iter = TMP_Class_new_1.$$p, block = $iter || nil;\n\n      if (superclass == null) {\n        superclass = $$($nesting, 'Object');\n      }\n      if ($iter) TMP_Class_new_1.$$p = null;\n      \n      if (!superclass.$$is_class) {\n        throw Opal.TypeError.$new(\"superclass must be a Class\");\n      }\n\n      var alloc = Opal.boot_class_alloc(null, function(){}, superclass);\n      var klass = Opal.setup_class_object(null, alloc, superclass.$$name, superclass.constructor);\n\n      klass.$$super  = superclass;\n      klass.$$parent = superclass;\n\n      superclass.$inherited(klass);\n      Opal.module_initialize(klass, block);\n\n      return klass;\n    \n    }, TMP_Class_new_1.$$arity = -1);\n    \n    Opal.def(self, '$allocate', TMP_Class_allocate_2 = function $$allocate() {\n      var self = this;\n\n      \n      var obj = new self.$$alloc();\n      obj.$$id = Opal.uid();\n      return obj;\n    \n    }, TMP_Class_allocate_2.$$arity = 0);\n    \n    Opal.def(self, '$inherited', TMP_Class_inherited_3 = function $$inherited(cls) {\n      var self = this;\n\n      return nil\n    }, TMP_Class_inherited_3.$$arity = 1);\n    \n    Opal.def(self, '$initialize_dup', TMP_Class_initialize_dup_4 = function $$initialize_dup(original) {\n      var self = this;\n\n      \n      self.$initialize_copy(original);\n      \n      self.$$name = null;\n      self.$$full_name = null;\n    ;\n    }, TMP_Class_initialize_dup_4.$$arity = 1);\n    \n    Opal.def(self, '$new', TMP_Class_new_5 = function($a_rest) {\n      var self = this, args, $iter = TMP_Class_new_5.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Class_new_5.$$p = null;\n      \n      var object = self.$allocate();\n      Opal.send(object, object.$initialize, args, block);\n      return object;\n    \n    }, TMP_Class_new_5.$$arity = -1);\n    \n    Opal.def(self, '$superclass', TMP_Class_superclass_6 = function $$superclass() {\n      var self = this;\n\n      return self.$$super || nil;\n    }, TMP_Class_superclass_6.$$arity = 0);\n    return (Opal.def(self, '$to_s', TMP_Class_to_s_7 = function $$to_s() {\n      var self = this, $iter = TMP_Class_to_s_7.$$p, $yield = $iter || nil;\n\n      if ($iter) TMP_Class_to_s_7.$$p = null;\n      \n      var singleton_of = self.$$singleton_of;\n\n      if (singleton_of && (singleton_of.$$is_class || singleton_of.$$is_module)) {\n        return \"\" + \"#<Class:\" + ((singleton_of).$name()) + \">\";\n      }\n      else if (singleton_of) {\n        // a singleton class created from an object\n        return \"\" + \"#<Class:#<\" + ((singleton_of.$$class).$name()) + \":0x\" + ((Opal.id(singleton_of)).$to_s(16)) + \">>\";\n      }\n      return $send(self, Opal.find_super_dispatcher(self, 'to_s', TMP_Class_to_s_7, false), [], null);\n    \n    }, TMP_Class_to_s_7.$$arity = 0), nil) && 'to_s';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/basic_object\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $hash2 = Opal.hash2, $send = Opal.send;\n\n  Opal.add_stubs(['$==', '$!', '$nil?', '$cover?', '$size', '$raise', '$merge', '$compile', '$proc', '$any?', '$inspect', '$new']);\n  return (function($base, $super, $parent_nesting) {\n    function $BasicObject(){};\n    var self = $BasicObject = $klass($base, $super, 'BasicObject', $BasicObject);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BasicObject_initialize_1, TMP_BasicObject_$eq$eq_2, TMP_BasicObject_eql$q_3, TMP_BasicObject___id___4, TMP_BasicObject___send___5, TMP_BasicObject_$B_6, TMP_BasicObject_$B$eq_7, TMP_BasicObject_instance_eval_8, TMP_BasicObject_instance_exec_10, TMP_BasicObject_singleton_method_added_11, TMP_BasicObject_singleton_method_removed_12, TMP_BasicObject_singleton_method_undefined_13, TMP_BasicObject_method_missing_14;\n\n    \n    \n    Opal.def(self, '$initialize', TMP_BasicObject_initialize_1 = function $$initialize($a_rest) {\n      var self = this;\n\n      return nil\n    }, TMP_BasicObject_initialize_1.$$arity = -1);\n    \n    Opal.def(self, '$==', TMP_BasicObject_$eq$eq_2 = function(other) {\n      var self = this;\n\n      return self === other;\n    }, TMP_BasicObject_$eq$eq_2.$$arity = 1);\n    \n    Opal.def(self, '$eql?', TMP_BasicObject_eql$q_3 = function(other) {\n      var self = this;\n\n      return self['$=='](other)\n    }, TMP_BasicObject_eql$q_3.$$arity = 1);\n    Opal.alias(self, \"equal?\", \"==\");\n    \n    Opal.def(self, '$__id__', TMP_BasicObject___id___4 = function $$__id__() {\n      var self = this;\n\n      return self.$$id || (self.$$id = Opal.uid());\n    }, TMP_BasicObject___id___4.$$arity = 0);\n    \n    Opal.def(self, '$__send__', TMP_BasicObject___send___5 = function $$__send__(symbol, $a_rest) {\n      var self = this, args, $iter = TMP_BasicObject___send___5.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_BasicObject___send___5.$$p = null;\n      \n      var func = self['$' + symbol]\n\n      if (func) {\n        if (block !== nil) {\n          func.$$p = block;\n        }\n\n        return func.apply(self, args);\n      }\n\n      if (block !== nil) {\n        self.$method_missing.$$p = block;\n      }\n\n      return self.$method_missing.apply(self, [symbol].concat(args));\n    \n    }, TMP_BasicObject___send___5.$$arity = -2);\n    \n    Opal.def(self, '$!', TMP_BasicObject_$B_6 = function() {\n      var self = this;\n\n      return false\n    }, TMP_BasicObject_$B_6.$$arity = 0);\n    \n    Opal.def(self, '$!=', TMP_BasicObject_$B$eq_7 = function(other) {\n      var self = this;\n\n      return self['$=='](other)['$!']()\n    }, TMP_BasicObject_$B$eq_7.$$arity = 1);\n    \n    Opal.def(self, '$instance_eval', TMP_BasicObject_instance_eval_8 = function $$instance_eval($a_rest) {\n      var $b, TMP_9, self = this, args, $iter = TMP_BasicObject_instance_eval_8.$$p, block = $iter || nil, string = nil, file = nil, _lineno = nil, default_eval_options = nil, compiling_options = nil, compiled = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_BasicObject_instance_eval_8.$$p = null;\n      \n      if ($truthy(($truthy($b = block['$nil?']()) ? !!Opal.compile : $b))) {\n        \n        if ($truthy($range(1, 3, false)['$cover?'](args.$size()))) {\n        } else {\n          $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), \"wrong number of arguments (0 for 1..3)\")\n        };\n        $b = [].concat(Opal.to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;\n        default_eval_options = $hash2([\"file\", \"eval\"], {\"file\": ($truthy($b = file) ? $b : \"(eval)\"), \"eval\": true});\n        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);\n        compiled = $$$('::', 'Opal').$compile(string, compiling_options);\n        block = $send($$$('::', 'Kernel'), 'proc', [], (TMP_9 = function(){var self = TMP_9.$$s || this;\n\n        \n          return (function(self) {\n            return eval(compiled);\n          })(self)\n        }, TMP_9.$$s = self, TMP_9.$$arity = 0, TMP_9));\n      } else if ($truthy(args['$any?']())) {\n        $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (args.$size()) + \" for 0)\")};\n      \n      var old = block.$$s,\n          result;\n\n      block.$$s = null;\n\n      // Need to pass $$eval so that method definitions know if this is\n      // being done on a class/module. Cannot be compiler driven since\n      // send(:instance_eval) needs to work.\n      if (self.$$is_class || self.$$is_module) {\n        self.$$eval = true;\n        try {\n          result = block.call(self, self);\n        }\n        finally {\n          self.$$eval = false;\n        }\n      }\n      else {\n        result = block.call(self, self);\n      }\n\n      block.$$s = old;\n\n      return result;\n    ;\n    }, TMP_BasicObject_instance_eval_8.$$arity = -1);\n    \n    Opal.def(self, '$instance_exec', TMP_BasicObject_instance_exec_10 = function $$instance_exec($a_rest) {\n      var self = this, args, $iter = TMP_BasicObject_instance_exec_10.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_BasicObject_instance_exec_10.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), \"no block given\")\n      };\n      \n      var block_self = block.$$s,\n          result;\n\n      block.$$s = null;\n\n      if (self.$$is_class || self.$$is_module) {\n        self.$$eval = true;\n        try {\n          result = block.apply(self, args);\n        }\n        finally {\n          self.$$eval = false;\n        }\n      }\n      else {\n        result = block.apply(self, args);\n      }\n\n      block.$$s = block_self;\n\n      return result;\n    ;\n    }, TMP_BasicObject_instance_exec_10.$$arity = -1);\n    \n    Opal.def(self, '$singleton_method_added', TMP_BasicObject_singleton_method_added_11 = function $$singleton_method_added($a_rest) {\n      var self = this;\n\n      return nil\n    }, TMP_BasicObject_singleton_method_added_11.$$arity = -1);\n    \n    Opal.def(self, '$singleton_method_removed', TMP_BasicObject_singleton_method_removed_12 = function $$singleton_method_removed($a_rest) {\n      var self = this;\n\n      return nil\n    }, TMP_BasicObject_singleton_method_removed_12.$$arity = -1);\n    \n    Opal.def(self, '$singleton_method_undefined', TMP_BasicObject_singleton_method_undefined_13 = function $$singleton_method_undefined($a_rest) {\n      var self = this;\n\n      return nil\n    }, TMP_BasicObject_singleton_method_undefined_13.$$arity = -1);\n    return (Opal.def(self, '$method_missing', TMP_BasicObject_method_missing_14 = function $$method_missing(symbol, $a_rest) {\n      var self = this, args, $iter = TMP_BasicObject_method_missing_14.$$p, block = $iter || nil, message = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_BasicObject_method_missing_14.$$p = null;\n      \n      message = (function() {if ($truthy(self.$inspect && !self.$inspect.$$stub)) {\n        return \"\" + \"undefined method `\" + (symbol) + \"' for \" + (self.$inspect()) + \":\" + (self.$$class)\n      } else {\n        return \"\" + \"undefined method `\" + (symbol) + \"' for \" + (self.$$class)\n      }; return nil; })();\n      return $$$('::', 'Kernel').$raise($$$('::', 'NoMethodError').$new(message, symbol));\n    }, TMP_BasicObject_method_missing_14.$$arity = -2), nil) && 'method_missing';\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/kernel\"] = function(Opal) {\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $gvars = Opal.gvars, $hash2 = Opal.hash2, $send = Opal.send, $klass = Opal.klass;\n\n  Opal.add_stubs(['$raise', '$new', '$inspect', '$!', '$=~', '$==', '$object_id', '$class', '$coerce_to?', '$<<', '$allocate', '$copy_instance_variables', '$copy_singleton_methods', '$initialize_clone', '$initialize_copy', '$define_method', '$singleton_class', '$to_proc', '$initialize_dup', '$for', '$empty?', '$pop', '$call', '$append_features', '$extend_object', '$extended', '$length', '$respond_to?', '$[]', '$nil?', '$to_a', '$to_int', '$fetch', '$Integer', '$Float', '$to_ary', '$to_str', '$coerce_to', '$to_s', '$__id__', '$instance_variable_name!', '$coerce_to!', '$===', '$enum_for', '$result', '$any?', '$print', '$format', '$puts', '$each', '$<=', '$exception', '$is_a?', '$rand', '$respond_to_missing?', '$try_convert!', '$expand_path', '$join', '$start_with?', '$srand', '$new_seed', '$sym', '$arg', '$open', '$include']);\n  \n  (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_method_missing_1, TMP_Kernel_$eq$_2, TMP_Kernel_$B$_3, TMP_Kernel_$eq$eq$eq_4, TMP_Kernel_$lt$eq$gt_5, TMP_Kernel_method_6, TMP_Kernel_methods_7, TMP_Kernel_Array_8, TMP_Kernel_at_exit_9, TMP_Kernel_caller_10, TMP_Kernel_class_11, TMP_Kernel_copy_instance_variables_12, TMP_Kernel_copy_singleton_methods_13, TMP_Kernel_clone_14, TMP_Kernel_initialize_clone_15, TMP_Kernel_define_singleton_method_16, TMP_Kernel_dup_17, TMP_Kernel_initialize_dup_18, TMP_Kernel_enum_for_19, TMP_Kernel_equal$q_20, TMP_Kernel_exit_21, TMP_Kernel_extend_22, TMP_Kernel_format_23, TMP_Kernel_hash_24, TMP_Kernel_initialize_copy_25, TMP_Kernel_inspect_26, TMP_Kernel_instance_of$q_27, TMP_Kernel_instance_variable_defined$q_28, TMP_Kernel_instance_variable_get_29, TMP_Kernel_instance_variable_set_30, TMP_Kernel_remove_instance_variable_31, TMP_Kernel_instance_variables_32, TMP_Kernel_Integer_33, TMP_Kernel_Float_34, TMP_Kernel_Hash_35, TMP_Kernel_is_a$q_36, TMP_Kernel_itself_37, TMP_Kernel_lambda_38, TMP_Kernel_load_39, TMP_Kernel_loop_40, TMP_Kernel_nil$q_42, TMP_Kernel_printf_43, TMP_Kernel_proc_44, TMP_Kernel_puts_45, TMP_Kernel_p_47, TMP_Kernel_print_48, TMP_Kernel_warn_49, TMP_Kernel_raise_50, TMP_Kernel_rand_51, TMP_Kernel_respond_to$q_52, TMP_Kernel_respond_to_missing$q_53, TMP_Kernel_require_54, TMP_Kernel_require_relative_55, TMP_Kernel_require_tree_56, TMP_Kernel_singleton_class_57, TMP_Kernel_sleep_58, TMP_Kernel_srand_59, TMP_Kernel_String_60, TMP_Kernel_tap_61, TMP_Kernel_to_proc_62, TMP_Kernel_to_s_63, TMP_Kernel_catch_64, TMP_Kernel_throw_65, TMP_Kernel_open_66, TMP_Kernel_yield_self_67;\n\n    \n    \n    Opal.def(self, '$method_missing', TMP_Kernel_method_missing_1 = function $$method_missing(symbol, $a_rest) {\n      var self = this, args, $iter = TMP_Kernel_method_missing_1.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Kernel_method_missing_1.$$p = null;\n      return self.$raise($$($nesting, 'NoMethodError').$new(\"\" + \"undefined method `\" + (symbol) + \"' for \" + (self.$inspect()), symbol, args))\n    }, TMP_Kernel_method_missing_1.$$arity = -2);\n    \n    Opal.def(self, '$=~', TMP_Kernel_$eq$_2 = function(obj) {\n      var self = this;\n\n      return false\n    }, TMP_Kernel_$eq$_2.$$arity = 1);\n    \n    Opal.def(self, '$!~', TMP_Kernel_$B$_3 = function(obj) {\n      var self = this;\n\n      return self['$=~'](obj)['$!']()\n    }, TMP_Kernel_$B$_3.$$arity = 1);\n    \n    Opal.def(self, '$===', TMP_Kernel_$eq$eq$eq_4 = function(other) {\n      var $a, self = this;\n\n      return ($truthy($a = self.$object_id()['$=='](other.$object_id())) ? $a : self['$=='](other))\n    }, TMP_Kernel_$eq$eq$eq_4.$$arity = 1);\n    \n    Opal.def(self, '$<=>', TMP_Kernel_$lt$eq$gt_5 = function(other) {\n      var self = this;\n\n      \n      // set guard for infinite recursion\n      self.$$comparable = true;\n\n      var x = self['$=='](other);\n\n      if (x && x !== nil) {\n        return 0;\n      }\n\n      return nil;\n    \n    }, TMP_Kernel_$lt$eq$gt_5.$$arity = 1);\n    \n    Opal.def(self, '$method', TMP_Kernel_method_6 = function $$method(name) {\n      var self = this;\n\n      \n      var meth = self['$' + name];\n\n      if (!meth || meth.$$stub) {\n        self.$raise($$($nesting, 'NameError').$new(\"\" + \"undefined method `\" + (name) + \"' for class `\" + (self.$class()) + \"'\", name));\n      }\n\n      return $$($nesting, 'Method').$new(self, meth.$$owner || self.$class(), meth, name);\n    \n    }, TMP_Kernel_method_6.$$arity = 1);\n    \n    Opal.def(self, '$methods', TMP_Kernel_methods_7 = function $$methods(all) {\n      var self = this;\n\n      if (all == null) {\n        all = true;\n      }\n      \n      var methods = [];\n\n      for (var key in self) {\n        if (key[0] == \"$\" && typeof(self[key]) === \"function\") {\n          if (all == false || all === nil) {\n            if (!Opal.hasOwnProperty.call(self, key)) {\n              continue;\n            }\n          }\n          if (self[key].$$stub === undefined) {\n            methods.push(key.substr(1));\n          }\n        }\n      }\n\n      return methods;\n    \n    }, TMP_Kernel_methods_7.$$arity = -1);\n    Opal.alias(self, \"public_methods\", \"methods\");\n    \n    Opal.def(self, '$Array', TMP_Kernel_Array_8 = function $$Array(object) {\n      var self = this;\n\n      \n      var coerced;\n\n      if (object === nil) {\n        return [];\n      }\n\n      if (object.$$is_array) {\n        return object;\n      }\n\n      coerced = $$($nesting, 'Opal')['$coerce_to?'](object, $$($nesting, 'Array'), \"to_ary\");\n      if (coerced !== nil) { return coerced; }\n\n      coerced = $$($nesting, 'Opal')['$coerce_to?'](object, $$($nesting, 'Array'), \"to_a\");\n      if (coerced !== nil) { return coerced; }\n\n      return [object];\n    \n    }, TMP_Kernel_Array_8.$$arity = 1);\n    \n    Opal.def(self, '$at_exit', TMP_Kernel_at_exit_9 = function $$at_exit() {\n      var $a, self = this, $iter = TMP_Kernel_at_exit_9.$$p, block = $iter || nil;\n      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;\n\n      if ($iter) TMP_Kernel_at_exit_9.$$p = null;\n      \n      $gvars.__at_exit__ = ($truthy($a = $gvars.__at_exit__) ? $a : []);\n      return $gvars.__at_exit__['$<<'](block);\n    }, TMP_Kernel_at_exit_9.$$arity = 0);\n    \n    Opal.def(self, '$caller', TMP_Kernel_caller_10 = function $$caller($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return []\n    }, TMP_Kernel_caller_10.$$arity = -1);\n    \n    Opal.def(self, '$class', TMP_Kernel_class_11 = function() {\n      var self = this;\n\n      return self.$$class;\n    }, TMP_Kernel_class_11.$$arity = 0);\n    \n    Opal.def(self, '$copy_instance_variables', TMP_Kernel_copy_instance_variables_12 = function $$copy_instance_variables(other) {\n      var self = this;\n\n      \n      var keys = Object.keys(other), i, ii, name;\n      for (i = 0, ii = keys.length; i < ii; i++) {\n        name = keys[i];\n        if (name.charAt(0) !== '$' && other.hasOwnProperty(name)) {\n          self[name] = other[name];\n        }\n      }\n    \n    }, TMP_Kernel_copy_instance_variables_12.$$arity = 1);\n    \n    Opal.def(self, '$copy_singleton_methods', TMP_Kernel_copy_singleton_methods_13 = function $$copy_singleton_methods(other) {\n      var self = this;\n\n      \n      var name;\n\n      if (other.hasOwnProperty('$$meta')) {\n        var other_singleton_class_proto = Opal.get_singleton_class(other).$$proto;\n        var self_singleton_class_proto = Opal.get_singleton_class(self).$$proto;\n\n        for (name in other_singleton_class_proto) {\n          if (name.charAt(0) === '$' && other_singleton_class_proto.hasOwnProperty(name)) {\n            self_singleton_class_proto[name] = other_singleton_class_proto[name];\n          }\n        }\n      }\n\n      for (name in other) {\n        if (name.charAt(0) === '$' && name.charAt(1) !== '$' && other.hasOwnProperty(name)) {\n          self[name] = other[name];\n        }\n      }\n    \n    }, TMP_Kernel_copy_singleton_methods_13.$$arity = 1);\n    \n    Opal.def(self, '$clone', TMP_Kernel_clone_14 = function $$clone($kwargs) {\n      var self = this, freeze, copy = nil;\n\n      if ($kwargs == null || !$kwargs.$$is_hash) {\n        if ($kwargs == null) {\n          $kwargs = $hash2([], {});\n        } else {\n          throw Opal.ArgumentError.$new('expected kwargs');\n        }\n      }\n      freeze = $kwargs.$$smap[\"freeze\"];\n      if (freeze == null) {\n        freeze = true\n      }\n      \n      copy = self.$class().$allocate();\n      copy.$copy_instance_variables(self);\n      copy.$copy_singleton_methods(self);\n      copy.$initialize_clone(self);\n      return copy;\n    }, TMP_Kernel_clone_14.$$arity = -1);\n    \n    Opal.def(self, '$initialize_clone', TMP_Kernel_initialize_clone_15 = function $$initialize_clone(other) {\n      var self = this;\n\n      return self.$initialize_copy(other)\n    }, TMP_Kernel_initialize_clone_15.$$arity = 1);\n    \n    Opal.def(self, '$define_singleton_method', TMP_Kernel_define_singleton_method_16 = function $$define_singleton_method(name, method) {\n      var self = this, $iter = TMP_Kernel_define_singleton_method_16.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Kernel_define_singleton_method_16.$$p = null;\n      return $send(self.$singleton_class(), 'define_method', [name, method], block.$to_proc())\n    }, TMP_Kernel_define_singleton_method_16.$$arity = -2);\n    \n    Opal.def(self, '$dup', TMP_Kernel_dup_17 = function $$dup() {\n      var self = this, copy = nil;\n\n      \n      copy = self.$class().$allocate();\n      copy.$copy_instance_variables(self);\n      copy.$initialize_dup(self);\n      return copy;\n    }, TMP_Kernel_dup_17.$$arity = 0);\n    \n    Opal.def(self, '$initialize_dup', TMP_Kernel_initialize_dup_18 = function $$initialize_dup(other) {\n      var self = this;\n\n      return self.$initialize_copy(other)\n    }, TMP_Kernel_initialize_dup_18.$$arity = 1);\n    \n    Opal.def(self, '$enum_for', TMP_Kernel_enum_for_19 = function $$enum_for(method, $a_rest) {\n      var self = this, args, $iter = TMP_Kernel_enum_for_19.$$p, block = $iter || nil;\n\n      if (method == null) {\n        method = \"each\";\n      }\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Kernel_enum_for_19.$$p = null;\n      return $send($$($nesting, 'Enumerator'), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc())\n    }, TMP_Kernel_enum_for_19.$$arity = -1);\n    Opal.alias(self, \"to_enum\", \"enum_for\");\n    \n    Opal.def(self, '$equal?', TMP_Kernel_equal$q_20 = function(other) {\n      var self = this;\n\n      return self === other;\n    }, TMP_Kernel_equal$q_20.$$arity = 1);\n    \n    Opal.def(self, '$exit', TMP_Kernel_exit_21 = function $$exit(status) {\n      var $a, self = this, block = nil;\n      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;\n\n      if (status == null) {\n        status = true;\n      }\n      \n      $gvars.__at_exit__ = ($truthy($a = $gvars.__at_exit__) ? $a : []);\n      while (!($truthy($gvars.__at_exit__['$empty?']()))) {\n        \n        block = $gvars.__at_exit__.$pop();\n        block.$call();\n      };\n      \n      if (status == null) {\n        status = 0\n      } else if (status.$$is_boolean) {\n        status = status ? 0 : 1;\n      } else if (status.$$is_numeric) {\n        status = status.$to_i();\n      } else {\n        status = 0\n      }\n\n      Opal.exit(status);\n    ;\n      return nil;\n    }, TMP_Kernel_exit_21.$$arity = -1);\n    \n    Opal.def(self, '$extend', TMP_Kernel_extend_22 = function $$extend($a_rest) {\n      var self = this, mods;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      mods = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        mods[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      \n      var singleton = self.$singleton_class();\n\n      for (var i = mods.length - 1; i >= 0; i--) {\n        var mod = mods[i];\n\n        if (!mod.$$is_module) {\n          self.$raise($$($nesting, 'TypeError'), \"\" + \"wrong argument type \" + ((mod).$class()) + \" (expected Module)\");\n        }\n\n        (mod).$append_features(singleton);\n        (mod).$extend_object(self);\n        (mod).$extended(self);\n      }\n    ;\n      return self;\n    }, TMP_Kernel_extend_22.$$arity = -1);\n    \n    Opal.def(self, '$format', TMP_Kernel_format_23 = function $$format(format_string, $a_rest) {\n      var $b, self = this, args, ary = nil;\n      if ($gvars.DEBUG == null) $gvars.DEBUG = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      \n      if ($truthy((($b = args.$length()['$=='](1)) ? args['$[]'](0)['$respond_to?'](\"to_ary\") : args.$length()['$=='](1)))) {\n        \n        ary = $$($nesting, 'Opal')['$coerce_to?'](args['$[]'](0), $$($nesting, 'Array'), \"to_ary\");\n        if ($truthy(ary['$nil?']())) {\n        } else {\n          args = ary.$to_a()\n        };};\n      \n      var result = '',\n          //used for slicing:\n          begin_slice = 0,\n          end_slice,\n          //used for iterating over the format string:\n          i,\n          len = format_string.length,\n          //used for processing field values:\n          arg,\n          str,\n          //used for processing %g and %G fields:\n          exponent,\n          //used for keeping track of width and precision:\n          width,\n          precision,\n          //used for holding temporary values:\n          tmp_num,\n          //used for processing %{} and %<> fileds:\n          hash_parameter_key,\n          closing_brace_char,\n          //used for processing %b, %B, %o, %x, and %X fields:\n          base_number,\n          base_prefix,\n          base_neg_zero_regex,\n          base_neg_zero_digit,\n          //used for processing arguments:\n          next_arg,\n          seq_arg_num = 1,\n          pos_arg_num = 0,\n          //used for keeping track of flags:\n          flags,\n          FNONE  = 0,\n          FSHARP = 1,\n          FMINUS = 2,\n          FPLUS  = 4,\n          FZERO  = 8,\n          FSPACE = 16,\n          FWIDTH = 32,\n          FPREC  = 64,\n          FPREC0 = 128;\n\n      function CHECK_FOR_FLAGS() {\n        if (flags&FWIDTH) { self.$raise($$($nesting, 'ArgumentError'), \"flag after width\") }\n        if (flags&FPREC0) { self.$raise($$($nesting, 'ArgumentError'), \"flag after precision\") }\n      }\n\n      function CHECK_FOR_WIDTH() {\n        if (flags&FWIDTH) { self.$raise($$($nesting, 'ArgumentError'), \"width given twice\") }\n        if (flags&FPREC0) { self.$raise($$($nesting, 'ArgumentError'), \"width after precision\") }\n      }\n\n      function GET_NTH_ARG(num) {\n        if (num >= args.length) { self.$raise($$($nesting, 'ArgumentError'), \"too few arguments\") }\n        return args[num];\n      }\n\n      function GET_NEXT_ARG() {\n        switch (pos_arg_num) {\n        case -1: self.$raise($$($nesting, 'ArgumentError'), \"\" + \"unnumbered(\" + (seq_arg_num) + \") mixed with numbered\")\n        case -2: self.$raise($$($nesting, 'ArgumentError'), \"\" + \"unnumbered(\" + (seq_arg_num) + \") mixed with named\")\n        }\n        pos_arg_num = seq_arg_num++;\n        return GET_NTH_ARG(pos_arg_num - 1);\n      }\n\n      function GET_POS_ARG(num) {\n        if (pos_arg_num > 0) {\n          self.$raise($$($nesting, 'ArgumentError'), \"\" + \"numbered(\" + (num) + \") after unnumbered(\" + (pos_arg_num) + \")\")\n        }\n        if (pos_arg_num === -2) {\n          self.$raise($$($nesting, 'ArgumentError'), \"\" + \"numbered(\" + (num) + \") after named\")\n        }\n        if (num < 1) {\n          self.$raise($$($nesting, 'ArgumentError'), \"\" + \"invalid index - \" + (num) + \"$\")\n        }\n        pos_arg_num = -1;\n        return GET_NTH_ARG(num - 1);\n      }\n\n      function GET_ARG() {\n        return (next_arg === undefined ? GET_NEXT_ARG() : next_arg);\n      }\n\n      function READ_NUM(label) {\n        var num, str = '';\n        for (;; i++) {\n          if (i === len) {\n            self.$raise($$($nesting, 'ArgumentError'), \"malformed format string - %*[0-9]\")\n          }\n          if (format_string.charCodeAt(i) < 48 || format_string.charCodeAt(i) > 57) {\n            i--;\n            num = parseInt(str, 10) || 0;\n            if (num > 2147483647) {\n              self.$raise($$($nesting, 'ArgumentError'), \"\" + (label) + \" too big\")\n            }\n            return num;\n          }\n          str += format_string.charAt(i);\n        }\n      }\n\n      function READ_NUM_AFTER_ASTER(label) {\n        var arg, num = READ_NUM(label);\n        if (format_string.charAt(i + 1) === '$') {\n          i++;\n          arg = GET_POS_ARG(num);\n        } else {\n          arg = GET_NEXT_ARG();\n        }\n        return (arg).$to_int();\n      }\n\n      for (i = format_string.indexOf('%'); i !== -1; i = format_string.indexOf('%', i)) {\n        str = undefined;\n\n        flags = FNONE;\n        width = -1;\n        precision = -1;\n        next_arg = undefined;\n\n        end_slice = i;\n\n        i++;\n\n        switch (format_string.charAt(i)) {\n        case '%':\n          begin_slice = i;\n        case '':\n        case '\\n':\n        case '\\0':\n          i++;\n          continue;\n        }\n\n        format_sequence: for (; i < len; i++) {\n          switch (format_string.charAt(i)) {\n\n          case ' ':\n            CHECK_FOR_FLAGS();\n            flags |= FSPACE;\n            continue format_sequence;\n\n          case '#':\n            CHECK_FOR_FLAGS();\n            flags |= FSHARP;\n            continue format_sequence;\n\n          case '+':\n            CHECK_FOR_FLAGS();\n            flags |= FPLUS;\n            continue format_sequence;\n\n          case '-':\n            CHECK_FOR_FLAGS();\n            flags |= FMINUS;\n            continue format_sequence;\n\n          case '0':\n            CHECK_FOR_FLAGS();\n            flags |= FZERO;\n            continue format_sequence;\n\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            tmp_num = READ_NUM('width');\n            if (format_string.charAt(i + 1) === '$') {\n              if (i + 2 === len) {\n                str = '%';\n                i++;\n                break format_sequence;\n              }\n              if (next_arg !== undefined) {\n                self.$raise($$($nesting, 'ArgumentError'), \"\" + \"value given twice - %\" + (tmp_num) + \"$\")\n              }\n              next_arg = GET_POS_ARG(tmp_num);\n              i++;\n            } else {\n              CHECK_FOR_WIDTH();\n              flags |= FWIDTH;\n              width = tmp_num;\n            }\n            continue format_sequence;\n\n          case '<':\n          case '\\{':\n            closing_brace_char = (format_string.charAt(i) === '<' ? '>' : '\\}');\n            hash_parameter_key = '';\n\n            i++;\n\n            for (;; i++) {\n              if (i === len) {\n                self.$raise($$($nesting, 'ArgumentError'), \"malformed name - unmatched parenthesis\")\n              }\n              if (format_string.charAt(i) === closing_brace_char) {\n\n                if (pos_arg_num > 0) {\n                  self.$raise($$($nesting, 'ArgumentError'), \"\" + \"named \" + (hash_parameter_key) + \" after unnumbered(\" + (pos_arg_num) + \")\")\n                }\n                if (pos_arg_num === -1) {\n                  self.$raise($$($nesting, 'ArgumentError'), \"\" + \"named \" + (hash_parameter_key) + \" after numbered\")\n                }\n                pos_arg_num = -2;\n\n                if (args[0] === undefined || !args[0].$$is_hash) {\n                  self.$raise($$($nesting, 'ArgumentError'), \"one hash required\")\n                }\n\n                next_arg = (args[0]).$fetch(hash_parameter_key);\n\n                if (closing_brace_char === '>') {\n                  continue format_sequence;\n                } else {\n                  str = next_arg.toString();\n                  if (precision !== -1) { str = str.slice(0, precision); }\n                  if (flags&FMINUS) {\n                    while (str.length < width) { str = str + ' '; }\n                  } else {\n                    while (str.length < width) { str = ' ' + str; }\n                  }\n                  break format_sequence;\n                }\n              }\n              hash_parameter_key += format_string.charAt(i);\n            }\n\n          case '*':\n            i++;\n            CHECK_FOR_WIDTH();\n            flags |= FWIDTH;\n            width = READ_NUM_AFTER_ASTER('width');\n            if (width < 0) {\n              flags |= FMINUS;\n              width = -width;\n            }\n            continue format_sequence;\n\n          case '.':\n            if (flags&FPREC0) {\n              self.$raise($$($nesting, 'ArgumentError'), \"precision given twice\")\n            }\n            flags |= FPREC|FPREC0;\n            precision = 0;\n            i++;\n            if (format_string.charAt(i) === '*') {\n              i++;\n              precision = READ_NUM_AFTER_ASTER('precision');\n              if (precision < 0) {\n                flags &= ~FPREC;\n              }\n              continue format_sequence;\n            }\n            precision = READ_NUM('precision');\n            continue format_sequence;\n\n          case 'd':\n          case 'i':\n          case 'u':\n            arg = self.$Integer(GET_ARG());\n            if (arg >= 0) {\n              str = arg.toString();\n              while (str.length < precision) { str = '0' + str; }\n              if (flags&FMINUS) {\n                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }\n                while (str.length < width) { str = str + ' '; }\n              } else {\n                if (flags&FZERO && precision === -1) {\n                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }\n                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }\n                } else {\n                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }\n                  while (str.length < width) { str = ' ' + str; }\n                }\n              }\n            } else {\n              str = (-arg).toString();\n              while (str.length < precision) { str = '0' + str; }\n              if (flags&FMINUS) {\n                str = '-' + str;\n                while (str.length < width) { str = str + ' '; }\n              } else {\n                if (flags&FZERO && precision === -1) {\n                  while (str.length < width - 1) { str = '0' + str; }\n                  str = '-' + str;\n                } else {\n                  str = '-' + str;\n                  while (str.length < width) { str = ' ' + str; }\n                }\n              }\n            }\n            break format_sequence;\n\n          case 'b':\n          case 'B':\n          case 'o':\n          case 'x':\n          case 'X':\n            switch (format_string.charAt(i)) {\n            case 'b':\n            case 'B':\n              base_number = 2;\n              base_prefix = '0b';\n              base_neg_zero_regex = /^1+/;\n              base_neg_zero_digit = '1';\n              break;\n            case 'o':\n              base_number = 8;\n              base_prefix = '0';\n              base_neg_zero_regex = /^3?7+/;\n              base_neg_zero_digit = '7';\n              break;\n            case 'x':\n            case 'X':\n              base_number = 16;\n              base_prefix = '0x';\n              base_neg_zero_regex = /^f+/;\n              base_neg_zero_digit = 'f';\n              break;\n            }\n            arg = self.$Integer(GET_ARG());\n            if (arg >= 0) {\n              str = arg.toString(base_number);\n              while (str.length < precision) { str = '0' + str; }\n              if (flags&FMINUS) {\n                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }\n                if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }\n                while (str.length < width) { str = str + ' '; }\n              } else {\n                if (flags&FZERO && precision === -1) {\n                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0) - ((flags&FSHARP && arg !== 0) ? base_prefix.length : 0)) { str = '0' + str; }\n                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }\n                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }\n                } else {\n                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }\n                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }\n                  while (str.length < width) { str = ' ' + str; }\n                }\n              }\n            } else {\n              if (flags&FPLUS || flags&FSPACE) {\n                str = (-arg).toString(base_number);\n                while (str.length < precision) { str = '0' + str; }\n                if (flags&FMINUS) {\n                  if (flags&FSHARP) { str = base_prefix + str; }\n                  str = '-' + str;\n                  while (str.length < width) { str = str + ' '; }\n                } else {\n                  if (flags&FZERO && precision === -1) {\n                    while (str.length < width - 1 - (flags&FSHARP ? 2 : 0)) { str = '0' + str; }\n                    if (flags&FSHARP) { str = base_prefix + str; }\n                    str = '-' + str;\n                  } else {\n                    if (flags&FSHARP) { str = base_prefix + str; }\n                    str = '-' + str;\n                    while (str.length < width) { str = ' ' + str; }\n                  }\n                }\n              } else {\n                str = (arg >>> 0).toString(base_number).replace(base_neg_zero_regex, base_neg_zero_digit);\n                while (str.length < precision - 2) { str = base_neg_zero_digit + str; }\n                if (flags&FMINUS) {\n                  str = '..' + str;\n                  if (flags&FSHARP) { str = base_prefix + str; }\n                  while (str.length < width) { str = str + ' '; }\n                } else {\n                  if (flags&FZERO && precision === -1) {\n                    while (str.length < width - 2 - (flags&FSHARP ? base_prefix.length : 0)) { str = base_neg_zero_digit + str; }\n                    str = '..' + str;\n                    if (flags&FSHARP) { str = base_prefix + str; }\n                  } else {\n                    str = '..' + str;\n                    if (flags&FSHARP) { str = base_prefix + str; }\n                    while (str.length < width) { str = ' ' + str; }\n                  }\n                }\n              }\n            }\n            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase()) {\n              str = str.toUpperCase();\n            }\n            break format_sequence;\n\n          case 'f':\n          case 'e':\n          case 'E':\n          case 'g':\n          case 'G':\n            arg = self.$Float(GET_ARG());\n            if (arg >= 0 || isNaN(arg)) {\n              if (arg === Infinity) {\n                str = 'Inf';\n              } else {\n                switch (format_string.charAt(i)) {\n                case 'f':\n                  str = arg.toFixed(precision === -1 ? 6 : precision);\n                  break;\n                case 'e':\n                case 'E':\n                  str = arg.toExponential(precision === -1 ? 6 : precision);\n                  break;\n                case 'g':\n                case 'G':\n                  str = arg.toExponential();\n                  exponent = parseInt(str.split('e')[1], 10);\n                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {\n                    str = arg.toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);\n                  }\n                  break;\n                }\n              }\n              if (flags&FMINUS) {\n                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }\n                while (str.length < width) { str = str + ' '; }\n              } else {\n                if (flags&FZERO && arg !== Infinity && !isNaN(arg)) {\n                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }\n                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }\n                } else {\n                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }\n                  while (str.length < width) { str = ' ' + str; }\n                }\n              }\n            } else {\n              if (arg === -Infinity) {\n                str = 'Inf';\n              } else {\n                switch (format_string.charAt(i)) {\n                case 'f':\n                  str = (-arg).toFixed(precision === -1 ? 6 : precision);\n                  break;\n                case 'e':\n                case 'E':\n                  str = (-arg).toExponential(precision === -1 ? 6 : precision);\n                  break;\n                case 'g':\n                case 'G':\n                  str = (-arg).toExponential();\n                  exponent = parseInt(str.split('e')[1], 10);\n                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {\n                    str = (-arg).toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);\n                  }\n                  break;\n                }\n              }\n              if (flags&FMINUS) {\n                str = '-' + str;\n                while (str.length < width) { str = str + ' '; }\n              } else {\n                if (flags&FZERO && arg !== -Infinity) {\n                  while (str.length < width - 1) { str = '0' + str; }\n                  str = '-' + str;\n                } else {\n                  str = '-' + str;\n                  while (str.length < width) { str = ' ' + str; }\n                }\n              }\n            }\n            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase() && arg !== Infinity && arg !== -Infinity && !isNaN(arg)) {\n              str = str.toUpperCase();\n            }\n            str = str.replace(/([eE][-+]?)([0-9])$/, '$10$2');\n            break format_sequence;\n\n          case 'a':\n          case 'A':\n            // Not implemented because there are no specs for this field type.\n            self.$raise($$($nesting, 'NotImplementedError'), \"`A` and `a` format field types are not implemented in Opal yet\")\n\n          case 'c':\n            arg = GET_ARG();\n            if ((arg)['$respond_to?'](\"to_ary\")) { arg = (arg).$to_ary()[0]; }\n            if ((arg)['$respond_to?'](\"to_str\")) {\n              str = (arg).$to_str();\n            } else {\n              str = String.fromCharCode($$($nesting, 'Opal').$coerce_to(arg, $$($nesting, 'Integer'), \"to_int\"));\n            }\n            if (str.length !== 1) {\n              self.$raise($$($nesting, 'ArgumentError'), \"%c requires a character\")\n            }\n            if (flags&FMINUS) {\n              while (str.length < width) { str = str + ' '; }\n            } else {\n              while (str.length < width) { str = ' ' + str; }\n            }\n            break format_sequence;\n\n          case 'p':\n            str = (GET_ARG()).$inspect();\n            if (precision !== -1) { str = str.slice(0, precision); }\n            if (flags&FMINUS) {\n              while (str.length < width) { str = str + ' '; }\n            } else {\n              while (str.length < width) { str = ' ' + str; }\n            }\n            break format_sequence;\n\n          case 's':\n            str = (GET_ARG()).$to_s();\n            if (precision !== -1) { str = str.slice(0, precision); }\n            if (flags&FMINUS) {\n              while (str.length < width) { str = str + ' '; }\n            } else {\n              while (str.length < width) { str = ' ' + str; }\n            }\n            break format_sequence;\n\n          default:\n            self.$raise($$($nesting, 'ArgumentError'), \"\" + \"malformed format string - %\" + (format_string.charAt(i)))\n          }\n        }\n\n        if (str === undefined) {\n          self.$raise($$($nesting, 'ArgumentError'), \"malformed format string - %\")\n        }\n\n        result += format_string.slice(begin_slice, end_slice) + str;\n        begin_slice = i + 1;\n      }\n\n      if ($gvars.DEBUG && pos_arg_num >= 0 && seq_arg_num < args.length) {\n        self.$raise($$($nesting, 'ArgumentError'), \"too many arguments for format string\")\n      }\n\n      return result + format_string.slice(begin_slice);\n    ;\n    }, TMP_Kernel_format_23.$$arity = -2);\n    \n    Opal.def(self, '$hash', TMP_Kernel_hash_24 = function $$hash() {\n      var self = this;\n\n      return self.$__id__()\n    }, TMP_Kernel_hash_24.$$arity = 0);\n    \n    Opal.def(self, '$initialize_copy', TMP_Kernel_initialize_copy_25 = function $$initialize_copy(other) {\n      var self = this;\n\n      return nil\n    }, TMP_Kernel_initialize_copy_25.$$arity = 1);\n    \n    Opal.def(self, '$inspect', TMP_Kernel_inspect_26 = function $$inspect() {\n      var self = this;\n\n      return self.$to_s()\n    }, TMP_Kernel_inspect_26.$$arity = 0);\n    \n    Opal.def(self, '$instance_of?', TMP_Kernel_instance_of$q_27 = function(klass) {\n      var self = this;\n\n      \n      if (!klass.$$is_class && !klass.$$is_module) {\n        self.$raise($$($nesting, 'TypeError'), \"class or module required\");\n      }\n\n      return self.$$class === klass;\n    \n    }, TMP_Kernel_instance_of$q_27.$$arity = 1);\n    \n    Opal.def(self, '$instance_variable_defined?', TMP_Kernel_instance_variable_defined$q_28 = function(name) {\n      var self = this;\n\n      \n      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);\n      return Opal.hasOwnProperty.call(self, name.substr(1));;\n    }, TMP_Kernel_instance_variable_defined$q_28.$$arity = 1);\n    \n    Opal.def(self, '$instance_variable_get', TMP_Kernel_instance_variable_get_29 = function $$instance_variable_get(name) {\n      var self = this;\n\n      \n      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);\n      \n      var ivar = self[Opal.ivar(name.substr(1))];\n\n      return ivar == null ? nil : ivar;\n    ;\n    }, TMP_Kernel_instance_variable_get_29.$$arity = 1);\n    \n    Opal.def(self, '$instance_variable_set', TMP_Kernel_instance_variable_set_30 = function $$instance_variable_set(name, value) {\n      var self = this;\n\n      \n      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);\n      return self[Opal.ivar(name.substr(1))] = value;;\n    }, TMP_Kernel_instance_variable_set_30.$$arity = 2);\n    \n    Opal.def(self, '$remove_instance_variable', TMP_Kernel_remove_instance_variable_31 = function $$remove_instance_variable(name) {\n      var self = this;\n\n      \n      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);\n      \n      var key = Opal.ivar(name.substr(1)),\n          val;\n      if (self.hasOwnProperty(key)) {\n        val = self[key];\n        delete self[key];\n        return val;\n      }\n    ;\n      return self.$raise($$($nesting, 'NameError'), \"\" + \"instance variable \" + (name) + \" not defined\");\n    }, TMP_Kernel_remove_instance_variable_31.$$arity = 1);\n    \n    Opal.def(self, '$instance_variables', TMP_Kernel_instance_variables_32 = function $$instance_variables() {\n      var self = this;\n\n      \n      var result = [], ivar;\n\n      for (var name in self) {\n        if (self.hasOwnProperty(name) && name.charAt(0) !== '$') {\n          if (name.substr(-1) === '$') {\n            ivar = name.slice(0, name.length - 1);\n          } else {\n            ivar = name;\n          }\n          result.push('@' + ivar);\n        }\n      }\n\n      return result;\n    \n    }, TMP_Kernel_instance_variables_32.$$arity = 0);\n    \n    Opal.def(self, '$Integer', TMP_Kernel_Integer_33 = function $$Integer(value, base) {\n      var self = this;\n\n      \n      var i, str, base_digits;\n\n      if (!value.$$is_string) {\n        if (base !== undefined) {\n          self.$raise($$($nesting, 'ArgumentError'), \"base specified for non string value\")\n        }\n        if (value === nil) {\n          self.$raise($$($nesting, 'TypeError'), \"can't convert nil into Integer\")\n        }\n        if (value.$$is_number) {\n          if (value === Infinity || value === -Infinity || isNaN(value)) {\n            self.$raise($$($nesting, 'FloatDomainError'), value)\n          }\n          return Math.floor(value);\n        }\n        if (value['$respond_to?'](\"to_int\")) {\n          i = value.$to_int();\n          if (i !== nil) {\n            return i;\n          }\n        }\n        return $$($nesting, 'Opal')['$coerce_to!'](value, $$($nesting, 'Integer'), \"to_i\");\n      }\n\n      if (value === \"0\") {\n        return 0;\n      }\n\n      if (base === undefined) {\n        base = 0;\n      } else {\n        base = $$($nesting, 'Opal').$coerce_to(base, $$($nesting, 'Integer'), \"to_int\");\n        if (base === 1 || base < 0 || base > 36) {\n          self.$raise($$($nesting, 'ArgumentError'), \"\" + \"invalid radix \" + (base))\n        }\n      }\n\n      str = value.toLowerCase();\n\n      str = str.replace(/(\\d)_(?=\\d)/g, '$1');\n\n      str = str.replace(/^(\\s*[+-]?)(0[bodx]?)/, function (_, head, flag) {\n        switch (flag) {\n        case '0b':\n          if (base === 0 || base === 2) {\n            base = 2;\n            return head;\n          }\n        case '0':\n        case '0o':\n          if (base === 0 || base === 8) {\n            base = 8;\n            return head;\n          }\n        case '0d':\n          if (base === 0 || base === 10) {\n            base = 10;\n            return head;\n          }\n        case '0x':\n          if (base === 0 || base === 16) {\n            base = 16;\n            return head;\n          }\n        }\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"invalid value for Integer(): \\\"\" + (value) + \"\\\"\")\n      });\n\n      base = (base === 0 ? 10 : base);\n\n      base_digits = '0-' + (base <= 10 ? base - 1 : '9a-' + String.fromCharCode(97 + (base - 11)));\n\n      if (!(new RegExp('^\\\\s*[+-]?[' + base_digits + ']+\\\\s*$')).test(str)) {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"invalid value for Integer(): \\\"\" + (value) + \"\\\"\")\n      }\n\n      i = parseInt(str, base);\n\n      if (isNaN(i)) {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"invalid value for Integer(): \\\"\" + (value) + \"\\\"\")\n      }\n\n      return i;\n    \n    }, TMP_Kernel_Integer_33.$$arity = -2);\n    \n    Opal.def(self, '$Float', TMP_Kernel_Float_34 = function $$Float(value) {\n      var self = this;\n\n      \n      var str;\n\n      if (value === nil) {\n        self.$raise($$($nesting, 'TypeError'), \"can't convert nil into Float\")\n      }\n\n      if (value.$$is_string) {\n        str = value.toString();\n\n        str = str.replace(/(\\d)_(?=\\d)/g, '$1');\n\n        //Special case for hex strings only:\n        if (/^\\s*[-+]?0[xX][0-9a-fA-F]+\\s*$/.test(str)) {\n          return self.$Integer(str);\n        }\n\n        if (!/^\\s*[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?\\s*$/.test(str)) {\n          self.$raise($$($nesting, 'ArgumentError'), \"\" + \"invalid value for Float(): \\\"\" + (value) + \"\\\"\")\n        }\n\n        return parseFloat(str);\n      }\n\n      return $$($nesting, 'Opal')['$coerce_to!'](value, $$($nesting, 'Float'), \"to_f\");\n    \n    }, TMP_Kernel_Float_34.$$arity = 1);\n    \n    Opal.def(self, '$Hash', TMP_Kernel_Hash_35 = function $$Hash(arg) {\n      var $a, self = this;\n\n      \n      if ($truthy(($truthy($a = arg['$nil?']()) ? $a : arg['$==']([])))) {\n        return $hash2([], {})};\n      if ($truthy($$($nesting, 'Hash')['$==='](arg))) {\n        return arg};\n      return $$($nesting, 'Opal')['$coerce_to!'](arg, $$($nesting, 'Hash'), \"to_hash\");\n    }, TMP_Kernel_Hash_35.$$arity = 1);\n    \n    Opal.def(self, '$is_a?', TMP_Kernel_is_a$q_36 = function(klass) {\n      var self = this;\n\n      \n      if (!klass.$$is_class && !klass.$$is_module) {\n        self.$raise($$($nesting, 'TypeError'), \"class or module required\");\n      }\n\n      return Opal.is_a(self, klass);\n    \n    }, TMP_Kernel_is_a$q_36.$$arity = 1);\n    \n    Opal.def(self, '$itself', TMP_Kernel_itself_37 = function $$itself() {\n      var self = this;\n\n      return self\n    }, TMP_Kernel_itself_37.$$arity = 0);\n    Opal.alias(self, \"kind_of?\", \"is_a?\");\n    \n    Opal.def(self, '$lambda', TMP_Kernel_lambda_38 = function $$lambda() {\n      var self = this, $iter = TMP_Kernel_lambda_38.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Kernel_lambda_38.$$p = null;\n      return Opal.lambda(block);\n    }, TMP_Kernel_lambda_38.$$arity = 0);\n    \n    Opal.def(self, '$load', TMP_Kernel_load_39 = function $$load(file) {\n      var self = this;\n\n      \n      file = $$($nesting, 'Opal')['$coerce_to!'](file, $$($nesting, 'String'), \"to_str\");\n      return Opal.load(file);\n    }, TMP_Kernel_load_39.$$arity = 1);\n    \n    Opal.def(self, '$loop', TMP_Kernel_loop_40 = function $$loop() {\n      var TMP_41, $a, self = this, $iter = TMP_Kernel_loop_40.$$p, $yield = $iter || nil, e = nil;\n\n      if ($iter) TMP_Kernel_loop_40.$$p = null;\n      \n      if (($yield !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"loop\"], (TMP_41 = function(){var self = TMP_41.$$s || this;\n\n        return $$$($$($nesting, 'Float'), 'INFINITY')}, TMP_41.$$s = self, TMP_41.$$arity = 0, TMP_41))\n      };\n      while ($truthy(true)) {\n        \n        try {\n          Opal.yieldX($yield, [])\n        } catch ($err) {\n          if (Opal.rescue($err, [$$($nesting, 'StopIteration')])) {e = $err;\n            try {\n              return e.$result()\n            } finally { Opal.pop_exception() }\n          } else { throw $err; }\n        };\n      };\n      return self;\n    }, TMP_Kernel_loop_40.$$arity = 0);\n    \n    Opal.def(self, '$nil?', TMP_Kernel_nil$q_42 = function() {\n      var self = this;\n\n      return false\n    }, TMP_Kernel_nil$q_42.$$arity = 0);\n    Opal.alias(self, \"object_id\", \"__id__\");\n    \n    Opal.def(self, '$printf', TMP_Kernel_printf_43 = function $$printf($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      if ($truthy(args['$any?']())) {\n        self.$print($send(self, 'format', Opal.to_a(args)))};\n      return nil;\n    }, TMP_Kernel_printf_43.$$arity = -1);\n    \n    Opal.def(self, '$proc', TMP_Kernel_proc_44 = function $$proc() {\n      var self = this, $iter = TMP_Kernel_proc_44.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Kernel_proc_44.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        self.$raise($$($nesting, 'ArgumentError'), \"tried to create Proc object without a block\")\n      };\n      block.$$is_lambda = false;\n      return block;\n    }, TMP_Kernel_proc_44.$$arity = 0);\n    \n    Opal.def(self, '$puts', TMP_Kernel_puts_45 = function $$puts($a_rest) {\n      var self = this, strs;\n      if ($gvars.stdout == null) $gvars.stdout = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      strs = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        strs[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return $send($gvars.stdout, 'puts', Opal.to_a(strs))\n    }, TMP_Kernel_puts_45.$$arity = -1);\n    \n    Opal.def(self, '$p', TMP_Kernel_p_47 = function $$p($a_rest) {\n      var TMP_46, self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      $send(args, 'each', [], (TMP_46 = function(obj){var self = TMP_46.$$s || this;\n        if ($gvars.stdout == null) $gvars.stdout = nil;\nif (obj == null) obj = nil;\n      return $gvars.stdout.$puts(obj.$inspect())}, TMP_46.$$s = self, TMP_46.$$arity = 1, TMP_46));\n      if ($truthy($rb_le(args.$length(), 1))) {\n        return args['$[]'](0)\n      } else {\n        return args\n      };\n    }, TMP_Kernel_p_47.$$arity = -1);\n    \n    Opal.def(self, '$print', TMP_Kernel_print_48 = function $$print($a_rest) {\n      var self = this, strs;\n      if ($gvars.stdout == null) $gvars.stdout = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      strs = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        strs[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return $send($gvars.stdout, 'print', Opal.to_a(strs))\n    }, TMP_Kernel_print_48.$$arity = -1);\n    \n    Opal.def(self, '$warn', TMP_Kernel_warn_49 = function $$warn($a_rest) {\n      var $b, self = this, strs;\n      if ($gvars.VERBOSE == null) $gvars.VERBOSE = nil;\n      if ($gvars.stderr == null) $gvars.stderr = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      strs = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        strs[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($truthy(($truthy($b = $gvars.VERBOSE['$nil?']()) ? $b : strs['$empty?']()))) {\n        return nil\n      } else {\n        return $send($gvars.stderr, 'puts', Opal.to_a(strs))\n      }\n    }, TMP_Kernel_warn_49.$$arity = -1);\n    \n    Opal.def(self, '$raise', TMP_Kernel_raise_50 = function $$raise(exception, string, _backtrace) {\n      var self = this;\n      if ($gvars[\"!\"] == null) $gvars[\"!\"] = nil;\n\n      if (string == null) {\n        string = nil;\n      }\n      if (_backtrace == null) {\n        _backtrace = nil;\n      }\n      \n      if (exception == null && $gvars[\"!\"] !== nil) {\n        throw $gvars[\"!\"];\n      }\n      if (exception == null) {\n        exception = $$($nesting, 'RuntimeError').$new();\n      }\n      else if (exception.$$is_string) {\n        exception = $$($nesting, 'RuntimeError').$new(exception);\n      }\n      // using respond_to? and not an undefined check to avoid method_missing matching as true\n      else if (exception.$$is_class && exception['$respond_to?'](\"exception\")) {\n        exception = exception.$exception(string);\n      }\n      else if (exception['$is_a?']($$($nesting, 'Exception'))) {\n        // exception is fine\n      }\n      else {\n        exception = $$($nesting, 'TypeError').$new(\"exception class/object expected\");\n      }\n\n      if ($gvars[\"!\"] !== nil) {\n        Opal.exceptions.push($gvars[\"!\"]);\n      }\n\n      $gvars[\"!\"] = exception;\n\n      throw exception;\n    \n    }, TMP_Kernel_raise_50.$$arity = -1);\n    Opal.alias(self, \"fail\", \"raise\");\n    \n    Opal.def(self, '$rand', TMP_Kernel_rand_51 = function $$rand(max) {\n      var self = this;\n\n      \n      \n      if (max === undefined) {\n        return $$$($$($nesting, 'Random'), 'DEFAULT').$rand();\n      }\n\n      if (max.$$is_number) {\n        if (max < 0) {\n          max = Math.abs(max);\n        }\n\n        if (max % 1 !== 0) {\n          max = max.$to_i();\n        }\n\n        if (max === 0) {\n          max = undefined;\n        }\n      }\n    ;\n      return $$$($$($nesting, 'Random'), 'DEFAULT').$rand(max);\n    }, TMP_Kernel_rand_51.$$arity = -1);\n    \n    Opal.def(self, '$respond_to?', TMP_Kernel_respond_to$q_52 = function(name, include_all) {\n      var self = this;\n\n      if (include_all == null) {\n        include_all = false;\n      }\n      \n      if ($truthy(self['$respond_to_missing?'](name, include_all))) {\n        return true};\n      \n      var body = self['$' + name];\n\n      if (typeof(body) === \"function\" && !body.$$stub) {\n        return true;\n      }\n    ;\n      return false;\n    }, TMP_Kernel_respond_to$q_52.$$arity = -2);\n    \n    Opal.def(self, '$respond_to_missing?', TMP_Kernel_respond_to_missing$q_53 = function(method_name, include_all) {\n      var self = this;\n\n      if (include_all == null) {\n        include_all = false;\n      }\n      return false\n    }, TMP_Kernel_respond_to_missing$q_53.$$arity = -2);\n    \n    Opal.def(self, '$require', TMP_Kernel_require_54 = function $$require(file) {\n      var self = this;\n\n      \n      file = $$($nesting, 'Opal')['$coerce_to!'](file, $$($nesting, 'String'), \"to_str\");\n      return Opal.require(file);\n    }, TMP_Kernel_require_54.$$arity = 1);\n    \n    Opal.def(self, '$require_relative', TMP_Kernel_require_relative_55 = function $$require_relative(file) {\n      var self = this;\n\n      \n      $$($nesting, 'Opal')['$try_convert!'](file, $$($nesting, 'String'), \"to_str\");\n      file = $$($nesting, 'File').$expand_path($$($nesting, 'File').$join(Opal.current_file, \"..\", file));\n      return Opal.require(file);\n    }, TMP_Kernel_require_relative_55.$$arity = 1);\n    \n    Opal.def(self, '$require_tree', TMP_Kernel_require_tree_56 = function $$require_tree(path) {\n      var self = this;\n\n      \n      var result = [];\n\n      path = $$($nesting, 'File').$expand_path(path)\n      path = Opal.normalize(path);\n      if (path === '.') path = '';\n      for (var name in Opal.modules) {\n        if ((name)['$start_with?'](path)) {\n          result.push([name, Opal.require(name)]);\n        }\n      }\n\n      return result;\n    \n    }, TMP_Kernel_require_tree_56.$$arity = 1);\n    Opal.alias(self, \"send\", \"__send__\");\n    Opal.alias(self, \"public_send\", \"__send__\");\n    \n    Opal.def(self, '$singleton_class', TMP_Kernel_singleton_class_57 = function $$singleton_class() {\n      var self = this;\n\n      return Opal.get_singleton_class(self);\n    }, TMP_Kernel_singleton_class_57.$$arity = 0);\n    \n    Opal.def(self, '$sleep', TMP_Kernel_sleep_58 = function $$sleep(seconds) {\n      var self = this;\n\n      if (seconds == null) {\n        seconds = nil;\n      }\n      \n      if (seconds === nil) {\n        self.$raise($$($nesting, 'TypeError'), \"can't convert NilClass into time interval\")\n      }\n      if (!seconds.$$is_number) {\n        self.$raise($$($nesting, 'TypeError'), \"\" + \"can't convert \" + (seconds.$class()) + \" into time interval\")\n      }\n      if (seconds < 0) {\n        self.$raise($$($nesting, 'ArgumentError'), \"time interval must be positive\")\n      }\n      var get_time = Opal.global.performance ?\n        function() {return performance.now()} :\n        function() {return new Date()}\n\n      var t = get_time();\n      while (get_time() - t <= seconds * 1000);\n      return seconds;\n    \n    }, TMP_Kernel_sleep_58.$$arity = -1);\n    Opal.alias(self, \"sprintf\", \"format\");\n    \n    Opal.def(self, '$srand', TMP_Kernel_srand_59 = function $$srand(seed) {\n      var self = this;\n\n      if (seed == null) {\n        seed = $$($nesting, 'Random').$new_seed();\n      }\n      return $$($nesting, 'Random').$srand(seed)\n    }, TMP_Kernel_srand_59.$$arity = -1);\n    \n    Opal.def(self, '$String', TMP_Kernel_String_60 = function $$String(str) {\n      var $a, self = this;\n\n      return ($truthy($a = $$($nesting, 'Opal')['$coerce_to?'](str, $$($nesting, 'String'), \"to_str\")) ? $a : $$($nesting, 'Opal')['$coerce_to!'](str, $$($nesting, 'String'), \"to_s\"))\n    }, TMP_Kernel_String_60.$$arity = 1);\n    \n    Opal.def(self, '$tap', TMP_Kernel_tap_61 = function $$tap() {\n      var self = this, $iter = TMP_Kernel_tap_61.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Kernel_tap_61.$$p = null;\n      \n      Opal.yield1(block, self);\n      return self;\n    }, TMP_Kernel_tap_61.$$arity = 0);\n    \n    Opal.def(self, '$to_proc', TMP_Kernel_to_proc_62 = function $$to_proc() {\n      var self = this;\n\n      return self\n    }, TMP_Kernel_to_proc_62.$$arity = 0);\n    \n    Opal.def(self, '$to_s', TMP_Kernel_to_s_63 = function $$to_s() {\n      var self = this;\n\n      return \"\" + \"#<\" + (self.$class()) + \":0x\" + (self.$__id__().$to_s(16)) + \">\"\n    }, TMP_Kernel_to_s_63.$$arity = 0);\n    \n    Opal.def(self, '$catch', TMP_Kernel_catch_64 = function(sym) {\n      var self = this, $iter = TMP_Kernel_catch_64.$$p, $yield = $iter || nil, e = nil;\n\n      if ($iter) TMP_Kernel_catch_64.$$p = null;\n      try {\n        return Opal.yieldX($yield, []);\n      } catch ($err) {\n        if (Opal.rescue($err, [$$($nesting, 'UncaughtThrowError')])) {e = $err;\n          try {\n            \n            if (e.$sym()['$=='](sym)) {\n              return e.$arg()};\n            return self.$raise();\n          } finally { Opal.pop_exception() }\n        } else { throw $err; }\n      }\n    }, TMP_Kernel_catch_64.$$arity = 1);\n    \n    Opal.def(self, '$throw', TMP_Kernel_throw_65 = function($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return self.$raise($$($nesting, 'UncaughtThrowError'), args)\n    }, TMP_Kernel_throw_65.$$arity = -1);\n    \n    Opal.def(self, '$open', TMP_Kernel_open_66 = function $$open($a_rest) {\n      var self = this, args, $iter = TMP_Kernel_open_66.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Kernel_open_66.$$p = null;\n      return $send($$($nesting, 'File'), 'open', Opal.to_a(args), block.$to_proc())\n    }, TMP_Kernel_open_66.$$arity = -1);\n    \n    Opal.def(self, '$yield_self', TMP_Kernel_yield_self_67 = function $$yield_self() {\n      var TMP_68, self = this, $iter = TMP_Kernel_yield_self_67.$$p, $yield = $iter || nil;\n\n      if ($iter) TMP_Kernel_yield_self_67.$$p = null;\n      \n      if (($yield !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"yield_self\"], (TMP_68 = function(){var self = TMP_68.$$s || this;\n\n        return 1}, TMP_68.$$s = self, TMP_68.$$arity = 0, TMP_68))\n      };\n      return Opal.yield1($yield, self);;\n    }, TMP_Kernel_yield_self_67.$$arity = 0);\n  })($nesting[0], $nesting);\n  return (function($base, $super, $parent_nesting) {\n    function $Object(){};\n    var self = $Object = $klass($base, $super, 'Object', $Object);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return self.$include($$($nesting, 'Kernel'))\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/error\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $module = Opal.module, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$new', '$clone', '$to_s', '$empty?', '$class', '$+', '$attr_reader', '$[]', '$>', '$length', '$inspect', '$raise']);\n  \n  (function($base, $super, $parent_nesting) {\n    function $Exception(){};\n    var self = $Exception = $klass($base, $super, 'Exception', $Exception);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Exception_new_1, TMP_Exception_exception_2, TMP_Exception_initialize_3, TMP_Exception_backtrace_4, TMP_Exception_exception_5, TMP_Exception_message_6, TMP_Exception_inspect_7, TMP_Exception_to_s_8;\n\n    def.message = nil;\n    \n    var stack_trace_limit;\n    Opal.defs(self, '$new', TMP_Exception_new_1 = function($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      var message   = (args.length > 0) ? args[0] : nil;\n      var error     = new self.$$alloc(message);\n      error.name    = self.$$name;\n      error.message = message;\n      Opal.send(error, error.$initialize, args);\n\n      // Error.captureStackTrace() will use .name and .toString to build the\n      // first line of the stack trace so it must be called after the error\n      // has been initialized.\n      // https://nodejs.org/dist/latest-v6.x/docs/api/errors.html\n      if (Opal.config.enable_stack_trace && Error.captureStackTrace) {\n        // Passing Kernel.raise will cut the stack trace from that point above\n        Error.captureStackTrace(error, stack_trace_limit);\n      }\n\n      return error;\n    \n    }, TMP_Exception_new_1.$$arity = -1);\n    stack_trace_limit = self.$new;\n    Opal.defs(self, '$exception', TMP_Exception_exception_2 = function $$exception($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return $send(self, 'new', Opal.to_a(args))\n    }, TMP_Exception_exception_2.$$arity = -1);\n    \n    Opal.def(self, '$initialize', TMP_Exception_initialize_3 = function $$initialize($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return self.message = (args.length > 0) ? args[0] : nil;\n    }, TMP_Exception_initialize_3.$$arity = -1);\n    \n    Opal.def(self, '$backtrace', TMP_Exception_backtrace_4 = function $$backtrace() {\n      var self = this;\n\n      \n      var backtrace = self.stack;\n\n      if (typeof(backtrace) === 'string') {\n        return backtrace.split(\"\\n\").slice(0, 15);\n      }\n      else if (backtrace) {\n        return backtrace.slice(0, 15);\n      }\n\n      return [];\n    \n    }, TMP_Exception_backtrace_4.$$arity = 0);\n    \n    Opal.def(self, '$exception', TMP_Exception_exception_5 = function $$exception(str) {\n      var self = this;\n\n      if (str == null) {\n        str = nil;\n      }\n      \n      if (str === nil || self === str) {\n        return self;\n      }\n\n      var cloned = self.$clone();\n      cloned.message = str;\n      return cloned;\n    \n    }, TMP_Exception_exception_5.$$arity = -1);\n    \n    Opal.def(self, '$message', TMP_Exception_message_6 = function $$message() {\n      var self = this;\n\n      return self.$to_s()\n    }, TMP_Exception_message_6.$$arity = 0);\n    \n    Opal.def(self, '$inspect', TMP_Exception_inspect_7 = function $$inspect() {\n      var self = this, as_str = nil;\n\n      \n      as_str = self.$to_s();\n      if ($truthy(as_str['$empty?']())) {\n        return self.$class().$to_s()\n      } else {\n        return \"\" + \"#<\" + (self.$class().$to_s()) + \": \" + (self.$to_s()) + \">\"\n      };\n    }, TMP_Exception_inspect_7.$$arity = 0);\n    return (Opal.def(self, '$to_s', TMP_Exception_to_s_8 = function $$to_s() {\n      var $a, $b, self = this;\n\n      return ($truthy($a = ($truthy($b = self.message) ? self.message.$to_s() : $b)) ? $a : self.$class().$to_s())\n    }, TMP_Exception_to_s_8.$$arity = 0), nil) && 'to_s';\n  })($nesting[0], Error, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $ScriptError(){};\n    var self = $ScriptError = $klass($base, $super, 'ScriptError', $ScriptError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'Exception'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $SyntaxError(){};\n    var self = $SyntaxError = $klass($base, $super, 'SyntaxError', $SyntaxError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $LoadError(){};\n    var self = $LoadError = $klass($base, $super, 'LoadError', $LoadError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $NotImplementedError(){};\n    var self = $NotImplementedError = $klass($base, $super, 'NotImplementedError', $NotImplementedError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $SystemExit(){};\n    var self = $SystemExit = $klass($base, $super, 'SystemExit', $SystemExit);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'Exception'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $NoMemoryError(){};\n    var self = $NoMemoryError = $klass($base, $super, 'NoMemoryError', $NoMemoryError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'Exception'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $SignalException(){};\n    var self = $SignalException = $klass($base, $super, 'SignalException', $SignalException);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'Exception'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Interrupt(){};\n    var self = $Interrupt = $klass($base, $super, 'Interrupt', $Interrupt);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'Exception'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $SecurityError(){};\n    var self = $SecurityError = $klass($base, $super, 'SecurityError', $SecurityError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'Exception'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $StandardError(){};\n    var self = $StandardError = $klass($base, $super, 'StandardError', $StandardError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'Exception'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $EncodingError(){};\n    var self = $EncodingError = $klass($base, $super, 'EncodingError', $EncodingError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $ZeroDivisionError(){};\n    var self = $ZeroDivisionError = $klass($base, $super, 'ZeroDivisionError', $ZeroDivisionError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $NameError(){};\n    var self = $NameError = $klass($base, $super, 'NameError', $NameError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $NoMethodError(){};\n    var self = $NoMethodError = $klass($base, $super, 'NoMethodError', $NoMethodError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'NameError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $RuntimeError(){};\n    var self = $RuntimeError = $klass($base, $super, 'RuntimeError', $RuntimeError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $FrozenError(){};\n    var self = $FrozenError = $klass($base, $super, 'FrozenError', $FrozenError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'RuntimeError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $LocalJumpError(){};\n    var self = $LocalJumpError = $klass($base, $super, 'LocalJumpError', $LocalJumpError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $TypeError(){};\n    var self = $TypeError = $klass($base, $super, 'TypeError', $TypeError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $ArgumentError(){};\n    var self = $ArgumentError = $klass($base, $super, 'ArgumentError', $ArgumentError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $IndexError(){};\n    var self = $IndexError = $klass($base, $super, 'IndexError', $IndexError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $StopIteration(){};\n    var self = $StopIteration = $klass($base, $super, 'StopIteration', $StopIteration);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'IndexError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $KeyError(){};\n    var self = $KeyError = $klass($base, $super, 'KeyError', $KeyError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'IndexError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $RangeError(){};\n    var self = $RangeError = $klass($base, $super, 'RangeError', $RangeError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $FloatDomainError(){};\n    var self = $FloatDomainError = $klass($base, $super, 'FloatDomainError', $FloatDomainError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'RangeError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $IOError(){};\n    var self = $IOError = $klass($base, $super, 'IOError', $IOError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $SystemCallError(){};\n    var self = $SystemCallError = $klass($base, $super, 'SystemCallError', $SystemCallError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'StandardError'), $nesting);\n  (function($base, $parent_nesting) {\n    var $Errno, self = $Errno = $module($base, 'Errno');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $EINVAL(){};\n      var self = $EINVAL = $klass($base, $super, 'EINVAL', $EINVAL);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_EINVAL_new_9;\n\n      return (Opal.defs(self, '$new', TMP_EINVAL_new_9 = function(name) {\n        var self = this, $iter = TMP_EINVAL_new_9.$$p, $yield = $iter || nil, message = nil;\n\n        if (name == null) {\n          name = nil;\n        }\n        if ($iter) TMP_EINVAL_new_9.$$p = null;\n        \n        message = \"Invalid argument\";\n        if ($truthy(name)) {\n          message = $rb_plus(message, \"\" + \" - \" + (name))};\n        return $send(self, Opal.find_super_dispatcher(self, 'new', TMP_EINVAL_new_9, false, $EINVAL), [message], null);\n      }, TMP_EINVAL_new_9.$$arity = -1), nil) && 'new'\n    })($nesting[0], $$($nesting, 'SystemCallError'), $nesting)\n  })($nesting[0], $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $UncaughtThrowError(){};\n    var self = $UncaughtThrowError = $klass($base, $super, 'UncaughtThrowError', $UncaughtThrowError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_UncaughtThrowError_initialize_10;\n\n    def.sym = nil;\n    \n    self.$attr_reader(\"sym\", \"arg\");\n    return (Opal.def(self, '$initialize', TMP_UncaughtThrowError_initialize_10 = function $$initialize(args) {\n      var self = this, $iter = TMP_UncaughtThrowError_initialize_10.$$p, $yield = $iter || nil;\n\n      if ($iter) TMP_UncaughtThrowError_initialize_10.$$p = null;\n      \n      self.sym = args['$[]'](0);\n      if ($truthy($rb_gt(args.$length(), 1))) {\n        self.arg = args['$[]'](1)};\n      return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_UncaughtThrowError_initialize_10, false), [\"\" + \"uncaught throw \" + (self.sym.$inspect())], null);\n    }, TMP_UncaughtThrowError_initialize_10.$$arity = 1), nil) && 'initialize';\n  })($nesting[0], $$($nesting, 'ArgumentError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $NameError(){};\n    var self = $NameError = $klass($base, $super, 'NameError', $NameError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NameError_initialize_11;\n\n    \n    self.$attr_reader(\"name\");\n    return (Opal.def(self, '$initialize', TMP_NameError_initialize_11 = function $$initialize(message, name) {\n      var self = this, $iter = TMP_NameError_initialize_11.$$p, $yield = $iter || nil;\n\n      if (name == null) {\n        name = nil;\n      }\n      if ($iter) TMP_NameError_initialize_11.$$p = null;\n      \n      $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_NameError_initialize_11, false), [message], null);\n      return (self.name = name);\n    }, TMP_NameError_initialize_11.$$arity = -2), nil) && 'initialize';\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $NoMethodError(){};\n    var self = $NoMethodError = $klass($base, $super, 'NoMethodError', $NoMethodError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NoMethodError_initialize_12;\n\n    \n    self.$attr_reader(\"args\");\n    return (Opal.def(self, '$initialize', TMP_NoMethodError_initialize_12 = function $$initialize(message, name, args) {\n      var self = this, $iter = TMP_NoMethodError_initialize_12.$$p, $yield = $iter || nil;\n\n      if (name == null) {\n        name = nil;\n      }\n      if (args == null) {\n        args = [];\n      }\n      if ($iter) TMP_NoMethodError_initialize_12.$$p = null;\n      \n      $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_NoMethodError_initialize_12, false), [message, name], null);\n      return (self.args = args);\n    }, TMP_NoMethodError_initialize_12.$$arity = -2), nil) && 'initialize';\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $StopIteration(){};\n    var self = $StopIteration = $klass($base, $super, 'StopIteration', $StopIteration);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return self.$attr_reader(\"result\")\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $KeyError(){};\n    var self = $KeyError = $klass($base, $super, 'KeyError', $KeyError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_KeyError_initialize_13, TMP_KeyError_receiver_14, TMP_KeyError_key_15;\n\n    def.receiver = def.key = nil;\n    \n    \n    Opal.def(self, '$initialize', TMP_KeyError_initialize_13 = function $$initialize(message, $kwargs) {\n      var self = this, receiver, key, $iter = TMP_KeyError_initialize_13.$$p, $yield = $iter || nil;\n\n      if ($kwargs == null || !$kwargs.$$is_hash) {\n        if ($kwargs == null) {\n          $kwargs = $hash2([], {});\n        } else {\n          throw Opal.ArgumentError.$new('expected kwargs');\n        }\n      }\n      receiver = $kwargs.$$smap[\"receiver\"];\n      if (receiver == null) {\n        receiver = nil\n      }\n      key = $kwargs.$$smap[\"key\"];\n      if (key == null) {\n        key = nil\n      }\n      if ($iter) TMP_KeyError_initialize_13.$$p = null;\n      \n      $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_KeyError_initialize_13, false), [message], null);\n      self.receiver = receiver;\n      return (self.key = key);\n    }, TMP_KeyError_initialize_13.$$arity = -2);\n    \n    Opal.def(self, '$receiver', TMP_KeyError_receiver_14 = function $$receiver() {\n      var $a, self = this;\n\n      return ($truthy($a = self.receiver) ? $a : self.$raise($$($nesting, 'ArgumentError'), \"no receiver is available\"))\n    }, TMP_KeyError_receiver_14.$$arity = 0);\n    return (Opal.def(self, '$key', TMP_KeyError_key_15 = function $$key() {\n      var $a, self = this;\n\n      return ($truthy($a = self.key) ? $a : self.$raise($$($nesting, 'ArgumentError'), \"no key is available\"))\n    }, TMP_KeyError_key_15.$$arity = 0), nil) && 'key';\n  })($nesting[0], null, $nesting);\n  return (function($base, $parent_nesting) {\n    var $JS, self = $JS = $module($base, 'JS');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Error(){};\n      var self = $Error = $klass($base, $super, 'Error', $Error);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return nil\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/constants\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;\n\n  \n  Opal.const_set($nesting[0], 'RUBY_PLATFORM', \"opal\");\n  Opal.const_set($nesting[0], 'RUBY_ENGINE', \"opal\");\n  Opal.const_set($nesting[0], 'RUBY_VERSION', \"2.5.0\");\n  Opal.const_set($nesting[0], 'RUBY_ENGINE_VERSION', \"0.11.1.dev\");\n  Opal.const_set($nesting[0], 'RUBY_RELEASE_DATE', \"2018-03-06\");\n  Opal.const_set($nesting[0], 'RUBY_PATCHLEVEL', 0);\n  Opal.const_set($nesting[0], 'RUBY_REVISION', 0);\n  Opal.const_set($nesting[0], 'RUBY_COPYRIGHT', \"opal - Copyright (C) 2013-2015 Adam Beynon\");\n  return Opal.const_set($nesting[0], 'RUBY_DESCRIPTION', \"\" + \"opal \" + ($$($nesting, 'RUBY_ENGINE_VERSION')) + \" (\" + ($$($nesting, 'RUBY_RELEASE_DATE')) + \" revision \" + ($$($nesting, 'RUBY_REVISION')) + \")\");\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"opal/base\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;\n\n  Opal.add_stubs(['$require']);\n  \n  self.$require(\"corelib/runtime\");\n  self.$require(\"corelib/helpers\");\n  self.$require(\"corelib/module\");\n  self.$require(\"corelib/class\");\n  self.$require(\"corelib/basic_object\");\n  self.$require(\"corelib/kernel\");\n  self.$require(\"corelib/error\");\n  return self.$require(\"corelib/constants\");\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/nil\"] = function(Opal) {\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$raise', '$name', '$new', '$>', '$length', '$Rational']);\n  \n  (function($base, $super, $parent_nesting) {\n    function $NilClass(){};\n    var self = $NilClass = $klass($base, $super, 'NilClass', $NilClass);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_NilClass_$B_2, TMP_NilClass_$_3, TMP_NilClass_$_4, TMP_NilClass_$_5, TMP_NilClass_$eq$eq_6, TMP_NilClass_dup_7, TMP_NilClass_clone_8, TMP_NilClass_inspect_9, TMP_NilClass_nil$q_10, TMP_NilClass_singleton_class_11, TMP_NilClass_to_a_12, TMP_NilClass_to_h_13, TMP_NilClass_to_i_14, TMP_NilClass_to_s_15, TMP_NilClass_to_c_16, TMP_NilClass_rationalize_17, TMP_NilClass_to_r_18, TMP_NilClass_instance_variables_19;\n\n    \n    def.$$meta = self;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_allocate_1;\n\n      \n      \n      Opal.def(self, '$allocate', TMP_allocate_1 = function $$allocate() {\n        var self = this;\n\n        return self.$raise($$($nesting, 'TypeError'), \"\" + \"allocator undefined for \" + (self.$name()))\n      }, TMP_allocate_1.$$arity = 0);\n      \n      \n      Opal.udef(self, '$' + \"new\");;\n      return nil;;\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    Opal.def(self, '$!', TMP_NilClass_$B_2 = function() {\n      var self = this;\n\n      return true\n    }, TMP_NilClass_$B_2.$$arity = 0);\n    \n    Opal.def(self, '$&', TMP_NilClass_$_3 = function(other) {\n      var self = this;\n\n      return false\n    }, TMP_NilClass_$_3.$$arity = 1);\n    \n    Opal.def(self, '$|', TMP_NilClass_$_4 = function(other) {\n      var self = this;\n\n      return other !== false && other !== nil;\n    }, TMP_NilClass_$_4.$$arity = 1);\n    \n    Opal.def(self, '$^', TMP_NilClass_$_5 = function(other) {\n      var self = this;\n\n      return other !== false && other !== nil;\n    }, TMP_NilClass_$_5.$$arity = 1);\n    \n    Opal.def(self, '$==', TMP_NilClass_$eq$eq_6 = function(other) {\n      var self = this;\n\n      return other === nil;\n    }, TMP_NilClass_$eq$eq_6.$$arity = 1);\n    \n    Opal.def(self, '$dup', TMP_NilClass_dup_7 = function $$dup() {\n      var self = this;\n\n      return nil\n    }, TMP_NilClass_dup_7.$$arity = 0);\n    \n    Opal.def(self, '$clone', TMP_NilClass_clone_8 = function $$clone($kwargs) {\n      var self = this, freeze;\n\n      if ($kwargs == null || !$kwargs.$$is_hash) {\n        if ($kwargs == null) {\n          $kwargs = $hash2([], {});\n        } else {\n          throw Opal.ArgumentError.$new('expected kwargs');\n        }\n      }\n      freeze = $kwargs.$$smap[\"freeze\"];\n      if (freeze == null) {\n        freeze = true\n      }\n      return nil\n    }, TMP_NilClass_clone_8.$$arity = -1);\n    \n    Opal.def(self, '$inspect', TMP_NilClass_inspect_9 = function $$inspect() {\n      var self = this;\n\n      return \"nil\"\n    }, TMP_NilClass_inspect_9.$$arity = 0);\n    \n    Opal.def(self, '$nil?', TMP_NilClass_nil$q_10 = function() {\n      var self = this;\n\n      return true\n    }, TMP_NilClass_nil$q_10.$$arity = 0);\n    \n    Opal.def(self, '$singleton_class', TMP_NilClass_singleton_class_11 = function $$singleton_class() {\n      var self = this;\n\n      return $$($nesting, 'NilClass')\n    }, TMP_NilClass_singleton_class_11.$$arity = 0);\n    \n    Opal.def(self, '$to_a', TMP_NilClass_to_a_12 = function $$to_a() {\n      var self = this;\n\n      return []\n    }, TMP_NilClass_to_a_12.$$arity = 0);\n    \n    Opal.def(self, '$to_h', TMP_NilClass_to_h_13 = function $$to_h() {\n      var self = this;\n\n      return Opal.hash();\n    }, TMP_NilClass_to_h_13.$$arity = 0);\n    \n    Opal.def(self, '$to_i', TMP_NilClass_to_i_14 = function $$to_i() {\n      var self = this;\n\n      return 0\n    }, TMP_NilClass_to_i_14.$$arity = 0);\n    Opal.alias(self, \"to_f\", \"to_i\");\n    \n    Opal.def(self, '$to_s', TMP_NilClass_to_s_15 = function $$to_s() {\n      var self = this;\n\n      return \"\"\n    }, TMP_NilClass_to_s_15.$$arity = 0);\n    \n    Opal.def(self, '$to_c', TMP_NilClass_to_c_16 = function $$to_c() {\n      var self = this;\n\n      return $$($nesting, 'Complex').$new(0, 0)\n    }, TMP_NilClass_to_c_16.$$arity = 0);\n    \n    Opal.def(self, '$rationalize', TMP_NilClass_rationalize_17 = function $$rationalize($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      if ($truthy($rb_gt(args.$length(), 1))) {\n        self.$raise($$($nesting, 'ArgumentError'))};\n      return self.$Rational(0, 1);\n    }, TMP_NilClass_rationalize_17.$$arity = -1);\n    \n    Opal.def(self, '$to_r', TMP_NilClass_to_r_18 = function $$to_r() {\n      var self = this;\n\n      return self.$Rational(0, 1)\n    }, TMP_NilClass_to_r_18.$$arity = 0);\n    return (Opal.def(self, '$instance_variables', TMP_NilClass_instance_variables_19 = function $$instance_variables() {\n      var self = this;\n\n      return []\n    }, TMP_NilClass_instance_variables_19.$$arity = 0), nil) && 'instance_variables';\n  })($nesting[0], null, $nesting);\n  return Opal.const_set($nesting[0], 'NIL', nil);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/boolean\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$raise', '$name']);\n  \n  (function($base, $super, $parent_nesting) {\n    function $Boolean(){};\n    var self = $Boolean = $klass($base, $super, 'Boolean', $Boolean);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Boolean___id___2, TMP_Boolean_$B_3, TMP_Boolean_$_4, TMP_Boolean_$_5, TMP_Boolean_$_6, TMP_Boolean_$eq$eq_7, TMP_Boolean_singleton_class_8, TMP_Boolean_to_s_9, TMP_Boolean_dup_10, TMP_Boolean_clone_11;\n\n    \n    def.$$is_boolean = true;\n    def.$$meta = self;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_allocate_1;\n\n      \n      \n      Opal.def(self, '$allocate', TMP_allocate_1 = function $$allocate() {\n        var self = this;\n\n        return self.$raise($$($nesting, 'TypeError'), \"\" + \"allocator undefined for \" + (self.$name()))\n      }, TMP_allocate_1.$$arity = 0);\n      \n      \n      Opal.udef(self, '$' + \"new\");;\n      return nil;;\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    Opal.def(self, '$__id__', TMP_Boolean___id___2 = function $$__id__() {\n      var self = this;\n\n      return self.valueOf() ? 2 : 0;\n    }, TMP_Boolean___id___2.$$arity = 0);\n    Opal.alias(self, \"object_id\", \"__id__\");\n    \n    Opal.def(self, '$!', TMP_Boolean_$B_3 = function() {\n      var self = this;\n\n      return self != true;\n    }, TMP_Boolean_$B_3.$$arity = 0);\n    \n    Opal.def(self, '$&', TMP_Boolean_$_4 = function(other) {\n      var self = this;\n\n      return (self == true) ? (other !== false && other !== nil) : false;\n    }, TMP_Boolean_$_4.$$arity = 1);\n    \n    Opal.def(self, '$|', TMP_Boolean_$_5 = function(other) {\n      var self = this;\n\n      return (self == true) ? true : (other !== false && other !== nil);\n    }, TMP_Boolean_$_5.$$arity = 1);\n    \n    Opal.def(self, '$^', TMP_Boolean_$_6 = function(other) {\n      var self = this;\n\n      return (self == true) ? (other === false || other === nil) : (other !== false && other !== nil);\n    }, TMP_Boolean_$_6.$$arity = 1);\n    \n    Opal.def(self, '$==', TMP_Boolean_$eq$eq_7 = function(other) {\n      var self = this;\n\n      return (self == true) === other.valueOf();\n    }, TMP_Boolean_$eq$eq_7.$$arity = 1);\n    Opal.alias(self, \"equal?\", \"==\");\n    Opal.alias(self, \"eql?\", \"==\");\n    \n    Opal.def(self, '$singleton_class', TMP_Boolean_singleton_class_8 = function $$singleton_class() {\n      var self = this;\n\n      return $$($nesting, 'Boolean')\n    }, TMP_Boolean_singleton_class_8.$$arity = 0);\n    \n    Opal.def(self, '$to_s', TMP_Boolean_to_s_9 = function $$to_s() {\n      var self = this;\n\n      return (self == true) ? 'true' : 'false';\n    }, TMP_Boolean_to_s_9.$$arity = 0);\n    \n    Opal.def(self, '$dup', TMP_Boolean_dup_10 = function $$dup() {\n      var self = this;\n\n      return self\n    }, TMP_Boolean_dup_10.$$arity = 0);\n    return (Opal.def(self, '$clone', TMP_Boolean_clone_11 = function $$clone($kwargs) {\n      var self = this, freeze;\n\n      if ($kwargs == null || !$kwargs.$$is_hash) {\n        if ($kwargs == null) {\n          $kwargs = $hash2([], {});\n        } else {\n          throw Opal.ArgumentError.$new('expected kwargs');\n        }\n      }\n      freeze = $kwargs.$$smap[\"freeze\"];\n      if (freeze == null) {\n        freeze = true\n      }\n      return self\n    }, TMP_Boolean_clone_11.$$arity = -1), nil) && 'clone';\n  })($nesting[0], Boolean, $nesting);\n  Opal.const_set($nesting[0], 'TrueClass', $$($nesting, 'Boolean'));\n  Opal.const_set($nesting[0], 'FalseClass', $$($nesting, 'Boolean'));\n  Opal.const_set($nesting[0], 'TRUE', true);\n  return Opal.const_set($nesting[0], 'FALSE', false);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/comparable\"] = function(Opal) {\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$===', '$>', '$<', '$equal?', '$<=>', '$normalize', '$raise', '$class']);\n  return (function($base, $parent_nesting) {\n    var $Comparable, self = $Comparable = $module($base, 'Comparable');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Comparable_normalize_1, TMP_Comparable_$eq$eq_2, TMP_Comparable_$gt_3, TMP_Comparable_$gt$eq_4, TMP_Comparable_$lt_5, TMP_Comparable_$lt$eq_6, TMP_Comparable_between$q_7, TMP_Comparable_clamp_8;\n\n    \n    Opal.defs(self, '$normalize', TMP_Comparable_normalize_1 = function $$normalize(what) {\n      var self = this;\n\n      \n      if ($truthy($$($nesting, 'Integer')['$==='](what))) {\n        return what};\n      if ($truthy($rb_gt(what, 0))) {\n        return 1};\n      if ($truthy($rb_lt(what, 0))) {\n        return -1};\n      return 0;\n    }, TMP_Comparable_normalize_1.$$arity = 1);\n    \n    Opal.def(self, '$==', TMP_Comparable_$eq$eq_2 = function(other) {\n      var self = this, cmp = nil;\n\n      try {\n        \n        if ($truthy(self['$equal?'](other))) {\n          return true};\n        \n      if (self[\"$<=>\"] == Opal.Kernel[\"$<=>\"]) {\n        return false;\n      }\n\n      // check for infinite recursion\n      if (self.$$comparable) {\n        delete self.$$comparable;\n        return false;\n      }\n    ;\n        if ($truthy((cmp = self['$<=>'](other)))) {\n        } else {\n          return false\n        };\n        return $$($nesting, 'Comparable').$normalize(cmp) == 0;\n      } catch ($err) {\n        if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {\n          try {\n            return false\n          } finally { Opal.pop_exception() }\n        } else { throw $err; }\n      }\n    }, TMP_Comparable_$eq$eq_2.$$arity = 1);\n    \n    Opal.def(self, '$>', TMP_Comparable_$gt_3 = function(other) {\n      var self = this, cmp = nil;\n\n      \n      if ($truthy((cmp = self['$<=>'](other)))) {\n      } else {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (self.$class()) + \" with \" + (other.$class()) + \" failed\")\n      };\n      return $$($nesting, 'Comparable').$normalize(cmp) > 0;\n    }, TMP_Comparable_$gt_3.$$arity = 1);\n    \n    Opal.def(self, '$>=', TMP_Comparable_$gt$eq_4 = function(other) {\n      var self = this, cmp = nil;\n\n      \n      if ($truthy((cmp = self['$<=>'](other)))) {\n      } else {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (self.$class()) + \" with \" + (other.$class()) + \" failed\")\n      };\n      return $$($nesting, 'Comparable').$normalize(cmp) >= 0;\n    }, TMP_Comparable_$gt$eq_4.$$arity = 1);\n    \n    Opal.def(self, '$<', TMP_Comparable_$lt_5 = function(other) {\n      var self = this, cmp = nil;\n\n      \n      if ($truthy((cmp = self['$<=>'](other)))) {\n      } else {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (self.$class()) + \" with \" + (other.$class()) + \" failed\")\n      };\n      return $$($nesting, 'Comparable').$normalize(cmp) < 0;\n    }, TMP_Comparable_$lt_5.$$arity = 1);\n    \n    Opal.def(self, '$<=', TMP_Comparable_$lt$eq_6 = function(other) {\n      var self = this, cmp = nil;\n\n      \n      if ($truthy((cmp = self['$<=>'](other)))) {\n      } else {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (self.$class()) + \" with \" + (other.$class()) + \" failed\")\n      };\n      return $$($nesting, 'Comparable').$normalize(cmp) <= 0;\n    }, TMP_Comparable_$lt$eq_6.$$arity = 1);\n    \n    Opal.def(self, '$between?', TMP_Comparable_between$q_7 = function(min, max) {\n      var self = this;\n\n      \n      if ($rb_lt(self, min)) {\n        return false};\n      if ($rb_gt(self, max)) {\n        return false};\n      return true;\n    }, TMP_Comparable_between$q_7.$$arity = 2);\n    \n    Opal.def(self, '$clamp', TMP_Comparable_clamp_8 = function $$clamp(min, max) {\n      var self = this, cmp = nil;\n\n      \n      cmp = min['$<=>'](max);\n      if ($truthy(cmp)) {\n      } else {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (min.$class()) + \" with \" + (max.$class()) + \" failed\")\n      };\n      if ($truthy($rb_gt($$($nesting, 'Comparable').$normalize(cmp), 0))) {\n        self.$raise($$($nesting, 'ArgumentError'), \"min argument must be smaller than max argument\")};\n      if ($truthy($rb_lt($$($nesting, 'Comparable').$normalize(self['$<=>'](min)), 0))) {\n        return min};\n      if ($truthy($rb_gt($$($nesting, 'Comparable').$normalize(self['$<=>'](max)), 0))) {\n        return max};\n      return self;\n    }, TMP_Comparable_clamp_8.$$arity = 2);\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/regexp\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$nil?', '$[]', '$raise', '$escape', '$options', '$to_str', '$new', '$join', '$coerce_to!', '$!', '$match', '$coerce_to?', '$begin', '$coerce_to', '$=~', '$attr_reader', '$===', '$inspect', '$to_a']);\n  \n  (function($base, $super, $parent_nesting) {\n    function $RegexpError(){};\n    var self = $RegexpError = $klass($base, $super, 'RegexpError', $RegexpError);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return nil\n  })($nesting[0], $$($nesting, 'StandardError'), $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Regexp(){};\n    var self = $Regexp = $klass($base, $super, 'Regexp', $Regexp);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Regexp_$eq$eq_6, TMP_Regexp_$eq$eq$eq_7, TMP_Regexp_$eq$_8, TMP_Regexp_inspect_9, TMP_Regexp_match_10, TMP_Regexp_match$q_11, TMP_Regexp_$_12, TMP_Regexp_source_13, TMP_Regexp_options_14, TMP_Regexp_casefold$q_15;\n\n    \n    Opal.const_set($nesting[0], 'IGNORECASE', 1);\n    Opal.const_set($nesting[0], 'EXTENDED', 2);\n    Opal.const_set($nesting[0], 'MULTILINE', 4);\n    def.$$is_regexp = true;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_allocate_1, TMP_escape_2, TMP_last_match_3, TMP_union_4, TMP_new_5;\n\n      \n      \n      Opal.def(self, '$allocate', TMP_allocate_1 = function $$allocate() {\n        var self = this, $iter = TMP_allocate_1.$$p, $yield = $iter || nil, allocated = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n        if ($iter) TMP_allocate_1.$$p = null;\n        // Prepare super implicit arguments\n        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n          $zuper[$zuper_i] = arguments[$zuper_i];\n        }\n        \n        allocated = $send(self, Opal.find_super_dispatcher(self, 'allocate', TMP_allocate_1, false), $zuper, $iter);\n        allocated.uninitialized = true;\n        return allocated;\n      }, TMP_allocate_1.$$arity = 0);\n      \n      Opal.def(self, '$escape', TMP_escape_2 = function $$escape(string) {\n        var self = this;\n\n        return Opal.escape_regexp(string);\n      }, TMP_escape_2.$$arity = 1);\n      \n      Opal.def(self, '$last_match', TMP_last_match_3 = function $$last_match(n) {\n        var self = this;\n        if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n        if (n == null) {\n          n = nil;\n        }\n        if ($truthy(n['$nil?']())) {\n          return $gvars[\"~\"]\n        } else {\n          return $gvars[\"~\"]['$[]'](n)\n        }\n      }, TMP_last_match_3.$$arity = -1);\n      Opal.alias(self, \"quote\", \"escape\");\n      \n      Opal.def(self, '$union', TMP_union_4 = function $$union($a_rest) {\n        var self = this, parts;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        parts = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          parts[$arg_idx - 0] = arguments[$arg_idx];\n        }\n        \n        \n        var is_first_part_array, quoted_validated, part, options, each_part_options;\n        if (parts.length == 0) {\n          return /(?!)/;\n        }\n        // return fast if there's only one element\n        if (parts.length == 1 && parts[0].$$is_regexp) {\n          return parts[0];\n        }\n        // cover the 2 arrays passed as arguments case\n        is_first_part_array = parts[0].$$is_array;\n        if (parts.length > 1 && is_first_part_array) {\n          self.$raise($$($nesting, 'TypeError'), \"no implicit conversion of Array into String\")\n        }\n        // deal with splat issues (related to https://github.com/opal/opal/issues/858)\n        if (is_first_part_array) {\n          parts = parts[0];\n        }\n        options = undefined;\n        quoted_validated = [];\n        for (var i=0; i < parts.length; i++) {\n          part = parts[i];\n          if (part.$$is_string) {\n            quoted_validated.push(self.$escape(part));\n          }\n          else if (part.$$is_regexp) {\n            each_part_options = (part).$options();\n            if (options != undefined && options != each_part_options) {\n              self.$raise($$($nesting, 'TypeError'), \"All expressions must use the same options\")\n            }\n            options = each_part_options;\n            quoted_validated.push('('+part.source+')');\n          }\n          else {\n            quoted_validated.push(self.$escape((part).$to_str()));\n          }\n        }\n      ;\n        return self.$new((quoted_validated).$join(\"|\"), options);\n      }, TMP_union_4.$$arity = -1);\n      return (Opal.def(self, '$new', TMP_new_5 = function(regexp, options) {\n        var self = this;\n\n        \n        if (regexp.$$is_regexp) {\n          return new RegExp(regexp);\n        }\n\n        regexp = $$($nesting, 'Opal')['$coerce_to!'](regexp, $$($nesting, 'String'), \"to_str\");\n\n        if (regexp.charAt(regexp.length - 1) === '\\\\' && regexp.charAt(regexp.length - 2) !== '\\\\') {\n          self.$raise($$($nesting, 'RegexpError'), \"\" + \"too short escape sequence: /\" + (regexp) + \"/\")\n        }\n\n        if (options === undefined || options['$!']()) {\n          return new RegExp(regexp);\n        }\n\n        if (options.$$is_number) {\n          var temp = '';\n          if ($$($nesting, 'IGNORECASE') & options) { temp += 'i'; }\n          if ($$($nesting, 'MULTILINE')  & options) { temp += 'm'; }\n          options = temp;\n        }\n        else {\n          options = 'i';\n        }\n\n        return new RegExp(regexp, options);\n      \n      }, TMP_new_5.$$arity = -2), nil) && 'new';\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    Opal.def(self, '$==', TMP_Regexp_$eq$eq_6 = function(other) {\n      var self = this;\n\n      return other.constructor == RegExp && self.toString() === other.toString();\n    }, TMP_Regexp_$eq$eq_6.$$arity = 1);\n    \n    Opal.def(self, '$===', TMP_Regexp_$eq$eq$eq_7 = function(string) {\n      var self = this;\n\n      return self.$match($$($nesting, 'Opal')['$coerce_to?'](string, $$($nesting, 'String'), \"to_str\")) !== nil\n    }, TMP_Regexp_$eq$eq$eq_7.$$arity = 1);\n    \n    Opal.def(self, '$=~', TMP_Regexp_$eq$_8 = function(string) {\n      var $a, self = this;\n      if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n      return ($truthy($a = self.$match(string)) ? $gvars[\"~\"].$begin(0) : $a)\n    }, TMP_Regexp_$eq$_8.$$arity = 1);\n    Opal.alias(self, \"eql?\", \"==\");\n    \n    Opal.def(self, '$inspect', TMP_Regexp_inspect_9 = function $$inspect() {\n      var self = this;\n\n      \n      var regexp_format = /^\\/(.*)\\/([^\\/]*)$/;\n      var value = self.toString();\n      var matches = regexp_format.exec(value);\n      if (matches) {\n        var regexp_pattern = matches[1];\n        var regexp_flags = matches[2];\n        var chars = regexp_pattern.split('');\n        var chars_length = chars.length;\n        var char_escaped = false;\n        var regexp_pattern_escaped = '';\n        for (var i = 0; i < chars_length; i++) {\n          var current_char = chars[i];\n          if (!char_escaped && current_char == '/') {\n            regexp_pattern_escaped = regexp_pattern_escaped.concat('\\\\');\n          }\n          regexp_pattern_escaped = regexp_pattern_escaped.concat(current_char);\n          if (current_char == '\\\\') {\n            if (char_escaped) {\n              // does not over escape\n              char_escaped = false;\n            } else {\n              char_escaped = true;\n            }\n          } else {\n            char_escaped = false;\n          }\n        }\n        return '/' + regexp_pattern_escaped + '/' + regexp_flags;\n      } else {\n        return value;\n      }\n    \n    }, TMP_Regexp_inspect_9.$$arity = 0);\n    \n    Opal.def(self, '$match', TMP_Regexp_match_10 = function $$match(string, pos) {\n      var self = this, $iter = TMP_Regexp_match_10.$$p, block = $iter || nil;\n      if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n      if ($iter) TMP_Regexp_match_10.$$p = null;\n      \n      if (self.uninitialized) {\n        self.$raise($$($nesting, 'TypeError'), \"uninitialized Regexp\")\n      }\n\n      if (pos === undefined) {\n        if (string === nil) return ($gvars[\"~\"] = nil);\n        var m = self.exec($$($nesting, 'Opal').$coerce_to(string, $$($nesting, 'String'), \"to_str\"));\n        if (m) {\n          ($gvars[\"~\"] = $$($nesting, 'MatchData').$new(self, m));\n          return block === nil ? $gvars[\"~\"] : Opal.yield1(block, $gvars[\"~\"]);\n        } else {\n          return ($gvars[\"~\"] = nil);\n        }\n      }\n\n      pos = $$($nesting, 'Opal').$coerce_to(pos, $$($nesting, 'Integer'), \"to_int\");\n\n      if (string === nil) {\n        return ($gvars[\"~\"] = nil);\n      }\n\n      string = $$($nesting, 'Opal').$coerce_to(string, $$($nesting, 'String'), \"to_str\");\n\n      if (pos < 0) {\n        pos += string.length;\n        if (pos < 0) {\n          return ($gvars[\"~\"] = nil);\n        }\n      }\n\n      var source = self.source;\n      var flags = self.multiline ? 'gm' : 'g';\n\n      // global RegExp maintains state, so not using self/this\n      var md, re = new RegExp(source, flags + (self.ignoreCase ? 'i' : ''));\n\n      while (true) {\n        md = re.exec(string);\n        if (md === null) {\n          return ($gvars[\"~\"] = nil);\n        }\n        if (md.index >= pos) {\n          ($gvars[\"~\"] = $$($nesting, 'MatchData').$new(re, md));\n          return block === nil ? $gvars[\"~\"] : Opal.yield1(block, $gvars[\"~\"]);\n        }\n        re.lastIndex = md.index + 1;\n      }\n    \n    }, TMP_Regexp_match_10.$$arity = -2);\n    \n    Opal.def(self, '$match?', TMP_Regexp_match$q_11 = function(string, pos) {\n      var self = this;\n\n      \n      if (self.uninitialized) {\n        self.$raise($$($nesting, 'TypeError'), \"uninitialized Regexp\")\n      }\n\n      if (pos === undefined) {\n        return string === nil ? false : self.test($$($nesting, 'Opal').$coerce_to(string, $$($nesting, 'String'), \"to_str\"));\n      }\n\n      pos = $$($nesting, 'Opal').$coerce_to(pos, $$($nesting, 'Integer'), \"to_int\");\n\n      if (string === nil) {\n        return false;\n      }\n\n      string = $$($nesting, 'Opal').$coerce_to(string, $$($nesting, 'String'), \"to_str\");\n\n      if (pos < 0) {\n        pos += string.length;\n        if (pos < 0) {\n          return false;\n        }\n      }\n\n      var source = self.source;\n      var flags = self.multiline ? 'gm' : 'g';\n\n      // global RegExp maintains state, so not using self/this\n      var md, re = new RegExp(source, flags + (self.ignoreCase ? 'i' : ''));\n\n      md = re.exec(string);\n      if (md === null || md.index < pos) {\n        return false;\n      } else {\n        return true;\n      }\n    \n    }, TMP_Regexp_match$q_11.$$arity = -2);\n    \n    Opal.def(self, '$~', TMP_Regexp_$_12 = function() {\n      var self = this;\n      if ($gvars._ == null) $gvars._ = nil;\n\n      return self['$=~']($gvars._)\n    }, TMP_Regexp_$_12.$$arity = 0);\n    \n    Opal.def(self, '$source', TMP_Regexp_source_13 = function $$source() {\n      var self = this;\n\n      return self.source;\n    }, TMP_Regexp_source_13.$$arity = 0);\n    \n    Opal.def(self, '$options', TMP_Regexp_options_14 = function $$options() {\n      var self = this;\n\n      \n      if (self.uninitialized) {\n        self.$raise($$($nesting, 'TypeError'), \"uninitialized Regexp\")\n      }\n      var result = 0;\n      // should be supported in IE6 according to https://msdn.microsoft.com/en-us/library/7f5z26w4(v=vs.94).aspx\n      if (self.multiline) {\n        result |= $$($nesting, 'MULTILINE');\n      }\n      if (self.ignoreCase) {\n        result |= $$($nesting, 'IGNORECASE');\n      }\n      return result;\n    \n    }, TMP_Regexp_options_14.$$arity = 0);\n    \n    Opal.def(self, '$casefold?', TMP_Regexp_casefold$q_15 = function() {\n      var self = this;\n\n      return self.ignoreCase;\n    }, TMP_Regexp_casefold$q_15.$$arity = 0);\n    return Opal.alias(self, \"to_s\", \"source\");\n  })($nesting[0], RegExp, $nesting);\n  return (function($base, $super, $parent_nesting) {\n    function $MatchData(){};\n    var self = $MatchData = $klass($base, $super, 'MatchData', $MatchData);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_MatchData_initialize_16, TMP_MatchData_$$_17, TMP_MatchData_offset_18, TMP_MatchData_$eq$eq_19, TMP_MatchData_begin_20, TMP_MatchData_end_21, TMP_MatchData_captures_22, TMP_MatchData_inspect_23, TMP_MatchData_length_24, TMP_MatchData_to_a_25, TMP_MatchData_to_s_26, TMP_MatchData_values_at_27;\n\n    def.matches = nil;\n    \n    self.$attr_reader(\"post_match\", \"pre_match\", \"regexp\", \"string\");\n    \n    Opal.def(self, '$initialize', TMP_MatchData_initialize_16 = function $$initialize(regexp, match_groups) {\n      var self = this;\n\n      \n      $gvars[\"~\"] = self;\n      self.regexp = regexp;\n      self.begin = match_groups.index;\n      self.string = match_groups.input;\n      self.pre_match = match_groups.input.slice(0, match_groups.index);\n      self.post_match = match_groups.input.slice(match_groups.index + match_groups[0].length);\n      self.matches = [];\n      \n      for (var i = 0, length = match_groups.length; i < length; i++) {\n        var group = match_groups[i];\n\n        if (group == null) {\n          self.matches.push(nil);\n        }\n        else {\n          self.matches.push(group);\n        }\n      }\n    ;\n    }, TMP_MatchData_initialize_16.$$arity = 2);\n    \n    Opal.def(self, '$[]', TMP_MatchData_$$_17 = function($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return $send(self.matches, '[]', Opal.to_a(args))\n    }, TMP_MatchData_$$_17.$$arity = -1);\n    \n    Opal.def(self, '$offset', TMP_MatchData_offset_18 = function $$offset(n) {\n      var self = this;\n\n      \n      if (n !== 0) {\n        self.$raise($$($nesting, 'ArgumentError'), \"MatchData#offset only supports 0th element\")\n      }\n      return [self.begin, self.begin + self.matches[n].length];\n    \n    }, TMP_MatchData_offset_18.$$arity = 1);\n    \n    Opal.def(self, '$==', TMP_MatchData_$eq$eq_19 = function(other) {\n      var $a, $b, $c, $d, self = this;\n\n      \n      if ($truthy($$($nesting, 'MatchData')['$==='](other))) {\n      } else {\n        return false\n      };\n      return ($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = self.string == other.string) ? self.regexp.toString() == other.regexp.toString() : $d)) ? self.pre_match == other.pre_match : $c)) ? self.post_match == other.post_match : $b)) ? self.begin == other.begin : $a);\n    }, TMP_MatchData_$eq$eq_19.$$arity = 1);\n    Opal.alias(self, \"eql?\", \"==\");\n    \n    Opal.def(self, '$begin', TMP_MatchData_begin_20 = function $$begin(n) {\n      var self = this;\n\n      \n      if (n !== 0) {\n        self.$raise($$($nesting, 'ArgumentError'), \"MatchData#begin only supports 0th element\")\n      }\n      return self.begin;\n    \n    }, TMP_MatchData_begin_20.$$arity = 1);\n    \n    Opal.def(self, '$end', TMP_MatchData_end_21 = function $$end(n) {\n      var self = this;\n\n      \n      if (n !== 0) {\n        self.$raise($$($nesting, 'ArgumentError'), \"MatchData#end only supports 0th element\")\n      }\n      return self.begin + self.matches[n].length;\n    \n    }, TMP_MatchData_end_21.$$arity = 1);\n    \n    Opal.def(self, '$captures', TMP_MatchData_captures_22 = function $$captures() {\n      var self = this;\n\n      return self.matches.slice(1)\n    }, TMP_MatchData_captures_22.$$arity = 0);\n    \n    Opal.def(self, '$inspect', TMP_MatchData_inspect_23 = function $$inspect() {\n      var self = this;\n\n      \n      var str = \"#<MatchData \" + (self.matches[0]).$inspect();\n\n      for (var i = 1, length = self.matches.length; i < length; i++) {\n        str += \" \" + i + \":\" + (self.matches[i]).$inspect();\n      }\n\n      return str + \">\";\n    \n    }, TMP_MatchData_inspect_23.$$arity = 0);\n    \n    Opal.def(self, '$length', TMP_MatchData_length_24 = function $$length() {\n      var self = this;\n\n      return self.matches.length\n    }, TMP_MatchData_length_24.$$arity = 0);\n    Opal.alias(self, \"size\", \"length\");\n    \n    Opal.def(self, '$to_a', TMP_MatchData_to_a_25 = function $$to_a() {\n      var self = this;\n\n      return self.matches\n    }, TMP_MatchData_to_a_25.$$arity = 0);\n    \n    Opal.def(self, '$to_s', TMP_MatchData_to_s_26 = function $$to_s() {\n      var self = this;\n\n      return self.matches[0]\n    }, TMP_MatchData_to_s_26.$$arity = 0);\n    return (Opal.def(self, '$values_at', TMP_MatchData_values_at_27 = function $$values_at($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      var i, a, index, values = [];\n\n      for (i = 0; i < args.length; i++) {\n\n        if (args[i].$$is_range) {\n          a = (args[i]).$to_a();\n          a.unshift(i, 1);\n          Array.prototype.splice.apply(args, a);\n        }\n\n        index = $$($nesting, 'Opal')['$coerce_to!'](args[i], $$($nesting, 'Integer'), \"to_int\");\n\n        if (index < 0) {\n          index += self.matches.length;\n          if (index < 0) {\n            values.push(nil);\n            continue;\n          }\n        }\n\n        values.push(self.matches[index]);\n      }\n\n      return values;\n    \n    }, TMP_MatchData_values_at_27.$$arity = -1), nil) && 'values_at';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/string\"] = function(Opal) {\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$require', '$include', '$coerce_to?', '$coerce_to', '$raise', '$===', '$format', '$to_s', '$respond_to?', '$to_str', '$<=>', '$==', '$=~', '$new', '$force_encoding', '$casecmp', '$empty?', '$ljust', '$ceil', '$/', '$+', '$rjust', '$floor', '$to_a', '$each_char', '$to_proc', '$coerce_to!', '$copy_singleton_methods', '$initialize_clone', '$initialize_dup', '$enum_for', '$size', '$chomp', '$[]', '$to_i', '$each_line', '$class', '$match', '$captures', '$proc', '$succ', '$escape']);\n  \n  self.$require(\"corelib/comparable\");\n  self.$require(\"corelib/regexp\");\n  (function($base, $super, $parent_nesting) {\n    function $String(){};\n    var self = $String = $klass($base, $super, 'String', $String);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String___id___1, TMP_String_try_convert_2, TMP_String_new_3, TMP_String_initialize_4, TMP_String_$_5, TMP_String_$_6, TMP_String_$_7, TMP_String_$lt$eq$gt_8, TMP_String_$eq$eq_9, TMP_String_$eq$_10, TMP_String_$$_11, TMP_String_b_12, TMP_String_capitalize_13, TMP_String_casecmp_14, TMP_String_casecmp$q_15, TMP_String_center_16, TMP_String_chars_17, TMP_String_chomp_18, TMP_String_chop_19, TMP_String_chr_20, TMP_String_clone_21, TMP_String_dup_22, TMP_String_count_23, TMP_String_delete_24, TMP_String_delete_prefix_25, TMP_String_delete_suffix_26, TMP_String_downcase_27, TMP_String_each_char_28, TMP_String_each_line_30, TMP_String_empty$q_31, TMP_String_end_with$q_32, TMP_String_gsub_33, TMP_String_hash_34, TMP_String_hex_35, TMP_String_include$q_36, TMP_String_index_37, TMP_String_inspect_38, TMP_String_intern_39, TMP_String_lines_40, TMP_String_length_41, TMP_String_ljust_42, TMP_String_lstrip_43, TMP_String_ascii_only$q_44, TMP_String_match_45, TMP_String_next_46, TMP_String_oct_47, TMP_String_ord_48, TMP_String_partition_49, TMP_String_reverse_50, TMP_String_rindex_51, TMP_String_rjust_52, TMP_String_rpartition_53, TMP_String_rstrip_54, TMP_String_scan_55, TMP_String_split_56, TMP_String_squeeze_57, TMP_String_start_with$q_58, TMP_String_strip_59, TMP_String_sub_60, TMP_String_sum_61, TMP_String_swapcase_62, TMP_String_to_f_63, TMP_String_to_i_64, TMP_String_to_proc_66, TMP_String_to_s_67, TMP_String_tr_68, TMP_String_tr_s_69, TMP_String_upcase_70, TMP_String_upto_71, TMP_String_instance_variables_72, TMP_String__load_73, TMP_String_unpack_74, TMP_String_unpack1_75;\n\n    def.length = nil;\n    \n    self.$include($$($nesting, 'Comparable'));\n    def.$$is_string = true;\n    \n    Opal.def(self, '$__id__', TMP_String___id___1 = function $$__id__() {\n      var self = this;\n\n      return self.toString();\n    }, TMP_String___id___1.$$arity = 0);\n    Opal.alias(self, \"object_id\", \"__id__\");\n    Opal.defs(self, '$try_convert', TMP_String_try_convert_2 = function $$try_convert(what) {\n      var self = this;\n\n      return $$($nesting, 'Opal')['$coerce_to?'](what, $$($nesting, 'String'), \"to_str\")\n    }, TMP_String_try_convert_2.$$arity = 1);\n    Opal.defs(self, '$new', TMP_String_new_3 = function(str) {\n      var self = this;\n\n      if (str == null) {\n        str = \"\";\n      }\n      \n      str = $$($nesting, 'Opal').$coerce_to(str, $$($nesting, 'String'), \"to_str\");\n      return new String(str);;\n    }, TMP_String_new_3.$$arity = -1);\n    \n    Opal.def(self, '$initialize', TMP_String_initialize_4 = function $$initialize(str) {\n      var self = this;\n\n      \n      \n      if (str === undefined) {\n        return self;\n      }\n    ;\n      return self.$raise($$($nesting, 'NotImplementedError'), \"Mutable strings are not supported in Opal.\");\n    }, TMP_String_initialize_4.$$arity = -1);\n    \n    Opal.def(self, '$%', TMP_String_$_5 = function(data) {\n      var self = this;\n\n      if ($truthy($$($nesting, 'Array')['$==='](data))) {\n        return $send(self, 'format', [self].concat(Opal.to_a(data)))\n      } else {\n        return self.$format(self, data)\n      }\n    }, TMP_String_$_5.$$arity = 1);\n    \n    Opal.def(self, '$*', TMP_String_$_6 = function(count) {\n      var self = this;\n\n      \n      count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), \"to_int\");\n\n      if (count < 0) {\n        self.$raise($$($nesting, 'ArgumentError'), \"negative argument\")\n      }\n\n      if (count === 0) {\n        return '';\n      }\n\n      var result = '',\n          string = self.toString();\n\n      // All credit for the bit-twiddling magic code below goes to Mozilla\n      // polyfill implementation of String.prototype.repeat() posted here:\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat\n\n      if (string.length * count >= 1 << 28) {\n        self.$raise($$($nesting, 'RangeError'), \"multiply count must not overflow maximum string size\")\n      }\n\n      for (;;) {\n        if ((count & 1) === 1) {\n          result += string;\n        }\n        count >>>= 1;\n        if (count === 0) {\n          break;\n        }\n        string += string;\n      }\n\n      return result;\n    \n    }, TMP_String_$_6.$$arity = 1);\n    \n    Opal.def(self, '$+', TMP_String_$_7 = function(other) {\n      var self = this;\n\n      \n      other = $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'String'), \"to_str\");\n      return self + other.$to_s();\n    }, TMP_String_$_7.$$arity = 1);\n    \n    Opal.def(self, '$<=>', TMP_String_$lt$eq$gt_8 = function(other) {\n      var self = this;\n\n      if ($truthy(other['$respond_to?'](\"to_str\"))) {\n        \n        other = other.$to_str().$to_s();\n        return self > other ? 1 : (self < other ? -1 : 0);;\n      } else {\n        \n        var cmp = other['$<=>'](self);\n\n        if (cmp === nil) {\n          return nil;\n        }\n        else {\n          return cmp > 0 ? -1 : (cmp < 0 ? 1 : 0);\n        }\n      \n      }\n    }, TMP_String_$lt$eq$gt_8.$$arity = 1);\n    \n    Opal.def(self, '$==', TMP_String_$eq$eq_9 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_string) {\n        return self.toString() === other.toString();\n      }\n      if ($$($nesting, 'Opal')['$respond_to?'](other, \"to_str\")) {\n        return other['$=='](self);\n      }\n      return false;\n    \n    }, TMP_String_$eq$eq_9.$$arity = 1);\n    Opal.alias(self, \"eql?\", \"==\");\n    Opal.alias(self, \"===\", \"==\");\n    \n    Opal.def(self, '$=~', TMP_String_$eq$_10 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_string) {\n        self.$raise($$($nesting, 'TypeError'), \"type mismatch: String given\");\n      }\n\n      return other['$=~'](self);\n    \n    }, TMP_String_$eq$_10.$$arity = 1);\n    \n    Opal.def(self, '$[]', TMP_String_$$_11 = function(index, length) {\n      var self = this;\n\n      \n      var size = self.length, exclude;\n\n      if (index.$$is_range) {\n        exclude = index.excl;\n        length  = $$($nesting, 'Opal').$coerce_to(index.end, $$($nesting, 'Integer'), \"to_int\");\n        index   = $$($nesting, 'Opal').$coerce_to(index.begin, $$($nesting, 'Integer'), \"to_int\");\n\n        if (Math.abs(index) > size) {\n          return nil;\n        }\n\n        if (index < 0) {\n          index += size;\n        }\n\n        if (length < 0) {\n          length += size;\n        }\n\n        if (!exclude) {\n          length += 1;\n        }\n\n        length = length - index;\n\n        if (length < 0) {\n          length = 0;\n        }\n\n        return self.substr(index, length);\n      }\n\n\n      if (index.$$is_string) {\n        if (length != null) {\n          self.$raise($$($nesting, 'TypeError'))\n        }\n        return self.indexOf(index) !== -1 ? index : nil;\n      }\n\n\n      if (index.$$is_regexp) {\n        var match = self.match(index);\n\n        if (match === null) {\n          ($gvars[\"~\"] = nil)\n          return nil;\n        }\n\n        ($gvars[\"~\"] = $$($nesting, 'MatchData').$new(index, match))\n\n        if (length == null) {\n          return match[0];\n        }\n\n        length = $$($nesting, 'Opal').$coerce_to(length, $$($nesting, 'Integer'), \"to_int\");\n\n        if (length < 0 && -length < match.length) {\n          return match[length += match.length];\n        }\n\n        if (length >= 0 && length < match.length) {\n          return match[length];\n        }\n\n        return nil;\n      }\n\n\n      index = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), \"to_int\");\n\n      if (index < 0) {\n        index += size;\n      }\n\n      if (length == null) {\n        if (index >= size || index < 0) {\n          return nil;\n        }\n        return self.substr(index, 1);\n      }\n\n      length = $$($nesting, 'Opal').$coerce_to(length, $$($nesting, 'Integer'), \"to_int\");\n\n      if (length < 0) {\n        return nil;\n      }\n\n      if (index > size || index < 0) {\n        return nil;\n      }\n\n      return self.substr(index, length);\n    \n    }, TMP_String_$$_11.$$arity = -2);\n    Opal.alias(self, \"byteslice\", \"[]\");\n    \n    Opal.def(self, '$b', TMP_String_b_12 = function $$b() {\n      var self = this;\n\n      return self.$force_encoding(\"binary\")\n    }, TMP_String_b_12.$$arity = 0);\n    \n    Opal.def(self, '$capitalize', TMP_String_capitalize_13 = function $$capitalize() {\n      var self = this;\n\n      return self.charAt(0).toUpperCase() + self.substr(1).toLowerCase();\n    }, TMP_String_capitalize_13.$$arity = 0);\n    \n    Opal.def(self, '$casecmp', TMP_String_casecmp_14 = function $$casecmp(other) {\n      var self = this;\n\n      \n      if ($truthy(other['$respond_to?'](\"to_str\"))) {\n      } else {\n        return nil\n      };\n      other = $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'String'), \"to_str\").$to_s();\n      \n      var ascii_only = /^[\\x00-\\x7F]*$/;\n      if (ascii_only.test(self) && ascii_only.test(other)) {\n        self = self.toLowerCase();\n        other = other.toLowerCase();\n      }\n    ;\n      return self['$<=>'](other);\n    }, TMP_String_casecmp_14.$$arity = 1);\n    \n    Opal.def(self, '$casecmp?', TMP_String_casecmp$q_15 = function(other) {\n      var self = this;\n\n      \n      var cmp = self.$casecmp(other);\n      if (cmp === nil) {\n        return nil;\n      } else {\n        return cmp === 0;\n      }\n    \n    }, TMP_String_casecmp$q_15.$$arity = 1);\n    \n    Opal.def(self, '$center', TMP_String_center_16 = function $$center(width, padstr) {\n      var self = this;\n\n      if (padstr == null) {\n        padstr = \" \";\n      }\n      \n      width = $$($nesting, 'Opal').$coerce_to(width, $$($nesting, 'Integer'), \"to_int\");\n      padstr = $$($nesting, 'Opal').$coerce_to(padstr, $$($nesting, 'String'), \"to_str\").$to_s();\n      if ($truthy(padstr['$empty?']())) {\n        self.$raise($$($nesting, 'ArgumentError'), \"zero width padding\")};\n      if ($truthy(width <= self.length)) {\n        return self};\n      \n      var ljustified = self.$ljust($rb_divide($rb_plus(width, self.length), 2).$ceil(), padstr),\n          rjustified = self.$rjust($rb_divide($rb_plus(width, self.length), 2).$floor(), padstr);\n\n      return rjustified + ljustified.slice(self.length);\n    ;\n    }, TMP_String_center_16.$$arity = -2);\n    \n    Opal.def(self, '$chars', TMP_String_chars_17 = function $$chars() {\n      var self = this, $iter = TMP_String_chars_17.$$p, block = $iter || nil;\n\n      if ($iter) TMP_String_chars_17.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        return self.$each_char().$to_a()\n      };\n      return $send(self, 'each_char', [], block.$to_proc());\n    }, TMP_String_chars_17.$$arity = 0);\n    \n    Opal.def(self, '$chomp', TMP_String_chomp_18 = function $$chomp(separator) {\n      var self = this;\n      if ($gvars[\"/\"] == null) $gvars[\"/\"] = nil;\n\n      if (separator == null) {\n        separator = $gvars[\"/\"];\n      }\n      \n      if ($truthy(separator === nil || self.length === 0)) {\n        return self};\n      separator = $$($nesting, 'Opal')['$coerce_to!'](separator, $$($nesting, 'String'), \"to_str\").$to_s();\n      \n      if (separator === \"\\n\") {\n        return self.replace(/\\r?\\n?$/, '');\n      }\n      else if (separator === \"\") {\n        return self.replace(/(\\r?\\n)+$/, '');\n      }\n      else if (self.length > separator.length) {\n        var tail = self.substr(self.length - separator.length, separator.length);\n\n        if (tail === separator) {\n          return self.substr(0, self.length - separator.length);\n        }\n      }\n    ;\n      return self;\n    }, TMP_String_chomp_18.$$arity = -1);\n    \n    Opal.def(self, '$chop', TMP_String_chop_19 = function $$chop() {\n      var self = this;\n\n      \n      var length = self.length;\n\n      if (length <= 1) {\n        return \"\";\n      }\n\n      if (self.charAt(length - 1) === \"\\n\" && self.charAt(length - 2) === \"\\r\") {\n        return self.substr(0, length - 2);\n      }\n      else {\n        return self.substr(0, length - 1);\n      }\n    \n    }, TMP_String_chop_19.$$arity = 0);\n    \n    Opal.def(self, '$chr', TMP_String_chr_20 = function $$chr() {\n      var self = this;\n\n      return self.charAt(0);\n    }, TMP_String_chr_20.$$arity = 0);\n    \n    Opal.def(self, '$clone', TMP_String_clone_21 = function $$clone() {\n      var self = this, copy = nil;\n\n      \n      copy = self.slice();\n      copy.$copy_singleton_methods(self);\n      copy.$initialize_clone(self);\n      return copy;\n    }, TMP_String_clone_21.$$arity = 0);\n    \n    Opal.def(self, '$dup', TMP_String_dup_22 = function $$dup() {\n      var self = this, copy = nil;\n\n      \n      copy = self.slice();\n      copy.$initialize_dup(self);\n      return copy;\n    }, TMP_String_dup_22.$$arity = 0);\n    \n    Opal.def(self, '$count', TMP_String_count_23 = function $$count($a_rest) {\n      var self = this, sets;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      sets = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        sets[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      if (sets.length === 0) {\n        self.$raise($$($nesting, 'ArgumentError'), \"ArgumentError: wrong number of arguments (0 for 1+)\")\n      }\n      var char_class = char_class_from_char_sets(sets);\n      if (char_class === null) {\n        return 0;\n      }\n      return self.length - self.replace(new RegExp(char_class, 'g'), '').length;\n    \n    }, TMP_String_count_23.$$arity = -1);\n    \n    Opal.def(self, '$delete', TMP_String_delete_24 = function($a_rest) {\n      var self = this, sets;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      sets = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        sets[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      if (sets.length === 0) {\n        self.$raise($$($nesting, 'ArgumentError'), \"ArgumentError: wrong number of arguments (0 for 1+)\")\n      }\n      var char_class = char_class_from_char_sets(sets);\n      if (char_class === null) {\n        return self;\n      }\n      return self.replace(new RegExp(char_class, 'g'), '');\n    \n    }, TMP_String_delete_24.$$arity = -1);\n    \n    Opal.def(self, '$delete_prefix', TMP_String_delete_prefix_25 = function $$delete_prefix(prefix) {\n      var self = this;\n\n      \n      if (!prefix.$$is_string) {\n        (prefix = $$($nesting, 'Opal').$coerce_to(prefix, $$($nesting, 'String'), \"to_str\"))\n      }\n\n      if (self.slice(0, prefix.length) === prefix) {\n        return self.slice(prefix.length);\n      } else {\n        return self;\n      }\n    \n    }, TMP_String_delete_prefix_25.$$arity = 1);\n    \n    Opal.def(self, '$delete_suffix', TMP_String_delete_suffix_26 = function $$delete_suffix(suffix) {\n      var self = this;\n\n      \n      if (!suffix.$$is_string) {\n        (suffix = $$($nesting, 'Opal').$coerce_to(suffix, $$($nesting, 'String'), \"to_str\"))\n      }\n\n      if (self.slice(self.length - suffix.length) === suffix) {\n        return self.slice(0, self.length - suffix.length);\n      } else {\n        return self;\n      }\n    \n    }, TMP_String_delete_suffix_26.$$arity = 1);\n    \n    Opal.def(self, '$downcase', TMP_String_downcase_27 = function $$downcase() {\n      var self = this;\n\n      return self.toLowerCase();\n    }, TMP_String_downcase_27.$$arity = 0);\n    \n    Opal.def(self, '$each_char', TMP_String_each_char_28 = function $$each_char() {\n      var TMP_29, self = this, $iter = TMP_String_each_char_28.$$p, block = $iter || nil;\n\n      if ($iter) TMP_String_each_char_28.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"each_char\"], (TMP_29 = function(){var self = TMP_29.$$s || this;\n\n        return self.$size()}, TMP_29.$$s = self, TMP_29.$$arity = 0, TMP_29))\n      };\n      \n      for (var i = 0, length = self.length; i < length; i++) {\n        Opal.yield1(block, self.charAt(i));\n      }\n    ;\n      return self;\n    }, TMP_String_each_char_28.$$arity = 0);\n    \n    Opal.def(self, '$each_line', TMP_String_each_line_30 = function $$each_line(separator) {\n      var self = this, $iter = TMP_String_each_line_30.$$p, block = $iter || nil;\n      if ($gvars[\"/\"] == null) $gvars[\"/\"] = nil;\n\n      if (separator == null) {\n        separator = $gvars[\"/\"];\n      }\n      if ($iter) TMP_String_each_line_30.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return self.$enum_for(\"each_line\", separator)\n      };\n      \n      if (separator === nil) {\n        Opal.yield1(block, self);\n\n        return self;\n      }\n\n      separator = $$($nesting, 'Opal').$coerce_to(separator, $$($nesting, 'String'), \"to_str\")\n\n      var a, i, n, length, chomped, trailing, splitted;\n\n      if (separator.length === 0) {\n        for (a = self.split(/(\\n{2,})/), i = 0, n = a.length; i < n; i += 2) {\n          if (a[i] || a[i + 1]) {\n            Opal.yield1(block, (a[i] || \"\") + (a[i + 1] || \"\"));\n          }\n        }\n\n        return self;\n      }\n\n      chomped  = self.$chomp(separator);\n      trailing = self.length != chomped.length;\n      splitted = chomped.split(separator);\n\n      for (i = 0, length = splitted.length; i < length; i++) {\n        if (i < length - 1 || trailing) {\n          Opal.yield1(block, splitted[i] + separator);\n        }\n        else {\n          Opal.yield1(block, splitted[i]);\n        }\n      }\n    ;\n      return self;\n    }, TMP_String_each_line_30.$$arity = -1);\n    \n    Opal.def(self, '$empty?', TMP_String_empty$q_31 = function() {\n      var self = this;\n\n      return self.length === 0;\n    }, TMP_String_empty$q_31.$$arity = 0);\n    \n    Opal.def(self, '$end_with?', TMP_String_end_with$q_32 = function($a_rest) {\n      var self = this, suffixes;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      suffixes = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        suffixes[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      \n      for (var i = 0, length = suffixes.length; i < length; i++) {\n        var suffix = $$($nesting, 'Opal').$coerce_to(suffixes[i], $$($nesting, 'String'), \"to_str\").$to_s();\n\n        if (self.length >= suffix.length &&\n            self.substr(self.length - suffix.length, suffix.length) == suffix) {\n          return true;\n        }\n      }\n    ;\n      return false;\n    }, TMP_String_end_with$q_32.$$arity = -1);\n    Opal.alias(self, \"equal?\", \"===\");\n    \n    Opal.def(self, '$gsub', TMP_String_gsub_33 = function $$gsub(pattern, replacement) {\n      var self = this, $iter = TMP_String_gsub_33.$$p, block = $iter || nil;\n\n      if ($iter) TMP_String_gsub_33.$$p = null;\n      \n      if (replacement === undefined && block === nil) {\n        return self.$enum_for(\"gsub\", pattern);\n      }\n\n      var result = '', match_data = nil, index = 0, match, _replacement;\n\n      if (pattern.$$is_regexp) {\n        pattern = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));\n      } else {\n        pattern = $$($nesting, 'Opal').$coerce_to(pattern, $$($nesting, 'String'), \"to_str\");\n        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'gm');\n      }\n\n      while (true) {\n        match = pattern.exec(self);\n\n        if (match === null) {\n          ($gvars[\"~\"] = nil)\n          result += self.slice(index);\n          break;\n        }\n\n        match_data = $$($nesting, 'MatchData').$new(pattern, match);\n\n        if (replacement === undefined) {\n          _replacement = block(match[0]);\n        }\n        else if (replacement.$$is_hash) {\n          _replacement = (replacement)['$[]'](match[0]).$to_s();\n        }\n        else {\n          if (!replacement.$$is_string) {\n            replacement = $$($nesting, 'Opal').$coerce_to(replacement, $$($nesting, 'String'), \"to_str\");\n          }\n          _replacement = replacement.replace(/([\\\\]+)([0-9+&`'])/g, function (original, slashes, command) {\n            if (slashes.length % 2 === 0) {\n              return original;\n            }\n            switch (command) {\n            case \"+\":\n              for (var i = match.length - 1; i > 0; i--) {\n                if (match[i] !== undefined) {\n                  return slashes.slice(1) + match[i];\n                }\n              }\n              return '';\n            case \"&\": return slashes.slice(1) + match[0];\n            case \"`\": return slashes.slice(1) + self.slice(0, match.index);\n            case \"'\": return slashes.slice(1) + self.slice(match.index + match[0].length);\n            default:  return slashes.slice(1) + (match[command] || '');\n            }\n          }).replace(/\\\\\\\\/g, '\\\\');\n        }\n\n        if (pattern.lastIndex === match.index) {\n          result += (_replacement + self.slice(index, match.index + 1))\n          pattern.lastIndex += 1;\n        }\n        else {\n          result += (self.slice(index, match.index) + _replacement)\n        }\n        index = pattern.lastIndex;\n      }\n\n      ($gvars[\"~\"] = match_data)\n      return result;\n    \n    }, TMP_String_gsub_33.$$arity = -2);\n    \n    Opal.def(self, '$hash', TMP_String_hash_34 = function $$hash() {\n      var self = this;\n\n      return self.toString();\n    }, TMP_String_hash_34.$$arity = 0);\n    \n    Opal.def(self, '$hex', TMP_String_hex_35 = function $$hex() {\n      var self = this;\n\n      return self.$to_i(16)\n    }, TMP_String_hex_35.$$arity = 0);\n    \n    Opal.def(self, '$include?', TMP_String_include$q_36 = function(other) {\n      var self = this;\n\n      \n      if (!other.$$is_string) {\n        (other = $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'String'), \"to_str\"))\n      }\n      return self.indexOf(other) !== -1;\n    \n    }, TMP_String_include$q_36.$$arity = 1);\n    \n    Opal.def(self, '$index', TMP_String_index_37 = function $$index(search, offset) {\n      var self = this;\n\n      \n      var index,\n          match,\n          regex;\n\n      if (offset === undefined) {\n        offset = 0;\n      } else {\n        offset = $$($nesting, 'Opal').$coerce_to(offset, $$($nesting, 'Integer'), \"to_int\");\n        if (offset < 0) {\n          offset += self.length;\n          if (offset < 0) {\n            return nil;\n          }\n        }\n      }\n\n      if (search.$$is_regexp) {\n        regex = new RegExp(search.source, 'gm' + (search.ignoreCase ? 'i' : ''));\n        while (true) {\n          match = regex.exec(self);\n          if (match === null) {\n            ($gvars[\"~\"] = nil);\n            index = -1;\n            break;\n          }\n          if (match.index >= offset) {\n            ($gvars[\"~\"] = $$($nesting, 'MatchData').$new(regex, match))\n            index = match.index;\n            break;\n          }\n          regex.lastIndex = match.index + 1;\n        }\n      } else {\n        search = $$($nesting, 'Opal').$coerce_to(search, $$($nesting, 'String'), \"to_str\");\n        if (search.length === 0 && offset > self.length) {\n          index = -1;\n        } else {\n          index = self.indexOf(search, offset);\n        }\n      }\n\n      return index === -1 ? nil : index;\n    \n    }, TMP_String_index_37.$$arity = -2);\n    \n    Opal.def(self, '$inspect', TMP_String_inspect_38 = function $$inspect() {\n      var self = this;\n\n      \n      var escapable = /[\\\\\\\"\\x00-\\x1f\\u007F-\\u009F\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n          meta = {\n            '\\u0007': '\\\\a',\n            '\\u001b': '\\\\e',\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\\v': '\\\\v',\n            '\"' : '\\\\\"',\n            '\\\\': '\\\\\\\\'\n          },\n          escaped = self.replace(escapable, function (chr) {\n            return meta[chr] || '\\\\u' + ('0000' + chr.charCodeAt(0).toString(16).toUpperCase()).slice(-4);\n          });\n      return '\"' + escaped.replace(/\\#[\\$\\@\\{]/g, '\\\\$&') + '\"';\n    \n    }, TMP_String_inspect_38.$$arity = 0);\n    \n    Opal.def(self, '$intern', TMP_String_intern_39 = function $$intern() {\n      var self = this;\n\n      return self\n    }, TMP_String_intern_39.$$arity = 0);\n    \n    Opal.def(self, '$lines', TMP_String_lines_40 = function $$lines(separator) {\n      var self = this, $iter = TMP_String_lines_40.$$p, block = $iter || nil, e = nil;\n      if ($gvars[\"/\"] == null) $gvars[\"/\"] = nil;\n\n      if (separator == null) {\n        separator = $gvars[\"/\"];\n      }\n      if ($iter) TMP_String_lines_40.$$p = null;\n      \n      e = $send(self, 'each_line', [separator], block.$to_proc());\n      if ($truthy(block)) {\n        return self\n      } else {\n        return e.$to_a()\n      };\n    }, TMP_String_lines_40.$$arity = -1);\n    \n    Opal.def(self, '$length', TMP_String_length_41 = function $$length() {\n      var self = this;\n\n      return self.length;\n    }, TMP_String_length_41.$$arity = 0);\n    \n    Opal.def(self, '$ljust', TMP_String_ljust_42 = function $$ljust(width, padstr) {\n      var self = this;\n\n      if (padstr == null) {\n        padstr = \" \";\n      }\n      \n      width = $$($nesting, 'Opal').$coerce_to(width, $$($nesting, 'Integer'), \"to_int\");\n      padstr = $$($nesting, 'Opal').$coerce_to(padstr, $$($nesting, 'String'), \"to_str\").$to_s();\n      if ($truthy(padstr['$empty?']())) {\n        self.$raise($$($nesting, 'ArgumentError'), \"zero width padding\")};\n      if ($truthy(width <= self.length)) {\n        return self};\n      \n      var index  = -1,\n          result = \"\";\n\n      width -= self.length;\n\n      while (++index < width) {\n        result += padstr;\n      }\n\n      return self + result.slice(0, width);\n    ;\n    }, TMP_String_ljust_42.$$arity = -2);\n    \n    Opal.def(self, '$lstrip', TMP_String_lstrip_43 = function $$lstrip() {\n      var self = this;\n\n      return self.replace(/^\\s*/, '');\n    }, TMP_String_lstrip_43.$$arity = 0);\n    \n    Opal.def(self, '$ascii_only?', TMP_String_ascii_only$q_44 = function() {\n      var self = this;\n\n      return self.match(/[ -~\\n]*/)[0] === self;\n    }, TMP_String_ascii_only$q_44.$$arity = 0);\n    \n    Opal.def(self, '$match', TMP_String_match_45 = function $$match(pattern, pos) {\n      var $a, self = this, $iter = TMP_String_match_45.$$p, block = $iter || nil;\n\n      if ($iter) TMP_String_match_45.$$p = null;\n      \n      if ($truthy(($truthy($a = $$($nesting, 'String')['$==='](pattern)) ? $a : pattern['$respond_to?'](\"to_str\")))) {\n        pattern = $$($nesting, 'Regexp').$new(pattern.$to_str())};\n      if ($truthy($$($nesting, 'Regexp')['$==='](pattern))) {\n      } else {\n        self.$raise($$($nesting, 'TypeError'), \"\" + \"wrong argument type \" + (pattern.$class()) + \" (expected Regexp)\")\n      };\n      return $send(pattern, 'match', [self, pos], block.$to_proc());\n    }, TMP_String_match_45.$$arity = -2);\n    \n    Opal.def(self, '$next', TMP_String_next_46 = function $$next() {\n      var self = this;\n\n      \n      var i = self.length;\n      if (i === 0) {\n        return '';\n      }\n      var result = self;\n      var first_alphanum_char_index = self.search(/[a-zA-Z0-9]/);\n      var carry = false;\n      var code;\n      while (i--) {\n        code = self.charCodeAt(i);\n        if ((code >= 48 && code <= 57) ||\n          (code >= 65 && code <= 90) ||\n          (code >= 97 && code <= 122)) {\n          switch (code) {\n          case 57:\n            carry = true;\n            code = 48;\n            break;\n          case 90:\n            carry = true;\n            code = 65;\n            break;\n          case 122:\n            carry = true;\n            code = 97;\n            break;\n          default:\n            carry = false;\n            code += 1;\n          }\n        } else {\n          if (first_alphanum_char_index === -1) {\n            if (code === 255) {\n              carry = true;\n              code = 0;\n            } else {\n              carry = false;\n              code += 1;\n            }\n          } else {\n            carry = true;\n          }\n        }\n        result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i + 1);\n        if (carry && (i === 0 || i === first_alphanum_char_index)) {\n          switch (code) {\n          case 65:\n            break;\n          case 97:\n            break;\n          default:\n            code += 1;\n          }\n          if (i === 0) {\n            result = String.fromCharCode(code) + result;\n          } else {\n            result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i);\n          }\n          carry = false;\n        }\n        if (!carry) {\n          break;\n        }\n      }\n      return result;\n    \n    }, TMP_String_next_46.$$arity = 0);\n    \n    Opal.def(self, '$oct', TMP_String_oct_47 = function $$oct() {\n      var self = this;\n\n      \n      var result,\n          string = self,\n          radix = 8;\n\n      if (/^\\s*_/.test(string)) {\n        return 0;\n      }\n\n      string = string.replace(/^(\\s*[+-]?)(0[bodx]?)(.+)$/i, function (original, head, flag, tail) {\n        switch (tail.charAt(0)) {\n        case '+':\n        case '-':\n          return original;\n        case '0':\n          if (tail.charAt(1) === 'x' && flag === '0x') {\n            return original;\n          }\n        }\n        switch (flag) {\n        case '0b':\n          radix = 2;\n          break;\n        case '0':\n        case '0o':\n          radix = 8;\n          break;\n        case '0d':\n          radix = 10;\n          break;\n        case '0x':\n          radix = 16;\n          break;\n        }\n        return head + tail;\n      });\n\n      result = parseInt(string.replace(/_(?!_)/g, ''), radix);\n      return isNaN(result) ? 0 : result;\n    \n    }, TMP_String_oct_47.$$arity = 0);\n    \n    Opal.def(self, '$ord', TMP_String_ord_48 = function $$ord() {\n      var self = this;\n\n      return self.charCodeAt(0);\n    }, TMP_String_ord_48.$$arity = 0);\n    \n    Opal.def(self, '$partition', TMP_String_partition_49 = function $$partition(sep) {\n      var self = this;\n\n      \n      var i, m;\n\n      if (sep.$$is_regexp) {\n        m = sep.exec(self);\n        if (m === null) {\n          i = -1;\n        } else {\n          $$($nesting, 'MatchData').$new(sep, m);\n          sep = m[0];\n          i = m.index;\n        }\n      } else {\n        sep = $$($nesting, 'Opal').$coerce_to(sep, $$($nesting, 'String'), \"to_str\");\n        i = self.indexOf(sep);\n      }\n\n      if (i === -1) {\n        return [self, '', ''];\n      }\n\n      return [\n        self.slice(0, i),\n        self.slice(i, i + sep.length),\n        self.slice(i + sep.length)\n      ];\n    \n    }, TMP_String_partition_49.$$arity = 1);\n    \n    Opal.def(self, '$reverse', TMP_String_reverse_50 = function $$reverse() {\n      var self = this;\n\n      return self.split('').reverse().join('');\n    }, TMP_String_reverse_50.$$arity = 0);\n    \n    Opal.def(self, '$rindex', TMP_String_rindex_51 = function $$rindex(search, offset) {\n      var self = this;\n\n      \n      var i, m, r, _m;\n\n      if (offset === undefined) {\n        offset = self.length;\n      } else {\n        offset = $$($nesting, 'Opal').$coerce_to(offset, $$($nesting, 'Integer'), \"to_int\");\n        if (offset < 0) {\n          offset += self.length;\n          if (offset < 0) {\n            return nil;\n          }\n        }\n      }\n\n      if (search.$$is_regexp) {\n        m = null;\n        r = new RegExp(search.source, 'gm' + (search.ignoreCase ? 'i' : ''));\n        while (true) {\n          _m = r.exec(self);\n          if (_m === null || _m.index > offset) {\n            break;\n          }\n          m = _m;\n          r.lastIndex = m.index + 1;\n        }\n        if (m === null) {\n          ($gvars[\"~\"] = nil)\n          i = -1;\n        } else {\n          $$($nesting, 'MatchData').$new(r, m);\n          i = m.index;\n        }\n      } else {\n        search = $$($nesting, 'Opal').$coerce_to(search, $$($nesting, 'String'), \"to_str\");\n        i = self.lastIndexOf(search, offset);\n      }\n\n      return i === -1 ? nil : i;\n    \n    }, TMP_String_rindex_51.$$arity = -2);\n    \n    Opal.def(self, '$rjust', TMP_String_rjust_52 = function $$rjust(width, padstr) {\n      var self = this;\n\n      if (padstr == null) {\n        padstr = \" \";\n      }\n      \n      width = $$($nesting, 'Opal').$coerce_to(width, $$($nesting, 'Integer'), \"to_int\");\n      padstr = $$($nesting, 'Opal').$coerce_to(padstr, $$($nesting, 'String'), \"to_str\").$to_s();\n      if ($truthy(padstr['$empty?']())) {\n        self.$raise($$($nesting, 'ArgumentError'), \"zero width padding\")};\n      if ($truthy(width <= self.length)) {\n        return self};\n      \n      var chars     = Math.floor(width - self.length),\n          patterns  = Math.floor(chars / padstr.length),\n          result    = Array(patterns + 1).join(padstr),\n          remaining = chars - result.length;\n\n      return result + padstr.slice(0, remaining) + self;\n    ;\n    }, TMP_String_rjust_52.$$arity = -2);\n    \n    Opal.def(self, '$rpartition', TMP_String_rpartition_53 = function $$rpartition(sep) {\n      var self = this;\n\n      \n      var i, m, r, _m;\n\n      if (sep.$$is_regexp) {\n        m = null;\n        r = new RegExp(sep.source, 'gm' + (sep.ignoreCase ? 'i' : ''));\n\n        while (true) {\n          _m = r.exec(self);\n          if (_m === null) {\n            break;\n          }\n          m = _m;\n          r.lastIndex = m.index + 1;\n        }\n\n        if (m === null) {\n          i = -1;\n        } else {\n          $$($nesting, 'MatchData').$new(r, m);\n          sep = m[0];\n          i = m.index;\n        }\n\n      } else {\n        sep = $$($nesting, 'Opal').$coerce_to(sep, $$($nesting, 'String'), \"to_str\");\n        i = self.lastIndexOf(sep);\n      }\n\n      if (i === -1) {\n        return ['', '', self];\n      }\n\n      return [\n        self.slice(0, i),\n        self.slice(i, i + sep.length),\n        self.slice(i + sep.length)\n      ];\n    \n    }, TMP_String_rpartition_53.$$arity = 1);\n    \n    Opal.def(self, '$rstrip', TMP_String_rstrip_54 = function $$rstrip() {\n      var self = this;\n\n      return self.replace(/[\\s\\u0000]*$/, '');\n    }, TMP_String_rstrip_54.$$arity = 0);\n    \n    Opal.def(self, '$scan', TMP_String_scan_55 = function $$scan(pattern) {\n      var self = this, $iter = TMP_String_scan_55.$$p, block = $iter || nil;\n\n      if ($iter) TMP_String_scan_55.$$p = null;\n      \n      var result = [],\n          match_data = nil,\n          match;\n\n      if (pattern.$$is_regexp) {\n        pattern = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));\n      } else {\n        pattern = $$($nesting, 'Opal').$coerce_to(pattern, $$($nesting, 'String'), \"to_str\");\n        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'gm');\n      }\n\n      while ((match = pattern.exec(self)) != null) {\n        match_data = $$($nesting, 'MatchData').$new(pattern, match);\n        if (block === nil) {\n          match.length == 1 ? result.push(match[0]) : result.push((match_data).$captures());\n        } else {\n          match.length == 1 ? block(match[0]) : block.call(self, (match_data).$captures());\n        }\n        if (pattern.lastIndex === match.index) {\n          pattern.lastIndex += 1;\n        }\n      }\n\n      ($gvars[\"~\"] = match_data)\n\n      return (block !== nil ? self : result);\n    \n    }, TMP_String_scan_55.$$arity = 1);\n    Opal.alias(self, \"size\", \"length\");\n    Opal.alias(self, \"slice\", \"[]\");\n    \n    Opal.def(self, '$split', TMP_String_split_56 = function $$split(pattern, limit) {\n      var $a, self = this;\n      if ($gvars[\";\"] == null) $gvars[\";\"] = nil;\n\n      \n      if (self.length === 0) {\n        return [];\n      }\n\n      if (limit === undefined) {\n        limit = 0;\n      } else {\n        limit = $$($nesting, 'Opal')['$coerce_to!'](limit, $$($nesting, 'Integer'), \"to_int\");\n        if (limit === 1) {\n          return [self];\n        }\n      }\n\n      if (pattern === undefined || pattern === nil) {\n        pattern = ($truthy($a = $gvars[\";\"]) ? $a : \" \");\n      }\n\n      var result = [],\n          string = self.toString(),\n          index = 0,\n          match,\n          i, ii;\n\n      if (pattern.$$is_regexp) {\n        pattern = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));\n      } else {\n        pattern = $$($nesting, 'Opal').$coerce_to(pattern, $$($nesting, 'String'), \"to_str\").$to_s();\n        if (pattern === ' ') {\n          pattern = /\\s+/gm;\n          string = string.replace(/^\\s+/, '');\n        } else {\n          pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'gm');\n        }\n      }\n\n      result = string.split(pattern);\n\n      if (result.length === 1 && result[0] === string) {\n        return result;\n      }\n\n      while ((i = result.indexOf(undefined)) !== -1) {\n        result.splice(i, 1);\n      }\n\n      if (limit === 0) {\n        while (result[result.length - 1] === '') {\n          result.length -= 1;\n        }\n        return result;\n      }\n\n      match = pattern.exec(string);\n\n      if (limit < 0) {\n        if (match !== null && match[0] === '' && pattern.source.indexOf('(?=') === -1) {\n          for (i = 0, ii = match.length; i < ii; i++) {\n            result.push('');\n          }\n        }\n        return result;\n      }\n\n      if (match !== null && match[0] === '') {\n        result.splice(limit - 1, result.length - 1, result.slice(limit - 1).join(''));\n        return result;\n      }\n\n      if (limit >= result.length) {\n        return result;\n      }\n\n      i = 0;\n      while (match !== null) {\n        i++;\n        index = pattern.lastIndex;\n        if (i + 1 === limit) {\n          break;\n        }\n        match = pattern.exec(string);\n      }\n      result.splice(limit - 1, result.length - 1, string.slice(index));\n      return result;\n    \n    }, TMP_String_split_56.$$arity = -1);\n    \n    Opal.def(self, '$squeeze', TMP_String_squeeze_57 = function $$squeeze($a_rest) {\n      var self = this, sets;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      sets = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        sets[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      if (sets.length === 0) {\n        return self.replace(/(.)\\1+/g, '$1');\n      }\n      var char_class = char_class_from_char_sets(sets);\n      if (char_class === null) {\n        return self;\n      }\n      return self.replace(new RegExp('(' + char_class + ')\\\\1+', 'g'), '$1');\n    \n    }, TMP_String_squeeze_57.$$arity = -1);\n    \n    Opal.def(self, '$start_with?', TMP_String_start_with$q_58 = function($a_rest) {\n      var self = this, prefixes;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      prefixes = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        prefixes[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      for (var i = 0, length = prefixes.length; i < length; i++) {\n        var prefix = $$($nesting, 'Opal').$coerce_to(prefixes[i], $$($nesting, 'String'), \"to_str\").$to_s();\n\n        if (self.indexOf(prefix) === 0) {\n          return true;\n        }\n      }\n\n      return false;\n    \n    }, TMP_String_start_with$q_58.$$arity = -1);\n    \n    Opal.def(self, '$strip', TMP_String_strip_59 = function $$strip() {\n      var self = this;\n\n      return self.replace(/^\\s*/, '').replace(/[\\s\\u0000]*$/, '');\n    }, TMP_String_strip_59.$$arity = 0);\n    \n    Opal.def(self, '$sub', TMP_String_sub_60 = function $$sub(pattern, replacement) {\n      var self = this, $iter = TMP_String_sub_60.$$p, block = $iter || nil;\n\n      if ($iter) TMP_String_sub_60.$$p = null;\n      \n      if (!pattern.$$is_regexp) {\n        pattern = $$($nesting, 'Opal').$coerce_to(pattern, $$($nesting, 'String'), \"to_str\");\n        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'));\n      }\n\n      var result = pattern.exec(self);\n\n      if (result === null) {\n        ($gvars[\"~\"] = nil)\n        return self.toString();\n      }\n\n      $$($nesting, 'MatchData').$new(pattern, result)\n\n      if (replacement === undefined) {\n        if (block === nil) {\n          self.$raise($$($nesting, 'ArgumentError'), \"wrong number of arguments (1 for 2)\")\n        }\n        return self.slice(0, result.index) + block(result[0]) + self.slice(result.index + result[0].length);\n      }\n\n      if (replacement.$$is_hash) {\n        return self.slice(0, result.index) + (replacement)['$[]'](result[0]).$to_s() + self.slice(result.index + result[0].length);\n      }\n\n      replacement = $$($nesting, 'Opal').$coerce_to(replacement, $$($nesting, 'String'), \"to_str\");\n\n      replacement = replacement.replace(/([\\\\]+)([0-9+&`'])/g, function (original, slashes, command) {\n        if (slashes.length % 2 === 0) {\n          return original;\n        }\n        switch (command) {\n        case \"+\":\n          for (var i = result.length - 1; i > 0; i--) {\n            if (result[i] !== undefined) {\n              return slashes.slice(1) + result[i];\n            }\n          }\n          return '';\n        case \"&\": return slashes.slice(1) + result[0];\n        case \"`\": return slashes.slice(1) + self.slice(0, result.index);\n        case \"'\": return slashes.slice(1) + self.slice(result.index + result[0].length);\n        default:  return slashes.slice(1) + (result[command] || '');\n        }\n      }).replace(/\\\\\\\\/g, '\\\\');\n\n      return self.slice(0, result.index) + replacement + self.slice(result.index + result[0].length);\n    \n    }, TMP_String_sub_60.$$arity = -2);\n    Opal.alias(self, \"succ\", \"next\");\n    \n    Opal.def(self, '$sum', TMP_String_sum_61 = function $$sum(n) {\n      var self = this;\n\n      if (n == null) {\n        n = 16;\n      }\n      \n      n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), \"to_int\");\n\n      var result = 0,\n          length = self.length,\n          i = 0;\n\n      for (; i < length; i++) {\n        result += self.charCodeAt(i);\n      }\n\n      if (n <= 0) {\n        return result;\n      }\n\n      return result & (Math.pow(2, n) - 1);\n    \n    }, TMP_String_sum_61.$$arity = -1);\n    \n    Opal.def(self, '$swapcase', TMP_String_swapcase_62 = function $$swapcase() {\n      var self = this;\n\n      \n      var str = self.replace(/([a-z]+)|([A-Z]+)/g, function($0,$1,$2) {\n        return $1 ? $0.toUpperCase() : $0.toLowerCase();\n      });\n\n      if (self.constructor === String) {\n        return str;\n      }\n\n      return self.$class().$new(str);\n    \n    }, TMP_String_swapcase_62.$$arity = 0);\n    \n    Opal.def(self, '$to_f', TMP_String_to_f_63 = function $$to_f() {\n      var self = this;\n\n      \n      if (self.charAt(0) === '_') {\n        return 0;\n      }\n\n      var result = parseFloat(self.replace(/_/g, ''));\n\n      if (isNaN(result) || result == Infinity || result == -Infinity) {\n        return 0;\n      }\n      else {\n        return result;\n      }\n    \n    }, TMP_String_to_f_63.$$arity = 0);\n    \n    Opal.def(self, '$to_i', TMP_String_to_i_64 = function $$to_i(base) {\n      var self = this;\n\n      if (base == null) {\n        base = 10;\n      }\n      \n      var result,\n          string = self.toLowerCase(),\n          radix = $$($nesting, 'Opal').$coerce_to(base, $$($nesting, 'Integer'), \"to_int\");\n\n      if (radix === 1 || radix < 0 || radix > 36) {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"invalid radix \" + (radix))\n      }\n\n      if (/^\\s*_/.test(string)) {\n        return 0;\n      }\n\n      string = string.replace(/^(\\s*[+-]?)(0[bodx]?)(.+)$/, function (original, head, flag, tail) {\n        switch (tail.charAt(0)) {\n        case '+':\n        case '-':\n          return original;\n        case '0':\n          if (tail.charAt(1) === 'x' && flag === '0x' && (radix === 0 || radix === 16)) {\n            return original;\n          }\n        }\n        switch (flag) {\n        case '0b':\n          if (radix === 0 || radix === 2) {\n            radix = 2;\n            return head + tail;\n          }\n          break;\n        case '0':\n        case '0o':\n          if (radix === 0 || radix === 8) {\n            radix = 8;\n            return head + tail;\n          }\n          break;\n        case '0d':\n          if (radix === 0 || radix === 10) {\n            radix = 10;\n            return head + tail;\n          }\n          break;\n        case '0x':\n          if (radix === 0 || radix === 16) {\n            radix = 16;\n            return head + tail;\n          }\n          break;\n        }\n        return original\n      });\n\n      result = parseInt(string.replace(/_(?!_)/g, ''), radix);\n      return isNaN(result) ? 0 : result;\n    \n    }, TMP_String_to_i_64.$$arity = -1);\n    \n    Opal.def(self, '$to_proc', TMP_String_to_proc_66 = function $$to_proc() {\n      var TMP_65, self = this, sym = nil;\n\n      \n      sym = self.valueOf();\n      return $send(self, 'proc', [], (TMP_65 = function($a_rest){var self = TMP_65.$$s || this, block, args;\n\n        block = TMP_65.$$p || nil;\n        if (block) TMP_65.$$p = null;\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n      \n        if (args.length === 0) {\n          self.$raise($$($nesting, 'ArgumentError'), \"no receiver given\")\n        }\n        var obj = args.shift();\n        if (obj == null) obj = nil;\n        return Opal.send(obj, sym, args, block);\n      }, TMP_65.$$s = self, TMP_65.$$arity = -1, TMP_65));\n    }, TMP_String_to_proc_66.$$arity = 0);\n    \n    Opal.def(self, '$to_s', TMP_String_to_s_67 = function $$to_s() {\n      var self = this;\n\n      return self.toString();\n    }, TMP_String_to_s_67.$$arity = 0);\n    Opal.alias(self, \"to_str\", \"to_s\");\n    Opal.alias(self, \"to_sym\", \"intern\");\n    \n    Opal.def(self, '$tr', TMP_String_tr_68 = function $$tr(from, to) {\n      var self = this;\n\n      \n      from = $$($nesting, 'Opal').$coerce_to(from, $$($nesting, 'String'), \"to_str\").$to_s();\n      to = $$($nesting, 'Opal').$coerce_to(to, $$($nesting, 'String'), \"to_str\").$to_s();\n      \n      if (from.length == 0 || from === to) {\n        return self;\n      }\n\n      var i, in_range, c, ch, start, end, length;\n      var subs = {};\n      var from_chars = from.split('');\n      var from_length = from_chars.length;\n      var to_chars = to.split('');\n      var to_length = to_chars.length;\n\n      var inverse = false;\n      var global_sub = null;\n      if (from_chars[0] === '^' && from_chars.length > 1) {\n        inverse = true;\n        from_chars.shift();\n        global_sub = to_chars[to_length - 1]\n        from_length -= 1;\n      }\n\n      var from_chars_expanded = [];\n      var last_from = null;\n      in_range = false;\n      for (i = 0; i < from_length; i++) {\n        ch = from_chars[i];\n        if (last_from == null) {\n          last_from = ch;\n          from_chars_expanded.push(ch);\n        }\n        else if (ch === '-') {\n          if (last_from === '-') {\n            from_chars_expanded.push('-');\n            from_chars_expanded.push('-');\n          }\n          else if (i == from_length - 1) {\n            from_chars_expanded.push('-');\n          }\n          else {\n            in_range = true;\n          }\n        }\n        else if (in_range) {\n          start = last_from.charCodeAt(0);\n          end = ch.charCodeAt(0);\n          if (start > end) {\n            self.$raise($$($nesting, 'ArgumentError'), \"\" + \"invalid range \\\"\" + (String.fromCharCode(start)) + \"-\" + (String.fromCharCode(end)) + \"\\\" in string transliteration\")\n          }\n          for (c = start + 1; c < end; c++) {\n            from_chars_expanded.push(String.fromCharCode(c));\n          }\n          from_chars_expanded.push(ch);\n          in_range = null;\n          last_from = null;\n        }\n        else {\n          from_chars_expanded.push(ch);\n        }\n      }\n\n      from_chars = from_chars_expanded;\n      from_length = from_chars.length;\n\n      if (inverse) {\n        for (i = 0; i < from_length; i++) {\n          subs[from_chars[i]] = true;\n        }\n      }\n      else {\n        if (to_length > 0) {\n          var to_chars_expanded = [];\n          var last_to = null;\n          in_range = false;\n          for (i = 0; i < to_length; i++) {\n            ch = to_chars[i];\n            if (last_to == null) {\n              last_to = ch;\n              to_chars_expanded.push(ch);\n            }\n            else if (ch === '-') {\n              if (last_to === '-') {\n                to_chars_expanded.push('-');\n                to_chars_expanded.push('-');\n              }\n              else if (i == to_length - 1) {\n                to_chars_expanded.push('-');\n              }\n              else {\n                in_range = true;\n              }\n            }\n            else if (in_range) {\n              start = last_to.charCodeAt(0);\n              end = ch.charCodeAt(0);\n              if (start > end) {\n                self.$raise($$($nesting, 'ArgumentError'), \"\" + \"invalid range \\\"\" + (String.fromCharCode(start)) + \"-\" + (String.fromCharCode(end)) + \"\\\" in string transliteration\")\n              }\n              for (c = start + 1; c < end; c++) {\n                to_chars_expanded.push(String.fromCharCode(c));\n              }\n              to_chars_expanded.push(ch);\n              in_range = null;\n              last_to = null;\n            }\n            else {\n              to_chars_expanded.push(ch);\n            }\n          }\n\n          to_chars = to_chars_expanded;\n          to_length = to_chars.length;\n        }\n\n        var length_diff = from_length - to_length;\n        if (length_diff > 0) {\n          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');\n          for (i = 0; i < length_diff; i++) {\n            to_chars.push(pad_char);\n          }\n        }\n\n        for (i = 0; i < from_length; i++) {\n          subs[from_chars[i]] = to_chars[i];\n        }\n      }\n\n      var new_str = ''\n      for (i = 0, length = self.length; i < length; i++) {\n        ch = self.charAt(i);\n        var sub = subs[ch];\n        if (inverse) {\n          new_str += (sub == null ? global_sub : ch);\n        }\n        else {\n          new_str += (sub != null ? sub : ch);\n        }\n      }\n      return new_str;\n    ;\n    }, TMP_String_tr_68.$$arity = 2);\n    \n    Opal.def(self, '$tr_s', TMP_String_tr_s_69 = function $$tr_s(from, to) {\n      var self = this;\n\n      \n      from = $$($nesting, 'Opal').$coerce_to(from, $$($nesting, 'String'), \"to_str\").$to_s();\n      to = $$($nesting, 'Opal').$coerce_to(to, $$($nesting, 'String'), \"to_str\").$to_s();\n      \n      if (from.length == 0) {\n        return self;\n      }\n\n      var i, in_range, c, ch, start, end, length;\n      var subs = {};\n      var from_chars = from.split('');\n      var from_length = from_chars.length;\n      var to_chars = to.split('');\n      var to_length = to_chars.length;\n\n      var inverse = false;\n      var global_sub = null;\n      if (from_chars[0] === '^' && from_chars.length > 1) {\n        inverse = true;\n        from_chars.shift();\n        global_sub = to_chars[to_length - 1]\n        from_length -= 1;\n      }\n\n      var from_chars_expanded = [];\n      var last_from = null;\n      in_range = false;\n      for (i = 0; i < from_length; i++) {\n        ch = from_chars[i];\n        if (last_from == null) {\n          last_from = ch;\n          from_chars_expanded.push(ch);\n        }\n        else if (ch === '-') {\n          if (last_from === '-') {\n            from_chars_expanded.push('-');\n            from_chars_expanded.push('-');\n          }\n          else if (i == from_length - 1) {\n            from_chars_expanded.push('-');\n          }\n          else {\n            in_range = true;\n          }\n        }\n        else if (in_range) {\n          start = last_from.charCodeAt(0);\n          end = ch.charCodeAt(0);\n          if (start > end) {\n            self.$raise($$($nesting, 'ArgumentError'), \"\" + \"invalid range \\\"\" + (String.fromCharCode(start)) + \"-\" + (String.fromCharCode(end)) + \"\\\" in string transliteration\")\n          }\n          for (c = start + 1; c < end; c++) {\n            from_chars_expanded.push(String.fromCharCode(c));\n          }\n          from_chars_expanded.push(ch);\n          in_range = null;\n          last_from = null;\n        }\n        else {\n          from_chars_expanded.push(ch);\n        }\n      }\n\n      from_chars = from_chars_expanded;\n      from_length = from_chars.length;\n\n      if (inverse) {\n        for (i = 0; i < from_length; i++) {\n          subs[from_chars[i]] = true;\n        }\n      }\n      else {\n        if (to_length > 0) {\n          var to_chars_expanded = [];\n          var last_to = null;\n          in_range = false;\n          for (i = 0; i < to_length; i++) {\n            ch = to_chars[i];\n            if (last_from == null) {\n              last_from = ch;\n              to_chars_expanded.push(ch);\n            }\n            else if (ch === '-') {\n              if (last_to === '-') {\n                to_chars_expanded.push('-');\n                to_chars_expanded.push('-');\n              }\n              else if (i == to_length - 1) {\n                to_chars_expanded.push('-');\n              }\n              else {\n                in_range = true;\n              }\n            }\n            else if (in_range) {\n              start = last_from.charCodeAt(0);\n              end = ch.charCodeAt(0);\n              if (start > end) {\n                self.$raise($$($nesting, 'ArgumentError'), \"\" + \"invalid range \\\"\" + (String.fromCharCode(start)) + \"-\" + (String.fromCharCode(end)) + \"\\\" in string transliteration\")\n              }\n              for (c = start + 1; c < end; c++) {\n                to_chars_expanded.push(String.fromCharCode(c));\n              }\n              to_chars_expanded.push(ch);\n              in_range = null;\n              last_from = null;\n            }\n            else {\n              to_chars_expanded.push(ch);\n            }\n          }\n\n          to_chars = to_chars_expanded;\n          to_length = to_chars.length;\n        }\n\n        var length_diff = from_length - to_length;\n        if (length_diff > 0) {\n          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');\n          for (i = 0; i < length_diff; i++) {\n            to_chars.push(pad_char);\n          }\n        }\n\n        for (i = 0; i < from_length; i++) {\n          subs[from_chars[i]] = to_chars[i];\n        }\n      }\n      var new_str = ''\n      var last_substitute = null\n      for (i = 0, length = self.length; i < length; i++) {\n        ch = self.charAt(i);\n        var sub = subs[ch]\n        if (inverse) {\n          if (sub == null) {\n            if (last_substitute == null) {\n              new_str += global_sub;\n              last_substitute = true;\n            }\n          }\n          else {\n            new_str += ch;\n            last_substitute = null;\n          }\n        }\n        else {\n          if (sub != null) {\n            if (last_substitute == null || last_substitute !== sub) {\n              new_str += sub;\n              last_substitute = sub;\n            }\n          }\n          else {\n            new_str += ch;\n            last_substitute = null;\n          }\n        }\n      }\n      return new_str;\n    ;\n    }, TMP_String_tr_s_69.$$arity = 2);\n    \n    Opal.def(self, '$upcase', TMP_String_upcase_70 = function $$upcase() {\n      var self = this;\n\n      return self.toUpperCase();\n    }, TMP_String_upcase_70.$$arity = 0);\n    \n    Opal.def(self, '$upto', TMP_String_upto_71 = function $$upto(stop, excl) {\n      var self = this, $iter = TMP_String_upto_71.$$p, block = $iter || nil;\n\n      if (excl == null) {\n        excl = false;\n      }\n      if ($iter) TMP_String_upto_71.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return self.$enum_for(\"upto\", stop, excl)\n      };\n      stop = $$($nesting, 'Opal').$coerce_to(stop, $$($nesting, 'String'), \"to_str\");\n      \n      var a, b, s = self.toString();\n\n      if (s.length === 1 && stop.length === 1) {\n\n        a = s.charCodeAt(0);\n        b = stop.charCodeAt(0);\n\n        while (a <= b) {\n          if (excl && a === b) {\n            break;\n          }\n\n          block(String.fromCharCode(a));\n\n          a += 1;\n        }\n\n      } else if (parseInt(s, 10).toString() === s && parseInt(stop, 10).toString() === stop) {\n\n        a = parseInt(s, 10);\n        b = parseInt(stop, 10);\n\n        while (a <= b) {\n          if (excl && a === b) {\n            break;\n          }\n\n          block(a.toString());\n\n          a += 1;\n        }\n\n      } else {\n\n        while (s.length <= stop.length && s <= stop) {\n          if (excl && s === stop) {\n            break;\n          }\n\n          block(s);\n\n          s = (s).$succ();\n        }\n\n      }\n      return self;\n    ;\n    }, TMP_String_upto_71.$$arity = -2);\n    \n    function char_class_from_char_sets(sets) {\n      function explode_sequences_in_character_set(set) {\n        var result = '',\n            i, len = set.length,\n            curr_char,\n            skip_next_dash,\n            char_code_from,\n            char_code_upto,\n            char_code;\n        for (i = 0; i < len; i++) {\n          curr_char = set.charAt(i);\n          if (curr_char === '-' && i > 0 && i < (len - 1) && !skip_next_dash) {\n            char_code_from = set.charCodeAt(i - 1);\n            char_code_upto = set.charCodeAt(i + 1);\n            if (char_code_from > char_code_upto) {\n              self.$raise($$($nesting, 'ArgumentError'), \"\" + \"invalid range \\\"\" + (char_code_from) + \"-\" + (char_code_upto) + \"\\\" in string transliteration\")\n            }\n            for (char_code = char_code_from + 1; char_code < char_code_upto + 1; char_code++) {\n              result += String.fromCharCode(char_code);\n            }\n            skip_next_dash = true;\n            i++;\n          } else {\n            skip_next_dash = (curr_char === '\\\\');\n            result += curr_char;\n          }\n        }\n        return result;\n      }\n\n      function intersection(setA, setB) {\n        if (setA.length === 0) {\n          return setB;\n        }\n        var result = '',\n            i, len = setA.length,\n            chr;\n        for (i = 0; i < len; i++) {\n          chr = setA.charAt(i);\n          if (setB.indexOf(chr) !== -1) {\n            result += chr;\n          }\n        }\n        return result;\n      }\n\n      var i, len, set, neg, chr, tmp,\n          pos_intersection = '',\n          neg_intersection = '';\n\n      for (i = 0, len = sets.length; i < len; i++) {\n        set = $$($nesting, 'Opal').$coerce_to(sets[i], $$($nesting, 'String'), \"to_str\");\n        neg = (set.charAt(0) === '^' && set.length > 1);\n        set = explode_sequences_in_character_set(neg ? set.slice(1) : set);\n        if (neg) {\n          neg_intersection = intersection(neg_intersection, set);\n        } else {\n          pos_intersection = intersection(pos_intersection, set);\n        }\n      }\n\n      if (pos_intersection.length > 0 && neg_intersection.length > 0) {\n        tmp = '';\n        for (i = 0, len = pos_intersection.length; i < len; i++) {\n          chr = pos_intersection.charAt(i);\n          if (neg_intersection.indexOf(chr) === -1) {\n            tmp += chr;\n          }\n        }\n        pos_intersection = tmp;\n        neg_intersection = '';\n      }\n\n      if (pos_intersection.length > 0) {\n        return '[' + $$($nesting, 'Regexp').$escape(pos_intersection) + ']';\n      }\n\n      if (neg_intersection.length > 0) {\n        return '[^' + $$($nesting, 'Regexp').$escape(neg_intersection) + ']';\n      }\n\n      return null;\n    }\n  ;\n    \n    Opal.def(self, '$instance_variables', TMP_String_instance_variables_72 = function $$instance_variables() {\n      var self = this;\n\n      return []\n    }, TMP_String_instance_variables_72.$$arity = 0);\n    Opal.defs(self, '$_load', TMP_String__load_73 = function $$_load($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return $send(self, 'new', Opal.to_a(args))\n    }, TMP_String__load_73.$$arity = -1);\n    \n    Opal.def(self, '$unpack', TMP_String_unpack_74 = function $$unpack(format) {\n      var self = this;\n\n      return self.$raise(\"To use String#unpack, you must first require 'corelib/string/unpack'.\")\n    }, TMP_String_unpack_74.$$arity = 1);\n    return (Opal.def(self, '$unpack1', TMP_String_unpack1_75 = function $$unpack1(format) {\n      var self = this;\n\n      return self.$raise(\"To use String#unpack1, you must first require 'corelib/string/unpack'.\")\n    }, TMP_String_unpack1_75.$$arity = 1), nil) && 'unpack1';\n  })($nesting[0], String, $nesting);\n  return Opal.const_set($nesting[0], 'Symbol', $$($nesting, 'String'));\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/enumerable\"] = function(Opal) {\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send, $falsy = Opal.falsy, $hash2 = Opal.hash2, $lambda = Opal.lambda;\n\n  Opal.add_stubs(['$each', '$public_send', '$destructure', '$to_enum', '$enumerator_size', '$new', '$yield', '$raise', '$slice_when', '$!', '$enum_for', '$flatten', '$map', '$warn', '$proc', '$==', '$nil?', '$respond_to?', '$coerce_to!', '$>', '$*', '$coerce_to', '$try_convert', '$<', '$+', '$-', '$ceil', '$/', '$size', '$__send__', '$length', '$<=', '$[]', '$push', '$<<', '$[]=', '$===', '$inspect', '$<=>', '$first', '$reverse', '$sort', '$to_proc', '$compare', '$call', '$dup', '$to_a', '$sort!', '$map!', '$key?', '$values', '$zip']);\n  return (function($base, $parent_nesting) {\n    var $Enumerable, self = $Enumerable = $module($base, 'Enumerable');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Enumerable_all$q_1, TMP_Enumerable_any$q_5, TMP_Enumerable_chunk_9, TMP_Enumerable_chunk_while_12, TMP_Enumerable_collect_14, TMP_Enumerable_collect_concat_16, TMP_Enumerable_count_19, TMP_Enumerable_cycle_23, TMP_Enumerable_detect_25, TMP_Enumerable_drop_27, TMP_Enumerable_drop_while_28, TMP_Enumerable_each_cons_29, TMP_Enumerable_each_entry_31, TMP_Enumerable_each_slice_33, TMP_Enumerable_each_with_index_35, TMP_Enumerable_each_with_object_37, TMP_Enumerable_entries_39, TMP_Enumerable_find_all_40, TMP_Enumerable_find_index_42, TMP_Enumerable_first_47, TMP_Enumerable_grep_48, TMP_Enumerable_grep_v_50, TMP_Enumerable_group_by_52, TMP_Enumerable_include$q_55, TMP_Enumerable_inject_56, TMP_Enumerable_lazy_58, TMP_Enumerable_enumerator_size_59, TMP_Enumerable_max_60, TMP_Enumerable_max_by_61, TMP_Enumerable_min_63, TMP_Enumerable_min_by_64, TMP_Enumerable_minmax_66, TMP_Enumerable_minmax_by_68, TMP_Enumerable_none$q_69, TMP_Enumerable_one$q_73, TMP_Enumerable_partition_77, TMP_Enumerable_reject_79, TMP_Enumerable_reverse_each_81, TMP_Enumerable_slice_before_83, TMP_Enumerable_slice_after_85, TMP_Enumerable_slice_when_88, TMP_Enumerable_sort_90, TMP_Enumerable_sort_by_92, TMP_Enumerable_sum_98, TMP_Enumerable_take_99, TMP_Enumerable_take_while_100, TMP_Enumerable_uniq_102, TMP_Enumerable_zip_104;\n\n    \n    \n    function comparableForPattern(value) {\n      if (value.length === 0) {\n        value = [nil];\n      }\n\n      if (value.length > 1) {\n        value = [value];\n      }\n\n      return value;\n    }\n  ;\n    \n    Opal.def(self, '$all?', TMP_Enumerable_all$q_1 = function(pattern) {try {\n\n      var TMP_2, TMP_3, TMP_4, self = this, $iter = TMP_Enumerable_all$q_1.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_all$q_1.$$p = null;\n      \n      if ($truthy(pattern !== undefined)) {\n        $send(self, 'each', [], (TMP_2 = function($a_rest){var self = TMP_2.$$s || this, value, comparable = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        \n          comparable = comparableForPattern(value);\n          if ($truthy($send(pattern, 'public_send', [\"===\"].concat(Opal.to_a(comparable))))) {\n            return nil\n          } else {\n            Opal.ret(false)\n          };}, TMP_2.$$s = self, TMP_2.$$arity = -1, TMP_2))\n      } else if ((block !== nil)) {\n        $send(self, 'each', [], (TMP_3 = function($a_rest){var self = TMP_3.$$s || this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {\n            return nil\n          } else {\n            Opal.ret(false)\n          }}, TMP_3.$$s = self, TMP_3.$$arity = -1, TMP_3))\n      } else {\n        $send(self, 'each', [], (TMP_4 = function($a_rest){var self = TMP_4.$$s || this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        if ($truthy($$($nesting, 'Opal').$destructure(value))) {\n            return nil\n          } else {\n            Opal.ret(false)\n          }}, TMP_4.$$s = self, TMP_4.$$arity = -1, TMP_4))\n      };\n      return true;\n      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n    }, TMP_Enumerable_all$q_1.$$arity = -1);\n    \n    Opal.def(self, '$any?', TMP_Enumerable_any$q_5 = function(pattern) {try {\n\n      var TMP_6, TMP_7, TMP_8, self = this, $iter = TMP_Enumerable_any$q_5.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_any$q_5.$$p = null;\n      \n      if ($truthy(pattern !== undefined)) {\n        $send(self, 'each', [], (TMP_6 = function($a_rest){var self = TMP_6.$$s || this, value, comparable = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        \n          comparable = comparableForPattern(value);\n          if ($truthy($send(pattern, 'public_send', [\"===\"].concat(Opal.to_a(comparable))))) {\n            Opal.ret(true)\n          } else {\n            return nil\n          };}, TMP_6.$$s = self, TMP_6.$$arity = -1, TMP_6))\n      } else if ((block !== nil)) {\n        $send(self, 'each', [], (TMP_7 = function($a_rest){var self = TMP_7.$$s || this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {\n            Opal.ret(true)\n          } else {\n            return nil\n          }}, TMP_7.$$s = self, TMP_7.$$arity = -1, TMP_7))\n      } else {\n        $send(self, 'each', [], (TMP_8 = function($a_rest){var self = TMP_8.$$s || this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        if ($truthy($$($nesting, 'Opal').$destructure(value))) {\n            Opal.ret(true)\n          } else {\n            return nil\n          }}, TMP_8.$$s = self, TMP_8.$$arity = -1, TMP_8))\n      };\n      return false;\n      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n    }, TMP_Enumerable_any$q_5.$$arity = -1);\n    \n    Opal.def(self, '$chunk', TMP_Enumerable_chunk_9 = function $$chunk() {\n      var TMP_10, TMP_11, self = this, $iter = TMP_Enumerable_chunk_9.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_chunk_9.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'to_enum', [\"chunk\"], (TMP_10 = function(){var self = TMP_10.$$s || this;\n\n        return self.$enumerator_size()}, TMP_10.$$s = self, TMP_10.$$arity = 0, TMP_10))\n      };\n      return $send($$$('::', 'Enumerator'), 'new', [], (TMP_11 = function(yielder){var self = TMP_11.$$s || this;\nif (yielder == null) yielder = nil;\n      \n        var previous = nil, accumulate = [];\n\n        function releaseAccumulate() {\n          if (accumulate.length > 0) {\n            yielder.$yield(previous, accumulate)\n          }\n        }\n\n        self.$each.$$p = function(value) {\n          var key = Opal.yield1(block, value);\n\n          if (key === nil) {\n            releaseAccumulate();\n            accumulate = [];\n            previous = nil;\n          } else {\n            if (previous === nil || previous === key) {\n              accumulate.push(value);\n            } else {\n              releaseAccumulate();\n              accumulate = [value];\n            }\n\n            previous = key;\n          }\n        }\n\n        self.$each();\n\n        releaseAccumulate();\n      }, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11));\n    }, TMP_Enumerable_chunk_9.$$arity = 0);\n    \n    Opal.def(self, '$chunk_while', TMP_Enumerable_chunk_while_12 = function $$chunk_while() {\n      var TMP_13, self = this, $iter = TMP_Enumerable_chunk_while_12.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_chunk_while_12.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        self.$raise($$($nesting, 'ArgumentError'), \"no block given\")\n      };\n      return $send(self, 'slice_when', [], (TMP_13 = function(before, after){var self = TMP_13.$$s || this;\nif (before == null) before = nil;if (after == null) after = nil;\n      return Opal.yieldX(block, [before, after])['$!']()}, TMP_13.$$s = self, TMP_13.$$arity = 2, TMP_13));\n    }, TMP_Enumerable_chunk_while_12.$$arity = 0);\n    \n    Opal.def(self, '$collect', TMP_Enumerable_collect_14 = function $$collect() {\n      var TMP_15, self = this, $iter = TMP_Enumerable_collect_14.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_collect_14.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"collect\"], (TMP_15 = function(){var self = TMP_15.$$s || this;\n\n        return self.$enumerator_size()}, TMP_15.$$s = self, TMP_15.$$arity = 0, TMP_15))\n      };\n      \n      var result = [];\n\n      self.$each.$$p = function() {\n        var value = Opal.yieldX(block, arguments);\n\n        result.push(value);\n      };\n\n      self.$each();\n\n      return result;\n    ;\n    }, TMP_Enumerable_collect_14.$$arity = 0);\n    \n    Opal.def(self, '$collect_concat', TMP_Enumerable_collect_concat_16 = function $$collect_concat() {\n      var TMP_17, TMP_18, self = this, $iter = TMP_Enumerable_collect_concat_16.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_collect_concat_16.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"collect_concat\"], (TMP_17 = function(){var self = TMP_17.$$s || this;\n\n        return self.$enumerator_size()}, TMP_17.$$s = self, TMP_17.$$arity = 0, TMP_17))\n      };\n      return $send(self, 'map', [], (TMP_18 = function(item){var self = TMP_18.$$s || this;\nif (item == null) item = nil;\n      return Opal.yield1(block, item);}, TMP_18.$$s = self, TMP_18.$$arity = 1, TMP_18)).$flatten(1);\n    }, TMP_Enumerable_collect_concat_16.$$arity = 0);\n    \n    Opal.def(self, '$count', TMP_Enumerable_count_19 = function $$count(object) {\n      var TMP_20, TMP_21, TMP_22, self = this, $iter = TMP_Enumerable_count_19.$$p, block = $iter || nil, result = nil;\n\n      if ($iter) TMP_Enumerable_count_19.$$p = null;\n      \n      result = 0;\n      \n      if (object != null && block !== nil) {\n        self.$warn(\"warning: given block not used\")\n      }\n    ;\n      if ($truthy(object != null)) {\n        block = $send(self, 'proc', [], (TMP_20 = function($a_rest){var self = TMP_20.$$s || this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        return $$($nesting, 'Opal').$destructure(args)['$=='](object)}, TMP_20.$$s = self, TMP_20.$$arity = -1, TMP_20))\n      } else if ($truthy(block['$nil?']())) {\n        block = $send(self, 'proc', [], (TMP_21 = function(){var self = TMP_21.$$s || this;\n\n        return true}, TMP_21.$$s = self, TMP_21.$$arity = 0, TMP_21))};\n      $send(self, 'each', [], (TMP_22 = function($a_rest){var self = TMP_22.$$s || this, args;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n      if ($truthy(Opal.yieldX(block, args))) {\n          return result++;\n        } else {\n          return nil\n        }}, TMP_22.$$s = self, TMP_22.$$arity = -1, TMP_22));\n      return result;\n    }, TMP_Enumerable_count_19.$$arity = -1);\n    \n    Opal.def(self, '$cycle', TMP_Enumerable_cycle_23 = function $$cycle(n) {\n      var TMP_24, self = this, $iter = TMP_Enumerable_cycle_23.$$p, block = $iter || nil;\n\n      if (n == null) {\n        n = nil;\n      }\n      if ($iter) TMP_Enumerable_cycle_23.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"cycle\", n], (TMP_24 = function(){var self = TMP_24.$$s || this;\n\n        if ($truthy(n['$nil?']())) {\n            if ($truthy(self['$respond_to?'](\"size\"))) {\n              return $$$($$($nesting, 'Float'), 'INFINITY')\n            } else {\n              return nil\n            }\n          } else {\n            \n            n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), \"to_int\");\n            if ($truthy($rb_gt(n, 0))) {\n              return $rb_times(self.$enumerator_size(), n)\n            } else {\n              return 0\n            };\n          }}, TMP_24.$$s = self, TMP_24.$$arity = 0, TMP_24))\n      };\n      if ($truthy(n['$nil?']())) {\n      } else {\n        \n        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), \"to_int\");\n        if ($truthy(n <= 0)) {\n          return nil};\n      };\n      \n      var result,\n          all = [], i, length, value;\n\n      self.$each.$$p = function() {\n        var param = $$($nesting, 'Opal').$destructure(arguments),\n            value = Opal.yield1(block, param);\n\n        all.push(param);\n      }\n\n      self.$each();\n\n      if (result !== undefined) {\n        return result;\n      }\n\n      if (all.length === 0) {\n        return nil;\n      }\n\n      if (n === nil) {\n        while (true) {\n          for (i = 0, length = all.length; i < length; i++) {\n            value = Opal.yield1(block, all[i]);\n          }\n        }\n      }\n      else {\n        while (n > 1) {\n          for (i = 0, length = all.length; i < length; i++) {\n            value = Opal.yield1(block, all[i]);\n          }\n\n          n--;\n        }\n      }\n    ;\n    }, TMP_Enumerable_cycle_23.$$arity = -1);\n    \n    Opal.def(self, '$detect', TMP_Enumerable_detect_25 = function $$detect(ifnone) {try {\n\n      var TMP_26, self = this, $iter = TMP_Enumerable_detect_25.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_detect_25.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return self.$enum_for(\"detect\", ifnone)\n      };\n      $send(self, 'each', [], (TMP_26 = function($a_rest){var self = TMP_26.$$s || this, args, value = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n      \n        value = $$($nesting, 'Opal').$destructure(args);\n        if ($truthy(Opal.yield1(block, value))) {\n          Opal.ret(value)\n        } else {\n          return nil\n        };}, TMP_26.$$s = self, TMP_26.$$arity = -1, TMP_26));\n      \n      if (ifnone !== undefined) {\n        if (typeof(ifnone) === 'function') {\n          return ifnone();\n        } else {\n          return ifnone;\n        }\n      }\n    ;\n      return nil;\n      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n    }, TMP_Enumerable_detect_25.$$arity = -1);\n    \n    Opal.def(self, '$drop', TMP_Enumerable_drop_27 = function $$drop(number) {\n      var self = this;\n\n      \n      number = $$($nesting, 'Opal').$coerce_to(number, $$($nesting, 'Integer'), \"to_int\");\n      if ($truthy(number < 0)) {\n        self.$raise($$($nesting, 'ArgumentError'), \"attempt to drop negative size\")};\n      \n      var result  = [],\n          current = 0;\n\n      self.$each.$$p = function() {\n        if (number <= current) {\n          result.push($$($nesting, 'Opal').$destructure(arguments));\n        }\n\n        current++;\n      };\n\n      self.$each()\n\n      return result;\n    ;\n    }, TMP_Enumerable_drop_27.$$arity = 1);\n    \n    Opal.def(self, '$drop_while', TMP_Enumerable_drop_while_28 = function $$drop_while() {\n      var self = this, $iter = TMP_Enumerable_drop_while_28.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_drop_while_28.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return self.$enum_for(\"drop_while\")\n      };\n      \n      var result   = [],\n          dropping = true;\n\n      self.$each.$$p = function() {\n        var param = $$($nesting, 'Opal').$destructure(arguments);\n\n        if (dropping) {\n          var value = Opal.yield1(block, param);\n\n          if ($falsy(value)) {\n            dropping = false;\n            result.push(param);\n          }\n        }\n        else {\n          result.push(param);\n        }\n      };\n\n      self.$each();\n\n      return result;\n    ;\n    }, TMP_Enumerable_drop_while_28.$$arity = 0);\n    \n    Opal.def(self, '$each_cons', TMP_Enumerable_each_cons_29 = function $$each_cons(n) {\n      var TMP_30, self = this, $iter = TMP_Enumerable_each_cons_29.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_each_cons_29.$$p = null;\n      \n      if ($truthy(arguments.length != 1)) {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (arguments.length) + \" for 1)\")};\n      n = $$($nesting, 'Opal').$try_convert(n, $$($nesting, 'Integer'), \"to_int\");\n      if ($truthy(n <= 0)) {\n        self.$raise($$($nesting, 'ArgumentError'), \"invalid size\")};\n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"each_cons\", n], (TMP_30 = function(){var self = TMP_30.$$s || this, $a, enum_size = nil;\n\n        \n          enum_size = self.$enumerator_size();\n          if ($truthy(enum_size['$nil?']())) {\n            return nil\n          } else if ($truthy(($truthy($a = enum_size['$=='](0)) ? $a : $rb_lt(enum_size, n)))) {\n            return 0\n          } else {\n            return $rb_plus($rb_minus(enum_size, n), 1)\n          };}, TMP_30.$$s = self, TMP_30.$$arity = 0, TMP_30))\n      };\n      \n      var buffer = [], result = nil;\n\n      self.$each.$$p = function() {\n        var element = $$($nesting, 'Opal').$destructure(arguments);\n        buffer.push(element);\n        if (buffer.length > n) {\n          buffer.shift();\n        }\n        if (buffer.length == n) {\n          Opal.yield1(block, buffer.slice(0, n));\n        }\n      }\n\n      self.$each();\n\n      return result;\n    ;\n    }, TMP_Enumerable_each_cons_29.$$arity = 1);\n    \n    Opal.def(self, '$each_entry', TMP_Enumerable_each_entry_31 = function $$each_entry($a_rest) {\n      var TMP_32, self = this, data, $iter = TMP_Enumerable_each_entry_31.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      data = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        data[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Enumerable_each_entry_31.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'to_enum', [\"each_entry\"].concat(Opal.to_a(data)), (TMP_32 = function(){var self = TMP_32.$$s || this;\n\n        return self.$enumerator_size()}, TMP_32.$$s = self, TMP_32.$$arity = 0, TMP_32))\n      };\n      \n      self.$each.$$p = function() {\n        var item = $$($nesting, 'Opal').$destructure(arguments);\n\n        Opal.yield1(block, item);\n      }\n\n      self.$each.apply(self, data);\n\n      return self;\n    ;\n    }, TMP_Enumerable_each_entry_31.$$arity = -1);\n    \n    Opal.def(self, '$each_slice', TMP_Enumerable_each_slice_33 = function $$each_slice(n) {\n      var TMP_34, self = this, $iter = TMP_Enumerable_each_slice_33.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_each_slice_33.$$p = null;\n      \n      n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), \"to_int\");\n      if ($truthy(n <= 0)) {\n        self.$raise($$($nesting, 'ArgumentError'), \"invalid slice size\")};\n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"each_slice\", n], (TMP_34 = function(){var self = TMP_34.$$s || this;\n\n        if ($truthy(self['$respond_to?'](\"size\"))) {\n            return $rb_divide(self.$size(), n).$ceil()\n          } else {\n            return nil\n          }}, TMP_34.$$s = self, TMP_34.$$arity = 0, TMP_34))\n      };\n      \n      var result,\n          slice = []\n\n      self.$each.$$p = function() {\n        var param = $$($nesting, 'Opal').$destructure(arguments);\n\n        slice.push(param);\n\n        if (slice.length === n) {\n          Opal.yield1(block, slice);\n          slice = [];\n        }\n      };\n\n      self.$each();\n\n      if (result !== undefined) {\n        return result;\n      }\n\n      // our \"last\" group, if smaller than n then won't have been yielded\n      if (slice.length > 0) {\n        Opal.yield1(block, slice);\n      }\n    ;\n      return nil;\n    }, TMP_Enumerable_each_slice_33.$$arity = 1);\n    \n    Opal.def(self, '$each_with_index', TMP_Enumerable_each_with_index_35 = function $$each_with_index($a_rest) {\n      var TMP_36, self = this, args, $iter = TMP_Enumerable_each_with_index_35.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Enumerable_each_with_index_35.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"each_with_index\"].concat(Opal.to_a(args)), (TMP_36 = function(){var self = TMP_36.$$s || this;\n\n        return self.$enumerator_size()}, TMP_36.$$s = self, TMP_36.$$arity = 0, TMP_36))\n      };\n      \n      var result,\n          index = 0;\n\n      self.$each.$$p = function() {\n        var param = $$($nesting, 'Opal').$destructure(arguments);\n\n        block(param, index);\n\n        index++;\n      };\n\n      self.$each.apply(self, args);\n\n      if (result !== undefined) {\n        return result;\n      }\n    ;\n      return self;\n    }, TMP_Enumerable_each_with_index_35.$$arity = -1);\n    \n    Opal.def(self, '$each_with_object', TMP_Enumerable_each_with_object_37 = function $$each_with_object(object) {\n      var TMP_38, self = this, $iter = TMP_Enumerable_each_with_object_37.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_each_with_object_37.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"each_with_object\", object], (TMP_38 = function(){var self = TMP_38.$$s || this;\n\n        return self.$enumerator_size()}, TMP_38.$$s = self, TMP_38.$$arity = 0, TMP_38))\n      };\n      \n      var result;\n\n      self.$each.$$p = function() {\n        var param = $$($nesting, 'Opal').$destructure(arguments);\n\n        block(param, object);\n      };\n\n      self.$each();\n\n      if (result !== undefined) {\n        return result;\n      }\n    ;\n      return object;\n    }, TMP_Enumerable_each_with_object_37.$$arity = 1);\n    \n    Opal.def(self, '$entries', TMP_Enumerable_entries_39 = function $$entries($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      var result = [];\n\n      self.$each.$$p = function() {\n        result.push($$($nesting, 'Opal').$destructure(arguments));\n      };\n\n      self.$each.apply(self, args);\n\n      return result;\n    \n    }, TMP_Enumerable_entries_39.$$arity = -1);\n    Opal.alias(self, \"find\", \"detect\");\n    \n    Opal.def(self, '$find_all', TMP_Enumerable_find_all_40 = function $$find_all() {\n      var TMP_41, self = this, $iter = TMP_Enumerable_find_all_40.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_find_all_40.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"find_all\"], (TMP_41 = function(){var self = TMP_41.$$s || this;\n\n        return self.$enumerator_size()}, TMP_41.$$s = self, TMP_41.$$arity = 0, TMP_41))\n      };\n      \n      var result = [];\n\n      self.$each.$$p = function() {\n        var param = $$($nesting, 'Opal').$destructure(arguments),\n            value = Opal.yield1(block, param);\n\n        if ($truthy(value)) {\n          result.push(param);\n        }\n      };\n\n      self.$each();\n\n      return result;\n    ;\n    }, TMP_Enumerable_find_all_40.$$arity = 0);\n    \n    Opal.def(self, '$find_index', TMP_Enumerable_find_index_42 = function $$find_index(object) {try {\n\n      var TMP_43, TMP_44, self = this, $iter = TMP_Enumerable_find_index_42.$$p, block = $iter || nil, index = nil;\n\n      if ($iter) TMP_Enumerable_find_index_42.$$p = null;\n      \n      if ($truthy(object === undefined && block === nil)) {\n        return self.$enum_for(\"find_index\")};\n      \n      if (object != null && block !== nil) {\n        self.$warn(\"warning: given block not used\")\n      }\n    ;\n      index = 0;\n      if ($truthy(object != null)) {\n        $send(self, 'each', [], (TMP_43 = function($a_rest){var self = TMP_43.$$s || this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        \n          if ($$($nesting, 'Opal').$destructure(value)['$=='](object)) {\n            Opal.ret(index)};\n          return index += 1;;}, TMP_43.$$s = self, TMP_43.$$arity = -1, TMP_43))\n      } else {\n        $send(self, 'each', [], (TMP_44 = function($a_rest){var self = TMP_44.$$s || this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        \n          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {\n            Opal.ret(index)};\n          return index += 1;;}, TMP_44.$$s = self, TMP_44.$$arity = -1, TMP_44))\n      };\n      return nil;\n      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n    }, TMP_Enumerable_find_index_42.$$arity = -1);\n    \n    Opal.def(self, '$first', TMP_Enumerable_first_47 = function $$first(number) {try {\n\n      var TMP_45, TMP_46, self = this, result = nil, current = nil;\n\n      if ($truthy(number === undefined)) {\n        return $send(self, 'each', [], (TMP_45 = function(value){var self = TMP_45.$$s || this;\nif (value == null) value = nil;\n        Opal.ret(value)}, TMP_45.$$s = self, TMP_45.$$arity = 1, TMP_45))\n      } else {\n        \n        result = [];\n        number = $$($nesting, 'Opal').$coerce_to(number, $$($nesting, 'Integer'), \"to_int\");\n        if ($truthy(number < 0)) {\n          self.$raise($$($nesting, 'ArgumentError'), \"attempt to take negative size\")};\n        if ($truthy(number == 0)) {\n          return []};\n        current = 0;\n        $send(self, 'each', [], (TMP_46 = function($a_rest){var self = TMP_46.$$s || this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        \n          result.push($$($nesting, 'Opal').$destructure(args));\n          if ($truthy(number <= ++current)) {\n            Opal.ret(result)\n          } else {\n            return nil\n          };}, TMP_46.$$s = self, TMP_46.$$arity = -1, TMP_46));\n        return result;\n      }\n      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n    }, TMP_Enumerable_first_47.$$arity = -1);\n    Opal.alias(self, \"flat_map\", \"collect_concat\");\n    \n    Opal.def(self, '$grep', TMP_Enumerable_grep_48 = function $$grep(pattern) {\n      var TMP_49, self = this, $iter = TMP_Enumerable_grep_48.$$p, block = $iter || nil, result = nil;\n\n      if ($iter) TMP_Enumerable_grep_48.$$p = null;\n      \n      result = [];\n      $send(self, 'each', [], (TMP_49 = function($a_rest){var self = TMP_49.$$s || this, value, cmp = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        value = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          value[$arg_idx - 0] = arguments[$arg_idx];\n        }\n      \n        cmp = comparableForPattern(value);\n        if ($truthy($send(pattern, '__send__', [\"===\"].concat(Opal.to_a(cmp))))) {\n        } else {\n          return nil;\n        };\n        if ((block !== nil)) {\n          \n          if ($truthy($rb_gt(value.$length(), 1))) {\n            value = [value]};\n          value = Opal.yieldX(block, Opal.to_a(value));\n        } else if ($truthy($rb_le(value.$length(), 1))) {\n          value = value['$[]'](0)};\n        return result.$push(value);}, TMP_49.$$s = self, TMP_49.$$arity = -1, TMP_49));\n      return result;\n    }, TMP_Enumerable_grep_48.$$arity = 1);\n    \n    Opal.def(self, '$grep_v', TMP_Enumerable_grep_v_50 = function $$grep_v(pattern) {\n      var TMP_51, self = this, $iter = TMP_Enumerable_grep_v_50.$$p, block = $iter || nil, result = nil;\n\n      if ($iter) TMP_Enumerable_grep_v_50.$$p = null;\n      \n      result = [];\n      $send(self, 'each', [], (TMP_51 = function($a_rest){var self = TMP_51.$$s || this, value, cmp = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        value = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          value[$arg_idx - 0] = arguments[$arg_idx];\n        }\n      \n        cmp = comparableForPattern(value);\n        if ($truthy($send(pattern, '__send__', [\"===\"].concat(Opal.to_a(cmp))))) {\n          return nil;};\n        if ((block !== nil)) {\n          \n          if ($truthy($rb_gt(value.$length(), 1))) {\n            value = [value]};\n          value = Opal.yieldX(block, Opal.to_a(value));\n        } else if ($truthy($rb_le(value.$length(), 1))) {\n          value = value['$[]'](0)};\n        return result.$push(value);}, TMP_51.$$s = self, TMP_51.$$arity = -1, TMP_51));\n      return result;\n    }, TMP_Enumerable_grep_v_50.$$arity = 1);\n    \n    Opal.def(self, '$group_by', TMP_Enumerable_group_by_52 = function $$group_by() {\n      var TMP_53, $a, self = this, $iter = TMP_Enumerable_group_by_52.$$p, block = $iter || nil, hash = nil, $writer = nil;\n\n      if ($iter) TMP_Enumerable_group_by_52.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"group_by\"], (TMP_53 = function(){var self = TMP_53.$$s || this;\n\n        return self.$enumerator_size()}, TMP_53.$$s = self, TMP_53.$$arity = 0, TMP_53))\n      };\n      hash = $hash2([], {});\n      \n      var result;\n\n      self.$each.$$p = function() {\n        var param = $$($nesting, 'Opal').$destructure(arguments),\n            value = Opal.yield1(block, param);\n\n        ($truthy($a = hash['$[]'](value)) ? $a : (($writer = [value, []]), $send(hash, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))['$<<'](param);\n      }\n\n      self.$each();\n\n      if (result !== undefined) {\n        return result;\n      }\n    ;\n      return hash;\n    }, TMP_Enumerable_group_by_52.$$arity = 0);\n    \n    Opal.def(self, '$include?', TMP_Enumerable_include$q_55 = function(obj) {try {\n\n      var TMP_54, self = this;\n\n      \n      $send(self, 'each', [], (TMP_54 = function($a_rest){var self = TMP_54.$$s || this, args;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n      if ($$($nesting, 'Opal').$destructure(args)['$=='](obj)) {\n          Opal.ret(true)\n        } else {\n          return nil\n        }}, TMP_54.$$s = self, TMP_54.$$arity = -1, TMP_54));\n      return false;\n      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n    }, TMP_Enumerable_include$q_55.$$arity = 1);\n    \n    Opal.def(self, '$inject', TMP_Enumerable_inject_56 = function $$inject(object, sym) {\n      var self = this, $iter = TMP_Enumerable_inject_56.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_inject_56.$$p = null;\n      \n      var result = object;\n\n      if (block !== nil && sym === undefined) {\n        self.$each.$$p = function() {\n          var value = $$($nesting, 'Opal').$destructure(arguments);\n\n          if (result === undefined) {\n            result = value;\n            return;\n          }\n\n          value = Opal.yieldX(block, [result, value]);\n\n          result = value;\n        };\n      }\n      else {\n        if (sym === undefined) {\n          if (!$$($nesting, 'Symbol')['$==='](object)) {\n            self.$raise($$($nesting, 'TypeError'), \"\" + (object.$inspect()) + \" is not a Symbol\");\n          }\n\n          sym    = object;\n          result = undefined;\n        }\n\n        self.$each.$$p = function() {\n          var value = $$($nesting, 'Opal').$destructure(arguments);\n\n          if (result === undefined) {\n            result = value;\n            return;\n          }\n\n          result = (result).$__send__(sym, value);\n        };\n      }\n\n      self.$each();\n\n      return result == undefined ? nil : result;\n    \n    }, TMP_Enumerable_inject_56.$$arity = -1);\n    \n    Opal.def(self, '$lazy', TMP_Enumerable_lazy_58 = function $$lazy() {\n      var TMP_57, self = this;\n\n      return $send($$$($$($nesting, 'Enumerator'), 'Lazy'), 'new', [self, self.$enumerator_size()], (TMP_57 = function(enum$, $a_rest){var self = TMP_57.$$s || this, args;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 1;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 1] = arguments[$arg_idx];\n        }if (enum$ == null) enum$ = nil;\n      return $send(enum$, 'yield', Opal.to_a(args))}, TMP_57.$$s = self, TMP_57.$$arity = -2, TMP_57))\n    }, TMP_Enumerable_lazy_58.$$arity = 0);\n    \n    Opal.def(self, '$enumerator_size', TMP_Enumerable_enumerator_size_59 = function $$enumerator_size() {\n      var self = this;\n\n      if ($truthy(self['$respond_to?'](\"size\"))) {\n        return self.$size()\n      } else {\n        return nil\n      }\n    }, TMP_Enumerable_enumerator_size_59.$$arity = 0);\n    Opal.alias(self, \"map\", \"collect\");\n    \n    Opal.def(self, '$max', TMP_Enumerable_max_60 = function $$max(n) {\n      var self = this, $iter = TMP_Enumerable_max_60.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_max_60.$$p = null;\n      \n      \n      if (n === undefined || n === nil) {\n        var result, value;\n\n        self.$each.$$p = function() {\n          var item = $$($nesting, 'Opal').$destructure(arguments);\n\n          if (result === undefined) {\n            result = item;\n            return;\n          }\n\n          if (block !== nil) {\n            value = Opal.yieldX(block, [item, result]);\n          } else {\n            value = (item)['$<=>'](result);\n          }\n\n          if (value === nil) {\n            self.$raise($$($nesting, 'ArgumentError'), \"comparison failed\");\n          }\n\n          if (value > 0) {\n            result = item;\n          }\n        }\n\n        self.$each();\n\n        if (result === undefined) {\n          return nil;\n        } else {\n          return result;\n        }\n      }\n    ;\n      n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), \"to_int\");\n      return $send(self, 'sort', [], block.$to_proc()).$reverse().$first(n);\n    }, TMP_Enumerable_max_60.$$arity = -1);\n    \n    Opal.def(self, '$max_by', TMP_Enumerable_max_by_61 = function $$max_by() {\n      var TMP_62, self = this, $iter = TMP_Enumerable_max_by_61.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_max_by_61.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        return $send(self, 'enum_for', [\"max_by\"], (TMP_62 = function(){var self = TMP_62.$$s || this;\n\n        return self.$enumerator_size()}, TMP_62.$$s = self, TMP_62.$$arity = 0, TMP_62))\n      };\n      \n      var result,\n          by;\n\n      self.$each.$$p = function() {\n        var param = $$($nesting, 'Opal').$destructure(arguments),\n            value = Opal.yield1(block, param);\n\n        if (result === undefined) {\n          result = param;\n          by     = value;\n          return;\n        }\n\n        if ((value)['$<=>'](by) > 0) {\n          result = param\n          by     = value;\n        }\n      };\n\n      self.$each();\n\n      return result === undefined ? nil : result;\n    ;\n    }, TMP_Enumerable_max_by_61.$$arity = 0);\n    Opal.alias(self, \"member?\", \"include?\");\n    \n    Opal.def(self, '$min', TMP_Enumerable_min_63 = function $$min() {\n      var self = this, $iter = TMP_Enumerable_min_63.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_min_63.$$p = null;\n      \n      var result;\n\n      if (block !== nil) {\n        self.$each.$$p = function() {\n          var param = $$($nesting, 'Opal').$destructure(arguments);\n\n          if (result === undefined) {\n            result = param;\n            return;\n          }\n\n          var value = block(param, result);\n\n          if (value === nil) {\n            self.$raise($$($nesting, 'ArgumentError'), \"comparison failed\");\n          }\n\n          if (value < 0) {\n            result = param;\n          }\n        };\n      }\n      else {\n        self.$each.$$p = function() {\n          var param = $$($nesting, 'Opal').$destructure(arguments);\n\n          if (result === undefined) {\n            result = param;\n            return;\n          }\n\n          if ($$($nesting, 'Opal').$compare(param, result) < 0) {\n            result = param;\n          }\n        };\n      }\n\n      self.$each();\n\n      return result === undefined ? nil : result;\n    \n    }, TMP_Enumerable_min_63.$$arity = 0);\n    \n    Opal.def(self, '$min_by', TMP_Enumerable_min_by_64 = function $$min_by() {\n      var TMP_65, self = this, $iter = TMP_Enumerable_min_by_64.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_min_by_64.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        return $send(self, 'enum_for', [\"min_by\"], (TMP_65 = function(){var self = TMP_65.$$s || this;\n\n        return self.$enumerator_size()}, TMP_65.$$s = self, TMP_65.$$arity = 0, TMP_65))\n      };\n      \n      var result,\n          by;\n\n      self.$each.$$p = function() {\n        var param = $$($nesting, 'Opal').$destructure(arguments),\n            value = Opal.yield1(block, param);\n\n        if (result === undefined) {\n          result = param;\n          by     = value;\n          return;\n        }\n\n        if ((value)['$<=>'](by) < 0) {\n          result = param\n          by     = value;\n        }\n      };\n\n      self.$each();\n\n      return result === undefined ? nil : result;\n    ;\n    }, TMP_Enumerable_min_by_64.$$arity = 0);\n    \n    Opal.def(self, '$minmax', TMP_Enumerable_minmax_66 = function $$minmax() {\n      var $a, TMP_67, self = this, $iter = TMP_Enumerable_minmax_66.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_minmax_66.$$p = null;\n      \n      block = ($truthy($a = block) ? $a : $send(self, 'proc', [], (TMP_67 = function(a, b){var self = TMP_67.$$s || this;\nif (a == null) a = nil;if (b == null) b = nil;\n      return a['$<=>'](b)}, TMP_67.$$s = self, TMP_67.$$arity = 2, TMP_67)));\n      \n      var min = nil, max = nil, first_time = true;\n\n      self.$each.$$p = function() {\n        var element = $$($nesting, 'Opal').$destructure(arguments);\n        if (first_time) {\n          min = max = element;\n          first_time = false;\n        } else {\n          var min_cmp = block.$call(min, element);\n\n          if (min_cmp === nil) {\n            self.$raise($$($nesting, 'ArgumentError'), \"comparison failed\")\n          } else if (min_cmp > 0) {\n            min = element;\n          }\n\n          var max_cmp = block.$call(max, element);\n\n          if (max_cmp === nil) {\n            self.$raise($$($nesting, 'ArgumentError'), \"comparison failed\")\n          } else if (max_cmp < 0) {\n            max = element;\n          }\n        }\n      }\n\n      self.$each();\n\n      return [min, max];\n    ;\n    }, TMP_Enumerable_minmax_66.$$arity = 0);\n    \n    Opal.def(self, '$minmax_by', TMP_Enumerable_minmax_by_68 = function $$minmax_by() {\n      var self = this, $iter = TMP_Enumerable_minmax_by_68.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_minmax_by_68.$$p = null;\n      return self.$raise($$($nesting, 'NotImplementedError'))\n    }, TMP_Enumerable_minmax_by_68.$$arity = 0);\n    \n    Opal.def(self, '$none?', TMP_Enumerable_none$q_69 = function(pattern) {try {\n\n      var TMP_70, TMP_71, TMP_72, self = this, $iter = TMP_Enumerable_none$q_69.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_none$q_69.$$p = null;\n      \n      if ($truthy(pattern !== undefined)) {\n        $send(self, 'each', [], (TMP_70 = function($a_rest){var self = TMP_70.$$s || this, value, comparable = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        \n          comparable = comparableForPattern(value);\n          if ($truthy($send(pattern, 'public_send', [\"===\"].concat(Opal.to_a(comparable))))) {\n            Opal.ret(false)\n          } else {\n            return nil\n          };}, TMP_70.$$s = self, TMP_70.$$arity = -1, TMP_70))\n      } else if ((block !== nil)) {\n        $send(self, 'each', [], (TMP_71 = function($a_rest){var self = TMP_71.$$s || this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {\n            Opal.ret(false)\n          } else {\n            return nil\n          }}, TMP_71.$$s = self, TMP_71.$$arity = -1, TMP_71))\n      } else {\n        $send(self, 'each', [], (TMP_72 = function($a_rest){var self = TMP_72.$$s || this, value, item = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        \n          item = $$($nesting, 'Opal').$destructure(value);\n          if ($truthy(item)) {\n            Opal.ret(false)\n          } else {\n            return nil\n          };}, TMP_72.$$s = self, TMP_72.$$arity = -1, TMP_72))\n      };\n      return true;\n      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n    }, TMP_Enumerable_none$q_69.$$arity = -1);\n    \n    Opal.def(self, '$one?', TMP_Enumerable_one$q_73 = function(pattern) {try {\n\n      var TMP_74, TMP_75, TMP_76, self = this, $iter = TMP_Enumerable_one$q_73.$$p, block = $iter || nil, count = nil;\n\n      if ($iter) TMP_Enumerable_one$q_73.$$p = null;\n      \n      count = 0;\n      if ($truthy(pattern !== undefined)) {\n        $send(self, 'each', [], (TMP_74 = function($a_rest){var self = TMP_74.$$s || this, value, comparable = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        \n          comparable = comparableForPattern(value);\n          if ($truthy($send(pattern, 'public_send', [\"===\"].concat(Opal.to_a(comparable))))) {\n            \n            count = $rb_plus(count, 1);\n            if ($truthy($rb_gt(count, 1))) {\n              Opal.ret(false)\n            } else {\n              return nil\n            };\n          } else {\n            return nil\n          };}, TMP_74.$$s = self, TMP_74.$$arity = -1, TMP_74))\n      } else if ((block !== nil)) {\n        $send(self, 'each', [], (TMP_75 = function($a_rest){var self = TMP_75.$$s || this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        \n          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {\n          } else {\n            return nil;\n          };\n          count = $rb_plus(count, 1);\n          if ($truthy($rb_gt(count, 1))) {\n            Opal.ret(false)\n          } else {\n            return nil\n          };}, TMP_75.$$s = self, TMP_75.$$arity = -1, TMP_75))\n      } else {\n        $send(self, 'each', [], (TMP_76 = function($a_rest){var self = TMP_76.$$s || this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n        \n          if ($truthy($$($nesting, 'Opal').$destructure(value))) {\n          } else {\n            return nil;\n          };\n          count = $rb_plus(count, 1);\n          if ($truthy($rb_gt(count, 1))) {\n            Opal.ret(false)\n          } else {\n            return nil\n          };}, TMP_76.$$s = self, TMP_76.$$arity = -1, TMP_76))\n      };\n      return count['$=='](1);\n      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n    }, TMP_Enumerable_one$q_73.$$arity = -1);\n    \n    Opal.def(self, '$partition', TMP_Enumerable_partition_77 = function $$partition() {\n      var TMP_78, self = this, $iter = TMP_Enumerable_partition_77.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_partition_77.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"partition\"], (TMP_78 = function(){var self = TMP_78.$$s || this;\n\n        return self.$enumerator_size()}, TMP_78.$$s = self, TMP_78.$$arity = 0, TMP_78))\n      };\n      \n      var truthy = [], falsy = [], result;\n\n      self.$each.$$p = function() {\n        var param = $$($nesting, 'Opal').$destructure(arguments),\n            value = Opal.yield1(block, param);\n\n        if ($truthy(value)) {\n          truthy.push(param);\n        }\n        else {\n          falsy.push(param);\n        }\n      };\n\n      self.$each();\n\n      return [truthy, falsy];\n    ;\n    }, TMP_Enumerable_partition_77.$$arity = 0);\n    Opal.alias(self, \"reduce\", \"inject\");\n    \n    Opal.def(self, '$reject', TMP_Enumerable_reject_79 = function $$reject() {\n      var TMP_80, self = this, $iter = TMP_Enumerable_reject_79.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_reject_79.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"reject\"], (TMP_80 = function(){var self = TMP_80.$$s || this;\n\n        return self.$enumerator_size()}, TMP_80.$$s = self, TMP_80.$$arity = 0, TMP_80))\n      };\n      \n      var result = [];\n\n      self.$each.$$p = function() {\n        var param = $$($nesting, 'Opal').$destructure(arguments),\n            value = Opal.yield1(block, param);\n\n        if ($falsy(value)) {\n          result.push(param);\n        }\n      };\n\n      self.$each();\n\n      return result;\n    ;\n    }, TMP_Enumerable_reject_79.$$arity = 0);\n    \n    Opal.def(self, '$reverse_each', TMP_Enumerable_reverse_each_81 = function $$reverse_each() {\n      var TMP_82, self = this, $iter = TMP_Enumerable_reverse_each_81.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_reverse_each_81.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"reverse_each\"], (TMP_82 = function(){var self = TMP_82.$$s || this;\n\n        return self.$enumerator_size()}, TMP_82.$$s = self, TMP_82.$$arity = 0, TMP_82))\n      };\n      \n      var result = [];\n\n      self.$each.$$p = function() {\n        result.push(arguments);\n      };\n\n      self.$each();\n\n      for (var i = result.length - 1; i >= 0; i--) {\n        Opal.yieldX(block, result[i]);\n      }\n\n      return result;\n    ;\n    }, TMP_Enumerable_reverse_each_81.$$arity = 0);\n    Opal.alias(self, \"select\", \"find_all\");\n    \n    Opal.def(self, '$slice_before', TMP_Enumerable_slice_before_83 = function $$slice_before(pattern) {\n      var TMP_84, self = this, $iter = TMP_Enumerable_slice_before_83.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_slice_before_83.$$p = null;\n      \n      if ($truthy(pattern === undefined && block === nil)) {\n        self.$raise($$($nesting, 'ArgumentError'), \"both pattern and block are given\")};\n      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (arguments.length) + \" expected 1)\")};\n      return $send($$($nesting, 'Enumerator'), 'new', [], (TMP_84 = function(e){var self = TMP_84.$$s || this;\nif (e == null) e = nil;\n      \n        var slice = [];\n\n        if (block !== nil) {\n          if (pattern === undefined) {\n            self.$each.$$p = function() {\n              var param = $$($nesting, 'Opal').$destructure(arguments),\n                  value = Opal.yield1(block, param);\n\n              if ($truthy(value) && slice.length > 0) {\n                e['$<<'](slice);\n                slice = [];\n              }\n\n              slice.push(param);\n            };\n          }\n          else {\n            self.$each.$$p = function() {\n              var param = $$($nesting, 'Opal').$destructure(arguments),\n                  value = block(param, pattern.$dup());\n\n              if ($truthy(value) && slice.length > 0) {\n                e['$<<'](slice);\n                slice = [];\n              }\n\n              slice.push(param);\n            };\n          }\n        }\n        else {\n          self.$each.$$p = function() {\n            var param = $$($nesting, 'Opal').$destructure(arguments),\n                value = pattern['$==='](param);\n\n            if ($truthy(value) && slice.length > 0) {\n              e['$<<'](slice);\n              slice = [];\n            }\n\n            slice.push(param);\n          };\n        }\n\n        self.$each();\n\n        if (slice.length > 0) {\n          e['$<<'](slice);\n        }\n      }, TMP_84.$$s = self, TMP_84.$$arity = 1, TMP_84));\n    }, TMP_Enumerable_slice_before_83.$$arity = -1);\n    \n    Opal.def(self, '$slice_after', TMP_Enumerable_slice_after_85 = function $$slice_after(pattern) {\n      var TMP_86, TMP_87, self = this, $iter = TMP_Enumerable_slice_after_85.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_slice_after_85.$$p = null;\n      \n      if ($truthy(pattern === undefined && block === nil)) {\n        self.$raise($$($nesting, 'ArgumentError'), \"both pattern and block are given\")};\n      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (arguments.length) + \" expected 1)\")};\n      if ($truthy(pattern !== undefined)) {\n        block = $send(self, 'proc', [], (TMP_86 = function(e){var self = TMP_86.$$s || this;\nif (e == null) e = nil;\n        return pattern['$==='](e)}, TMP_86.$$s = self, TMP_86.$$arity = 1, TMP_86))};\n      return $send($$($nesting, 'Enumerator'), 'new', [], (TMP_87 = function(yielder){var self = TMP_87.$$s || this;\nif (yielder == null) yielder = nil;\n      \n        var accumulate;\n\n        self.$each.$$p = function() {\n          var element = $$($nesting, 'Opal').$destructure(arguments),\n              end_chunk = Opal.yield1(block, element);\n\n          if (accumulate == null) {\n            accumulate = [];\n          }\n\n          if ($truthy(end_chunk)) {\n            accumulate.push(element);\n            yielder.$yield(accumulate);\n            accumulate = null;\n          } else {\n            accumulate.push(element)\n          }\n        }\n\n        self.$each();\n\n        if (accumulate != null) {\n          yielder.$yield(accumulate);\n        }\n      }, TMP_87.$$s = self, TMP_87.$$arity = 1, TMP_87));\n    }, TMP_Enumerable_slice_after_85.$$arity = -1);\n    \n    Opal.def(self, '$slice_when', TMP_Enumerable_slice_when_88 = function $$slice_when() {\n      var TMP_89, self = this, $iter = TMP_Enumerable_slice_when_88.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerable_slice_when_88.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        self.$raise($$($nesting, 'ArgumentError'), \"wrong number of arguments (0 for 1)\")\n      };\n      return $send($$($nesting, 'Enumerator'), 'new', [], (TMP_89 = function(yielder){var self = TMP_89.$$s || this;\nif (yielder == null) yielder = nil;\n      \n        var slice = nil, last_after = nil;\n\n        self.$each_cons.$$p = function() {\n          var params = $$($nesting, 'Opal').$destructure(arguments),\n              before = params[0],\n              after = params[1],\n              match = Opal.yieldX(block, [before, after]);\n\n          last_after = after;\n\n          if (slice === nil) {\n            slice = [];\n          }\n\n          if ($truthy(match)) {\n            slice.push(before);\n            yielder.$yield(slice);\n            slice = [];\n          } else {\n            slice.push(before);\n          }\n        }\n\n        self.$each_cons(2);\n\n        if (slice !== nil) {\n          slice.push(last_after);\n          yielder.$yield(slice);\n        }\n      }, TMP_89.$$s = self, TMP_89.$$arity = 1, TMP_89));\n    }, TMP_Enumerable_slice_when_88.$$arity = 0);\n    \n    Opal.def(self, '$sort', TMP_Enumerable_sort_90 = function $$sort() {\n      var TMP_91, self = this, $iter = TMP_Enumerable_sort_90.$$p, block = $iter || nil, ary = nil;\n\n      if ($iter) TMP_Enumerable_sort_90.$$p = null;\n      \n      ary = self.$to_a();\n      if ((block !== nil)) {\n      } else {\n        block = $lambda((TMP_91 = function(a, b){var self = TMP_91.$$s || this;\nif (a == null) a = nil;if (b == null) b = nil;\n        return a['$<=>'](b)}, TMP_91.$$s = self, TMP_91.$$arity = 2, TMP_91))\n      };\n      return $send(ary, 'sort', [], block.$to_proc());\n    }, TMP_Enumerable_sort_90.$$arity = 0);\n    \n    Opal.def(self, '$sort_by', TMP_Enumerable_sort_by_92 = function $$sort_by() {\n      var TMP_93, TMP_94, TMP_95, TMP_96, self = this, $iter = TMP_Enumerable_sort_by_92.$$p, block = $iter || nil, dup = nil;\n\n      if ($iter) TMP_Enumerable_sort_by_92.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"sort_by\"], (TMP_93 = function(){var self = TMP_93.$$s || this;\n\n        return self.$enumerator_size()}, TMP_93.$$s = self, TMP_93.$$arity = 0, TMP_93))\n      };\n      dup = $send(self, 'map', [], (TMP_94 = function(){var self = TMP_94.$$s || this, arg = nil;\n\n      \n        arg = $$($nesting, 'Opal').$destructure(arguments);\n        return [Opal.yield1(block, arg), arg];}, TMP_94.$$s = self, TMP_94.$$arity = 0, TMP_94));\n      $send(dup, 'sort!', [], (TMP_95 = function(a, b){var self = TMP_95.$$s || this;\nif (a == null) a = nil;if (b == null) b = nil;\n      return (a[0])['$<=>'](b[0])}, TMP_95.$$s = self, TMP_95.$$arity = 2, TMP_95));\n      return $send(dup, 'map!', [], (TMP_96 = function(i){var self = TMP_96.$$s || this;\nif (i == null) i = nil;\n      return i[1];}, TMP_96.$$s = self, TMP_96.$$arity = 1, TMP_96));\n    }, TMP_Enumerable_sort_by_92.$$arity = 0);\n    \n    Opal.def(self, '$sum', TMP_Enumerable_sum_98 = function $$sum(initial) {\n      var TMP_97, self = this, $iter = TMP_Enumerable_sum_98.$$p, $yield = $iter || nil, result = nil;\n\n      if (initial == null) {\n        initial = 0;\n      }\n      if ($iter) TMP_Enumerable_sum_98.$$p = null;\n      \n      result = initial;\n      $send(self, 'each', [], (TMP_97 = function($a_rest){var self = TMP_97.$$s || this, args, item = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n      \n        item = (function() {if (($yield !== nil)) {\n          return Opal.yieldX($yield, Opal.to_a(args));\n        } else {\n          return $$($nesting, 'Opal').$destructure(args)\n        }; return nil; })();\n        return (result = $rb_plus(result, item));}, TMP_97.$$s = self, TMP_97.$$arity = -1, TMP_97));\n      return result;\n    }, TMP_Enumerable_sum_98.$$arity = -1);\n    \n    Opal.def(self, '$take', TMP_Enumerable_take_99 = function $$take(num) {\n      var self = this;\n\n      return self.$first(num)\n    }, TMP_Enumerable_take_99.$$arity = 1);\n    \n    Opal.def(self, '$take_while', TMP_Enumerable_take_while_100 = function $$take_while() {try {\n\n      var TMP_101, self = this, $iter = TMP_Enumerable_take_while_100.$$p, block = $iter || nil, result = nil;\n\n      if ($iter) TMP_Enumerable_take_while_100.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        return self.$enum_for(\"take_while\")\n      };\n      result = [];\n      return $send(self, 'each', [], (TMP_101 = function($a_rest){var self = TMP_101.$$s || this, args, value = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n      \n        value = $$($nesting, 'Opal').$destructure(args);\n        if ($truthy(Opal.yield1(block, value))) {\n        } else {\n          Opal.ret(result)\n        };\n        return result.push(value);;}, TMP_101.$$s = self, TMP_101.$$arity = -1, TMP_101));\n      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n    }, TMP_Enumerable_take_while_100.$$arity = 0);\n    \n    Opal.def(self, '$uniq', TMP_Enumerable_uniq_102 = function $$uniq() {\n      var TMP_103, self = this, $iter = TMP_Enumerable_uniq_102.$$p, block = $iter || nil, hash = nil;\n\n      if ($iter) TMP_Enumerable_uniq_102.$$p = null;\n      \n      hash = $hash2([], {});\n      $send(self, 'each', [], (TMP_103 = function($a_rest){var self = TMP_103.$$s || this, args, value = nil, produced = nil, $writer = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n      \n        value = $$($nesting, 'Opal').$destructure(args);\n        produced = (function() {if ((block !== nil)) {\n          return Opal.yield1(block, value);\n        } else {\n          return value\n        }; return nil; })();\n        if ($truthy(hash['$key?'](produced))) {\n          return nil\n        } else {\n          \n          $writer = [produced, value];\n          $send(hash, '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];\n        };}, TMP_103.$$s = self, TMP_103.$$arity = -1, TMP_103));\n      return hash.$values();\n    }, TMP_Enumerable_uniq_102.$$arity = 0);\n    Opal.alias(self, \"to_a\", \"entries\");\n    \n    Opal.def(self, '$zip', TMP_Enumerable_zip_104 = function $$zip($a_rest) {\n      var self = this, others, $iter = TMP_Enumerable_zip_104.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      others = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        others[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Enumerable_zip_104.$$p = null;\n      return $send(self.$to_a(), 'zip', Opal.to_a(others))\n    }, TMP_Enumerable_zip_104.$$arity = -1);\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/enumerator\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $falsy = Opal.falsy;\n\n  Opal.add_stubs(['$require', '$include', '$allocate', '$new', '$to_proc', '$coerce_to', '$nil?', '$empty?', '$+', '$class', '$__send__', '$===', '$call', '$enum_for', '$size', '$destructure', '$inspect', '$any?', '$[]', '$raise', '$yield', '$each', '$enumerator_size', '$respond_to?', '$try_convert', '$<', '$for']);\n  \n  self.$require(\"corelib/enumerable\");\n  return (function($base, $super, $parent_nesting) {\n    function $Enumerator(){};\n    var self = $Enumerator = $klass($base, $super, 'Enumerator', $Enumerator);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Enumerator_for_1, TMP_Enumerator_initialize_2, TMP_Enumerator_each_3, TMP_Enumerator_size_4, TMP_Enumerator_with_index_5, TMP_Enumerator_inspect_7;\n\n    def.size = def.args = def.object = def.method = nil;\n    \n    self.$include($$($nesting, 'Enumerable'));\n    def.$$is_enumerator = true;\n    Opal.defs(self, '$for', TMP_Enumerator_for_1 = function(object, method, $a_rest) {\n      var self = this, args, $iter = TMP_Enumerator_for_1.$$p, block = $iter || nil;\n\n      if (method == null) {\n        method = \"each\";\n      }\n      var $args_len = arguments.length, $rest_len = $args_len - 2;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 2; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 2] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Enumerator_for_1.$$p = null;\n      \n      var obj = self.$allocate();\n\n      obj.object = object;\n      obj.size   = block;\n      obj.method = method;\n      obj.args   = args;\n\n      return obj;\n    \n    }, TMP_Enumerator_for_1.$$arity = -2);\n    \n    Opal.def(self, '$initialize', TMP_Enumerator_initialize_2 = function $$initialize($a_rest) {\n      var self = this, $iter = TMP_Enumerator_initialize_2.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Enumerator_initialize_2.$$p = null;\n      if ($truthy(block)) {\n        \n        self.object = $send($$($nesting, 'Generator'), 'new', [], block.$to_proc());\n        self.method = \"each\";\n        self.args = [];\n        self.size = arguments[0] || nil;\n        if ($truthy(self.size)) {\n          return (self.size = $$($nesting, 'Opal').$coerce_to(self.size, $$($nesting, 'Integer'), \"to_int\"))\n        } else {\n          return nil\n        };\n      } else {\n        \n        self.object = arguments[0];\n        self.method = arguments[1] || \"each\";\n        self.args = $slice.call(arguments, 2);\n        return (self.size = nil);\n      }\n    }, TMP_Enumerator_initialize_2.$$arity = -1);\n    \n    Opal.def(self, '$each', TMP_Enumerator_each_3 = function $$each($a_rest) {\n      var $b, self = this, args, $iter = TMP_Enumerator_each_3.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Enumerator_each_3.$$p = null;\n      \n      if ($truthy(($truthy($b = block['$nil?']()) ? args['$empty?']() : $b))) {\n        return self};\n      args = $rb_plus(self.args, args);\n      if ($truthy(block['$nil?']())) {\n        return $send(self.$class(), 'new', [self.object, self.method].concat(Opal.to_a(args)))};\n      return $send(self.object, '__send__', [self.method].concat(Opal.to_a(args)), block.$to_proc());\n    }, TMP_Enumerator_each_3.$$arity = -1);\n    \n    Opal.def(self, '$size', TMP_Enumerator_size_4 = function $$size() {\n      var self = this;\n\n      if ($truthy($$($nesting, 'Proc')['$==='](self.size))) {\n        return $send(self.size, 'call', Opal.to_a(self.args))\n      } else {\n        return self.size\n      }\n    }, TMP_Enumerator_size_4.$$arity = 0);\n    \n    Opal.def(self, '$with_index', TMP_Enumerator_with_index_5 = function $$with_index(offset) {\n      var TMP_6, self = this, $iter = TMP_Enumerator_with_index_5.$$p, block = $iter || nil;\n\n      if (offset == null) {\n        offset = 0;\n      }\n      if ($iter) TMP_Enumerator_with_index_5.$$p = null;\n      \n      offset = (function() {if ($truthy(offset)) {\n        return $$($nesting, 'Opal').$coerce_to(offset, $$($nesting, 'Integer'), \"to_int\")\n      } else {\n        return 0\n      }; return nil; })();\n      if ($truthy(block)) {\n      } else {\n        return $send(self, 'enum_for', [\"with_index\", offset], (TMP_6 = function(){var self = TMP_6.$$s || this;\n\n        return self.$size()}, TMP_6.$$s = self, TMP_6.$$arity = 0, TMP_6))\n      };\n      \n      var result, index = offset;\n\n      self.$each.$$p = function() {\n        var param = $$($nesting, 'Opal').$destructure(arguments),\n            value = block(param, index);\n\n        index++;\n\n        return value;\n      }\n\n      return self.$each();\n    ;\n    }, TMP_Enumerator_with_index_5.$$arity = -1);\n    Opal.alias(self, \"with_object\", \"each_with_object\");\n    \n    Opal.def(self, '$inspect', TMP_Enumerator_inspect_7 = function $$inspect() {\n      var self = this, result = nil;\n\n      \n      result = \"\" + \"#<\" + (self.$class()) + \": \" + (self.object.$inspect()) + \":\" + (self.method);\n      if ($truthy(self.args['$any?']())) {\n        result = $rb_plus(result, \"\" + \"(\" + (self.args.$inspect()['$[]']($$($nesting, 'Range').$new(1, -2))) + \")\")};\n      return $rb_plus(result, \">\");\n    }, TMP_Enumerator_inspect_7.$$arity = 0);\n    (function($base, $super, $parent_nesting) {\n      function $Generator(){};\n      var self = $Generator = $klass($base, $super, 'Generator', $Generator);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Generator_initialize_8, TMP_Generator_each_9;\n\n      def.block = nil;\n      \n      self.$include($$($nesting, 'Enumerable'));\n      \n      Opal.def(self, '$initialize', TMP_Generator_initialize_8 = function $$initialize() {\n        var self = this, $iter = TMP_Generator_initialize_8.$$p, block = $iter || nil;\n\n        if ($iter) TMP_Generator_initialize_8.$$p = null;\n        \n        if ($truthy(block)) {\n        } else {\n          self.$raise($$($nesting, 'LocalJumpError'), \"no block given\")\n        };\n        return (self.block = block);\n      }, TMP_Generator_initialize_8.$$arity = 0);\n      return (Opal.def(self, '$each', TMP_Generator_each_9 = function $$each($a_rest) {\n        var self = this, args, $iter = TMP_Generator_each_9.$$p, block = $iter || nil, yielder = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n        if ($iter) TMP_Generator_each_9.$$p = null;\n        \n        yielder = $send($$($nesting, 'Yielder'), 'new', [], block.$to_proc());\n        \n        try {\n          args.unshift(yielder);\n\n          Opal.yieldX(self.block, args);\n        }\n        catch (e) {\n          if (e === $breaker) {\n            return $breaker.$v;\n          }\n          else {\n            throw e;\n          }\n        }\n      ;\n        return self;\n      }, TMP_Generator_each_9.$$arity = -1), nil) && 'each';\n    })($nesting[0], null, $nesting);\n    (function($base, $super, $parent_nesting) {\n      function $Yielder(){};\n      var self = $Yielder = $klass($base, $super, 'Yielder', $Yielder);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Yielder_initialize_10, TMP_Yielder_yield_11, TMP_Yielder_$lt$lt_12;\n\n      def.block = nil;\n      \n      \n      Opal.def(self, '$initialize', TMP_Yielder_initialize_10 = function $$initialize() {\n        var self = this, $iter = TMP_Yielder_initialize_10.$$p, block = $iter || nil;\n\n        if ($iter) TMP_Yielder_initialize_10.$$p = null;\n        return (self.block = block)\n      }, TMP_Yielder_initialize_10.$$arity = 0);\n      \n      Opal.def(self, '$yield', TMP_Yielder_yield_11 = function($a_rest) {\n        var self = this, values;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        values = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          values[$arg_idx - 0] = arguments[$arg_idx];\n        }\n        \n        var value = Opal.yieldX(self.block, values);\n\n        if (value === $breaker) {\n          throw $breaker;\n        }\n\n        return value;\n      \n      }, TMP_Yielder_yield_11.$$arity = -1);\n      return (Opal.def(self, '$<<', TMP_Yielder_$lt$lt_12 = function($a_rest) {\n        var self = this, values;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        values = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          values[$arg_idx - 0] = arguments[$arg_idx];\n        }\n        \n        $send(self, 'yield', Opal.to_a(values));\n        return self;\n      }, TMP_Yielder_$lt$lt_12.$$arity = -1), nil) && '<<';\n    })($nesting[0], null, $nesting);\n    return (function($base, $super, $parent_nesting) {\n      function $Lazy(){};\n      var self = $Lazy = $klass($base, $super, 'Lazy', $Lazy);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Lazy_initialize_13, TMP_Lazy_lazy_16, TMP_Lazy_collect_17, TMP_Lazy_collect_concat_19, TMP_Lazy_drop_24, TMP_Lazy_drop_while_25, TMP_Lazy_enum_for_27, TMP_Lazy_find_all_28, TMP_Lazy_grep_30, TMP_Lazy_reject_33, TMP_Lazy_take_36, TMP_Lazy_take_while_37, TMP_Lazy_inspect_39;\n\n      def.enumerator = nil;\n      \n      (function($base, $super, $parent_nesting) {\n        function $StopLazyError(){};\n        var self = $StopLazyError = $klass($base, $super, 'StopLazyError', $StopLazyError);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return nil\n      })($nesting[0], $$($nesting, 'Exception'), $nesting);\n      \n      Opal.def(self, '$initialize', TMP_Lazy_initialize_13 = function $$initialize(object, size) {\n        var TMP_14, self = this, $iter = TMP_Lazy_initialize_13.$$p, block = $iter || nil;\n\n        if (size == null) {\n          size = nil;\n        }\n        if ($iter) TMP_Lazy_initialize_13.$$p = null;\n        \n        if ((block !== nil)) {\n        } else {\n          self.$raise($$($nesting, 'ArgumentError'), \"tried to call lazy new without a block\")\n        };\n        self.enumerator = object;\n        return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Lazy_initialize_13, false), [size], (TMP_14 = function(yielder, $a_rest){var self = TMP_14.$$s || this, each_args, TMP_15;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          each_args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            each_args[$arg_idx - 1] = arguments[$arg_idx];\n          }if (yielder == null) yielder = nil;\n        try {\n            return $send(object, 'each', Opal.to_a(each_args), (TMP_15 = function($a_rest){var self = TMP_15.$$s || this, args;\n\n              var $args_len = arguments.length, $rest_len = $args_len - 0;\n              if ($rest_len < 0) { $rest_len = 0; }\n              args = new Array($rest_len);\n              for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n                args[$arg_idx - 0] = arguments[$arg_idx];\n              }\n            \n            args.unshift(yielder);\n\n            Opal.yieldX(block, args);\n          }, TMP_15.$$s = self, TMP_15.$$arity = -1, TMP_15))\n          } catch ($err) {\n            if (Opal.rescue($err, [$$($nesting, 'Exception')])) {\n              try {\n                return nil\n              } finally { Opal.pop_exception() }\n            } else { throw $err; }\n          }}, TMP_14.$$s = self, TMP_14.$$arity = -2, TMP_14));\n      }, TMP_Lazy_initialize_13.$$arity = -2);\n      Opal.alias(self, \"force\", \"to_a\");\n      \n      Opal.def(self, '$lazy', TMP_Lazy_lazy_16 = function $$lazy() {\n        var self = this;\n\n        return self\n      }, TMP_Lazy_lazy_16.$$arity = 0);\n      \n      Opal.def(self, '$collect', TMP_Lazy_collect_17 = function $$collect() {\n        var TMP_18, self = this, $iter = TMP_Lazy_collect_17.$$p, block = $iter || nil;\n\n        if ($iter) TMP_Lazy_collect_17.$$p = null;\n        \n        if ($truthy(block)) {\n        } else {\n          self.$raise($$($nesting, 'ArgumentError'), \"tried to call lazy map without a block\")\n        };\n        return $send($$($nesting, 'Lazy'), 'new', [self, self.$enumerator_size()], (TMP_18 = function(enum$, $a_rest){var self = TMP_18.$$s || this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 1] = arguments[$arg_idx];\n          }if (enum$ == null) enum$ = nil;\n        \n          var value = Opal.yieldX(block, args);\n\n          enum$.$yield(value);\n        }, TMP_18.$$s = self, TMP_18.$$arity = -2, TMP_18));\n      }, TMP_Lazy_collect_17.$$arity = 0);\n      \n      Opal.def(self, '$collect_concat', TMP_Lazy_collect_concat_19 = function $$collect_concat() {\n        var TMP_20, self = this, $iter = TMP_Lazy_collect_concat_19.$$p, block = $iter || nil;\n\n        if ($iter) TMP_Lazy_collect_concat_19.$$p = null;\n        \n        if ($truthy(block)) {\n        } else {\n          self.$raise($$($nesting, 'ArgumentError'), \"tried to call lazy map without a block\")\n        };\n        return $send($$($nesting, 'Lazy'), 'new', [self, nil], (TMP_20 = function(enum$, $a_rest){var self = TMP_20.$$s || this, args, TMP_21, TMP_22;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 1] = arguments[$arg_idx];\n          }if (enum$ == null) enum$ = nil;\n        \n          var value = Opal.yieldX(block, args);\n\n          if ((value)['$respond_to?'](\"force\") && (value)['$respond_to?'](\"each\")) {\n            $send((value), 'each', [], (TMP_21 = function(v){var self = TMP_21.$$s || this;\nif (v == null) v = nil;\n          return enum$.$yield(v)}, TMP_21.$$s = self, TMP_21.$$arity = 1, TMP_21))\n          }\n          else {\n            var array = $$($nesting, 'Opal').$try_convert(value, $$($nesting, 'Array'), \"to_ary\");\n\n            if (array === nil) {\n              enum$.$yield(value);\n            }\n            else {\n              $send((value), 'each', [], (TMP_22 = function(v){var self = TMP_22.$$s || this;\nif (v == null) v = nil;\n          return enum$.$yield(v)}, TMP_22.$$s = self, TMP_22.$$arity = 1, TMP_22));\n            }\n          }\n        }, TMP_20.$$s = self, TMP_20.$$arity = -2, TMP_20));\n      }, TMP_Lazy_collect_concat_19.$$arity = 0);\n      \n      Opal.def(self, '$drop', TMP_Lazy_drop_24 = function $$drop(n) {\n        var TMP_23, self = this, current_size = nil, set_size = nil, dropped = nil;\n\n        \n        n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), \"to_int\");\n        if ($truthy($rb_lt(n, 0))) {\n          self.$raise($$($nesting, 'ArgumentError'), \"attempt to drop negative size\")};\n        current_size = self.$enumerator_size();\n        set_size = (function() {if ($truthy($$($nesting, 'Integer')['$==='](current_size))) {\n          if ($truthy($rb_lt(n, current_size))) {\n            return n\n          } else {\n            return current_size\n          }\n        } else {\n          return current_size\n        }; return nil; })();\n        dropped = 0;\n        return $send($$($nesting, 'Lazy'), 'new', [self, set_size], (TMP_23 = function(enum$, $a_rest){var self = TMP_23.$$s || this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 1] = arguments[$arg_idx];\n          }if (enum$ == null) enum$ = nil;\n        if ($truthy($rb_lt(dropped, n))) {\n            return (dropped = $rb_plus(dropped, 1))\n          } else {\n            return $send(enum$, 'yield', Opal.to_a(args))\n          }}, TMP_23.$$s = self, TMP_23.$$arity = -2, TMP_23));\n      }, TMP_Lazy_drop_24.$$arity = 1);\n      \n      Opal.def(self, '$drop_while', TMP_Lazy_drop_while_25 = function $$drop_while() {\n        var TMP_26, self = this, $iter = TMP_Lazy_drop_while_25.$$p, block = $iter || nil, succeeding = nil;\n\n        if ($iter) TMP_Lazy_drop_while_25.$$p = null;\n        \n        if ($truthy(block)) {\n        } else {\n          self.$raise($$($nesting, 'ArgumentError'), \"tried to call lazy drop_while without a block\")\n        };\n        succeeding = true;\n        return $send($$($nesting, 'Lazy'), 'new', [self, nil], (TMP_26 = function(enum$, $a_rest){var self = TMP_26.$$s || this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 1] = arguments[$arg_idx];\n          }if (enum$ == null) enum$ = nil;\n        if ($truthy(succeeding)) {\n            \n            var value = Opal.yieldX(block, args);\n\n            if ($falsy(value)) {\n              succeeding = false;\n\n              $send(enum$, 'yield', Opal.to_a(args));\n            }\n          \n          } else {\n            return $send(enum$, 'yield', Opal.to_a(args))\n          }}, TMP_26.$$s = self, TMP_26.$$arity = -2, TMP_26));\n      }, TMP_Lazy_drop_while_25.$$arity = 0);\n      \n      Opal.def(self, '$enum_for', TMP_Lazy_enum_for_27 = function $$enum_for(method, $a_rest) {\n        var self = this, args, $iter = TMP_Lazy_enum_for_27.$$p, block = $iter || nil;\n\n        if (method == null) {\n          method = \"each\";\n        }\n        var $args_len = arguments.length, $rest_len = $args_len - 1;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 1] = arguments[$arg_idx];\n        }\n        if ($iter) TMP_Lazy_enum_for_27.$$p = null;\n        return $send(self.$class(), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc())\n      }, TMP_Lazy_enum_for_27.$$arity = -1);\n      \n      Opal.def(self, '$find_all', TMP_Lazy_find_all_28 = function $$find_all() {\n        var TMP_29, self = this, $iter = TMP_Lazy_find_all_28.$$p, block = $iter || nil;\n\n        if ($iter) TMP_Lazy_find_all_28.$$p = null;\n        \n        if ($truthy(block)) {\n        } else {\n          self.$raise($$($nesting, 'ArgumentError'), \"tried to call lazy select without a block\")\n        };\n        return $send($$($nesting, 'Lazy'), 'new', [self, nil], (TMP_29 = function(enum$, $a_rest){var self = TMP_29.$$s || this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 1] = arguments[$arg_idx];\n          }if (enum$ == null) enum$ = nil;\n        \n          var value = Opal.yieldX(block, args);\n\n          if ($truthy(value)) {\n            $send(enum$, 'yield', Opal.to_a(args));\n          }\n        }, TMP_29.$$s = self, TMP_29.$$arity = -2, TMP_29));\n      }, TMP_Lazy_find_all_28.$$arity = 0);\n      Opal.alias(self, \"flat_map\", \"collect_concat\");\n      \n      Opal.def(self, '$grep', TMP_Lazy_grep_30 = function $$grep(pattern) {\n        var TMP_31, TMP_32, self = this, $iter = TMP_Lazy_grep_30.$$p, block = $iter || nil;\n\n        if ($iter) TMP_Lazy_grep_30.$$p = null;\n        if ($truthy(block)) {\n          return $send($$($nesting, 'Lazy'), 'new', [self, nil], (TMP_31 = function(enum$, $a_rest){var self = TMP_31.$$s || this, args;\n\n            var $args_len = arguments.length, $rest_len = $args_len - 1;\n            if ($rest_len < 0) { $rest_len = 0; }\n            args = new Array($rest_len);\n            for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n              args[$arg_idx - 1] = arguments[$arg_idx];\n            }if (enum$ == null) enum$ = nil;\n          \n            var param = $$($nesting, 'Opal').$destructure(args),\n                value = pattern['$==='](param);\n\n            if ($truthy(value)) {\n              value = Opal.yield1(block, param);\n\n              enum$.$yield(Opal.yield1(block, param));\n            }\n          }, TMP_31.$$s = self, TMP_31.$$arity = -2, TMP_31))\n        } else {\n          return $send($$($nesting, 'Lazy'), 'new', [self, nil], (TMP_32 = function(enum$, $a_rest){var self = TMP_32.$$s || this, args;\n\n            var $args_len = arguments.length, $rest_len = $args_len - 1;\n            if ($rest_len < 0) { $rest_len = 0; }\n            args = new Array($rest_len);\n            for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n              args[$arg_idx - 1] = arguments[$arg_idx];\n            }if (enum$ == null) enum$ = nil;\n          \n            var param = $$($nesting, 'Opal').$destructure(args),\n                value = pattern['$==='](param);\n\n            if ($truthy(value)) {\n              enum$.$yield(param);\n            }\n          }, TMP_32.$$s = self, TMP_32.$$arity = -2, TMP_32))\n        }\n      }, TMP_Lazy_grep_30.$$arity = 1);\n      Opal.alias(self, \"map\", \"collect\");\n      Opal.alias(self, \"select\", \"find_all\");\n      \n      Opal.def(self, '$reject', TMP_Lazy_reject_33 = function $$reject() {\n        var TMP_34, self = this, $iter = TMP_Lazy_reject_33.$$p, block = $iter || nil;\n\n        if ($iter) TMP_Lazy_reject_33.$$p = null;\n        \n        if ($truthy(block)) {\n        } else {\n          self.$raise($$($nesting, 'ArgumentError'), \"tried to call lazy reject without a block\")\n        };\n        return $send($$($nesting, 'Lazy'), 'new', [self, nil], (TMP_34 = function(enum$, $a_rest){var self = TMP_34.$$s || this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 1] = arguments[$arg_idx];\n          }if (enum$ == null) enum$ = nil;\n        \n          var value = Opal.yieldX(block, args);\n\n          if ($falsy(value)) {\n            $send(enum$, 'yield', Opal.to_a(args));\n          }\n        }, TMP_34.$$s = self, TMP_34.$$arity = -2, TMP_34));\n      }, TMP_Lazy_reject_33.$$arity = 0);\n      \n      Opal.def(self, '$take', TMP_Lazy_take_36 = function $$take(n) {\n        var TMP_35, self = this, current_size = nil, set_size = nil, taken = nil;\n\n        \n        n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), \"to_int\");\n        if ($truthy($rb_lt(n, 0))) {\n          self.$raise($$($nesting, 'ArgumentError'), \"attempt to take negative size\")};\n        current_size = self.$enumerator_size();\n        set_size = (function() {if ($truthy($$($nesting, 'Integer')['$==='](current_size))) {\n          if ($truthy($rb_lt(n, current_size))) {\n            return n\n          } else {\n            return current_size\n          }\n        } else {\n          return current_size\n        }; return nil; })();\n        taken = 0;\n        return $send($$($nesting, 'Lazy'), 'new', [self, set_size], (TMP_35 = function(enum$, $a_rest){var self = TMP_35.$$s || this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 1] = arguments[$arg_idx];\n          }if (enum$ == null) enum$ = nil;\n        if ($truthy($rb_lt(taken, n))) {\n            \n            $send(enum$, 'yield', Opal.to_a(args));\n            return (taken = $rb_plus(taken, 1));\n          } else {\n            return self.$raise($$($nesting, 'StopLazyError'))\n          }}, TMP_35.$$s = self, TMP_35.$$arity = -2, TMP_35));\n      }, TMP_Lazy_take_36.$$arity = 1);\n      \n      Opal.def(self, '$take_while', TMP_Lazy_take_while_37 = function $$take_while() {\n        var TMP_38, self = this, $iter = TMP_Lazy_take_while_37.$$p, block = $iter || nil;\n\n        if ($iter) TMP_Lazy_take_while_37.$$p = null;\n        \n        if ($truthy(block)) {\n        } else {\n          self.$raise($$($nesting, 'ArgumentError'), \"tried to call lazy take_while without a block\")\n        };\n        return $send($$($nesting, 'Lazy'), 'new', [self, nil], (TMP_38 = function(enum$, $a_rest){var self = TMP_38.$$s || this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 1;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 1] = arguments[$arg_idx];\n          }if (enum$ == null) enum$ = nil;\n        \n          var value = Opal.yieldX(block, args);\n\n          if ($truthy(value)) {\n            $send(enum$, 'yield', Opal.to_a(args));\n          }\n          else {\n            self.$raise($$($nesting, 'StopLazyError'));\n          }\n        }, TMP_38.$$s = self, TMP_38.$$arity = -2, TMP_38));\n      }, TMP_Lazy_take_while_37.$$arity = 0);\n      Opal.alias(self, \"to_enum\", \"enum_for\");\n      return (Opal.def(self, '$inspect', TMP_Lazy_inspect_39 = function $$inspect() {\n        var self = this;\n\n        return \"\" + \"#<\" + (self.$class()) + \": \" + (self.enumerator.$inspect()) + \">\"\n      }, TMP_Lazy_inspect_39.$$arity = 0), nil) && 'inspect';\n    })($nesting[0], self, $nesting);\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/numeric\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$include', '$instance_of?', '$class', '$Float', '$respond_to?', '$coerce', '$__send__', '$===', '$raise', '$equal?', '$-', '$*', '$div', '$<', '$-@', '$ceil', '$to_f', '$denominator', '$to_r', '$==', '$floor', '$/', '$%', '$Complex', '$zero?', '$numerator', '$abs', '$arg', '$coerce_to!', '$round', '$to_i', '$truncate', '$>']);\n  \n  self.$require(\"corelib/comparable\");\n  return (function($base, $super, $parent_nesting) {\n    function $Numeric(){};\n    var self = $Numeric = $klass($base, $super, 'Numeric', $Numeric);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Numeric_coerce_1, TMP_Numeric___coerced___2, TMP_Numeric_$lt$eq$gt_3, TMP_Numeric_$$_4, TMP_Numeric_$$_5, TMP_Numeric_$_6, TMP_Numeric_abs_7, TMP_Numeric_abs2_8, TMP_Numeric_angle_9, TMP_Numeric_ceil_10, TMP_Numeric_conj_11, TMP_Numeric_denominator_12, TMP_Numeric_div_13, TMP_Numeric_divmod_14, TMP_Numeric_fdiv_15, TMP_Numeric_floor_16, TMP_Numeric_i_17, TMP_Numeric_imag_18, TMP_Numeric_integer$q_19, TMP_Numeric_nonzero$q_20, TMP_Numeric_numerator_21, TMP_Numeric_polar_22, TMP_Numeric_quo_23, TMP_Numeric_real_24, TMP_Numeric_real$q_25, TMP_Numeric_rect_26, TMP_Numeric_round_27, TMP_Numeric_to_c_28, TMP_Numeric_to_int_29, TMP_Numeric_truncate_30, TMP_Numeric_zero$q_31, TMP_Numeric_positive$q_32, TMP_Numeric_negative$q_33, TMP_Numeric_dup_34, TMP_Numeric_clone_35, TMP_Numeric_finite$q_36, TMP_Numeric_infinite$q_37;\n\n    \n    self.$include($$($nesting, 'Comparable'));\n    \n    Opal.def(self, '$coerce', TMP_Numeric_coerce_1 = function $$coerce(other) {\n      var self = this;\n\n      \n      if ($truthy(other['$instance_of?'](self.$class()))) {\n        return [other, self]};\n      return [self.$Float(other), self.$Float(self)];\n    }, TMP_Numeric_coerce_1.$$arity = 1);\n    \n    Opal.def(self, '$__coerced__', TMP_Numeric___coerced___2 = function $$__coerced__(method, other) {\n      var $a, $b, self = this, a = nil, b = nil, $case = nil;\n\n      if ($truthy(other['$respond_to?'](\"coerce\"))) {\n        \n        $b = other.$coerce(self), $a = Opal.to_ary($b), (a = ($a[0] == null ? nil : $a[0])), (b = ($a[1] == null ? nil : $a[1])), $b;\n        return a.$__send__(method, b);\n      } else {\n        return (function() {$case = method;\n        if (\"+\"['$===']($case) || \"-\"['$===']($case) || \"*\"['$===']($case) || \"/\"['$===']($case) || \"%\"['$===']($case) || \"&\"['$===']($case) || \"|\"['$===']($case) || \"^\"['$===']($case) || \"**\"['$===']($case)) {return self.$raise($$($nesting, 'TypeError'), \"\" + (other.$class()) + \" can't be coerced into Numeric\")}\n        else if (\">\"['$===']($case) || \">=\"['$===']($case) || \"<\"['$===']($case) || \"<=\"['$===']($case) || \"<=>\"['$===']($case)) {return self.$raise($$($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (self.$class()) + \" with \" + (other.$class()) + \" failed\")}\n        else { return nil }})()\n      }\n    }, TMP_Numeric___coerced___2.$$arity = 2);\n    \n    Opal.def(self, '$<=>', TMP_Numeric_$lt$eq$gt_3 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(self['$equal?'](other))) {\n        return 0};\n      return nil;\n    }, TMP_Numeric_$lt$eq$gt_3.$$arity = 1);\n    \n    Opal.def(self, '$+@', TMP_Numeric_$$_4 = function() {\n      var self = this;\n\n      return self\n    }, TMP_Numeric_$$_4.$$arity = 0);\n    \n    Opal.def(self, '$-@', TMP_Numeric_$$_5 = function() {\n      var self = this;\n\n      return $rb_minus(0, self)\n    }, TMP_Numeric_$$_5.$$arity = 0);\n    \n    Opal.def(self, '$%', TMP_Numeric_$_6 = function(other) {\n      var self = this;\n\n      return $rb_minus(self, $rb_times(other, self.$div(other)))\n    }, TMP_Numeric_$_6.$$arity = 1);\n    \n    Opal.def(self, '$abs', TMP_Numeric_abs_7 = function $$abs() {\n      var self = this;\n\n      if ($rb_lt(self, 0)) {\n        return self['$-@']()\n      } else {\n        return self\n      }\n    }, TMP_Numeric_abs_7.$$arity = 0);\n    \n    Opal.def(self, '$abs2', TMP_Numeric_abs2_8 = function $$abs2() {\n      var self = this;\n\n      return $rb_times(self, self)\n    }, TMP_Numeric_abs2_8.$$arity = 0);\n    \n    Opal.def(self, '$angle', TMP_Numeric_angle_9 = function $$angle() {\n      var self = this;\n\n      if ($rb_lt(self, 0)) {\n        return $$$($$($nesting, 'Math'), 'PI')\n      } else {\n        return 0\n      }\n    }, TMP_Numeric_angle_9.$$arity = 0);\n    Opal.alias(self, \"arg\", \"angle\");\n    \n    Opal.def(self, '$ceil', TMP_Numeric_ceil_10 = function $$ceil(ndigits) {\n      var self = this;\n\n      if (ndigits == null) {\n        ndigits = 0;\n      }\n      return self.$to_f().$ceil(ndigits)\n    }, TMP_Numeric_ceil_10.$$arity = -1);\n    \n    Opal.def(self, '$conj', TMP_Numeric_conj_11 = function $$conj() {\n      var self = this;\n\n      return self\n    }, TMP_Numeric_conj_11.$$arity = 0);\n    Opal.alias(self, \"conjugate\", \"conj\");\n    \n    Opal.def(self, '$denominator', TMP_Numeric_denominator_12 = function $$denominator() {\n      var self = this;\n\n      return self.$to_r().$denominator()\n    }, TMP_Numeric_denominator_12.$$arity = 0);\n    \n    Opal.def(self, '$div', TMP_Numeric_div_13 = function $$div(other) {\n      var self = this;\n\n      \n      if (other['$=='](0)) {\n        self.$raise($$($nesting, 'ZeroDivisionError'), \"divided by o\")};\n      return $rb_divide(self, other).$floor();\n    }, TMP_Numeric_div_13.$$arity = 1);\n    \n    Opal.def(self, '$divmod', TMP_Numeric_divmod_14 = function $$divmod(other) {\n      var self = this;\n\n      return [self.$div(other), self['$%'](other)]\n    }, TMP_Numeric_divmod_14.$$arity = 1);\n    \n    Opal.def(self, '$fdiv', TMP_Numeric_fdiv_15 = function $$fdiv(other) {\n      var self = this;\n\n      return $rb_divide(self.$to_f(), other)\n    }, TMP_Numeric_fdiv_15.$$arity = 1);\n    \n    Opal.def(self, '$floor', TMP_Numeric_floor_16 = function $$floor(ndigits) {\n      var self = this;\n\n      if (ndigits == null) {\n        ndigits = 0;\n      }\n      return self.$to_f().$floor(ndigits)\n    }, TMP_Numeric_floor_16.$$arity = -1);\n    \n    Opal.def(self, '$i', TMP_Numeric_i_17 = function $$i() {\n      var self = this;\n\n      return self.$Complex(0, self)\n    }, TMP_Numeric_i_17.$$arity = 0);\n    \n    Opal.def(self, '$imag', TMP_Numeric_imag_18 = function $$imag() {\n      var self = this;\n\n      return 0\n    }, TMP_Numeric_imag_18.$$arity = 0);\n    Opal.alias(self, \"imaginary\", \"imag\");\n    \n    Opal.def(self, '$integer?', TMP_Numeric_integer$q_19 = function() {\n      var self = this;\n\n      return false\n    }, TMP_Numeric_integer$q_19.$$arity = 0);\n    Opal.alias(self, \"magnitude\", \"abs\");\n    Opal.alias(self, \"modulo\", \"%\");\n    \n    Opal.def(self, '$nonzero?', TMP_Numeric_nonzero$q_20 = function() {\n      var self = this;\n\n      if ($truthy(self['$zero?']())) {\n        return nil\n      } else {\n        return self\n      }\n    }, TMP_Numeric_nonzero$q_20.$$arity = 0);\n    \n    Opal.def(self, '$numerator', TMP_Numeric_numerator_21 = function $$numerator() {\n      var self = this;\n\n      return self.$to_r().$numerator()\n    }, TMP_Numeric_numerator_21.$$arity = 0);\n    Opal.alias(self, \"phase\", \"arg\");\n    \n    Opal.def(self, '$polar', TMP_Numeric_polar_22 = function $$polar() {\n      var self = this;\n\n      return [self.$abs(), self.$arg()]\n    }, TMP_Numeric_polar_22.$$arity = 0);\n    \n    Opal.def(self, '$quo', TMP_Numeric_quo_23 = function $$quo(other) {\n      var self = this;\n\n      return $rb_divide($$($nesting, 'Opal')['$coerce_to!'](self, $$($nesting, 'Rational'), \"to_r\"), other)\n    }, TMP_Numeric_quo_23.$$arity = 1);\n    \n    Opal.def(self, '$real', TMP_Numeric_real_24 = function $$real() {\n      var self = this;\n\n      return self\n    }, TMP_Numeric_real_24.$$arity = 0);\n    \n    Opal.def(self, '$real?', TMP_Numeric_real$q_25 = function() {\n      var self = this;\n\n      return true\n    }, TMP_Numeric_real$q_25.$$arity = 0);\n    \n    Opal.def(self, '$rect', TMP_Numeric_rect_26 = function $$rect() {\n      var self = this;\n\n      return [self, 0]\n    }, TMP_Numeric_rect_26.$$arity = 0);\n    Opal.alias(self, \"rectangular\", \"rect\");\n    \n    Opal.def(self, '$round', TMP_Numeric_round_27 = function $$round(digits) {\n      var self = this;\n\n      return self.$to_f().$round(digits)\n    }, TMP_Numeric_round_27.$$arity = -1);\n    \n    Opal.def(self, '$to_c', TMP_Numeric_to_c_28 = function $$to_c() {\n      var self = this;\n\n      return self.$Complex(self, 0)\n    }, TMP_Numeric_to_c_28.$$arity = 0);\n    \n    Opal.def(self, '$to_int', TMP_Numeric_to_int_29 = function $$to_int() {\n      var self = this;\n\n      return self.$to_i()\n    }, TMP_Numeric_to_int_29.$$arity = 0);\n    \n    Opal.def(self, '$truncate', TMP_Numeric_truncate_30 = function $$truncate(ndigits) {\n      var self = this;\n\n      if (ndigits == null) {\n        ndigits = 0;\n      }\n      return self.$to_f().$truncate(ndigits)\n    }, TMP_Numeric_truncate_30.$$arity = -1);\n    \n    Opal.def(self, '$zero?', TMP_Numeric_zero$q_31 = function() {\n      var self = this;\n\n      return self['$=='](0)\n    }, TMP_Numeric_zero$q_31.$$arity = 0);\n    \n    Opal.def(self, '$positive?', TMP_Numeric_positive$q_32 = function() {\n      var self = this;\n\n      return $rb_gt(self, 0)\n    }, TMP_Numeric_positive$q_32.$$arity = 0);\n    \n    Opal.def(self, '$negative?', TMP_Numeric_negative$q_33 = function() {\n      var self = this;\n\n      return $rb_lt(self, 0)\n    }, TMP_Numeric_negative$q_33.$$arity = 0);\n    \n    Opal.def(self, '$dup', TMP_Numeric_dup_34 = function $$dup() {\n      var self = this;\n\n      return self\n    }, TMP_Numeric_dup_34.$$arity = 0);\n    \n    Opal.def(self, '$clone', TMP_Numeric_clone_35 = function $$clone($kwargs) {\n      var self = this, freeze;\n\n      if ($kwargs == null || !$kwargs.$$is_hash) {\n        if ($kwargs == null) {\n          $kwargs = $hash2([], {});\n        } else {\n          throw Opal.ArgumentError.$new('expected kwargs');\n        }\n      }\n      freeze = $kwargs.$$smap[\"freeze\"];\n      if (freeze == null) {\n        freeze = true\n      }\n      return self\n    }, TMP_Numeric_clone_35.$$arity = -1);\n    \n    Opal.def(self, '$finite?', TMP_Numeric_finite$q_36 = function() {\n      var self = this;\n\n      return true\n    }, TMP_Numeric_finite$q_36.$$arity = 0);\n    return (Opal.def(self, '$infinite?', TMP_Numeric_infinite$q_37 = function() {\n      var self = this;\n\n      return nil\n    }, TMP_Numeric_infinite$q_37.$$arity = 0), nil) && 'infinite?';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/array\"] = function(Opal) {\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$require', '$include', '$to_a', '$warn', '$raise', '$replace', '$respond_to?', '$to_ary', '$coerce_to', '$coerce_to?', '$===', '$join', '$to_str', '$class', '$hash', '$<=>', '$==', '$object_id', '$inspect', '$enum_for', '$bsearch_index', '$to_proc', '$nil?', '$coerce_to!', '$>', '$*', '$enumerator_size', '$empty?', '$size', '$map', '$equal?', '$dup', '$each', '$[]', '$dig', '$eql?', '$length', '$begin', '$end', '$exclude_end?', '$flatten', '$__id__', '$to_s', '$new', '$max', '$min', '$!', '$>=', '$**', '$delete_if', '$reverse', '$rotate', '$rand', '$at', '$keep_if', '$shuffle!', '$<', '$sort', '$sort_by', '$!=', '$times', '$[]=', '$-', '$<<', '$values', '$is_a?', '$last', '$first', '$upto', '$reject', '$pristine', '$singleton_class']);\n  \n  self.$require(\"corelib/enumerable\");\n  self.$require(\"corelib/numeric\");\n  return (function($base, $super, $parent_nesting) {\n    function $Array(){};\n    var self = $Array = $klass($base, $super, 'Array', $Array);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Array_$$_1, TMP_Array_initialize_2, TMP_Array_try_convert_3, TMP_Array_$_4, TMP_Array_$_5, TMP_Array_$_6, TMP_Array_$_7, TMP_Array_$_8, TMP_Array_$lt$lt_9, TMP_Array_$lt$eq$gt_10, TMP_Array_$eq$eq_11, TMP_Array_$$_12, TMP_Array_$$$eq_13, TMP_Array_any$q_14, TMP_Array_assoc_15, TMP_Array_at_16, TMP_Array_bsearch_index_17, TMP_Array_bsearch_18, TMP_Array_cycle_19, TMP_Array_clear_21, TMP_Array_count_22, TMP_Array_initialize_copy_23, TMP_Array_collect_24, TMP_Array_collect$B_26, TMP_Array_combination_28, TMP_Array_repeated_combination_30, TMP_Array_compact_32, TMP_Array_compact$B_33, TMP_Array_concat_36, TMP_Array_delete_37, TMP_Array_delete_at_38, TMP_Array_delete_if_39, TMP_Array_dig_41, TMP_Array_drop_42, TMP_Array_dup_43, TMP_Array_each_44, TMP_Array_each_index_46, TMP_Array_empty$q_48, TMP_Array_eql$q_49, TMP_Array_fetch_50, TMP_Array_fill_51, TMP_Array_first_52, TMP_Array_flatten_53, TMP_Array_flatten$B_54, TMP_Array_hash_55, TMP_Array_include$q_56, TMP_Array_index_57, TMP_Array_insert_58, TMP_Array_inspect_59, TMP_Array_join_60, TMP_Array_keep_if_61, TMP_Array_last_63, TMP_Array_length_64, TMP_Array_max_65, TMP_Array_min_66, TMP_Array_permutation_67, TMP_Array_repeated_permutation_69, TMP_Array_pop_71, TMP_Array_product_72, TMP_Array_push_73, TMP_Array_rassoc_74, TMP_Array_reject_75, TMP_Array_reject$B_77, TMP_Array_replace_79, TMP_Array_reverse_80, TMP_Array_reverse$B_81, TMP_Array_reverse_each_82, TMP_Array_rindex_84, TMP_Array_rotate_85, TMP_Array_rotate$B_86, TMP_Array_sample_89, TMP_Array_select_90, TMP_Array_select$B_92, TMP_Array_shift_94, TMP_Array_shuffle_95, TMP_Array_shuffle$B_96, TMP_Array_slice$B_97, TMP_Array_sort_98, TMP_Array_sort$B_99, TMP_Array_sort_by$B_100, TMP_Array_take_102, TMP_Array_take_while_103, TMP_Array_to_a_104, TMP_Array_to_h_105, TMP_Array_transpose_108, TMP_Array_uniq_109, TMP_Array_uniq$B_110, TMP_Array_unshift_111, TMP_Array_values_at_114, TMP_Array_zip_115, TMP_Array_inherited_116, TMP_Array_instance_variables_117, TMP_Array_pack_119;\n\n    \n    self.$include($$($nesting, 'Enumerable'));\n    def.$$is_array = true;\n    \n    function toArraySubclass(obj, klass) {\n      if (klass.$$name === Opal.Array) {\n        return obj;\n      } else {\n        return klass.$allocate().$replace((obj).$to_a());\n      }\n    }\n  ;\n    Opal.defs(self, '$[]', TMP_Array_$$_1 = function($a_rest) {\n      var self = this, objects;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      objects = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        objects[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return toArraySubclass(objects, self);\n    }, TMP_Array_$$_1.$$arity = -1);\n    \n    Opal.def(self, '$initialize', TMP_Array_initialize_2 = function $$initialize(size, obj) {\n      var self = this, $iter = TMP_Array_initialize_2.$$p, block = $iter || nil;\n\n      if (size == null) {\n        size = nil;\n      }\n      if (obj == null) {\n        obj = nil;\n      }\n      if ($iter) TMP_Array_initialize_2.$$p = null;\n      \n      if (obj !== nil && block !== nil) {\n        self.$warn(\"warning: block supersedes default value argument\")\n      }\n\n      if (size > $$$($$($nesting, 'Integer'), 'MAX')) {\n        self.$raise($$($nesting, 'ArgumentError'), \"array size too big\")\n      }\n\n      if (arguments.length > 2) {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (arguments.length) + \" for 0..2)\")\n      }\n\n      if (arguments.length === 0) {\n        self.splice(0, self.length);\n        return self;\n      }\n\n      if (arguments.length === 1) {\n        if (size.$$is_array) {\n          self.$replace(size.$to_a())\n          return self;\n        } else if (size['$respond_to?'](\"to_ary\")) {\n          self.$replace(size.$to_ary())\n          return self;\n        }\n      }\n\n      size = $$($nesting, 'Opal').$coerce_to(size, $$($nesting, 'Integer'), \"to_int\")\n\n      if (size < 0) {\n        self.$raise($$($nesting, 'ArgumentError'), \"negative array size\")\n      }\n\n      self.splice(0, self.length);\n      var i, value;\n\n      if (block === nil) {\n        for (i = 0; i < size; i++) {\n          self.push(obj);\n        }\n      }\n      else {\n        for (i = 0, value; i < size; i++) {\n          value = block(i);\n          self[i] = value;\n        }\n      }\n\n      return self;\n    \n    }, TMP_Array_initialize_2.$$arity = -1);\n    Opal.defs(self, '$try_convert', TMP_Array_try_convert_3 = function $$try_convert(obj) {\n      var self = this;\n\n      return $$($nesting, 'Opal')['$coerce_to?'](obj, $$($nesting, 'Array'), \"to_ary\")\n    }, TMP_Array_try_convert_3.$$arity = 1);\n    \n    Opal.def(self, '$&', TMP_Array_$_4 = function(other) {\n      var self = this;\n\n      \n      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {\n        return other.$to_a()\n      } else {\n        return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), \"to_ary\").$to_a()\n      }; return nil; })();\n      \n      var result = [], hash = $hash2([], {}), i, length, item;\n\n      for (i = 0, length = other.length; i < length; i++) {\n        Opal.hash_put(hash, other[i], true);\n      }\n\n      for (i = 0, length = self.length; i < length; i++) {\n        item = self[i];\n        if (Opal.hash_delete(hash, item) !== undefined) {\n          result.push(item);\n        }\n      }\n\n      return result;\n    ;\n    }, TMP_Array_$_4.$$arity = 1);\n    \n    Opal.def(self, '$|', TMP_Array_$_5 = function(other) {\n      var self = this;\n\n      \n      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {\n        return other.$to_a()\n      } else {\n        return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), \"to_ary\").$to_a()\n      }; return nil; })();\n      \n      var hash = $hash2([], {}), i, length, item;\n\n      for (i = 0, length = self.length; i < length; i++) {\n        Opal.hash_put(hash, self[i], true);\n      }\n\n      for (i = 0, length = other.length; i < length; i++) {\n        Opal.hash_put(hash, other[i], true);\n      }\n\n      return hash.$keys();\n    ;\n    }, TMP_Array_$_5.$$arity = 1);\n    \n    Opal.def(self, '$*', TMP_Array_$_6 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(other['$respond_to?'](\"to_str\"))) {\n        return self.$join(other.$to_str())};\n      other = $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Integer'), \"to_int\");\n      if ($truthy(other < 0)) {\n        self.$raise($$($nesting, 'ArgumentError'), \"negative argument\")};\n      \n      var result = [],\n          converted = self.$to_a();\n\n      for (var i = 0; i < other; i++) {\n        result = result.concat(converted);\n      }\n\n      return toArraySubclass(result, self.$class());\n    ;\n    }, TMP_Array_$_6.$$arity = 1);\n    \n    Opal.def(self, '$+', TMP_Array_$_7 = function(other) {\n      var self = this;\n\n      \n      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {\n        return other.$to_a()\n      } else {\n        return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), \"to_ary\").$to_a()\n      }; return nil; })();\n      return self.concat(other);;\n    }, TMP_Array_$_7.$$arity = 1);\n    \n    Opal.def(self, '$-', TMP_Array_$_8 = function(other) {\n      var self = this;\n\n      \n      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {\n        return other.$to_a()\n      } else {\n        return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), \"to_ary\").$to_a()\n      }; return nil; })();\n      if ($truthy(self.length === 0)) {\n        return []};\n      if ($truthy(other.length === 0)) {\n        return self.slice()};\n      \n      var result = [], hash = $hash2([], {}), i, length, item;\n\n      for (i = 0, length = other.length; i < length; i++) {\n        Opal.hash_put(hash, other[i], true);\n      }\n\n      for (i = 0, length = self.length; i < length; i++) {\n        item = self[i];\n        if (Opal.hash_get(hash, item) === undefined) {\n          result.push(item);\n        }\n      }\n\n      return result;\n    ;\n    }, TMP_Array_$_8.$$arity = 1);\n    \n    Opal.def(self, '$<<', TMP_Array_$lt$lt_9 = function(object) {\n      var self = this;\n\n      \n      self.push(object);\n      return self;\n    }, TMP_Array_$lt$lt_9.$$arity = 1);\n    \n    Opal.def(self, '$<=>', TMP_Array_$lt$eq$gt_10 = function(other) {\n      var self = this;\n\n      \n      if ($truthy($$($nesting, 'Array')['$==='](other))) {\n        other = other.$to_a()\n      } else if ($truthy(other['$respond_to?'](\"to_ary\"))) {\n        other = other.$to_ary().$to_a()\n      } else {\n        return nil\n      };\n      \n      if (self.$hash() === other.$hash()) {\n        return 0;\n      }\n\n      var count = Math.min(self.length, other.length);\n\n      for (var i = 0; i < count; i++) {\n        var tmp = (self[i])['$<=>'](other[i]);\n\n        if (tmp !== 0) {\n          return tmp;\n        }\n      }\n\n      return (self.length)['$<=>'](other.length);\n    ;\n    }, TMP_Array_$lt$eq$gt_10.$$arity = 1);\n    \n    Opal.def(self, '$==', TMP_Array_$eq$eq_11 = function(other) {\n      var self = this;\n\n      \n      var recursed = {};\n\n      function _eqeq(array, other) {\n        var i, length, a, b;\n\n        if (array === other)\n          return true;\n\n        if (!other.$$is_array) {\n          if ($$($nesting, 'Opal')['$respond_to?'](other, \"to_ary\")) {\n            return (other)['$=='](array);\n          } else {\n            return false;\n          }\n        }\n\n        if (array.constructor !== Array)\n          array = (array).$to_a();\n        if (other.constructor !== Array)\n          other = (other).$to_a();\n\n        if (array.length !== other.length) {\n          return false;\n        }\n\n        recursed[(array).$object_id()] = true;\n\n        for (i = 0, length = array.length; i < length; i++) {\n          a = array[i];\n          b = other[i];\n          if (a.$$is_array) {\n            if (b.$$is_array && b.length !== a.length) {\n              return false;\n            }\n            if (!recursed.hasOwnProperty((a).$object_id())) {\n              if (!_eqeq(a, b)) {\n                return false;\n              }\n            }\n          } else {\n            if (!(a)['$=='](b)) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n      }\n\n      return _eqeq(self, other);\n    \n    }, TMP_Array_$eq$eq_11.$$arity = 1);\n    \n    function $array_slice_range(self, index) {\n      var size = self.length,\n          exclude, from, to, result;\n\n      exclude = index.excl;\n      from    = Opal.Opal.$coerce_to(index.begin, Opal.Integer, 'to_int');\n      to      = Opal.Opal.$coerce_to(index.end, Opal.Integer, 'to_int');\n\n      if (from < 0) {\n        from += size;\n\n        if (from < 0) {\n          return nil;\n        }\n      }\n\n      if (from > size) {\n        return nil;\n      }\n\n      if (to < 0) {\n        to += size;\n\n        if (to < 0) {\n          return [];\n        }\n      }\n\n      if (!exclude) {\n        to += 1;\n      }\n\n      result = self.slice(from, to);\n      return toArraySubclass(result, self.$class());\n    }\n\n    function $array_slice_index_length(self, index, length) {\n      var size = self.length,\n          exclude, from, to, result;\n\n      index = Opal.Opal.$coerce_to(index, Opal.Integer, 'to_int');\n\n      if (index < 0) {\n        index += size;\n\n        if (index < 0) {\n          return nil;\n        }\n      }\n\n      if (length === undefined) {\n        if (index >= size || index < 0) {\n          return nil;\n        }\n\n        return self[index];\n      }\n      else {\n        length = Opal.Opal.$coerce_to(length, Opal.Integer, 'to_int');\n\n        if (length < 0 || index > size || index < 0) {\n          return nil;\n        }\n\n        result = self.slice(index, index + length);\n      }\n      return toArraySubclass(result, self.$class());\n    }\n  ;\n    \n    Opal.def(self, '$[]', TMP_Array_$$_12 = function(index, length) {\n      var self = this;\n\n      \n      if (index.$$is_range) {\n        return $array_slice_range(self, index);\n      }\n      else {\n        return $array_slice_index_length(self, index, length);\n      }\n    \n    }, TMP_Array_$$_12.$$arity = -2);\n    \n    Opal.def(self, '$[]=', TMP_Array_$$$eq_13 = function(index, value, extra) {\n      var self = this, data = nil, length = nil;\n\n      \n            var i, size = self.length;;\n      if ($truthy($$($nesting, 'Range')['$==='](index))) {\n        \n        data = (function() {if ($truthy($$($nesting, 'Array')['$==='](value))) {\n          return value.$to_a()\n        } else if ($truthy(value['$respond_to?'](\"to_ary\"))) {\n          return value.$to_ary().$to_a()\n        } else {\n          return [value]\n        }; return nil; })();\n        \n        var exclude = index.excl,\n            from    = $$($nesting, 'Opal').$coerce_to(index.begin, $$($nesting, 'Integer'), \"to_int\"),\n            to      = $$($nesting, 'Opal').$coerce_to(index.end, $$($nesting, 'Integer'), \"to_int\");\n\n        if (from < 0) {\n          from += size;\n\n          if (from < 0) {\n            self.$raise($$($nesting, 'RangeError'), \"\" + (index.$inspect()) + \" out of range\");\n          }\n        }\n\n        if (to < 0) {\n          to += size;\n        }\n\n        if (!exclude) {\n          to += 1;\n        }\n\n        if (from > size) {\n          for (i = size; i < from; i++) {\n            self[i] = nil;\n          }\n        }\n\n        if (to < 0) {\n          self.splice.apply(self, [from, 0].concat(data));\n        }\n        else {\n          self.splice.apply(self, [from, to - from].concat(data));\n        }\n\n        return value;\n      ;\n      } else {\n        \n        if ($truthy(extra === undefined)) {\n          length = 1\n        } else {\n          \n          length = value;\n          value = extra;\n          data = (function() {if ($truthy($$($nesting, 'Array')['$==='](value))) {\n            return value.$to_a()\n          } else if ($truthy(value['$respond_to?'](\"to_ary\"))) {\n            return value.$to_ary().$to_a()\n          } else {\n            return [value]\n          }; return nil; })();\n        };\n        \n        var old;\n\n        index  = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), \"to_int\");\n        length = $$($nesting, 'Opal').$coerce_to(length, $$($nesting, 'Integer'), \"to_int\");\n\n        if (index < 0) {\n          old    = index;\n          index += size;\n\n          if (index < 0) {\n            self.$raise($$($nesting, 'IndexError'), \"\" + \"index \" + (old) + \" too small for array; minimum \" + (-self.length));\n          }\n        }\n\n        if (length < 0) {\n          self.$raise($$($nesting, 'IndexError'), \"\" + \"negative length (\" + (length) + \")\")\n        }\n\n        if (index > size) {\n          for (i = size; i < index; i++) {\n            self[i] = nil;\n          }\n        }\n\n        if (extra === undefined) {\n          self[index] = value;\n        }\n        else {\n          self.splice.apply(self, [index, length].concat(data));\n        }\n\n        return value;\n      ;\n      };\n    }, TMP_Array_$$$eq_13.$$arity = -3);\n    \n    Opal.def(self, '$any?', TMP_Array_any$q_14 = function(pattern) {\n      var self = this, $iter = TMP_Array_any$q_14.$$p, block = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Array_any$q_14.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      \n      if (self.length === 0) return false;\n      return $send(self, Opal.find_super_dispatcher(self, 'any?', TMP_Array_any$q_14, false), $zuper, $iter);\n    }, TMP_Array_any$q_14.$$arity = -1);\n    \n    Opal.def(self, '$assoc', TMP_Array_assoc_15 = function $$assoc(object) {\n      var self = this;\n\n      \n      for (var i = 0, length = self.length, item; i < length; i++) {\n        if (item = self[i], item.length && (item[0])['$=='](object)) {\n          return item;\n        }\n      }\n\n      return nil;\n    \n    }, TMP_Array_assoc_15.$$arity = 1);\n    \n    Opal.def(self, '$at', TMP_Array_at_16 = function $$at(index) {\n      var self = this;\n\n      \n      index = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), \"to_int\");\n      \n      if (index < 0) {\n        index += self.length;\n      }\n\n      if (index < 0 || index >= self.length) {\n        return nil;\n      }\n\n      return self[index];\n    ;\n    }, TMP_Array_at_16.$$arity = 1);\n    \n    Opal.def(self, '$bsearch_index', TMP_Array_bsearch_index_17 = function $$bsearch_index() {\n      var self = this, $iter = TMP_Array_bsearch_index_17.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_bsearch_index_17.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return self.$enum_for(\"bsearch_index\")\n      };\n      \n      var min = 0,\n          max = self.length,\n          mid,\n          val,\n          ret,\n          smaller = false,\n          satisfied = nil;\n\n      while (min < max) {\n        mid = min + Math.floor((max - min) / 2);\n        val = self[mid];\n        ret = Opal.yield1(block, val);\n\n        if (ret === true) {\n          satisfied = mid;\n          smaller = true;\n        }\n        else if (ret === false || ret === nil) {\n          smaller = false;\n        }\n        else if (ret.$$is_number) {\n          if (ret === 0) { return mid; }\n          smaller = (ret < 0);\n        }\n        else {\n          self.$raise($$($nesting, 'TypeError'), \"\" + \"wrong argument type \" + ((ret).$class()) + \" (must be numeric, true, false or nil)\")\n        }\n\n        if (smaller) { max = mid; } else { min = mid + 1; }\n      }\n\n      return satisfied;\n    ;\n    }, TMP_Array_bsearch_index_17.$$arity = 0);\n    \n    Opal.def(self, '$bsearch', TMP_Array_bsearch_18 = function $$bsearch() {\n      var self = this, $iter = TMP_Array_bsearch_18.$$p, block = $iter || nil, index = nil;\n\n      if ($iter) TMP_Array_bsearch_18.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return self.$enum_for(\"bsearch\")\n      };\n      index = $send(self, 'bsearch_index', [], block.$to_proc());\n      \n      if (index != null && index.$$is_number) {\n        return self[index];\n      } else {\n        return index;\n      }\n    ;\n    }, TMP_Array_bsearch_18.$$arity = 0);\n    \n    Opal.def(self, '$cycle', TMP_Array_cycle_19 = function $$cycle(n) {\n      var TMP_20, $a, self = this, $iter = TMP_Array_cycle_19.$$p, block = $iter || nil;\n\n      if (n == null) {\n        n = nil;\n      }\n      if ($iter) TMP_Array_cycle_19.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"cycle\", n], (TMP_20 = function(){var self = TMP_20.$$s || this;\n\n        if ($truthy(n['$nil?']())) {\n            return $$$($$($nesting, 'Float'), 'INFINITY')\n          } else {\n            \n            n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), \"to_int\");\n            if ($truthy($rb_gt(n, 0))) {\n              return $rb_times(self.$enumerator_size(), n)\n            } else {\n              return 0\n            };\n          }}, TMP_20.$$s = self, TMP_20.$$arity = 0, TMP_20))\n      };\n      if ($truthy(($truthy($a = self['$empty?']()) ? $a : n['$=='](0)))) {\n        return nil};\n      \n      var i, length, value;\n\n      if (n === nil) {\n        while (true) {\n          for (i = 0, length = self.length; i < length; i++) {\n            value = Opal.yield1(block, self[i]);\n          }\n        }\n      }\n      else {\n        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), \"to_int\");\n        if (n <= 0) {\n          return self;\n        }\n\n        while (n > 0) {\n          for (i = 0, length = self.length; i < length; i++) {\n            value = Opal.yield1(block, self[i]);\n          }\n\n          n--;\n        }\n      }\n    ;\n      return self;\n    }, TMP_Array_cycle_19.$$arity = -1);\n    \n    Opal.def(self, '$clear', TMP_Array_clear_21 = function $$clear() {\n      var self = this;\n\n      \n      self.splice(0, self.length);\n      return self;\n    }, TMP_Array_clear_21.$$arity = 0);\n    \n    Opal.def(self, '$count', TMP_Array_count_22 = function $$count(object) {\n      var $a, self = this, $iter = TMP_Array_count_22.$$p, block = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if (object == null) {\n        object = nil;\n      }\n      if ($iter) TMP_Array_count_22.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      if ($truthy(($truthy($a = object) ? $a : block))) {\n        return $send(self, Opal.find_super_dispatcher(self, 'count', TMP_Array_count_22, false), $zuper, $iter)\n      } else {\n        return self.$size()\n      }\n    }, TMP_Array_count_22.$$arity = -1);\n    \n    Opal.def(self, '$initialize_copy', TMP_Array_initialize_copy_23 = function $$initialize_copy(other) {\n      var self = this;\n\n      return self.$replace(other)\n    }, TMP_Array_initialize_copy_23.$$arity = 1);\n    \n    Opal.def(self, '$collect', TMP_Array_collect_24 = function $$collect() {\n      var TMP_25, self = this, $iter = TMP_Array_collect_24.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_collect_24.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"collect\"], (TMP_25 = function(){var self = TMP_25.$$s || this;\n\n        return self.$size()}, TMP_25.$$s = self, TMP_25.$$arity = 0, TMP_25))\n      };\n      \n      var result = [];\n\n      for (var i = 0, length = self.length; i < length; i++) {\n        var value = Opal.yield1(block, self[i]);\n        result.push(value);\n      }\n\n      return result;\n    ;\n    }, TMP_Array_collect_24.$$arity = 0);\n    \n    Opal.def(self, '$collect!', TMP_Array_collect$B_26 = function() {\n      var TMP_27, self = this, $iter = TMP_Array_collect$B_26.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_collect$B_26.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"collect!\"], (TMP_27 = function(){var self = TMP_27.$$s || this;\n\n        return self.$size()}, TMP_27.$$s = self, TMP_27.$$arity = 0, TMP_27))\n      };\n      \n      for (var i = 0, length = self.length; i < length; i++) {\n        var value = Opal.yield1(block, self[i]);\n        self[i] = value;\n      }\n    ;\n      return self;\n    }, TMP_Array_collect$B_26.$$arity = 0);\n    \n    function binomial_coefficient(n, k) {\n      if (n === k || k === 0) {\n        return 1;\n      }\n\n      if (k > 0 && n > k) {\n        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k);\n      }\n\n      return 0;\n    }\n  ;\n    \n    Opal.def(self, '$combination', TMP_Array_combination_28 = function $$combination(n) {\n      var TMP_29, self = this, $iter = TMP_Array_combination_28.$$p, $yield = $iter || nil, num = nil;\n\n      if ($iter) TMP_Array_combination_28.$$p = null;\n      \n      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), \"to_int\");\n      if (($yield !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"combination\", num], (TMP_29 = function(){var self = TMP_29.$$s || this;\n\n        return binomial_coefficient(self.length, num)}, TMP_29.$$s = self, TMP_29.$$arity = 0, TMP_29))\n      };\n      \n      var i, length, stack, chosen, lev, done, next;\n\n      if (num === 0) {\n        Opal.yield1($yield, [])\n      } else if (num === 1) {\n        for (i = 0, length = self.length; i < length; i++) {\n          Opal.yield1($yield, [self[i]])\n        }\n      }\n      else if (num === self.length) {\n        Opal.yield1($yield, self.slice())\n      }\n      else if (num >= 0 && num < self.length) {\n        stack = [];\n        for (i = 0; i <= num + 1; i++) {\n          stack.push(0);\n        }\n\n        chosen = [];\n        lev = 0;\n        done = false;\n        stack[0] = -1;\n\n        while (!done) {\n          chosen[lev] = self[stack[lev+1]];\n          while (lev < num - 1) {\n            lev++;\n            next = stack[lev+1] = stack[lev] + 1;\n            chosen[lev] = self[next];\n          }\n          Opal.yield1($yield, chosen.slice())\n          lev++;\n          do {\n            done = (lev === 0);\n            stack[lev]++;\n            lev--;\n          } while ( stack[lev+1] + num === self.length + lev + 1 );\n        }\n      }\n    ;\n      return self;\n    }, TMP_Array_combination_28.$$arity = 1);\n    \n    Opal.def(self, '$repeated_combination', TMP_Array_repeated_combination_30 = function $$repeated_combination(n) {\n      var TMP_31, self = this, $iter = TMP_Array_repeated_combination_30.$$p, $yield = $iter || nil, num = nil;\n\n      if ($iter) TMP_Array_repeated_combination_30.$$p = null;\n      \n      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), \"to_int\");\n      if (($yield !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"repeated_combination\", num], (TMP_31 = function(){var self = TMP_31.$$s || this;\n\n        return binomial_coefficient(self.length + num - 1, num);}, TMP_31.$$s = self, TMP_31.$$arity = 0, TMP_31))\n      };\n      \n      function iterate(max, from, buffer, self) {\n        if (buffer.length == max) {\n          var copy = buffer.slice();\n          Opal.yield1($yield, copy)\n          return;\n        }\n        for (var i = from; i < self.length; i++) {\n          buffer.push(self[i]);\n          iterate(max, i, buffer, self);\n          buffer.pop();\n        }\n      }\n\n      if (num >= 0) {\n        iterate(num, 0, [], self);\n      }\n    ;\n      return self;\n    }, TMP_Array_repeated_combination_30.$$arity = 1);\n    \n    Opal.def(self, '$compact', TMP_Array_compact_32 = function $$compact() {\n      var self = this;\n\n      \n      var result = [];\n\n      for (var i = 0, length = self.length, item; i < length; i++) {\n        if ((item = self[i]) !== nil) {\n          result.push(item);\n        }\n      }\n\n      return result;\n    \n    }, TMP_Array_compact_32.$$arity = 0);\n    \n    Opal.def(self, '$compact!', TMP_Array_compact$B_33 = function() {\n      var self = this;\n\n      \n      var original = self.length;\n\n      for (var i = 0, length = self.length; i < length; i++) {\n        if (self[i] === nil) {\n          self.splice(i, 1);\n\n          length--;\n          i--;\n        }\n      }\n\n      return self.length === original ? nil : self;\n    \n    }, TMP_Array_compact$B_33.$$arity = 0);\n    \n    Opal.def(self, '$concat', TMP_Array_concat_36 = function $$concat($a_rest) {\n      var TMP_34, TMP_35, self = this, others;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      others = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        others[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      others = $send(others, 'map', [], (TMP_34 = function(other){var self = TMP_34.$$s || this;\nif (other == null) other = nil;\n      \n        other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {\n          return other.$to_a()\n        } else {\n          return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), \"to_ary\").$to_a()\n        }; return nil; })();\n        if ($truthy(other['$equal?'](self))) {\n          other = other.$dup()};\n        return other;}, TMP_34.$$s = self, TMP_34.$$arity = 1, TMP_34));\n      $send(others, 'each', [], (TMP_35 = function(other){var self = TMP_35.$$s || this;\nif (other == null) other = nil;\n      \n        for (var i = 0, length = other.length; i < length; i++) {\n          self.push(other[i]);\n        }\n      }, TMP_35.$$s = self, TMP_35.$$arity = 1, TMP_35));\n      return self;\n    }, TMP_Array_concat_36.$$arity = -1);\n    \n    Opal.def(self, '$delete', TMP_Array_delete_37 = function(object) {\n      var self = this, $iter = TMP_Array_delete_37.$$p, $yield = $iter || nil;\n\n      if ($iter) TMP_Array_delete_37.$$p = null;\n      \n      var original = self.length;\n\n      for (var i = 0, length = original; i < length; i++) {\n        if ((self[i])['$=='](object)) {\n          self.splice(i, 1);\n\n          length--;\n          i--;\n        }\n      }\n\n      if (self.length === original) {\n        if (($yield !== nil)) {\n          return Opal.yieldX($yield, []);\n        }\n        return nil;\n      }\n      return object;\n    \n    }, TMP_Array_delete_37.$$arity = 1);\n    \n    Opal.def(self, '$delete_at', TMP_Array_delete_at_38 = function $$delete_at(index) {\n      var self = this;\n\n      \n      index = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), \"to_int\");\n\n      if (index < 0) {\n        index += self.length;\n      }\n\n      if (index < 0 || index >= self.length) {\n        return nil;\n      }\n\n      var result = self[index];\n\n      self.splice(index, 1);\n\n      return result;\n    \n    }, TMP_Array_delete_at_38.$$arity = 1);\n    \n    Opal.def(self, '$delete_if', TMP_Array_delete_if_39 = function $$delete_if() {\n      var TMP_40, self = this, $iter = TMP_Array_delete_if_39.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_delete_if_39.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"delete_if\"], (TMP_40 = function(){var self = TMP_40.$$s || this;\n\n        return self.$size()}, TMP_40.$$s = self, TMP_40.$$arity = 0, TMP_40))\n      };\n      \n      for (var i = 0, length = self.length, value; i < length; i++) {\n        value = block(self[i]);\n\n        if (value !== false && value !== nil) {\n          self.splice(i, 1);\n\n          length--;\n          i--;\n        }\n      }\n    ;\n      return self;\n    }, TMP_Array_delete_if_39.$$arity = 0);\n    \n    Opal.def(self, '$dig', TMP_Array_dig_41 = function $$dig(idx, $a_rest) {\n      var self = this, idxs, item = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      idxs = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        idxs[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      \n      item = self['$[]'](idx);\n      \n      if (item === nil || idxs.length === 0) {\n        return item;\n      }\n    ;\n      if ($truthy(item['$respond_to?'](\"dig\"))) {\n      } else {\n        self.$raise($$($nesting, 'TypeError'), \"\" + (item.$class()) + \" does not have #dig method\")\n      };\n      return $send(item, 'dig', Opal.to_a(idxs));\n    }, TMP_Array_dig_41.$$arity = -2);\n    \n    Opal.def(self, '$drop', TMP_Array_drop_42 = function $$drop(number) {\n      var self = this;\n\n      \n      if (number < 0) {\n        self.$raise($$($nesting, 'ArgumentError'))\n      }\n\n      return self.slice(number);\n    \n    }, TMP_Array_drop_42.$$arity = 1);\n    \n    Opal.def(self, '$dup', TMP_Array_dup_43 = function $$dup() {\n      var self = this, $iter = TMP_Array_dup_43.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Array_dup_43.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      \n      \n      if (self.$$class === Opal.Array &&\n          self.$$class.$allocate.$$pristine &&\n          self.$copy_instance_variables.$$pristine &&\n          self.$initialize_dup.$$pristine) {\n        return self.slice(0);\n      }\n    ;\n      return $send(self, Opal.find_super_dispatcher(self, 'dup', TMP_Array_dup_43, false), $zuper, $iter);\n    }, TMP_Array_dup_43.$$arity = 0);\n    \n    Opal.def(self, '$each', TMP_Array_each_44 = function $$each() {\n      var TMP_45, self = this, $iter = TMP_Array_each_44.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_each_44.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"each\"], (TMP_45 = function(){var self = TMP_45.$$s || this;\n\n        return self.$size()}, TMP_45.$$s = self, TMP_45.$$arity = 0, TMP_45))\n      };\n      \n      for (var i = 0, length = self.length; i < length; i++) {\n        var value = Opal.yield1(block, self[i]);\n      }\n    ;\n      return self;\n    }, TMP_Array_each_44.$$arity = 0);\n    \n    Opal.def(self, '$each_index', TMP_Array_each_index_46 = function $$each_index() {\n      var TMP_47, self = this, $iter = TMP_Array_each_index_46.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_each_index_46.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"each_index\"], (TMP_47 = function(){var self = TMP_47.$$s || this;\n\n        return self.$size()}, TMP_47.$$s = self, TMP_47.$$arity = 0, TMP_47))\n      };\n      \n      for (var i = 0, length = self.length; i < length; i++) {\n        var value = Opal.yield1(block, i);\n      }\n    ;\n      return self;\n    }, TMP_Array_each_index_46.$$arity = 0);\n    \n    Opal.def(self, '$empty?', TMP_Array_empty$q_48 = function() {\n      var self = this;\n\n      return self.length === 0;\n    }, TMP_Array_empty$q_48.$$arity = 0);\n    \n    Opal.def(self, '$eql?', TMP_Array_eql$q_49 = function(other) {\n      var self = this;\n\n      \n      var recursed = {};\n\n      function _eql(array, other) {\n        var i, length, a, b;\n\n        if (!other.$$is_array) {\n          return false;\n        }\n\n        other = other.$to_a();\n\n        if (array.length !== other.length) {\n          return false;\n        }\n\n        recursed[(array).$object_id()] = true;\n\n        for (i = 0, length = array.length; i < length; i++) {\n          a = array[i];\n          b = other[i];\n          if (a.$$is_array) {\n            if (b.$$is_array && b.length !== a.length) {\n              return false;\n            }\n            if (!recursed.hasOwnProperty((a).$object_id())) {\n              if (!_eql(a, b)) {\n                return false;\n              }\n            }\n          } else {\n            if (!(a)['$eql?'](b)) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n      }\n\n      return _eql(self, other);\n    \n    }, TMP_Array_eql$q_49.$$arity = 1);\n    \n    Opal.def(self, '$fetch', TMP_Array_fetch_50 = function $$fetch(index, defaults) {\n      var self = this, $iter = TMP_Array_fetch_50.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_fetch_50.$$p = null;\n      \n      var original = index;\n\n      index = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), \"to_int\");\n\n      if (index < 0) {\n        index += self.length;\n      }\n\n      if (index >= 0 && index < self.length) {\n        return self[index];\n      }\n\n      if (block !== nil && defaults != null) {\n        self.$warn(\"warning: block supersedes default value argument\")\n      }\n\n      if (block !== nil) {\n        return block(original);\n      }\n\n      if (defaults != null) {\n        return defaults;\n      }\n\n      if (self.length === 0) {\n        self.$raise($$($nesting, 'IndexError'), \"\" + \"index \" + (original) + \" outside of array bounds: 0...0\")\n      }\n      else {\n        self.$raise($$($nesting, 'IndexError'), \"\" + \"index \" + (original) + \" outside of array bounds: -\" + (self.length) + \"...\" + (self.length));\n      }\n    \n    }, TMP_Array_fetch_50.$$arity = -2);\n    \n    Opal.def(self, '$fill', TMP_Array_fill_51 = function $$fill($a_rest) {\n      var $b, $c, self = this, args, $iter = TMP_Array_fill_51.$$p, block = $iter || nil, one = nil, two = nil, obj = nil, left = nil, right = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Array_fill_51.$$p = null;\n      \n            var i, length, value;;\n      if ($truthy(block)) {\n        \n        if ($truthy(args.length > 2)) {\n          self.$raise($$($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (args.$length()) + \" for 0..2)\")};\n        $c = args, $b = Opal.to_ary($c), (one = ($b[0] == null ? nil : $b[0])), (two = ($b[1] == null ? nil : $b[1])), $c;\n      } else {\n        \n        if ($truthy(args.length == 0)) {\n          self.$raise($$($nesting, 'ArgumentError'), \"wrong number of arguments (0 for 1..3)\")\n        } else if ($truthy(args.length > 3)) {\n          self.$raise($$($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (args.$length()) + \" for 1..3)\")};\n        $c = args, $b = Opal.to_ary($c), (obj = ($b[0] == null ? nil : $b[0])), (one = ($b[1] == null ? nil : $b[1])), (two = ($b[2] == null ? nil : $b[2])), $c;\n      };\n      if ($truthy($$($nesting, 'Range')['$==='](one))) {\n        \n        if ($truthy(two)) {\n          self.$raise($$($nesting, 'TypeError'), \"length invalid with range\")};\n        left = $$($nesting, 'Opal').$coerce_to(one.$begin(), $$($nesting, 'Integer'), \"to_int\");\n        if ($truthy(left < 0)) {\n          left += this.length};\n        if ($truthy(left < 0)) {\n          self.$raise($$($nesting, 'RangeError'), \"\" + (one.$inspect()) + \" out of range\")};\n        right = $$($nesting, 'Opal').$coerce_to(one.$end(), $$($nesting, 'Integer'), \"to_int\");\n        if ($truthy(right < 0)) {\n          right += this.length};\n        if ($truthy(one['$exclude_end?']())) {\n        } else {\n          right += 1\n        };\n        if ($truthy(right <= left)) {\n          return self};\n      } else if ($truthy(one)) {\n        \n        left = $$($nesting, 'Opal').$coerce_to(one, $$($nesting, 'Integer'), \"to_int\");\n        if ($truthy(left < 0)) {\n          left += this.length};\n        if ($truthy(left < 0)) {\n          left = 0};\n        if ($truthy(two)) {\n          \n          right = $$($nesting, 'Opal').$coerce_to(two, $$($nesting, 'Integer'), \"to_int\");\n          if ($truthy(right == 0)) {\n            return self};\n          right += left;\n        } else {\n          right = this.length\n        };\n      } else {\n        \n        left = 0;\n        right = this.length;\n      };\n      if ($truthy(left > this.length)) {\n        \n        for (i = this.length; i < right; i++) {\n          self[i] = nil;\n        }\n      };\n      if ($truthy(right > this.length)) {\n        this.length = right};\n      if ($truthy(block)) {\n        \n        for (length = this.length; left < right; left++) {\n          value = block(left);\n          self[left] = value;\n        }\n      \n      } else {\n        \n        for (length = this.length; left < right; left++) {\n          self[left] = obj;\n        }\n      \n      };\n      return self;\n    }, TMP_Array_fill_51.$$arity = -1);\n    \n    Opal.def(self, '$first', TMP_Array_first_52 = function $$first(count) {\n      var self = this;\n\n      \n      if (count == null) {\n        return self.length === 0 ? nil : self[0];\n      }\n\n      count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), \"to_int\");\n\n      if (count < 0) {\n        self.$raise($$($nesting, 'ArgumentError'), \"negative array size\");\n      }\n\n      return self.slice(0, count);\n    \n    }, TMP_Array_first_52.$$arity = -1);\n    \n    Opal.def(self, '$flatten', TMP_Array_flatten_53 = function $$flatten(level) {\n      var self = this;\n\n      \n      function _flatten(array, level) {\n        var result = [],\n            i, length,\n            item, ary;\n\n        array = (array).$to_a();\n\n        for (i = 0, length = array.length; i < length; i++) {\n          item = array[i];\n\n          if (!$$($nesting, 'Opal')['$respond_to?'](item, \"to_ary\", true)) {\n            result.push(item);\n            continue;\n          }\n\n          ary = (item).$to_ary();\n\n          if (ary === nil) {\n            result.push(item);\n            continue;\n          }\n\n          if (!ary.$$is_array) {\n            self.$raise($$($nesting, 'TypeError'));\n          }\n\n          if (ary === self) {\n            self.$raise($$($nesting, 'ArgumentError'));\n          }\n\n          switch (level) {\n          case undefined:\n            result = result.concat(_flatten(ary));\n            break;\n          case 0:\n            result.push(ary);\n            break;\n          default:\n            result.push.apply(result, _flatten(ary, level - 1));\n          }\n        }\n        return result;\n      }\n\n      if (level !== undefined) {\n        level = $$($nesting, 'Opal').$coerce_to(level, $$($nesting, 'Integer'), \"to_int\");\n      }\n\n      return toArraySubclass(_flatten(self, level), self.$class());\n    \n    }, TMP_Array_flatten_53.$$arity = -1);\n    \n    Opal.def(self, '$flatten!', TMP_Array_flatten$B_54 = function(level) {\n      var self = this;\n\n      \n      \n      var flattened = self.$flatten(level);\n\n      if (self.length == flattened.length) {\n        for (var i = 0, length = self.length; i < length; i++) {\n          if (self[i] !== flattened[i]) {\n            break;\n          }\n        }\n\n        if (i == length) {\n          return nil;\n        }\n      }\n\n      self.$replace(flattened);\n    ;\n      return self;\n    }, TMP_Array_flatten$B_54.$$arity = -1);\n    \n    Opal.def(self, '$hash', TMP_Array_hash_55 = function $$hash() {\n      var self = this;\n\n      \n      var top = (Opal.hash_ids === undefined),\n          result = ['A'],\n          hash_id = self.$object_id(),\n          item, i, key;\n\n      try {\n        if (top) {\n          Opal.hash_ids = Object.create(null);\n        }\n\n        // return early for recursive structures\n        if (Opal.hash_ids[hash_id]) {\n          return 'self';\n        }\n\n        for (key in Opal.hash_ids) {\n          item = Opal.hash_ids[key];\n          if (self['$eql?'](item)) {\n            return 'self';\n          }\n        }\n\n        Opal.hash_ids[hash_id] = self;\n\n        for (i = 0; i < self.length; i++) {\n          item = self[i];\n          result.push(item.$hash());\n        }\n\n        return result.join(',');\n      } finally {\n        if (top) {\n          Opal.hash_ids = undefined;\n        }\n      }\n    \n    }, TMP_Array_hash_55.$$arity = 0);\n    \n    Opal.def(self, '$include?', TMP_Array_include$q_56 = function(member) {\n      var self = this;\n\n      \n      for (var i = 0, length = self.length; i < length; i++) {\n        if ((self[i])['$=='](member)) {\n          return true;\n        }\n      }\n\n      return false;\n    \n    }, TMP_Array_include$q_56.$$arity = 1);\n    \n    Opal.def(self, '$index', TMP_Array_index_57 = function $$index(object) {\n      var self = this, $iter = TMP_Array_index_57.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_index_57.$$p = null;\n      \n      var i, length, value;\n\n      if (object != null && block !== nil) {\n        self.$warn(\"warning: given block not used\")\n      }\n\n      if (object != null) {\n        for (i = 0, length = self.length; i < length; i++) {\n          if ((self[i])['$=='](object)) {\n            return i;\n          }\n        }\n      }\n      else if (block !== nil) {\n        for (i = 0, length = self.length; i < length; i++) {\n          value = block(self[i]);\n\n          if (value !== false && value !== nil) {\n            return i;\n          }\n        }\n      }\n      else {\n        return self.$enum_for(\"index\");\n      }\n\n      return nil;\n    \n    }, TMP_Array_index_57.$$arity = -1);\n    \n    Opal.def(self, '$insert', TMP_Array_insert_58 = function $$insert(index, $a_rest) {\n      var self = this, objects;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      objects = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        objects[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      \n      \n      index = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), \"to_int\");\n\n      if (objects.length > 0) {\n        if (index < 0) {\n          index += self.length + 1;\n\n          if (index < 0) {\n            self.$raise($$($nesting, 'IndexError'), \"\" + (index) + \" is out of bounds\");\n          }\n        }\n        if (index > self.length) {\n          for (var i = self.length; i < index; i++) {\n            self.push(nil);\n          }\n        }\n\n        self.splice.apply(self, [index, 0].concat(objects));\n      }\n    ;\n      return self;\n    }, TMP_Array_insert_58.$$arity = -2);\n    \n    Opal.def(self, '$inspect', TMP_Array_inspect_59 = function $$inspect() {\n      var self = this;\n\n      \n      var result = [],\n          id     = self.$__id__();\n\n      for (var i = 0, length = self.length; i < length; i++) {\n        var item = self['$[]'](i);\n\n        if ((item).$__id__() === id) {\n          result.push('[...]');\n        }\n        else {\n          result.push((item).$inspect());\n        }\n      }\n\n      return '[' + result.join(', ') + ']';\n    \n    }, TMP_Array_inspect_59.$$arity = 0);\n    \n    Opal.def(self, '$join', TMP_Array_join_60 = function $$join(sep) {\n      var self = this;\n      if ($gvars[\",\"] == null) $gvars[\",\"] = nil;\n\n      if (sep == null) {\n        sep = nil;\n      }\n      \n      if ($truthy(self.length === 0)) {\n        return \"\"};\n      if ($truthy(sep === nil)) {\n        sep = $gvars[\",\"]};\n      \n      var result = [];\n      var i, length, item, tmp;\n\n      for (i = 0, length = self.length; i < length; i++) {\n        item = self[i];\n\n        if ($$($nesting, 'Opal')['$respond_to?'](item, \"to_str\")) {\n          tmp = (item).$to_str();\n\n          if (tmp !== nil) {\n            result.push((tmp).$to_s());\n\n            continue;\n          }\n        }\n\n        if ($$($nesting, 'Opal')['$respond_to?'](item, \"to_ary\")) {\n          tmp = (item).$to_ary();\n\n          if (tmp === self) {\n            self.$raise($$($nesting, 'ArgumentError'));\n          }\n\n          if (tmp !== nil) {\n            result.push((tmp).$join(sep));\n\n            continue;\n          }\n        }\n\n        if ($$($nesting, 'Opal')['$respond_to?'](item, \"to_s\")) {\n          tmp = (item).$to_s();\n\n          if (tmp !== nil) {\n            result.push(tmp);\n\n            continue;\n          }\n        }\n\n        self.$raise($$($nesting, 'NoMethodError').$new(\"\" + (Opal.inspect(item)) + \" doesn't respond to #to_str, #to_ary or #to_s\", \"to_str\"));\n      }\n\n      if (sep === nil) {\n        return result.join('');\n      }\n      else {\n        return result.join($$($nesting, 'Opal')['$coerce_to!'](sep, $$($nesting, 'String'), \"to_str\").$to_s());\n      }\n    ;\n    }, TMP_Array_join_60.$$arity = -1);\n    \n    Opal.def(self, '$keep_if', TMP_Array_keep_if_61 = function $$keep_if() {\n      var TMP_62, self = this, $iter = TMP_Array_keep_if_61.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_keep_if_61.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"keep_if\"], (TMP_62 = function(){var self = TMP_62.$$s || this;\n\n        return self.$size()}, TMP_62.$$s = self, TMP_62.$$arity = 0, TMP_62))\n      };\n      \n      for (var i = 0, length = self.length, value; i < length; i++) {\n        value = block(self[i]);\n\n        if (value === false || value === nil) {\n          self.splice(i, 1);\n\n          length--;\n          i--;\n        }\n      }\n    ;\n      return self;\n    }, TMP_Array_keep_if_61.$$arity = 0);\n    \n    Opal.def(self, '$last', TMP_Array_last_63 = function $$last(count) {\n      var self = this;\n\n      \n      if (count == null) {\n        return self.length === 0 ? nil : self[self.length - 1];\n      }\n\n      count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), \"to_int\");\n\n      if (count < 0) {\n        self.$raise($$($nesting, 'ArgumentError'), \"negative array size\");\n      }\n\n      if (count > self.length) {\n        count = self.length;\n      }\n\n      return self.slice(self.length - count, self.length);\n    \n    }, TMP_Array_last_63.$$arity = -1);\n    \n    Opal.def(self, '$length', TMP_Array_length_64 = function $$length() {\n      var self = this;\n\n      return self.length;\n    }, TMP_Array_length_64.$$arity = 0);\n    Opal.alias(self, \"map\", \"collect\");\n    Opal.alias(self, \"map!\", \"collect!\");\n    \n    Opal.def(self, '$max', TMP_Array_max_65 = function $$max(n) {\n      var self = this, $iter = TMP_Array_max_65.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_max_65.$$p = null;\n      return $send(self.$each(), 'max', [n], block.$to_proc())\n    }, TMP_Array_max_65.$$arity = -1);\n    \n    Opal.def(self, '$min', TMP_Array_min_66 = function $$min() {\n      var self = this, $iter = TMP_Array_min_66.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_min_66.$$p = null;\n      return $send(self.$each(), 'min', [], block.$to_proc())\n    }, TMP_Array_min_66.$$arity = 0);\n    \n    // Returns the product of from, from-1, ..., from - how_many + 1.\n    function descending_factorial(from, how_many) {\n      var count = how_many >= 0 ? 1 : 0;\n      while (how_many) {\n        count *= from;\n        from--;\n        how_many--;\n      }\n      return count;\n    }\n  ;\n    \n    Opal.def(self, '$permutation', TMP_Array_permutation_67 = function $$permutation(num) {\n      var TMP_68, self = this, $iter = TMP_Array_permutation_67.$$p, block = $iter || nil, perm = nil, used = nil;\n\n      if ($iter) TMP_Array_permutation_67.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"permutation\", num], (TMP_68 = function(){var self = TMP_68.$$s || this;\n\n        return descending_factorial(self.length, num === undefined ? self.length : num);}, TMP_68.$$s = self, TMP_68.$$arity = 0, TMP_68))\n      };\n      \n      var permute, offensive, output;\n\n      if (num === undefined) {\n        num = self.length;\n      }\n      else {\n        num = $$($nesting, 'Opal').$coerce_to(num, $$($nesting, 'Integer'), \"to_int\")\n      }\n\n      if (num < 0 || self.length < num) {\n        // no permutations, yield nothing\n      }\n      else if (num === 0) {\n        // exactly one permutation: the zero-length array\n        Opal.yield1(block, [])\n      }\n      else if (num === 1) {\n        // this is a special, easy case\n        for (var i = 0; i < self.length; i++) {\n          Opal.yield1(block, [self[i]])\n        }\n      }\n      else {\n        // this is the general case\n        (perm = $$($nesting, 'Array').$new(num));\n        (used = $$($nesting, 'Array').$new(self.length, false));\n\n        permute = function(num, perm, index, used, blk) {\n          self = this;\n          for(var i = 0; i < self.length; i++){\n            if(used['$[]'](i)['$!']()) {\n              perm[index] = i;\n              if(index < num - 1) {\n                used[i] = true;\n                permute.call(self, num, perm, index + 1, used, blk);\n                used[i] = false;\n              }\n              else {\n                output = [];\n                for (var j = 0; j < perm.length; j++) {\n                  output.push(self[perm[j]]);\n                }\n                Opal.yield1(blk, output);\n              }\n            }\n          }\n        }\n\n        if ((block !== nil)) {\n          // offensive (both definitions) copy.\n          offensive = self.slice();\n          permute.call(offensive, num, perm, 0, used, block);\n        }\n        else {\n          permute.call(self, num, perm, 0, used, block);\n        }\n      }\n    ;\n      return self;\n    }, TMP_Array_permutation_67.$$arity = -1);\n    \n    Opal.def(self, '$repeated_permutation', TMP_Array_repeated_permutation_69 = function $$repeated_permutation(n) {\n      var TMP_70, self = this, $iter = TMP_Array_repeated_permutation_69.$$p, $yield = $iter || nil, num = nil;\n\n      if ($iter) TMP_Array_repeated_permutation_69.$$p = null;\n      \n      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), \"to_int\");\n      if (($yield !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"repeated_permutation\", num], (TMP_70 = function(){var self = TMP_70.$$s || this;\n\n        if ($truthy($rb_ge(num, 0))) {\n            return self.$size()['$**'](num)\n          } else {\n            return 0\n          }}, TMP_70.$$s = self, TMP_70.$$arity = 0, TMP_70))\n      };\n      \n      function iterate(max, buffer, self) {\n        if (buffer.length == max) {\n          var copy = buffer.slice();\n          Opal.yield1($yield, copy)\n          return;\n        }\n        for (var i = 0; i < self.length; i++) {\n          buffer.push(self[i]);\n          iterate(max, buffer, self);\n          buffer.pop();\n        }\n      }\n\n      iterate(num, [], self.slice());\n    ;\n      return self;\n    }, TMP_Array_repeated_permutation_69.$$arity = 1);\n    \n    Opal.def(self, '$pop', TMP_Array_pop_71 = function $$pop(count) {\n      var self = this;\n\n      \n      if ($truthy(count === undefined)) {\n        \n        if ($truthy(self.length === 0)) {\n          return nil};\n        return self.pop();};\n      count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), \"to_int\");\n      if ($truthy(count < 0)) {\n        self.$raise($$($nesting, 'ArgumentError'), \"negative array size\")};\n      if ($truthy(self.length === 0)) {\n        return []};\n      if ($truthy(count > self.length)) {\n        return self.splice(0, self.length);\n      } else {\n        return self.splice(self.length - count, self.length);\n      };\n    }, TMP_Array_pop_71.$$arity = -1);\n    \n    Opal.def(self, '$product', TMP_Array_product_72 = function $$product($a_rest) {\n      var self = this, args, $iter = TMP_Array_product_72.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Array_product_72.$$p = null;\n      \n      var result = (block !== nil) ? null : [],\n          n = args.length + 1,\n          counters = new Array(n),\n          lengths  = new Array(n),\n          arrays   = new Array(n),\n          i, m, subarray, len, resultlen = 1;\n\n      arrays[0] = self;\n      for (i = 1; i < n; i++) {\n        arrays[i] = $$($nesting, 'Opal').$coerce_to(args[i - 1], $$($nesting, 'Array'), \"to_ary\");\n      }\n\n      for (i = 0; i < n; i++) {\n        len = arrays[i].length;\n        if (len === 0) {\n          return result || self;\n        }\n        resultlen *= len;\n        if (resultlen > 2147483647) {\n          self.$raise($$($nesting, 'RangeError'), \"too big to product\")\n        }\n        lengths[i] = len;\n        counters[i] = 0;\n      }\n\n      outer_loop: for (;;) {\n        subarray = [];\n        for (i = 0; i < n; i++) {\n          subarray.push(arrays[i][counters[i]]);\n        }\n        if (result) {\n          result.push(subarray);\n        } else {\n          Opal.yield1(block, subarray)\n        }\n        m = n - 1;\n        counters[m]++;\n        while (counters[m] === lengths[m]) {\n          counters[m] = 0;\n          if (--m < 0) break outer_loop;\n          counters[m]++;\n        }\n      }\n\n      return result || self;\n    \n    }, TMP_Array_product_72.$$arity = -1);\n    \n    Opal.def(self, '$push', TMP_Array_push_73 = function $$push($a_rest) {\n      var self = this, objects;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      objects = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        objects[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      \n      for (var i = 0, length = objects.length; i < length; i++) {\n        self.push(objects[i]);\n      }\n    ;\n      return self;\n    }, TMP_Array_push_73.$$arity = -1);\n    Opal.alias(self, \"append\", \"push\");\n    \n    Opal.def(self, '$rassoc', TMP_Array_rassoc_74 = function $$rassoc(object) {\n      var self = this;\n\n      \n      for (var i = 0, length = self.length, item; i < length; i++) {\n        item = self[i];\n\n        if (item.length && item[1] !== undefined) {\n          if ((item[1])['$=='](object)) {\n            return item;\n          }\n        }\n      }\n\n      return nil;\n    \n    }, TMP_Array_rassoc_74.$$arity = 1);\n    \n    Opal.def(self, '$reject', TMP_Array_reject_75 = function $$reject() {\n      var TMP_76, self = this, $iter = TMP_Array_reject_75.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_reject_75.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"reject\"], (TMP_76 = function(){var self = TMP_76.$$s || this;\n\n        return self.$size()}, TMP_76.$$s = self, TMP_76.$$arity = 0, TMP_76))\n      };\n      \n      var result = [];\n\n      for (var i = 0, length = self.length, value; i < length; i++) {\n        value = block(self[i]);\n\n        if (value === false || value === nil) {\n          result.push(self[i]);\n        }\n      }\n      return result;\n    ;\n    }, TMP_Array_reject_75.$$arity = 0);\n    \n    Opal.def(self, '$reject!', TMP_Array_reject$B_77 = function() {\n      var TMP_78, self = this, $iter = TMP_Array_reject$B_77.$$p, block = $iter || nil, original = nil;\n\n      if ($iter) TMP_Array_reject$B_77.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"reject!\"], (TMP_78 = function(){var self = TMP_78.$$s || this;\n\n        return self.$size()}, TMP_78.$$s = self, TMP_78.$$arity = 0, TMP_78))\n      };\n      original = self.$length();\n      $send(self, 'delete_if', [], block.$to_proc());\n      if (self.$length()['$=='](original)) {\n        return nil\n      } else {\n        return self\n      };\n    }, TMP_Array_reject$B_77.$$arity = 0);\n    \n    Opal.def(self, '$replace', TMP_Array_replace_79 = function $$replace(other) {\n      var self = this;\n\n      \n      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {\n        return other.$to_a()\n      } else {\n        return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), \"to_ary\").$to_a()\n      }; return nil; })();\n      \n      self.splice(0, self.length);\n      self.push.apply(self, other);\n    ;\n      return self;\n    }, TMP_Array_replace_79.$$arity = 1);\n    \n    Opal.def(self, '$reverse', TMP_Array_reverse_80 = function $$reverse() {\n      var self = this;\n\n      return self.slice(0).reverse();\n    }, TMP_Array_reverse_80.$$arity = 0);\n    \n    Opal.def(self, '$reverse!', TMP_Array_reverse$B_81 = function() {\n      var self = this;\n\n      return self.reverse();\n    }, TMP_Array_reverse$B_81.$$arity = 0);\n    \n    Opal.def(self, '$reverse_each', TMP_Array_reverse_each_82 = function $$reverse_each() {\n      var TMP_83, self = this, $iter = TMP_Array_reverse_each_82.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_reverse_each_82.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"reverse_each\"], (TMP_83 = function(){var self = TMP_83.$$s || this;\n\n        return self.$size()}, TMP_83.$$s = self, TMP_83.$$arity = 0, TMP_83))\n      };\n      $send(self.$reverse(), 'each', [], block.$to_proc());\n      return self;\n    }, TMP_Array_reverse_each_82.$$arity = 0);\n    \n    Opal.def(self, '$rindex', TMP_Array_rindex_84 = function $$rindex(object) {\n      var self = this, $iter = TMP_Array_rindex_84.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_rindex_84.$$p = null;\n      \n      var i, value;\n\n      if (object != null && block !== nil) {\n        self.$warn(\"warning: given block not used\")\n      }\n\n      if (object != null) {\n        for (i = self.length - 1; i >= 0; i--) {\n          if (i >= self.length) {\n            break;\n          }\n          if ((self[i])['$=='](object)) {\n            return i;\n          }\n        }\n      }\n      else if (block !== nil) {\n        for (i = self.length - 1; i >= 0; i--) {\n          if (i >= self.length) {\n            break;\n          }\n\n          value = block(self[i]);\n\n          if (value !== false && value !== nil) {\n            return i;\n          }\n        }\n      }\n      else if (object == null) {\n        return self.$enum_for(\"rindex\");\n      }\n\n      return nil;\n    \n    }, TMP_Array_rindex_84.$$arity = -1);\n    \n    Opal.def(self, '$rotate', TMP_Array_rotate_85 = function $$rotate(n) {\n      var self = this;\n\n      if (n == null) {\n        n = 1;\n      }\n      \n      n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), \"to_int\");\n      \n      var ary, idx, firstPart, lastPart;\n\n      if (self.length === 1) {\n        return self.slice();\n      }\n      if (self.length === 0) {\n        return [];\n      }\n\n      ary = self.slice();\n      idx = n % ary.length;\n\n      firstPart = ary.slice(idx);\n      lastPart = ary.slice(0, idx);\n      return firstPart.concat(lastPart);\n    ;\n    }, TMP_Array_rotate_85.$$arity = -1);\n    \n    Opal.def(self, '$rotate!', TMP_Array_rotate$B_86 = function(cnt) {\n      var self = this, ary = nil;\n\n      if (cnt == null) {\n        cnt = 1;\n      }\n      \n      \n      if (self.length === 0 || self.length === 1) {\n        return self;\n      }\n    ;\n      cnt = $$($nesting, 'Opal').$coerce_to(cnt, $$($nesting, 'Integer'), \"to_int\");\n      ary = self.$rotate(cnt);\n      return self.$replace(ary);\n    }, TMP_Array_rotate$B_86.$$arity = -1);\n    (function($base, $super, $parent_nesting) {\n      function $SampleRandom(){};\n      var self = $SampleRandom = $klass($base, $super, 'SampleRandom', $SampleRandom);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_SampleRandom_initialize_87, TMP_SampleRandom_rand_88;\n\n      def.rng = nil;\n      \n      \n      Opal.def(self, '$initialize', TMP_SampleRandom_initialize_87 = function $$initialize(rng) {\n        var self = this;\n\n        return (self.rng = rng)\n      }, TMP_SampleRandom_initialize_87.$$arity = 1);\n      return (Opal.def(self, '$rand', TMP_SampleRandom_rand_88 = function $$rand(size) {\n        var self = this, random = nil;\n\n        \n        random = $$($nesting, 'Opal').$coerce_to(self.rng.$rand(size), $$($nesting, 'Integer'), \"to_int\");\n        if ($truthy(random < 0)) {\n          self.$raise($$($nesting, 'RangeError'), \"random value must be >= 0\")};\n        if ($truthy(random < size)) {\n        } else {\n          self.$raise($$($nesting, 'RangeError'), \"random value must be less than Array size\")\n        };\n        return random;\n      }, TMP_SampleRandom_rand_88.$$arity = 1), nil) && 'rand';\n    })($nesting[0], null, $nesting);\n    \n    Opal.def(self, '$sample', TMP_Array_sample_89 = function $$sample(count, options) {\n      var $a, self = this, o = nil, rng = nil;\n\n      \n      if ($truthy(count === undefined)) {\n        return self.$at($$($nesting, 'Kernel').$rand(self.length))};\n      if ($truthy(options === undefined)) {\n        if ($truthy((o = $$($nesting, 'Opal')['$coerce_to?'](count, $$($nesting, 'Hash'), \"to_hash\")))) {\n          \n          options = o;\n          count = nil;\n        } else {\n          \n          options = nil;\n          count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), \"to_int\");\n        }\n      } else {\n        \n        count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), \"to_int\");\n        options = $$($nesting, 'Opal').$coerce_to(options, $$($nesting, 'Hash'), \"to_hash\");\n      };\n      if ($truthy(($truthy($a = count) ? count < 0 : $a))) {\n        self.$raise($$($nesting, 'ArgumentError'), \"count must be greater than 0\")};\n      if ($truthy(options)) {\n        rng = options['$[]'](\"random\")};\n      rng = (function() {if ($truthy(($truthy($a = rng) ? rng['$respond_to?'](\"rand\") : $a))) {\n        return $$($nesting, 'SampleRandom').$new(rng)\n      } else {\n        return $$($nesting, 'Kernel')\n      }; return nil; })();\n      if ($truthy(count)) {\n      } else {\n        return self[rng.$rand(self.length)]\n      };\n      \n\n      var abandon, spin, result, i, j, k, targetIndex, oldValue;\n\n      if (count > self.length) {\n        count = self.length;\n      }\n\n      switch (count) {\n        case 0:\n          return [];\n          break;\n        case 1:\n          return [self[rng.$rand(self.length)]];\n          break;\n        case 2:\n          i = rng.$rand(self.length);\n          j = rng.$rand(self.length);\n          if (i === j) {\n            j = i === 0 ? i + 1 : i - 1;\n          }\n          return [self[i], self[j]];\n          break;\n        default:\n          if (self.length / count > 3) {\n            abandon = false;\n            spin = 0;\n\n            result = $$($nesting, 'Array').$new(count);\n            i = 1;\n\n            result[0] = rng.$rand(self.length);\n            while (i < count) {\n              k = rng.$rand(self.length);\n              j = 0;\n\n              while (j < i) {\n                while (k === result[j]) {\n                  spin++;\n                  if (spin > 100) {\n                    abandon = true;\n                    break;\n                  }\n                  k = rng.$rand(self.length);\n                }\n                if (abandon) { break; }\n\n                j++;\n              }\n\n              if (abandon) { break; }\n\n              result[i] = k;\n\n              i++;\n            }\n\n            if (!abandon) {\n              i = 0;\n              while (i < count) {\n                result[i] = self[result[i]];\n                i++;\n              }\n\n              return result;\n            }\n          }\n\n          result = self.slice();\n\n          for (var c = 0; c < count; c++) {\n            targetIndex = rng.$rand(self.length);\n            oldValue = result[c];\n            result[c] = result[targetIndex];\n            result[targetIndex] = oldValue;\n          }\n\n          return count === self.length ? result : (result)['$[]'](0, count);\n      }\n    ;\n    }, TMP_Array_sample_89.$$arity = -1);\n    \n    Opal.def(self, '$select', TMP_Array_select_90 = function $$select() {\n      var TMP_91, self = this, $iter = TMP_Array_select_90.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_select_90.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"select\"], (TMP_91 = function(){var self = TMP_91.$$s || this;\n\n        return self.$size()}, TMP_91.$$s = self, TMP_91.$$arity = 0, TMP_91))\n      };\n      \n      var result = [];\n\n      for (var i = 0, length = self.length, item, value; i < length; i++) {\n        item = self[i];\n\n        value = Opal.yield1(block, item);\n\n        if (value !== false && value !== nil) {\n          result.push(item);\n        }\n      }\n\n      return result;\n    ;\n    }, TMP_Array_select_90.$$arity = 0);\n    \n    Opal.def(self, '$select!', TMP_Array_select$B_92 = function() {\n      var TMP_93, self = this, $iter = TMP_Array_select$B_92.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_select$B_92.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"select!\"], (TMP_93 = function(){var self = TMP_93.$$s || this;\n\n        return self.$size()}, TMP_93.$$s = self, TMP_93.$$arity = 0, TMP_93))\n      };\n      \n      var original = self.length;\n      $send(self, 'keep_if', [], block.$to_proc());\n      return self.length === original ? nil : self;\n    ;\n    }, TMP_Array_select$B_92.$$arity = 0);\n    \n    Opal.def(self, '$shift', TMP_Array_shift_94 = function $$shift(count) {\n      var self = this;\n\n      \n      if ($truthy(count === undefined)) {\n        \n        if ($truthy(self.length === 0)) {\n          return nil};\n        return self.shift();};\n      count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), \"to_int\");\n      if ($truthy(count < 0)) {\n        self.$raise($$($nesting, 'ArgumentError'), \"negative array size\")};\n      if ($truthy(self.length === 0)) {\n        return []};\n      return self.splice(0, count);;\n    }, TMP_Array_shift_94.$$arity = -1);\n    Opal.alias(self, \"size\", \"length\");\n    \n    Opal.def(self, '$shuffle', TMP_Array_shuffle_95 = function $$shuffle(rng) {\n      var self = this;\n\n      return self.$dup().$to_a()['$shuffle!'](rng)\n    }, TMP_Array_shuffle_95.$$arity = -1);\n    \n    Opal.def(self, '$shuffle!', TMP_Array_shuffle$B_96 = function(rng) {\n      var self = this;\n\n      \n      var randgen, i = self.length, j, tmp;\n\n      if (rng !== undefined) {\n        rng = $$($nesting, 'Opal')['$coerce_to?'](rng, $$($nesting, 'Hash'), \"to_hash\");\n\n        if (rng !== nil) {\n          rng = rng['$[]'](\"random\");\n\n          if (rng !== nil && rng['$respond_to?'](\"rand\")) {\n            randgen = rng;\n          }\n        }\n      }\n\n      while (i) {\n        if (randgen) {\n          j = randgen.$rand(i).$to_int();\n\n          if (j < 0) {\n            self.$raise($$($nesting, 'RangeError'), \"\" + \"random number too small \" + (j))\n          }\n\n          if (j >= i) {\n            self.$raise($$($nesting, 'RangeError'), \"\" + \"random number too big \" + (j))\n          }\n        }\n        else {\n          j = self.$rand(i);\n        }\n\n        tmp = self[--i];\n        self[i] = self[j];\n        self[j] = tmp;\n      }\n\n      return self;\n    \n    }, TMP_Array_shuffle$B_96.$$arity = -1);\n    Opal.alias(self, \"slice\", \"[]\");\n    \n    Opal.def(self, '$slice!', TMP_Array_slice$B_97 = function(index, length) {\n      var self = this, result = nil, range = nil, range_start = nil, range_end = nil, start = nil;\n\n      \n      result = nil;\n      if ($truthy(length === undefined)) {\n        if ($truthy($$($nesting, 'Range')['$==='](index))) {\n          \n          range = index;\n          result = self['$[]'](range);\n          range_start = $$($nesting, 'Opal').$coerce_to(range.$begin(), $$($nesting, 'Integer'), \"to_int\");\n          range_end = $$($nesting, 'Opal').$coerce_to(range.$end(), $$($nesting, 'Integer'), \"to_int\");\n          \n          if (range_start < 0) {\n            range_start += self.length;\n          }\n\n          if (range_end < 0) {\n            range_end += self.length;\n          } else if (range_end >= self.length) {\n            range_end = self.length - 1;\n            if (range.excl) {\n              range_end += 1;\n            }\n          }\n\n          var range_length = range_end - range_start;\n          if (range.excl) {\n            range_end -= 1;\n          } else {\n            range_length += 1;\n          }\n\n          if (range_start < self.length && range_start >= 0 && range_end < self.length && range_end >= 0 && range_length > 0) {\n            self.splice(range_start, range_length);\n          }\n        ;\n        } else {\n          \n          start = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), \"to_int\");\n          \n          if (start < 0) {\n            start += self.length;\n          }\n\n          if (start < 0 || start >= self.length) {\n            return nil;\n          }\n\n          result = self[start];\n\n          if (start === 0) {\n            self.shift();\n          } else {\n            self.splice(start, 1);\n          }\n        ;\n        }\n      } else {\n        \n        start = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), \"to_int\");\n        length = $$($nesting, 'Opal').$coerce_to(length, $$($nesting, 'Integer'), \"to_int\");\n        \n        if (length < 0) {\n          return nil;\n        }\n\n        var end = start + length;\n\n        result = self['$[]'](start, length);\n\n        if (start < 0) {\n          start += self.length;\n        }\n\n        if (start + length > self.length) {\n          length = self.length - start;\n        }\n\n        if (start < self.length && start >= 0) {\n          self.splice(start, length);\n        }\n      ;\n      };\n      return result;\n    }, TMP_Array_slice$B_97.$$arity = -2);\n    \n    Opal.def(self, '$sort', TMP_Array_sort_98 = function $$sort() {\n      var self = this, $iter = TMP_Array_sort_98.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_sort_98.$$p = null;\n      \n      if ($truthy(self.length > 1)) {\n      } else {\n        return self\n      };\n      \n      if (block === nil) {\n        block = function(a, b) {\n          return (a)['$<=>'](b);\n        };\n      }\n\n      return self.slice().sort(function(x, y) {\n        var ret = block(x, y);\n\n        if (ret === nil) {\n          self.$raise($$($nesting, 'ArgumentError'), \"\" + \"comparison of \" + ((x).$inspect()) + \" with \" + ((y).$inspect()) + \" failed\");\n        }\n\n        return $rb_gt(ret, 0) ? 1 : ($rb_lt(ret, 0) ? -1 : 0);\n      });\n    ;\n    }, TMP_Array_sort_98.$$arity = 0);\n    \n    Opal.def(self, '$sort!', TMP_Array_sort$B_99 = function() {\n      var self = this, $iter = TMP_Array_sort$B_99.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_sort$B_99.$$p = null;\n      \n      var result;\n\n      if ((block !== nil)) {\n        result = $send((self.slice()), 'sort', [], block.$to_proc());\n      }\n      else {\n        result = (self.slice()).$sort();\n      }\n\n      self.length = 0;\n      for(var i = 0, length = result.length; i < length; i++) {\n        self.push(result[i]);\n      }\n\n      return self;\n    \n    }, TMP_Array_sort$B_99.$$arity = 0);\n    \n    Opal.def(self, '$sort_by!', TMP_Array_sort_by$B_100 = function() {\n      var TMP_101, self = this, $iter = TMP_Array_sort_by$B_100.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_sort_by$B_100.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"sort_by!\"], (TMP_101 = function(){var self = TMP_101.$$s || this;\n\n        return self.$size()}, TMP_101.$$s = self, TMP_101.$$arity = 0, TMP_101))\n      };\n      return self.$replace($send(self, 'sort_by', [], block.$to_proc()));\n    }, TMP_Array_sort_by$B_100.$$arity = 0);\n    \n    Opal.def(self, '$take', TMP_Array_take_102 = function $$take(count) {\n      var self = this;\n\n      \n      if (count < 0) {\n        self.$raise($$($nesting, 'ArgumentError'));\n      }\n\n      return self.slice(0, count);\n    \n    }, TMP_Array_take_102.$$arity = 1);\n    \n    Opal.def(self, '$take_while', TMP_Array_take_while_103 = function $$take_while() {\n      var self = this, $iter = TMP_Array_take_while_103.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_take_while_103.$$p = null;\n      \n      var result = [];\n\n      for (var i = 0, length = self.length, item, value; i < length; i++) {\n        item = self[i];\n\n        value = block(item);\n\n        if (value === false || value === nil) {\n          return result;\n        }\n\n        result.push(item);\n      }\n\n      return result;\n    \n    }, TMP_Array_take_while_103.$$arity = 0);\n    \n    Opal.def(self, '$to_a', TMP_Array_to_a_104 = function $$to_a() {\n      var self = this;\n\n      return self\n    }, TMP_Array_to_a_104.$$arity = 0);\n    Opal.alias(self, \"to_ary\", \"to_a\");\n    \n    Opal.def(self, '$to_h', TMP_Array_to_h_105 = function $$to_h() {\n      var self = this;\n\n      \n      var i, len = self.length, ary, key, val, hash = $hash2([], {});\n\n      for (i = 0; i < len; i++) {\n        ary = $$($nesting, 'Opal')['$coerce_to?'](self[i], $$($nesting, 'Array'), \"to_ary\");\n        if (!ary.$$is_array) {\n          self.$raise($$($nesting, 'TypeError'), \"\" + \"wrong element type \" + ((ary).$class()) + \" at \" + (i) + \" (expected array)\")\n        }\n        if (ary.length !== 2) {\n          self.$raise($$($nesting, 'ArgumentError'), \"\" + \"wrong array length at \" + (i) + \" (expected 2, was \" + ((ary).$length()) + \")\")\n        }\n        key = ary[0];\n        val = ary[1];\n        Opal.hash_put(hash, key, val);\n      }\n\n      return hash;\n    \n    }, TMP_Array_to_h_105.$$arity = 0);\n    Opal.alias(self, \"to_s\", \"inspect\");\n    \n    Opal.def(self, '$transpose', TMP_Array_transpose_108 = function $$transpose() {\n      var TMP_106, self = this, result = nil, max = nil;\n\n      \n      if ($truthy(self['$empty?']())) {\n        return []};\n      result = [];\n      max = nil;\n      $send(self, 'each', [], (TMP_106 = function(row){var self = TMP_106.$$s || this, $a, TMP_107;\nif (row == null) row = nil;\n      \n        row = (function() {if ($truthy($$($nesting, 'Array')['$==='](row))) {\n          return row.$to_a()\n        } else {\n          return $$($nesting, 'Opal').$coerce_to(row, $$($nesting, 'Array'), \"to_ary\").$to_a()\n        }; return nil; })();\n        max = ($truthy($a = max) ? $a : row.length);\n        if ($truthy((row.length)['$!='](max))) {\n          self.$raise($$($nesting, 'IndexError'), \"\" + \"element size differs (\" + (row.length) + \" should be \" + (max) + \")\")};\n        return $send((row.length), 'times', [], (TMP_107 = function(i){var self = TMP_107.$$s || this, $b, entry = nil, $writer = nil;\nif (i == null) i = nil;\n        \n          entry = ($truthy($b = result['$[]'](i)) ? $b : (($writer = [i, []]), $send(result, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n          return entry['$<<'](row.$at(i));}, TMP_107.$$s = self, TMP_107.$$arity = 1, TMP_107));}, TMP_106.$$s = self, TMP_106.$$arity = 1, TMP_106));\n      return result;\n    }, TMP_Array_transpose_108.$$arity = 0);\n    \n    Opal.def(self, '$uniq', TMP_Array_uniq_109 = function $$uniq() {\n      var self = this, $iter = TMP_Array_uniq_109.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_uniq_109.$$p = null;\n      \n      var hash = $hash2([], {}), i, length, item, key;\n\n      if (block === nil) {\n        for (i = 0, length = self.length; i < length; i++) {\n          item = self[i];\n          if (Opal.hash_get(hash, item) === undefined) {\n            Opal.hash_put(hash, item, item);\n          }\n        }\n      }\n      else {\n        for (i = 0, length = self.length; i < length; i++) {\n          item = self[i];\n          key = Opal.yield1(block, item);\n          if (Opal.hash_get(hash, key) === undefined) {\n            Opal.hash_put(hash, key, item);\n          }\n        }\n      }\n\n      return toArraySubclass((hash).$values(), self.$class());\n    \n    }, TMP_Array_uniq_109.$$arity = 0);\n    \n    Opal.def(self, '$uniq!', TMP_Array_uniq$B_110 = function() {\n      var self = this, $iter = TMP_Array_uniq$B_110.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Array_uniq$B_110.$$p = null;\n      \n      var original_length = self.length, hash = $hash2([], {}), i, length, item, key;\n\n      for (i = 0, length = original_length; i < length; i++) {\n        item = self[i];\n        key = (block === nil ? item : Opal.yield1(block, item));\n\n        if (Opal.hash_get(hash, key) === undefined) {\n          Opal.hash_put(hash, key, item);\n          continue;\n        }\n\n        self.splice(i, 1);\n        length--;\n        i--;\n      }\n\n      return self.length === original_length ? nil : self;\n    \n    }, TMP_Array_uniq$B_110.$$arity = 0);\n    \n    Opal.def(self, '$unshift', TMP_Array_unshift_111 = function $$unshift($a_rest) {\n      var self = this, objects;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      objects = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        objects[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      \n      for (var i = objects.length - 1; i >= 0; i--) {\n        self.unshift(objects[i]);\n      }\n    ;\n      return self;\n    }, TMP_Array_unshift_111.$$arity = -1);\n    Opal.alias(self, \"prepend\", \"unshift\");\n    \n    Opal.def(self, '$values_at', TMP_Array_values_at_114 = function $$values_at($a_rest) {\n      var TMP_112, self = this, args, out = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      out = [];\n      $send(args, 'each', [], (TMP_112 = function(elem){var self = TMP_112.$$s || this, TMP_113, finish = nil, start = nil, i = nil;\nif (elem == null) elem = nil;\n      if ($truthy(elem['$is_a?']($$($nesting, 'Range')))) {\n          \n          finish = $$($nesting, 'Opal').$coerce_to(elem.$last(), $$($nesting, 'Integer'), \"to_int\");\n          start = $$($nesting, 'Opal').$coerce_to(elem.$first(), $$($nesting, 'Integer'), \"to_int\");\n          \n          if (start < 0) {\n            start = start + self.length;\n            return nil;;\n          }\n        ;\n          \n          if (finish < 0) {\n            finish = finish + self.length;\n          }\n          if (elem['$exclude_end?']()) {\n            finish--;\n          }\n          if (finish < start) {\n            return nil;;\n          }\n        ;\n          return $send(start, 'upto', [finish], (TMP_113 = function(i){var self = TMP_113.$$s || this;\nif (i == null) i = nil;\n          return out['$<<'](self.$at(i))}, TMP_113.$$s = self, TMP_113.$$arity = 1, TMP_113));\n        } else {\n          \n          i = $$($nesting, 'Opal').$coerce_to(elem, $$($nesting, 'Integer'), \"to_int\");\n          return out['$<<'](self.$at(i));\n        }}, TMP_112.$$s = self, TMP_112.$$arity = 1, TMP_112));\n      return out;\n    }, TMP_Array_values_at_114.$$arity = -1);\n    \n    Opal.def(self, '$zip', TMP_Array_zip_115 = function $$zip($a_rest) {\n      var $b, self = this, others, $iter = TMP_Array_zip_115.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      others = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        others[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Array_zip_115.$$p = null;\n      \n      var result = [], size = self.length, part, o, i, j, jj;\n\n      for (j = 0, jj = others.length; j < jj; j++) {\n        o = others[j];\n        if (o.$$is_array) {\n          continue;\n        }\n        if (o.$$is_enumerator) {\n          if (o.$size() === Infinity) {\n            others[j] = o.$take(size);\n          } else {\n            others[j] = o.$to_a();\n          }\n          continue;\n        }\n        others[j] = ($truthy($b = $$($nesting, 'Opal')['$coerce_to?'](o, $$($nesting, 'Array'), \"to_ary\")) ? $b : $$($nesting, 'Opal')['$coerce_to!'](o, $$($nesting, 'Enumerator'), \"each\")).$to_a();\n      }\n\n      for (i = 0; i < size; i++) {\n        part = [self[i]];\n\n        for (j = 0, jj = others.length; j < jj; j++) {\n          o = others[j][i];\n\n          if (o == null) {\n            o = nil;\n          }\n\n          part[j + 1] = o;\n        }\n\n        result[i] = part;\n      }\n\n      if (block !== nil) {\n        for (i = 0; i < size; i++) {\n          block(result[i]);\n        }\n\n        return nil;\n      }\n\n      return result;\n    \n    }, TMP_Array_zip_115.$$arity = -1);\n    Opal.defs(self, '$inherited', TMP_Array_inherited_116 = function $$inherited(klass) {\n      var self = this;\n\n      \n      klass.$$proto.$to_a = function() {\n        return this.slice(0, this.length);\n      }\n    \n    }, TMP_Array_inherited_116.$$arity = 1);\n    \n    Opal.def(self, '$instance_variables', TMP_Array_instance_variables_117 = function $$instance_variables() {\n      var TMP_118, self = this, $iter = TMP_Array_instance_variables_117.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Array_instance_variables_117.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      return $send($send(self, Opal.find_super_dispatcher(self, 'instance_variables', TMP_Array_instance_variables_117, false), $zuper, $iter), 'reject', [], (TMP_118 = function(ivar){var self = TMP_118.$$s || this, $a;\nif (ivar == null) ivar = nil;\n      return ($truthy($a = /^@\\d+$/.test(ivar)) ? $a : ivar['$=='](\"@length\"))}, TMP_118.$$s = self, TMP_118.$$arity = 1, TMP_118))\n    }, TMP_Array_instance_variables_117.$$arity = 0);\n    $$($nesting, 'Opal').$pristine(self.$singleton_class(), \"allocate\");\n    $$($nesting, 'Opal').$pristine(self, \"copy_instance_variables\", \"initialize_dup\");\n    return (Opal.def(self, '$pack', TMP_Array_pack_119 = function $$pack($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return self.$raise(\"To use Array#pack, you must first require 'corelib/array/pack'.\")\n    }, TMP_Array_pack_119.$$arity = -1), nil) && 'pack';\n  })($nesting[0], Array, $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/hash\"] = function(Opal) {\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$include', '$coerce_to?', '$[]', '$merge!', '$allocate', '$raise', '$coerce_to!', '$each', '$fetch', '$>=', '$>', '$==', '$compare_by_identity', '$lambda?', '$abs', '$arity', '$enum_for', '$size', '$respond_to?', '$class', '$dig', '$new', '$inspect', '$map', '$to_proc', '$flatten', '$eql?', '$default', '$dup', '$default_proc', '$default_proc=', '$-', '$default=', '$proc']);\n  \n  self.$require(\"corelib/enumerable\");\n  return (function($base, $super, $parent_nesting) {\n    function $Hash(){};\n    var self = $Hash = $klass($base, $super, 'Hash', $Hash);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Hash_$$_1, TMP_Hash_allocate_2, TMP_Hash_try_convert_3, TMP_Hash_initialize_4, TMP_Hash_$eq$eq_5, TMP_Hash_$gt$eq_7, TMP_Hash_$gt_8, TMP_Hash_$lt_9, TMP_Hash_$lt$eq_10, TMP_Hash_$$_11, TMP_Hash_$$$eq_12, TMP_Hash_assoc_13, TMP_Hash_clear_14, TMP_Hash_clone_15, TMP_Hash_compact_16, TMP_Hash_compact$B_17, TMP_Hash_compare_by_identity_18, TMP_Hash_compare_by_identity$q_19, TMP_Hash_default_20, TMP_Hash_default$eq_21, TMP_Hash_default_proc_22, TMP_Hash_default_proc$eq_23, TMP_Hash_delete_24, TMP_Hash_delete_if_25, TMP_Hash_dig_27, TMP_Hash_each_28, TMP_Hash_each_key_30, TMP_Hash_each_value_32, TMP_Hash_empty$q_34, TMP_Hash_fetch_35, TMP_Hash_fetch_values_36, TMP_Hash_flatten_38, TMP_Hash_has_key$q_39, TMP_Hash_has_value$q_40, TMP_Hash_hash_41, TMP_Hash_index_42, TMP_Hash_indexes_43, TMP_Hash_inspect_44, TMP_Hash_invert_45, TMP_Hash_keep_if_46, TMP_Hash_keys_48, TMP_Hash_length_49, TMP_Hash_merge_50, TMP_Hash_merge$B_51, TMP_Hash_rassoc_52, TMP_Hash_rehash_53, TMP_Hash_reject_54, TMP_Hash_reject$B_56, TMP_Hash_replace_58, TMP_Hash_select_59, TMP_Hash_select$B_61, TMP_Hash_shift_63, TMP_Hash_slice_64, TMP_Hash_to_a_65, TMP_Hash_to_h_66, TMP_Hash_to_hash_67, TMP_Hash_to_proc_69, TMP_Hash_transform_keys_70, TMP_Hash_transform_keys$B_72, TMP_Hash_transform_values_74, TMP_Hash_transform_values$B_76, TMP_Hash_values_78;\n\n    \n    self.$include($$($nesting, 'Enumerable'));\n    def.$$is_hash = true;\n    Opal.defs(self, '$[]', TMP_Hash_$$_1 = function($a_rest) {\n      var self = this, argv;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      argv = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        argv[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      var hash, argc = argv.length, i;\n\n      if (argc === 1) {\n        hash = $$($nesting, 'Opal')['$coerce_to?'](argv['$[]'](0), $$($nesting, 'Hash'), \"to_hash\");\n        if (hash !== nil) {\n          return self.$allocate()['$merge!'](hash);\n        }\n\n        argv = $$($nesting, 'Opal')['$coerce_to?'](argv['$[]'](0), $$($nesting, 'Array'), \"to_ary\");\n        if (argv === nil) {\n          self.$raise($$($nesting, 'ArgumentError'), \"odd number of arguments for Hash\")\n        }\n\n        argc = argv.length;\n        hash = self.$allocate();\n\n        for (i = 0; i < argc; i++) {\n          if (!argv[i].$$is_array) continue;\n          switch(argv[i].length) {\n          case 1:\n            hash.$store(argv[i][0], nil);\n            break;\n          case 2:\n            hash.$store(argv[i][0], argv[i][1]);\n            break;\n          default:\n            self.$raise($$($nesting, 'ArgumentError'), \"\" + \"invalid number of elements (\" + (argv[i].length) + \" for 1..2)\")\n          }\n        }\n\n        return hash;\n      }\n\n      if (argc % 2 !== 0) {\n        self.$raise($$($nesting, 'ArgumentError'), \"odd number of arguments for Hash\")\n      }\n\n      hash = self.$allocate();\n\n      for (i = 0; i < argc; i += 2) {\n        hash.$store(argv[i], argv[i + 1]);\n      }\n\n      return hash;\n    \n    }, TMP_Hash_$$_1.$$arity = -1);\n    Opal.defs(self, '$allocate', TMP_Hash_allocate_2 = function $$allocate() {\n      var self = this;\n\n      \n      var hash = new self.$$alloc();\n\n      Opal.hash_init(hash);\n\n      hash.$$none = nil;\n      hash.$$proc = nil;\n\n      return hash;\n    \n    }, TMP_Hash_allocate_2.$$arity = 0);\n    Opal.defs(self, '$try_convert', TMP_Hash_try_convert_3 = function $$try_convert(obj) {\n      var self = this;\n\n      return $$($nesting, 'Opal')['$coerce_to?'](obj, $$($nesting, 'Hash'), \"to_hash\")\n    }, TMP_Hash_try_convert_3.$$arity = 1);\n    \n    Opal.def(self, '$initialize', TMP_Hash_initialize_4 = function $$initialize(defaults) {\n      var self = this, $iter = TMP_Hash_initialize_4.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_initialize_4.$$p = null;\n      \n      if (defaults !== undefined && block !== nil) {\n        self.$raise($$($nesting, 'ArgumentError'), \"wrong number of arguments (1 for 0)\")\n      }\n      self.$$none = (defaults === undefined ? nil : defaults);\n      self.$$proc = block;\n\n      return self;\n    \n    }, TMP_Hash_initialize_4.$$arity = -1);\n    \n    Opal.def(self, '$==', TMP_Hash_$eq$eq_5 = function(other) {\n      var self = this;\n\n      \n      if (self === other) {\n        return true;\n      }\n\n      if (!other.$$is_hash) {\n        return false;\n      }\n\n      if (self.$$keys.length !== other.$$keys.length) {\n        return false;\n      }\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, other_value; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n          other_value = other.$$smap[key];\n        } else {\n          value = key.value;\n          other_value = Opal.hash_get(other, key.key);\n        }\n\n        if (other_value === undefined || !value['$eql?'](other_value)) {\n          return false;\n        }\n      }\n\n      return true;\n    \n    }, TMP_Hash_$eq$eq_5.$$arity = 1);\n    \n    Opal.def(self, '$>=', TMP_Hash_$gt$eq_7 = function(other) {\n      var TMP_6, self = this, result = nil;\n\n      \n      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), \"to_hash\");\n      \n      if (self.$$keys.length < other.$$keys.length) {\n        return false\n      }\n    ;\n      result = true;\n      $send(other, 'each', [], (TMP_6 = function(other_key, other_val){var self = TMP_6.$$s || this, val = nil;\nif (other_key == null) other_key = nil;if (other_val == null) other_val = nil;\n      \n        val = self.$fetch(other_key, null);\n        \n        if (val == null || val !== other_val) {\n          result = false;\n          return;\n        }\n      ;}, TMP_6.$$s = self, TMP_6.$$arity = 2, TMP_6));\n      return result;\n    }, TMP_Hash_$gt$eq_7.$$arity = 1);\n    \n    Opal.def(self, '$>', TMP_Hash_$gt_8 = function(other) {\n      var self = this;\n\n      \n      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), \"to_hash\");\n      \n      if (self.$$keys.length <= other.$$keys.length) {\n        return false\n      }\n    ;\n      return $rb_ge(self, other);\n    }, TMP_Hash_$gt_8.$$arity = 1);\n    \n    Opal.def(self, '$<', TMP_Hash_$lt_9 = function(other) {\n      var self = this;\n\n      \n      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), \"to_hash\");\n      return $rb_gt(other, self);\n    }, TMP_Hash_$lt_9.$$arity = 1);\n    \n    Opal.def(self, '$<=', TMP_Hash_$lt$eq_10 = function(other) {\n      var self = this;\n\n      \n      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), \"to_hash\");\n      return $rb_ge(other, self);\n    }, TMP_Hash_$lt$eq_10.$$arity = 1);\n    \n    Opal.def(self, '$[]', TMP_Hash_$$_11 = function(key) {\n      var self = this;\n\n      \n      var value = Opal.hash_get(self, key);\n\n      if (value !== undefined) {\n        return value;\n      }\n\n      return self.$default(key);\n    \n    }, TMP_Hash_$$_11.$$arity = 1);\n    \n    Opal.def(self, '$[]=', TMP_Hash_$$$eq_12 = function(key, value) {\n      var self = this;\n\n      \n      Opal.hash_put(self, key, value);\n      return value;\n    \n    }, TMP_Hash_$$$eq_12.$$arity = 2);\n    \n    Opal.def(self, '$assoc', TMP_Hash_assoc_13 = function $$assoc(object) {\n      var self = this;\n\n      \n      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          if ((key)['$=='](object)) {\n            return [key, self.$$smap[key]];\n          }\n        } else {\n          if ((key.key)['$=='](object)) {\n            return [key.key, key.value];\n          }\n        }\n      }\n\n      return nil;\n    \n    }, TMP_Hash_assoc_13.$$arity = 1);\n    \n    Opal.def(self, '$clear', TMP_Hash_clear_14 = function $$clear() {\n      var self = this;\n\n      \n      Opal.hash_init(self);\n      return self;\n    \n    }, TMP_Hash_clear_14.$$arity = 0);\n    \n    Opal.def(self, '$clone', TMP_Hash_clone_15 = function $$clone() {\n      var self = this;\n\n      \n      var hash = new self.$$class.$$alloc();\n\n      Opal.hash_init(hash);\n      Opal.hash_clone(self, hash);\n\n      return hash;\n    \n    }, TMP_Hash_clone_15.$$arity = 0);\n    \n    Opal.def(self, '$compact', TMP_Hash_compact_16 = function $$compact() {\n      var self = this;\n\n      \n      var hash = Opal.hash();\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        if (value !== nil) {\n          Opal.hash_put(hash, key, value);\n        }\n      }\n\n      return hash;\n    \n    }, TMP_Hash_compact_16.$$arity = 0);\n    \n    Opal.def(self, '$compact!', TMP_Hash_compact$B_17 = function() {\n      var self = this;\n\n      \n      var changes_were_made = false;\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        if (value === nil) {\n          if (Opal.hash_delete(self, key) !== undefined) {\n            changes_were_made = true;\n            length--;\n            i--;\n          }\n        }\n      }\n\n      return changes_were_made ? self : nil;\n    \n    }, TMP_Hash_compact$B_17.$$arity = 0);\n    \n    Opal.def(self, '$compare_by_identity', TMP_Hash_compare_by_identity_18 = function $$compare_by_identity() {\n      var self = this;\n\n      \n      var i, ii, key, keys = self.$$keys, identity_hash;\n\n      if (self.$$by_identity) return self;\n      if (self.$$keys.length === 0) {\n        self.$$by_identity = true\n        return self;\n      }\n\n      identity_hash = $hash2([], {}).$compare_by_identity();\n      for(i = 0, ii = keys.length; i < ii; i++) {\n        key = keys[i];\n        if (!key.$$is_string) key = key.key;\n        Opal.hash_put(identity_hash, key, Opal.hash_get(self, key));\n      }\n\n      self.$$by_identity = true;\n      self.$$map = identity_hash.$$map;\n      self.$$smap = identity_hash.$$smap;\n      return self;\n    \n    }, TMP_Hash_compare_by_identity_18.$$arity = 0);\n    \n    Opal.def(self, '$compare_by_identity?', TMP_Hash_compare_by_identity$q_19 = function() {\n      var self = this;\n\n      return self.$$by_identity === true;\n    }, TMP_Hash_compare_by_identity$q_19.$$arity = 0);\n    \n    Opal.def(self, '$default', TMP_Hash_default_20 = function(key) {\n      var self = this;\n\n      \n      if (key !== undefined && self.$$proc !== nil && self.$$proc !== undefined) {\n        return self.$$proc.$call(self, key);\n      }\n      if (self.$$none === undefined) {\n        return nil;\n      }\n      return self.$$none;\n    \n    }, TMP_Hash_default_20.$$arity = -1);\n    \n    Opal.def(self, '$default=', TMP_Hash_default$eq_21 = function(object) {\n      var self = this;\n\n      \n      self.$$proc = nil;\n      self.$$none = object;\n\n      return object;\n    \n    }, TMP_Hash_default$eq_21.$$arity = 1);\n    \n    Opal.def(self, '$default_proc', TMP_Hash_default_proc_22 = function $$default_proc() {\n      var self = this;\n\n      \n      if (self.$$proc !== undefined) {\n        return self.$$proc;\n      }\n      return nil;\n    \n    }, TMP_Hash_default_proc_22.$$arity = 0);\n    \n    Opal.def(self, '$default_proc=', TMP_Hash_default_proc$eq_23 = function(default_proc) {\n      var self = this;\n\n      \n      var proc = default_proc;\n\n      if (proc !== nil) {\n        proc = $$($nesting, 'Opal')['$coerce_to!'](proc, $$($nesting, 'Proc'), \"to_proc\");\n\n        if ((proc)['$lambda?']() && (proc).$arity().$abs() !== 2) {\n          self.$raise($$($nesting, 'TypeError'), \"default_proc takes two arguments\");\n        }\n      }\n\n      self.$$none = nil;\n      self.$$proc = proc;\n\n      return default_proc;\n    \n    }, TMP_Hash_default_proc$eq_23.$$arity = 1);\n    \n    Opal.def(self, '$delete', TMP_Hash_delete_24 = function(key) {\n      var self = this, $iter = TMP_Hash_delete_24.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_delete_24.$$p = null;\n      \n      var value = Opal.hash_delete(self, key);\n\n      if (value !== undefined) {\n        return value;\n      }\n\n      if (block !== nil) {\n        return Opal.yield1(block, key);\n      }\n\n      return nil;\n    \n    }, TMP_Hash_delete_24.$$arity = 1);\n    \n    Opal.def(self, '$delete_if', TMP_Hash_delete_if_25 = function $$delete_if() {\n      var TMP_26, self = this, $iter = TMP_Hash_delete_if_25.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_delete_if_25.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        return $send(self, 'enum_for', [\"delete_if\"], (TMP_26 = function(){var self = TMP_26.$$s || this;\n\n        return self.$size()}, TMP_26.$$s = self, TMP_26.$$arity = 0, TMP_26))\n      };\n      \n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        obj = block(key, value);\n\n        if (obj !== false && obj !== nil) {\n          if (Opal.hash_delete(self, key) !== undefined) {\n            length--;\n            i--;\n          }\n        }\n      }\n\n      return self;\n    ;\n    }, TMP_Hash_delete_if_25.$$arity = 0);\n    Opal.alias(self, \"dup\", \"clone\");\n    \n    Opal.def(self, '$dig', TMP_Hash_dig_27 = function $$dig(key, $a_rest) {\n      var self = this, keys, item = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      keys = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        keys[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      \n      item = self['$[]'](key);\n      \n      if (item === nil || keys.length === 0) {\n        return item;\n      }\n    ;\n      if ($truthy(item['$respond_to?'](\"dig\"))) {\n      } else {\n        self.$raise($$($nesting, 'TypeError'), \"\" + (item.$class()) + \" does not have #dig method\")\n      };\n      return $send(item, 'dig', Opal.to_a(keys));\n    }, TMP_Hash_dig_27.$$arity = -2);\n    \n    Opal.def(self, '$each', TMP_Hash_each_28 = function $$each() {\n      var TMP_29, self = this, $iter = TMP_Hash_each_28.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_each_28.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        return $send(self, 'enum_for', [\"each\"], (TMP_29 = function(){var self = TMP_29.$$s || this;\n\n        return self.$size()}, TMP_29.$$s = self, TMP_29.$$arity = 0, TMP_29))\n      };\n      \n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        Opal.yield1(block, [key, value]);\n      }\n\n      return self;\n    ;\n    }, TMP_Hash_each_28.$$arity = 0);\n    \n    Opal.def(self, '$each_key', TMP_Hash_each_key_30 = function $$each_key() {\n      var TMP_31, self = this, $iter = TMP_Hash_each_key_30.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_each_key_30.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        return $send(self, 'enum_for', [\"each_key\"], (TMP_31 = function(){var self = TMP_31.$$s || this;\n\n        return self.$size()}, TMP_31.$$s = self, TMP_31.$$arity = 0, TMP_31))\n      };\n      \n      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {\n        key = keys[i];\n\n        block(key.$$is_string ? key : key.key);\n      }\n\n      return self;\n    ;\n    }, TMP_Hash_each_key_30.$$arity = 0);\n    Opal.alias(self, \"each_pair\", \"each\");\n    \n    Opal.def(self, '$each_value', TMP_Hash_each_value_32 = function $$each_value() {\n      var TMP_33, self = this, $iter = TMP_Hash_each_value_32.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_each_value_32.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        return $send(self, 'enum_for', [\"each_value\"], (TMP_33 = function(){var self = TMP_33.$$s || this;\n\n        return self.$size()}, TMP_33.$$s = self, TMP_33.$$arity = 0, TMP_33))\n      };\n      \n      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {\n        key = keys[i];\n\n        block(key.$$is_string ? self.$$smap[key] : key.value);\n      }\n\n      return self;\n    ;\n    }, TMP_Hash_each_value_32.$$arity = 0);\n    \n    Opal.def(self, '$empty?', TMP_Hash_empty$q_34 = function() {\n      var self = this;\n\n      return self.$$keys.length === 0;\n    }, TMP_Hash_empty$q_34.$$arity = 0);\n    Opal.alias(self, \"eql?\", \"==\");\n    \n    Opal.def(self, '$fetch', TMP_Hash_fetch_35 = function $$fetch(key, defaults) {\n      var self = this, $iter = TMP_Hash_fetch_35.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_fetch_35.$$p = null;\n      \n      \n      var value = Opal.hash_get(self, key);\n\n      if (value !== undefined) {\n        return value;\n      }\n\n      if (block !== nil) {\n        return block(key);\n      }\n\n      if (defaults !== undefined) {\n        return defaults;\n      }\n    ;\n      return self.$raise($$($nesting, 'KeyError').$new(\"\" + \"key not found: \" + (key.$inspect()), $hash2([\"key\", \"receiver\"], {\"key\": key, \"receiver\": self})));\n    }, TMP_Hash_fetch_35.$$arity = -2);\n    \n    Opal.def(self, '$fetch_values', TMP_Hash_fetch_values_36 = function $$fetch_values($a_rest) {\n      var TMP_37, self = this, keys, $iter = TMP_Hash_fetch_values_36.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      keys = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        keys[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Hash_fetch_values_36.$$p = null;\n      return $send(keys, 'map', [], (TMP_37 = function(key){var self = TMP_37.$$s || this;\nif (key == null) key = nil;\n      return $send(self, 'fetch', [key], block.$to_proc())}, TMP_37.$$s = self, TMP_37.$$arity = 1, TMP_37))\n    }, TMP_Hash_fetch_values_36.$$arity = -1);\n    \n    Opal.def(self, '$flatten', TMP_Hash_flatten_38 = function $$flatten(level) {\n      var self = this;\n\n      if (level == null) {\n        level = 1;\n      }\n      \n      level = $$($nesting, 'Opal')['$coerce_to!'](level, $$($nesting, 'Integer'), \"to_int\");\n      \n      var result = [];\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        result.push(key);\n\n        if (value.$$is_array) {\n          if (level === 1) {\n            result.push(value);\n            continue;\n          }\n\n          result = result.concat((value).$flatten(level - 2));\n          continue;\n        }\n\n        result.push(value);\n      }\n\n      return result;\n    ;\n    }, TMP_Hash_flatten_38.$$arity = -1);\n    \n    Opal.def(self, '$has_key?', TMP_Hash_has_key$q_39 = function(key) {\n      var self = this;\n\n      return Opal.hash_get(self, key) !== undefined;\n    }, TMP_Hash_has_key$q_39.$$arity = 1);\n    \n    Opal.def(self, '$has_value?', TMP_Hash_has_value$q_40 = function(value) {\n      var self = this;\n\n      \n      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {\n        key = keys[i];\n\n        if (((key.$$is_string ? self.$$smap[key] : key.value))['$=='](value)) {\n          return true;\n        }\n      }\n\n      return false;\n    \n    }, TMP_Hash_has_value$q_40.$$arity = 1);\n    \n    Opal.def(self, '$hash', TMP_Hash_hash_41 = function $$hash() {\n      var self = this;\n\n      \n      var top = (Opal.hash_ids === undefined),\n          hash_id = self.$object_id(),\n          result = ['Hash'],\n          key, item;\n\n      try {\n        if (top) {\n          Opal.hash_ids = Object.create(null);\n        }\n\n        if (Opal[hash_id]) {\n          return 'self';\n        }\n\n        for (key in Opal.hash_ids) {\n          item = Opal.hash_ids[key];\n          if (self['$eql?'](item)) {\n            return 'self';\n          }\n        }\n\n        Opal.hash_ids[hash_id] = self;\n\n        for (var i = 0, keys = self.$$keys, length = keys.length; i < length; i++) {\n          key = keys[i];\n\n          if (key.$$is_string) {\n            result.push([key, self.$$smap[key].$hash()]);\n          } else {\n            result.push([key.key_hash, key.value.$hash()]);\n          }\n        }\n\n        return result.sort().join();\n\n      } finally {\n        if (top) {\n          Opal.hash_ids = undefined;\n        }\n      }\n    \n    }, TMP_Hash_hash_41.$$arity = 0);\n    Opal.alias(self, \"include?\", \"has_key?\");\n    \n    Opal.def(self, '$index', TMP_Hash_index_42 = function $$index(object) {\n      var self = this;\n\n      \n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        if ((value)['$=='](object)) {\n          return key;\n        }\n      }\n\n      return nil;\n    \n    }, TMP_Hash_index_42.$$arity = 1);\n    \n    Opal.def(self, '$indexes', TMP_Hash_indexes_43 = function $$indexes($a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      var result = [];\n\n      for (var i = 0, length = args.length, key, value; i < length; i++) {\n        key = args[i];\n        value = Opal.hash_get(self, key);\n\n        if (value === undefined) {\n          result.push(self.$default());\n          continue;\n        }\n\n        result.push(value);\n      }\n\n      return result;\n    \n    }, TMP_Hash_indexes_43.$$arity = -1);\n    Opal.alias(self, \"indices\", \"indexes\");\n    var inspect_ids;\n    \n    Opal.def(self, '$inspect', TMP_Hash_inspect_44 = function $$inspect() {\n      var self = this;\n\n      \n      var top = (inspect_ids === undefined),\n          hash_id = self.$object_id(),\n          result = [];\n\n      try {\n        if (top) {\n          inspect_ids = {};\n        }\n\n        if (inspect_ids.hasOwnProperty(hash_id)) {\n          return '{...}';\n        }\n\n        inspect_ids[hash_id] = true;\n\n        for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {\n          key = keys[i];\n\n          if (key.$$is_string) {\n            value = self.$$smap[key];\n          } else {\n            value = key.value;\n            key = key.key;\n          }\n\n          result.push(key.$inspect() + '=>' + value.$inspect());\n        }\n\n        return '{' + result.join(', ') + '}';\n\n      } finally {\n        if (top) {\n          inspect_ids = undefined;\n        }\n      }\n    \n    }, TMP_Hash_inspect_44.$$arity = 0);\n    \n    Opal.def(self, '$invert', TMP_Hash_invert_45 = function $$invert() {\n      var self = this;\n\n      \n      var hash = Opal.hash();\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        Opal.hash_put(hash, value, key);\n      }\n\n      return hash;\n    \n    }, TMP_Hash_invert_45.$$arity = 0);\n    \n    Opal.def(self, '$keep_if', TMP_Hash_keep_if_46 = function $$keep_if() {\n      var TMP_47, self = this, $iter = TMP_Hash_keep_if_46.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_keep_if_46.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        return $send(self, 'enum_for', [\"keep_if\"], (TMP_47 = function(){var self = TMP_47.$$s || this;\n\n        return self.$size()}, TMP_47.$$s = self, TMP_47.$$arity = 0, TMP_47))\n      };\n      \n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        obj = block(key, value);\n\n        if (obj === false || obj === nil) {\n          if (Opal.hash_delete(self, key) !== undefined) {\n            length--;\n            i--;\n          }\n        }\n      }\n\n      return self;\n    ;\n    }, TMP_Hash_keep_if_46.$$arity = 0);\n    Opal.alias(self, \"key\", \"index\");\n    Opal.alias(self, \"key?\", \"has_key?\");\n    \n    Opal.def(self, '$keys', TMP_Hash_keys_48 = function $$keys() {\n      var self = this;\n\n      \n      var result = [];\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          result.push(key);\n        } else {\n          result.push(key.key);\n        }\n      }\n\n      return result;\n    \n    }, TMP_Hash_keys_48.$$arity = 0);\n    \n    Opal.def(self, '$length', TMP_Hash_length_49 = function $$length() {\n      var self = this;\n\n      return self.$$keys.length;\n    }, TMP_Hash_length_49.$$arity = 0);\n    Opal.alias(self, \"member?\", \"has_key?\");\n    \n    Opal.def(self, '$merge', TMP_Hash_merge_50 = function $$merge(other) {\n      var self = this, $iter = TMP_Hash_merge_50.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_merge_50.$$p = null;\n      return $send(self.$dup(), 'merge!', [other], block.$to_proc())\n    }, TMP_Hash_merge_50.$$arity = 1);\n    \n    Opal.def(self, '$merge!', TMP_Hash_merge$B_51 = function(other) {\n      var self = this, $iter = TMP_Hash_merge$B_51.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_merge$B_51.$$p = null;\n      \n      if (!other.$$is_hash) {\n        other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), \"to_hash\");\n      }\n\n      var i, other_keys = other.$$keys, length = other_keys.length, key, value, other_value;\n\n      if (block === nil) {\n        for (i = 0; i < length; i++) {\n          key = other_keys[i];\n\n          if (key.$$is_string) {\n            other_value = other.$$smap[key];\n          } else {\n            other_value = key.value;\n            key = key.key;\n          }\n\n          Opal.hash_put(self, key, other_value);\n        }\n\n        return self;\n      }\n\n      for (i = 0; i < length; i++) {\n        key = other_keys[i];\n\n        if (key.$$is_string) {\n          other_value = other.$$smap[key];\n        } else {\n          other_value = key.value;\n          key = key.key;\n        }\n\n        value = Opal.hash_get(self, key);\n\n        if (value === undefined) {\n          Opal.hash_put(self, key, other_value);\n          continue;\n        }\n\n        Opal.hash_put(self, key, block(key, value, other_value));\n      }\n\n      return self;\n    \n    }, TMP_Hash_merge$B_51.$$arity = 1);\n    \n    Opal.def(self, '$rassoc', TMP_Hash_rassoc_52 = function $$rassoc(object) {\n      var self = this;\n\n      \n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        if ((value)['$=='](object)) {\n          return [key, value];\n        }\n      }\n\n      return nil;\n    \n    }, TMP_Hash_rassoc_52.$$arity = 1);\n    \n    Opal.def(self, '$rehash', TMP_Hash_rehash_53 = function $$rehash() {\n      var self = this;\n\n      \n      Opal.hash_rehash(self);\n      return self;\n    \n    }, TMP_Hash_rehash_53.$$arity = 0);\n    \n    Opal.def(self, '$reject', TMP_Hash_reject_54 = function $$reject() {\n      var TMP_55, self = this, $iter = TMP_Hash_reject_54.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_reject_54.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        return $send(self, 'enum_for', [\"reject\"], (TMP_55 = function(){var self = TMP_55.$$s || this;\n\n        return self.$size()}, TMP_55.$$s = self, TMP_55.$$arity = 0, TMP_55))\n      };\n      \n      var hash = Opal.hash();\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        obj = block(key, value);\n\n        if (obj === false || obj === nil) {\n          Opal.hash_put(hash, key, value);\n        }\n      }\n\n      return hash;\n    ;\n    }, TMP_Hash_reject_54.$$arity = 0);\n    \n    Opal.def(self, '$reject!', TMP_Hash_reject$B_56 = function() {\n      var TMP_57, self = this, $iter = TMP_Hash_reject$B_56.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_reject$B_56.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        return $send(self, 'enum_for', [\"reject!\"], (TMP_57 = function(){var self = TMP_57.$$s || this;\n\n        return self.$size()}, TMP_57.$$s = self, TMP_57.$$arity = 0, TMP_57))\n      };\n      \n      var changes_were_made = false;\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        obj = block(key, value);\n\n        if (obj !== false && obj !== nil) {\n          if (Opal.hash_delete(self, key) !== undefined) {\n            changes_were_made = true;\n            length--;\n            i--;\n          }\n        }\n      }\n\n      return changes_were_made ? self : nil;\n    ;\n    }, TMP_Hash_reject$B_56.$$arity = 0);\n    \n    Opal.def(self, '$replace', TMP_Hash_replace_58 = function $$replace(other) {\n      var self = this, $writer = nil;\n\n      \n      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), \"to_hash\");\n      \n      Opal.hash_init(self);\n\n      for (var i = 0, other_keys = other.$$keys, length = other_keys.length, key, value, other_value; i < length; i++) {\n        key = other_keys[i];\n\n        if (key.$$is_string) {\n          other_value = other.$$smap[key];\n        } else {\n          other_value = key.value;\n          key = key.key;\n        }\n\n        Opal.hash_put(self, key, other_value);\n      }\n    ;\n      if ($truthy(other.$default_proc())) {\n        \n        $writer = [other.$default_proc()];\n        $send(self, 'default_proc=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];\n      } else {\n        \n        $writer = [other.$default()];\n        $send(self, 'default=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];\n      };\n      return self;\n    }, TMP_Hash_replace_58.$$arity = 1);\n    \n    Opal.def(self, '$select', TMP_Hash_select_59 = function $$select() {\n      var TMP_60, self = this, $iter = TMP_Hash_select_59.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_select_59.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        return $send(self, 'enum_for', [\"select\"], (TMP_60 = function(){var self = TMP_60.$$s || this;\n\n        return self.$size()}, TMP_60.$$s = self, TMP_60.$$arity = 0, TMP_60))\n      };\n      \n      var hash = Opal.hash();\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        obj = block(key, value);\n\n        if (obj !== false && obj !== nil) {\n          Opal.hash_put(hash, key, value);\n        }\n      }\n\n      return hash;\n    ;\n    }, TMP_Hash_select_59.$$arity = 0);\n    \n    Opal.def(self, '$select!', TMP_Hash_select$B_61 = function() {\n      var TMP_62, self = this, $iter = TMP_Hash_select$B_61.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_select$B_61.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        return $send(self, 'enum_for', [\"select!\"], (TMP_62 = function(){var self = TMP_62.$$s || this;\n\n        return self.$size()}, TMP_62.$$s = self, TMP_62.$$arity = 0, TMP_62))\n      };\n      \n      var result = nil;\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        obj = block(key, value);\n\n        if (obj === false || obj === nil) {\n          if (Opal.hash_delete(self, key) !== undefined) {\n            length--;\n            i--;\n          }\n          result = self;\n        }\n      }\n\n      return result;\n    ;\n    }, TMP_Hash_select$B_61.$$arity = 0);\n    \n    Opal.def(self, '$shift', TMP_Hash_shift_63 = function $$shift() {\n      var self = this;\n\n      \n      var keys = self.$$keys,\n          key;\n\n      if (keys.length > 0) {\n        key = keys[0];\n\n        key = key.$$is_string ? key : key.key;\n\n        return [key, Opal.hash_delete(self, key)];\n      }\n\n      return self.$default(nil);\n    \n    }, TMP_Hash_shift_63.$$arity = 0);\n    Opal.alias(self, \"size\", \"length\");\n    \n    Opal.def(self, '$slice', TMP_Hash_slice_64 = function $$slice($a_rest) {\n      var self = this, keys;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      keys = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        keys[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      var result = Opal.hash();\n\n      for (var i = 0, length = keys.length; i < length; i++) {\n        var key = keys[i], value = Opal.hash_get(self, key);\n\n        if (value !== undefined) {\n          Opal.hash_put(result, key, value);\n        }\n      }\n\n      return result;\n    \n    }, TMP_Hash_slice_64.$$arity = -1);\n    Opal.alias(self, \"store\", \"[]=\");\n    \n    Opal.def(self, '$to_a', TMP_Hash_to_a_65 = function $$to_a() {\n      var self = this;\n\n      \n      var result = [];\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        result.push([key, value]);\n      }\n\n      return result;\n    \n    }, TMP_Hash_to_a_65.$$arity = 0);\n    \n    Opal.def(self, '$to_h', TMP_Hash_to_h_66 = function $$to_h() {\n      var self = this;\n\n      \n      if (self.$$class === Opal.Hash) {\n        return self;\n      }\n\n      var hash = new Opal.Hash.$$alloc();\n\n      Opal.hash_init(hash);\n      Opal.hash_clone(self, hash);\n\n      return hash;\n    \n    }, TMP_Hash_to_h_66.$$arity = 0);\n    \n    Opal.def(self, '$to_hash', TMP_Hash_to_hash_67 = function $$to_hash() {\n      var self = this;\n\n      return self\n    }, TMP_Hash_to_hash_67.$$arity = 0);\n    \n    Opal.def(self, '$to_proc', TMP_Hash_to_proc_69 = function $$to_proc() {\n      var TMP_68, self = this;\n\n      return $send(self, 'proc', [], (TMP_68 = function(key){var self = TMP_68.$$s || this;\n\n      \n        \n        if (key == null) {\n          self.$raise($$($nesting, 'ArgumentError'), \"no key given\")\n        }\n      ;\n        return self['$[]'](key);}, TMP_68.$$s = self, TMP_68.$$arity = -1, TMP_68))\n    }, TMP_Hash_to_proc_69.$$arity = 0);\n    Opal.alias(self, \"to_s\", \"inspect\");\n    \n    Opal.def(self, '$transform_keys', TMP_Hash_transform_keys_70 = function $$transform_keys() {\n      var TMP_71, self = this, $iter = TMP_Hash_transform_keys_70.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_transform_keys_70.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        return $send(self, 'enum_for', [\"transform_keys\"], (TMP_71 = function(){var self = TMP_71.$$s || this;\n\n        return self.$size()}, TMP_71.$$s = self, TMP_71.$$arity = 0, TMP_71))\n      };\n      \n      var result = Opal.hash();\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        key = Opal.yield1(block, key);\n\n        Opal.hash_put(result, key, value);\n      }\n\n      return result;\n    ;\n    }, TMP_Hash_transform_keys_70.$$arity = 0);\n    \n    Opal.def(self, '$transform_keys!', TMP_Hash_transform_keys$B_72 = function() {\n      var TMP_73, self = this, $iter = TMP_Hash_transform_keys$B_72.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_transform_keys$B_72.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        return $send(self, 'enum_for', [\"transform_keys!\"], (TMP_73 = function(){var self = TMP_73.$$s || this;\n\n        return self.$size()}, TMP_73.$$s = self, TMP_73.$$arity = 0, TMP_73))\n      };\n      \n      var keys = Opal.slice.call(self.$$keys),\n          i, length = keys.length, key, value, new_key;\n\n      for (i = 0; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        new_key = Opal.yield1(block, key);\n\n        Opal.hash_delete(self, key);\n        Opal.hash_put(self, new_key, value);\n      }\n\n      return self;\n    ;\n    }, TMP_Hash_transform_keys$B_72.$$arity = 0);\n    \n    Opal.def(self, '$transform_values', TMP_Hash_transform_values_74 = function $$transform_values() {\n      var TMP_75, self = this, $iter = TMP_Hash_transform_values_74.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_transform_values_74.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        return $send(self, 'enum_for', [\"transform_values\"], (TMP_75 = function(){var self = TMP_75.$$s || this;\n\n        return self.$size()}, TMP_75.$$s = self, TMP_75.$$arity = 0, TMP_75))\n      };\n      \n      var result = Opal.hash();\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        value = Opal.yield1(block, value);\n\n        Opal.hash_put(result, key, value);\n      }\n\n      return result;\n    ;\n    }, TMP_Hash_transform_values_74.$$arity = 0);\n    \n    Opal.def(self, '$transform_values!', TMP_Hash_transform_values$B_76 = function() {\n      var TMP_77, self = this, $iter = TMP_Hash_transform_values$B_76.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Hash_transform_values$B_76.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        return $send(self, 'enum_for', [\"transform_values!\"], (TMP_77 = function(){var self = TMP_77.$$s || this;\n\n        return self.$size()}, TMP_77.$$s = self, TMP_77.$$arity = 0, TMP_77))\n      };\n      \n      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          value = self.$$smap[key];\n        } else {\n          value = key.value;\n          key = key.key;\n        }\n\n        value = Opal.yield1(block, value);\n\n        Opal.hash_put(self, key, value);\n      }\n\n      return self;\n    ;\n    }, TMP_Hash_transform_values$B_76.$$arity = 0);\n    Opal.alias(self, \"update\", \"merge!\");\n    Opal.alias(self, \"value?\", \"has_value?\");\n    Opal.alias(self, \"values_at\", \"indexes\");\n    return (Opal.def(self, '$values', TMP_Hash_values_78 = function $$values() {\n      var self = this;\n\n      \n      var result = [];\n\n      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {\n        key = keys[i];\n\n        if (key.$$is_string) {\n          result.push(self.$$smap[key]);\n        } else {\n          result.push(key.value);\n        }\n      }\n\n      return result;\n    \n    }, TMP_Hash_values_78.$$arity = 0), nil) && 'values';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/number\"] = function(Opal) {\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$bridge', '$raise', '$name', '$class', '$Float', '$respond_to?', '$coerce_to!', '$__coerced__', '$===', '$!', '$>', '$**', '$new', '$<', '$to_f', '$==', '$nan?', '$infinite?', '$enum_for', '$+', '$-', '$gcd', '$lcm', '$%', '$/', '$frexp', '$to_i', '$ldexp', '$rationalize', '$*', '$<<', '$to_r', '$truncate', '$-@', '$size', '$<=', '$>=', '$<=>', '$compare', '$any?']);\n  \n  self.$require(\"corelib/numeric\");\n  (function($base, $super, $parent_nesting) {\n    function $Number(){};\n    var self = $Number = $klass($base, $super, 'Number', $Number);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Number_coerce_2, TMP_Number___id___3, TMP_Number_$_4, TMP_Number_$_5, TMP_Number_$_6, TMP_Number_$_7, TMP_Number_$_8, TMP_Number_$_9, TMP_Number_$_10, TMP_Number_$_11, TMP_Number_$lt_12, TMP_Number_$lt$eq_13, TMP_Number_$gt_14, TMP_Number_$gt$eq_15, TMP_Number_$lt$eq$gt_16, TMP_Number_$lt$lt_17, TMP_Number_$gt$gt_18, TMP_Number_$$_19, TMP_Number_$$_20, TMP_Number_$$_21, TMP_Number_$_22, TMP_Number_$$_23, TMP_Number_$eq$eq$eq_24, TMP_Number_$eq$eq_25, TMP_Number_abs_26, TMP_Number_abs2_27, TMP_Number_allbits$q_28, TMP_Number_anybits$q_29, TMP_Number_angle_30, TMP_Number_bit_length_31, TMP_Number_ceil_32, TMP_Number_chr_33, TMP_Number_denominator_34, TMP_Number_downto_35, TMP_Number_equal$q_37, TMP_Number_even$q_38, TMP_Number_floor_39, TMP_Number_gcd_40, TMP_Number_gcdlcm_41, TMP_Number_integer$q_42, TMP_Number_is_a$q_43, TMP_Number_instance_of$q_44, TMP_Number_lcm_45, TMP_Number_next_46, TMP_Number_nobits$q_47, TMP_Number_nonzero$q_48, TMP_Number_numerator_49, TMP_Number_odd$q_50, TMP_Number_ord_51, TMP_Number_pow_52, TMP_Number_pred_53, TMP_Number_quo_54, TMP_Number_rationalize_55, TMP_Number_remainder_56, TMP_Number_round_57, TMP_Number_step_58, TMP_Number_times_60, TMP_Number_to_f_62, TMP_Number_to_i_63, TMP_Number_to_r_64, TMP_Number_to_s_65, TMP_Number_truncate_66, TMP_Number_digits_67, TMP_Number_divmod_68, TMP_Number_upto_69, TMP_Number_zero$q_71, TMP_Number_size_72, TMP_Number_nan$q_73, TMP_Number_finite$q_74, TMP_Number_infinite$q_75, TMP_Number_positive$q_76, TMP_Number_negative$q_77;\n\n    \n    $$($nesting, 'Opal').$bridge(self, Number);\n    Number.prototype.$$is_number = true;\n    self.$$is_number_class = true;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_allocate_1;\n\n      \n      \n      Opal.def(self, '$allocate', TMP_allocate_1 = function $$allocate() {\n        var self = this;\n\n        return self.$raise($$($nesting, 'TypeError'), \"\" + \"allocator undefined for \" + (self.$name()))\n      }, TMP_allocate_1.$$arity = 0);\n      \n      \n      Opal.udef(self, '$' + \"new\");;\n      return nil;;\n    })(Opal.get_singleton_class(self), $nesting);\n    \n    Opal.def(self, '$coerce', TMP_Number_coerce_2 = function $$coerce(other) {\n      var self = this;\n\n      \n      if (other === nil) {\n        self.$raise($$($nesting, 'TypeError'), \"\" + \"can't convert \" + (other.$class()) + \" into Float\");\n      }\n      else if (other.$$is_string) {\n        return [self.$Float(other), self];\n      }\n      else if (other['$respond_to?'](\"to_f\")) {\n        return [$$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Float'), \"to_f\"), self];\n      }\n      else if (other.$$is_number) {\n        return [other, self];\n      }\n      else {\n        self.$raise($$($nesting, 'TypeError'), \"\" + \"can't convert \" + (other.$class()) + \" into Float\");\n      }\n    \n    }, TMP_Number_coerce_2.$$arity = 1);\n    \n    Opal.def(self, '$__id__', TMP_Number___id___3 = function $$__id__() {\n      var self = this;\n\n      return (self * 2) + 1;\n    }, TMP_Number___id___3.$$arity = 0);\n    Opal.alias(self, \"object_id\", \"__id__\");\n    \n    Opal.def(self, '$+', TMP_Number_$_4 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self + other;\n      }\n      else {\n        return self.$__coerced__(\"+\", other);\n      }\n    \n    }, TMP_Number_$_4.$$arity = 1);\n    \n    Opal.def(self, '$-', TMP_Number_$_5 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self - other;\n      }\n      else {\n        return self.$__coerced__(\"-\", other);\n      }\n    \n    }, TMP_Number_$_5.$$arity = 1);\n    \n    Opal.def(self, '$*', TMP_Number_$_6 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self * other;\n      }\n      else {\n        return self.$__coerced__(\"*\", other);\n      }\n    \n    }, TMP_Number_$_6.$$arity = 1);\n    \n    Opal.def(self, '$/', TMP_Number_$_7 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self / other;\n      }\n      else {\n        return self.$__coerced__(\"/\", other);\n      }\n    \n    }, TMP_Number_$_7.$$arity = 1);\n    Opal.alias(self, \"fdiv\", \"/\");\n    \n    Opal.def(self, '$%', TMP_Number_$_8 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        if (other == -Infinity) {\n          return other;\n        }\n        else if (other == 0) {\n          self.$raise($$($nesting, 'ZeroDivisionError'), \"divided by 0\");\n        }\n        else if (other < 0 || self < 0) {\n          return (self % other + other) % other;\n        }\n        else {\n          return self % other;\n        }\n      }\n      else {\n        return self.$__coerced__(\"%\", other);\n      }\n    \n    }, TMP_Number_$_8.$$arity = 1);\n    \n    Opal.def(self, '$&', TMP_Number_$_9 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self & other;\n      }\n      else {\n        return self.$__coerced__(\"&\", other);\n      }\n    \n    }, TMP_Number_$_9.$$arity = 1);\n    \n    Opal.def(self, '$|', TMP_Number_$_10 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self | other;\n      }\n      else {\n        return self.$__coerced__(\"|\", other);\n      }\n    \n    }, TMP_Number_$_10.$$arity = 1);\n    \n    Opal.def(self, '$^', TMP_Number_$_11 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self ^ other;\n      }\n      else {\n        return self.$__coerced__(\"^\", other);\n      }\n    \n    }, TMP_Number_$_11.$$arity = 1);\n    \n    Opal.def(self, '$<', TMP_Number_$lt_12 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self < other;\n      }\n      else {\n        return self.$__coerced__(\"<\", other);\n      }\n    \n    }, TMP_Number_$lt_12.$$arity = 1);\n    \n    Opal.def(self, '$<=', TMP_Number_$lt$eq_13 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self <= other;\n      }\n      else {\n        return self.$__coerced__(\"<=\", other);\n      }\n    \n    }, TMP_Number_$lt$eq_13.$$arity = 1);\n    \n    Opal.def(self, '$>', TMP_Number_$gt_14 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self > other;\n      }\n      else {\n        return self.$__coerced__(\">\", other);\n      }\n    \n    }, TMP_Number_$gt_14.$$arity = 1);\n    \n    Opal.def(self, '$>=', TMP_Number_$gt$eq_15 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self >= other;\n      }\n      else {\n        return self.$__coerced__(\">=\", other);\n      }\n    \n    }, TMP_Number_$gt$eq_15.$$arity = 1);\n    \n    var spaceship_operator = function(self, other) {\n      if (other.$$is_number) {\n        if (isNaN(self) || isNaN(other)) {\n          return nil;\n        }\n\n        if (self > other) {\n          return 1;\n        } else if (self < other) {\n          return -1;\n        } else {\n          return 0;\n        }\n      }\n      else {\n        return self.$__coerced__(\"<=>\", other);\n      }\n    }\n  ;\n    \n    Opal.def(self, '$<=>', TMP_Number_$lt$eq$gt_16 = function(other) {\n      var self = this;\n\n      try {\n        return spaceship_operator(self, other);\n      } catch ($err) {\n        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {\n          try {\n            return nil\n          } finally { Opal.pop_exception() }\n        } else { throw $err; }\n      }\n    }, TMP_Number_$lt$eq$gt_16.$$arity = 1);\n    \n    Opal.def(self, '$<<', TMP_Number_$lt$lt_17 = function(count) {\n      var self = this;\n\n      \n      count = $$($nesting, 'Opal')['$coerce_to!'](count, $$($nesting, 'Integer'), \"to_int\");\n      return count > 0 ? self << count : self >> -count;\n    }, TMP_Number_$lt$lt_17.$$arity = 1);\n    \n    Opal.def(self, '$>>', TMP_Number_$gt$gt_18 = function(count) {\n      var self = this;\n\n      \n      count = $$($nesting, 'Opal')['$coerce_to!'](count, $$($nesting, 'Integer'), \"to_int\");\n      return count > 0 ? self >> count : self << -count;\n    }, TMP_Number_$gt$gt_18.$$arity = 1);\n    \n    Opal.def(self, '$[]', TMP_Number_$$_19 = function(bit) {\n      var self = this;\n\n      \n      bit = $$($nesting, 'Opal')['$coerce_to!'](bit, $$($nesting, 'Integer'), \"to_int\");\n      \n      if (bit < 0) {\n        return 0;\n      }\n      if (bit >= 32) {\n        return self < 0 ? 1 : 0;\n      }\n      return (self >> bit) & 1;\n    ;\n    }, TMP_Number_$$_19.$$arity = 1);\n    \n    Opal.def(self, '$+@', TMP_Number_$$_20 = function() {\n      var self = this;\n\n      return +self;\n    }, TMP_Number_$$_20.$$arity = 0);\n    \n    Opal.def(self, '$-@', TMP_Number_$$_21 = function() {\n      var self = this;\n\n      return -self;\n    }, TMP_Number_$$_21.$$arity = 0);\n    \n    Opal.def(self, '$~', TMP_Number_$_22 = function() {\n      var self = this;\n\n      return ~self;\n    }, TMP_Number_$_22.$$arity = 0);\n    \n    Opal.def(self, '$**', TMP_Number_$$_23 = function(other) {\n      var $a, $b, self = this;\n\n      if ($truthy($$($nesting, 'Integer')['$==='](other))) {\n        if ($truthy(($truthy($a = $$($nesting, 'Integer')['$==='](self)['$!']()) ? $a : $rb_gt(other, 0)))) {\n          return Math.pow(self, other);\n        } else {\n          return $$($nesting, 'Rational').$new(self, 1)['$**'](other)\n        }\n      } else if ($truthy((($a = $rb_lt(self, 0)) ? ($truthy($b = $$($nesting, 'Float')['$==='](other)) ? $b : $$($nesting, 'Rational')['$==='](other)) : $rb_lt(self, 0)))) {\n        return $$($nesting, 'Complex').$new(self, 0)['$**'](other.$to_f())\n      } else if ($truthy(other.$$is_number != null)) {\n        return Math.pow(self, other);\n      } else {\n        return self.$__coerced__(\"**\", other)\n      }\n    }, TMP_Number_$$_23.$$arity = 1);\n    \n    Opal.def(self, '$===', TMP_Number_$eq$eq$eq_24 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self.valueOf() === other.valueOf();\n      }\n      else if (other['$respond_to?'](\"==\")) {\n        return other['$=='](self);\n      }\n      else {\n        return false;\n      }\n    \n    }, TMP_Number_$eq$eq$eq_24.$$arity = 1);\n    \n    Opal.def(self, '$==', TMP_Number_$eq$eq_25 = function(other) {\n      var self = this;\n\n      \n      if (other.$$is_number) {\n        return self.valueOf() === other.valueOf();\n      }\n      else if (other['$respond_to?'](\"==\")) {\n        return other['$=='](self);\n      }\n      else {\n        return false;\n      }\n    \n    }, TMP_Number_$eq$eq_25.$$arity = 1);\n    \n    Opal.def(self, '$abs', TMP_Number_abs_26 = function $$abs() {\n      var self = this;\n\n      return Math.abs(self);\n    }, TMP_Number_abs_26.$$arity = 0);\n    \n    Opal.def(self, '$abs2', TMP_Number_abs2_27 = function $$abs2() {\n      var self = this;\n\n      return Math.abs(self * self);\n    }, TMP_Number_abs2_27.$$arity = 0);\n    \n    Opal.def(self, '$allbits?', TMP_Number_allbits$q_28 = function(mask) {\n      var self = this;\n\n      \n      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), \"to_int\");\n      return (self & mask) == mask;;\n    }, TMP_Number_allbits$q_28.$$arity = 1);\n    \n    Opal.def(self, '$anybits?', TMP_Number_anybits$q_29 = function(mask) {\n      var self = this;\n\n      \n      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), \"to_int\");\n      return (self & mask) !== 0;;\n    }, TMP_Number_anybits$q_29.$$arity = 1);\n    \n    Opal.def(self, '$angle', TMP_Number_angle_30 = function $$angle() {\n      var self = this;\n\n      \n      if ($truthy(self['$nan?']())) {\n        return self};\n      \n      if (self == 0) {\n        if (1 / self > 0) {\n          return 0;\n        }\n        else {\n          return Math.PI;\n        }\n      }\n      else if (self < 0) {\n        return Math.PI;\n      }\n      else {\n        return 0;\n      }\n    ;\n    }, TMP_Number_angle_30.$$arity = 0);\n    Opal.alias(self, \"arg\", \"angle\");\n    Opal.alias(self, \"phase\", \"angle\");\n    \n    Opal.def(self, '$bit_length', TMP_Number_bit_length_31 = function $$bit_length() {\n      var self = this;\n\n      \n      if ($truthy($$($nesting, 'Integer')['$==='](self))) {\n      } else {\n        self.$raise($$($nesting, 'NoMethodError').$new(\"\" + \"undefined method `bit_length` for \" + (self) + \":Float\", \"bit_length\"))\n      };\n      \n      if (self === 0 || self === -1) {\n        return 0;\n      }\n\n      var result = 0,\n          value  = self < 0 ? ~self : self;\n\n      while (value != 0) {\n        result   += 1;\n        value  >>>= 1;\n      }\n\n      return result;\n    ;\n    }, TMP_Number_bit_length_31.$$arity = 0);\n    \n    Opal.def(self, '$ceil', TMP_Number_ceil_32 = function $$ceil(ndigits) {\n      var self = this;\n\n      if (ndigits == null) {\n        ndigits = 0;\n      }\n      \n      var f = self.$to_f();\n\n      if (f % 1 === 0 && ndigits >= 0) {\n        return f;\n      }\n\n      var factor = Math.pow(10, ndigits),\n          result = Math.ceil(f * factor) / factor;\n\n      if (f % 1 === 0) {\n        result = Math.round(result);\n      }\n\n      return result;\n    \n    }, TMP_Number_ceil_32.$$arity = -1);\n    \n    Opal.def(self, '$chr', TMP_Number_chr_33 = function $$chr(encoding) {\n      var self = this;\n\n      return String.fromCharCode(self);\n    }, TMP_Number_chr_33.$$arity = -1);\n    \n    Opal.def(self, '$denominator', TMP_Number_denominator_34 = function $$denominator() {\n      var $a, self = this, $iter = TMP_Number_denominator_34.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Number_denominator_34.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      if ($truthy(($truthy($a = self['$nan?']()) ? $a : self['$infinite?']()))) {\n        return 1\n      } else {\n        return $send(self, Opal.find_super_dispatcher(self, 'denominator', TMP_Number_denominator_34, false), $zuper, $iter)\n      }\n    }, TMP_Number_denominator_34.$$arity = 0);\n    \n    Opal.def(self, '$downto', TMP_Number_downto_35 = function $$downto(stop) {\n      var TMP_36, self = this, $iter = TMP_Number_downto_35.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Number_downto_35.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"downto\", stop], (TMP_36 = function(){var self = TMP_36.$$s || this;\n\n        \n          if ($truthy($$($nesting, 'Numeric')['$==='](stop))) {\n          } else {\n            self.$raise($$($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (self.$class()) + \" with \" + (stop.$class()) + \" failed\")\n          };\n          if ($truthy($rb_gt(stop, self))) {\n            return 0\n          } else {\n            return $rb_plus($rb_minus(self, stop), 1)\n          };}, TMP_36.$$s = self, TMP_36.$$arity = 0, TMP_36))\n      };\n      \n      if (!stop.$$is_number) {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (self.$class()) + \" with \" + (stop.$class()) + \" failed\")\n      }\n      for (var i = self; i >= stop; i--) {\n        block(i);\n      }\n    ;\n      return self;\n    }, TMP_Number_downto_35.$$arity = 1);\n    Opal.alias(self, \"eql?\", \"==\");\n    \n    Opal.def(self, '$equal?', TMP_Number_equal$q_37 = function(other) {\n      var $a, self = this;\n\n      return ($truthy($a = self['$=='](other)) ? $a : isNaN(self) && isNaN(other))\n    }, TMP_Number_equal$q_37.$$arity = 1);\n    \n    Opal.def(self, '$even?', TMP_Number_even$q_38 = function() {\n      var self = this;\n\n      return self % 2 === 0;\n    }, TMP_Number_even$q_38.$$arity = 0);\n    \n    Opal.def(self, '$floor', TMP_Number_floor_39 = function $$floor(ndigits) {\n      var self = this;\n\n      if (ndigits == null) {\n        ndigits = 0;\n      }\n      \n      var f = self.$to_f();\n\n      if (f % 1 === 0 && ndigits >= 0) {\n        return f;\n      }\n\n      var factor = Math.pow(10, ndigits),\n          result = Math.floor(f * factor) / factor;\n\n      if (f % 1 === 0) {\n        result = Math.round(result);\n      }\n\n      return result;\n    \n    }, TMP_Number_floor_39.$$arity = -1);\n    \n    Opal.def(self, '$gcd', TMP_Number_gcd_40 = function $$gcd(other) {\n      var self = this;\n\n      \n      if ($truthy($$($nesting, 'Integer')['$==='](other))) {\n      } else {\n        self.$raise($$($nesting, 'TypeError'), \"not an integer\")\n      };\n      \n      var min = Math.abs(self),\n          max = Math.abs(other);\n\n      while (min > 0) {\n        var tmp = min;\n\n        min = max % min;\n        max = tmp;\n      }\n\n      return max;\n    ;\n    }, TMP_Number_gcd_40.$$arity = 1);\n    \n    Opal.def(self, '$gcdlcm', TMP_Number_gcdlcm_41 = function $$gcdlcm(other) {\n      var self = this;\n\n      return [self.$gcd(), self.$lcm()]\n    }, TMP_Number_gcdlcm_41.$$arity = 1);\n    \n    Opal.def(self, '$integer?', TMP_Number_integer$q_42 = function() {\n      var self = this;\n\n      return self % 1 === 0;\n    }, TMP_Number_integer$q_42.$$arity = 0);\n    \n    Opal.def(self, '$is_a?', TMP_Number_is_a$q_43 = function(klass) {\n      var $a, self = this, $iter = TMP_Number_is_a$q_43.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Number_is_a$q_43.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      \n      if ($truthy((($a = klass['$==']($$($nesting, 'Integer'))) ? $$($nesting, 'Integer')['$==='](self) : klass['$==']($$($nesting, 'Integer'))))) {\n        return true};\n      if ($truthy((($a = klass['$==']($$($nesting, 'Integer'))) ? $$($nesting, 'Integer')['$==='](self) : klass['$==']($$($nesting, 'Integer'))))) {\n        return true};\n      if ($truthy((($a = klass['$==']($$($nesting, 'Float'))) ? $$($nesting, 'Float')['$==='](self) : klass['$==']($$($nesting, 'Float'))))) {\n        return true};\n      return $send(self, Opal.find_super_dispatcher(self, 'is_a?', TMP_Number_is_a$q_43, false), $zuper, $iter);\n    }, TMP_Number_is_a$q_43.$$arity = 1);\n    Opal.alias(self, \"kind_of?\", \"is_a?\");\n    \n    Opal.def(self, '$instance_of?', TMP_Number_instance_of$q_44 = function(klass) {\n      var $a, self = this, $iter = TMP_Number_instance_of$q_44.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Number_instance_of$q_44.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      \n      if ($truthy((($a = klass['$==']($$($nesting, 'Integer'))) ? $$($nesting, 'Integer')['$==='](self) : klass['$==']($$($nesting, 'Integer'))))) {\n        return true};\n      if ($truthy((($a = klass['$==']($$($nesting, 'Integer'))) ? $$($nesting, 'Integer')['$==='](self) : klass['$==']($$($nesting, 'Integer'))))) {\n        return true};\n      if ($truthy((($a = klass['$==']($$($nesting, 'Float'))) ? $$($nesting, 'Float')['$==='](self) : klass['$==']($$($nesting, 'Float'))))) {\n        return true};\n      return $send(self, Opal.find_super_dispatcher(self, 'instance_of?', TMP_Number_instance_of$q_44, false), $zuper, $iter);\n    }, TMP_Number_instance_of$q_44.$$arity = 1);\n    \n    Opal.def(self, '$lcm', TMP_Number_lcm_45 = function $$lcm(other) {\n      var self = this;\n\n      \n      if ($truthy($$($nesting, 'Integer')['$==='](other))) {\n      } else {\n        self.$raise($$($nesting, 'TypeError'), \"not an integer\")\n      };\n      \n      if (self == 0 || other == 0) {\n        return 0;\n      }\n      else {\n        return Math.abs(self * other / self.$gcd(other));\n      }\n    ;\n    }, TMP_Number_lcm_45.$$arity = 1);\n    Opal.alias(self, \"magnitude\", \"abs\");\n    Opal.alias(self, \"modulo\", \"%\");\n    \n    Opal.def(self, '$next', TMP_Number_next_46 = function $$next() {\n      var self = this;\n\n      return self + 1;\n    }, TMP_Number_next_46.$$arity = 0);\n    \n    Opal.def(self, '$nobits?', TMP_Number_nobits$q_47 = function(mask) {\n      var self = this;\n\n      \n      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), \"to_int\");\n      return (self & mask) == 0;;\n    }, TMP_Number_nobits$q_47.$$arity = 1);\n    \n    Opal.def(self, '$nonzero?', TMP_Number_nonzero$q_48 = function() {\n      var self = this;\n\n      return self == 0 ? nil : self;\n    }, TMP_Number_nonzero$q_48.$$arity = 0);\n    \n    Opal.def(self, '$numerator', TMP_Number_numerator_49 = function $$numerator() {\n      var $a, self = this, $iter = TMP_Number_numerator_49.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Number_numerator_49.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      if ($truthy(($truthy($a = self['$nan?']()) ? $a : self['$infinite?']()))) {\n        return self\n      } else {\n        return $send(self, Opal.find_super_dispatcher(self, 'numerator', TMP_Number_numerator_49, false), $zuper, $iter)\n      }\n    }, TMP_Number_numerator_49.$$arity = 0);\n    \n    Opal.def(self, '$odd?', TMP_Number_odd$q_50 = function() {\n      var self = this;\n\n      return self % 2 !== 0;\n    }, TMP_Number_odd$q_50.$$arity = 0);\n    \n    Opal.def(self, '$ord', TMP_Number_ord_51 = function $$ord() {\n      var self = this;\n\n      return self\n    }, TMP_Number_ord_51.$$arity = 0);\n    \n    Opal.def(self, '$pow', TMP_Number_pow_52 = function $$pow(b, m) {\n      var self = this;\n\n      \n      if (self == 0) {\n        self.$raise($$($nesting, 'ZeroDivisionError'), \"divided by 0\")\n      }\n\n      if (m === undefined) {\n        return self['$**'](b);\n      } else {\n        if (!($$($nesting, 'Integer')['$==='](b))) {\n          self.$raise($$($nesting, 'TypeError'), \"Integer#pow() 2nd argument not allowed unless a 1st argument is integer\")\n        }\n\n        if (b < 0) {\n          self.$raise($$($nesting, 'TypeError'), \"Integer#pow() 1st argument cannot be negative when 2nd argument specified\")\n        }\n\n        if (!($$($nesting, 'Integer')['$==='](m))) {\n          self.$raise($$($nesting, 'TypeError'), \"Integer#pow() 2nd argument not allowed unless all arguments are integers\")\n        }\n\n        if (m === 0) {\n          self.$raise($$($nesting, 'ZeroDivisionError'), \"divided by 0\")\n        }\n\n        return self['$**'](b)['$%'](m)\n      }\n    \n    }, TMP_Number_pow_52.$$arity = -2);\n    \n    Opal.def(self, '$pred', TMP_Number_pred_53 = function $$pred() {\n      var self = this;\n\n      return self - 1;\n    }, TMP_Number_pred_53.$$arity = 0);\n    \n    Opal.def(self, '$quo', TMP_Number_quo_54 = function $$quo(other) {\n      var self = this, $iter = TMP_Number_quo_54.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Number_quo_54.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      if ($truthy($$($nesting, 'Integer')['$==='](self))) {\n        return $send(self, Opal.find_super_dispatcher(self, 'quo', TMP_Number_quo_54, false), $zuper, $iter)\n      } else {\n        return $rb_divide(self, other)\n      }\n    }, TMP_Number_quo_54.$$arity = 1);\n    \n    Opal.def(self, '$rationalize', TMP_Number_rationalize_55 = function $$rationalize(eps) {\n      var $a, $b, self = this, f = nil, n = nil;\n\n      \n      \n      if (arguments.length > 1) {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (arguments.length) + \" for 0..1)\");\n      }\n    ;\n      if ($truthy($$($nesting, 'Integer')['$==='](self))) {\n        return $$($nesting, 'Rational').$new(self, 1)\n      } else if ($truthy(self['$infinite?']())) {\n        return self.$raise($$($nesting, 'FloatDomainError'), \"Infinity\")\n      } else if ($truthy(self['$nan?']())) {\n        return self.$raise($$($nesting, 'FloatDomainError'), \"NaN\")\n      } else if ($truthy(eps == null)) {\n        \n        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (n = ($a[1] == null ? nil : $a[1])), $b;\n        f = $$($nesting, 'Math').$ldexp(f, $$$($$($nesting, 'Float'), 'MANT_DIG')).$to_i();\n        n = $rb_minus(n, $$$($$($nesting, 'Float'), 'MANT_DIG'));\n        return $$($nesting, 'Rational').$new($rb_times(2, f), (1)['$<<']($rb_minus(1, n))).$rationalize($$($nesting, 'Rational').$new(1, (1)['$<<']($rb_minus(1, n))));\n      } else {\n        return self.$to_r().$rationalize(eps)\n      };\n    }, TMP_Number_rationalize_55.$$arity = -1);\n    \n    Opal.def(self, '$remainder', TMP_Number_remainder_56 = function $$remainder(y) {\n      var self = this;\n\n      return $rb_minus(self, $rb_times(y, $rb_divide(self, y).$truncate()))\n    }, TMP_Number_remainder_56.$$arity = 1);\n    \n    Opal.def(self, '$round', TMP_Number_round_57 = function $$round(ndigits) {\n      var $a, $b, self = this, _ = nil, exp = nil;\n\n      if ($truthy($$($nesting, 'Integer')['$==='](self))) {\n        \n        if ($truthy(ndigits == null)) {\n          return self};\n        if ($truthy(($truthy($a = $$($nesting, 'Float')['$==='](ndigits)) ? ndigits['$infinite?']() : $a))) {\n          self.$raise($$($nesting, 'RangeError'), \"Infinity\")};\n        ndigits = $$($nesting, 'Opal')['$coerce_to!'](ndigits, $$($nesting, 'Integer'), \"to_int\");\n        if ($truthy($rb_lt(ndigits, $$$($$($nesting, 'Integer'), 'MIN')))) {\n          self.$raise($$($nesting, 'RangeError'), \"out of bounds\")};\n        if ($truthy(ndigits >= 0)) {\n          return self};\n        ndigits = ndigits['$-@']();\n        \n        if (0.415241 * ndigits - 0.125 > self.$size()) {\n          return 0;\n        }\n\n        var f = Math.pow(10, ndigits),\n            x = Math.floor((Math.abs(x) + f / 2) / f) * f;\n\n        return self < 0 ? -x : x;\n      ;\n      } else {\n        \n        if ($truthy(($truthy($a = self['$nan?']()) ? ndigits == null : $a))) {\n          self.$raise($$($nesting, 'FloatDomainError'), \"NaN\")};\n        ndigits = $$($nesting, 'Opal')['$coerce_to!'](ndigits || 0, $$($nesting, 'Integer'), \"to_int\");\n        if ($truthy($rb_le(ndigits, 0))) {\n          if ($truthy(self['$nan?']())) {\n            self.$raise($$($nesting, 'RangeError'), \"NaN\")\n          } else if ($truthy(self['$infinite?']())) {\n            self.$raise($$($nesting, 'FloatDomainError'), \"Infinity\")}\n        } else if (ndigits['$=='](0)) {\n          return Math.round(self)\n        } else if ($truthy(($truthy($a = self['$nan?']()) ? $a : self['$infinite?']()))) {\n          return self};\n        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (exp = ($a[1] == null ? nil : $a[1])), $b;\n        if ($truthy($rb_ge(ndigits, $rb_minus($rb_plus($$$($$($nesting, 'Float'), 'DIG'), 2), (function() {if ($truthy($rb_gt(exp, 0))) {\n          return $rb_divide(exp, 4)\n        } else {\n          return $rb_minus($rb_divide(exp, 3), 1)\n        }; return nil; })())))) {\n          return self};\n        if ($truthy($rb_lt(ndigits, (function() {if ($truthy($rb_gt(exp, 0))) {\n          return $rb_plus($rb_divide(exp, 3), 1)\n        } else {\n          return $rb_divide(exp, 4)\n        }; return nil; })()['$-@']()))) {\n          return 0};\n        return Math.round(self * Math.pow(10, ndigits)) / Math.pow(10, ndigits);;\n      }\n    }, TMP_Number_round_57.$$arity = -1);\n    \n    Opal.def(self, '$step', TMP_Number_step_58 = function $$step($limit, $step, $kwargs) {\n      var TMP_59, self = this, $post_args, to, by, limit, step, $iter = TMP_Number_step_58.$$p, block = $iter || nil, positional_args = nil, keyword_args = nil;\n\n      $post_args = Opal.slice.call(arguments, 0, arguments.length);\n      $kwargs = Opal.extract_kwargs($post_args);\n      if ($kwargs == null || !$kwargs.$$is_hash) {\n        if ($kwargs == null) {\n          $kwargs = $hash2([], {});\n        } else {\n          throw Opal.ArgumentError.$new('expected kwargs');\n        }\n      }\n      to = $kwargs.$$smap[\"to\"];\n      by = $kwargs.$$smap[\"by\"];\n      if (0 < $post_args.length) {\n        limit = $post_args.splice(0,1)[0];\n      }\n      if (0 < $post_args.length) {\n        step = $post_args.splice(0,1)[0];\n      }\n      if ($iter) TMP_Number_step_58.$$p = null;\n      \n      \n      if (limit !== undefined && to !== undefined) {\n        self.$raise($$($nesting, 'ArgumentError'), \"to is given twice\")\n      }\n\n      if (step !== undefined && by !== undefined) {\n        self.$raise($$($nesting, 'ArgumentError'), \"step is given twice\")\n      }\n\n      function validateParameters() {\n        if (to !== undefined) {\n          limit = to;\n        }\n\n        if (limit === undefined) {\n          limit = nil;\n        }\n\n        if (step === nil) {\n          self.$raise($$($nesting, 'TypeError'), \"step must be numeric\")\n        }\n\n        if (step === 0) {\n          self.$raise($$($nesting, 'ArgumentError'), \"step can't be 0\")\n        }\n\n        if (by !== undefined) {\n          step = by;\n        }\n\n        if (step === nil || step == null) {\n          step = 1;\n        }\n\n        var sign = step['$<=>'](0);\n\n        if (sign === nil) {\n          self.$raise($$($nesting, 'ArgumentError'), \"\" + \"0 can't be coerced into \" + (step.$class()))\n        }\n\n        if (limit === nil || limit == null) {\n          limit = sign > 0 ? $$$($$($nesting, 'Float'), 'INFINITY') : $$$($$($nesting, 'Float'), 'INFINITY')['$-@']();\n        }\n\n        $$($nesting, 'Opal').$compare(self, limit)\n      }\n\n      function stepFloatSize() {\n        if ((step > 0 && self > limit) || (step < 0 && self < limit)) {\n          return 0;\n        } else if (step === Infinity || step === -Infinity) {\n          return 1;\n        } else {\n          var abs = Math.abs, floor = Math.floor,\n              err = (abs(self) + abs(limit) + abs(limit - self)) / abs(step) * $$$($$($nesting, 'Float'), 'EPSILON');\n\n          if (err === Infinity || err === -Infinity) {\n            return 0;\n          } else {\n            if (err > 0.5) {\n              err = 0.5;\n            }\n\n            return floor((limit - self) / step + err) + 1\n          }\n        }\n      }\n\n      function stepSize() {\n        validateParameters();\n\n        if (step === 0) {\n          return Infinity;\n        }\n\n        if (step % 1 !== 0) {\n          return stepFloatSize();\n        } else if ((step > 0 && self > limit) || (step < 0 && self < limit)) {\n          return 0;\n        } else {\n          var ceil = Math.ceil, abs = Math.abs,\n              lhs = abs(self - limit) + 1,\n              rhs = abs(step);\n\n          return ceil(lhs / rhs);\n        }\n      }\n    ;\n      if ((block !== nil)) {\n      } else {\n        \n        positional_args = [];\n        keyword_args = $hash2([], {});\n        \n        if (limit !== undefined) {\n          positional_args.push(limit);\n        }\n\n        if (step !== undefined) {\n          positional_args.push(step);\n        }\n\n        if (to !== undefined) {\n          Opal.hash_put(keyword_args, \"to\", to);\n        }\n\n        if (by !== undefined) {\n          Opal.hash_put(keyword_args, \"by\", by);\n        }\n\n        if (keyword_args['$any?']()) {\n          positional_args.push(keyword_args);\n        }\n      ;\n        return $send(self, 'enum_for', [\"step\"].concat(Opal.to_a(positional_args)), (TMP_59 = function(){var self = TMP_59.$$s || this;\n\n        return stepSize();}, TMP_59.$$s = self, TMP_59.$$arity = 0, TMP_59));\n      };\n      \n      validateParameters();\n\n      if (step === 0) {\n        while (true) {\n          block(self);\n        }\n      }\n\n      if (self % 1 !== 0 || limit % 1 !== 0 || step % 1 !== 0) {\n        var n = stepFloatSize();\n\n        if (n > 0) {\n          if (step === Infinity || step === -Infinity) {\n            block(self);\n          } else {\n            var i = 0, d;\n\n            if (step > 0) {\n              while (i < n) {\n                d = i * step + self;\n                if (limit < d) {\n                  d = limit;\n                }\n                block(d);\n                i += 1;\n              }\n            } else {\n              while (i < n) {\n                d = i * step + self;\n                if (limit > d) {\n                  d = limit;\n                }\n                block(d);\n                i += 1\n              }\n            }\n          }\n        }\n      } else {\n        var value = self;\n\n        if (step > 0) {\n          while (value <= limit) {\n            block(value);\n            value += step;\n          }\n        } else {\n          while (value >= limit) {\n            block(value);\n            value += step\n          }\n        }\n      }\n\n      return self;\n    ;\n    }, TMP_Number_step_58.$$arity = -1);\n    Opal.alias(self, \"succ\", \"next\");\n    \n    Opal.def(self, '$times', TMP_Number_times_60 = function $$times() {\n      var TMP_61, self = this, $iter = TMP_Number_times_60.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Number_times_60.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        return $send(self, 'enum_for', [\"times\"], (TMP_61 = function(){var self = TMP_61.$$s || this;\n\n        return self}, TMP_61.$$s = self, TMP_61.$$arity = 0, TMP_61))\n      };\n      \n      for (var i = 0; i < self; i++) {\n        block(i);\n      }\n    ;\n      return self;\n    }, TMP_Number_times_60.$$arity = 0);\n    \n    Opal.def(self, '$to_f', TMP_Number_to_f_62 = function $$to_f() {\n      var self = this;\n\n      return self\n    }, TMP_Number_to_f_62.$$arity = 0);\n    \n    Opal.def(self, '$to_i', TMP_Number_to_i_63 = function $$to_i() {\n      var self = this;\n\n      return parseInt(self, 10);\n    }, TMP_Number_to_i_63.$$arity = 0);\n    Opal.alias(self, \"to_int\", \"to_i\");\n    \n    Opal.def(self, '$to_r', TMP_Number_to_r_64 = function $$to_r() {\n      var $a, $b, self = this, f = nil, e = nil;\n\n      if ($truthy($$($nesting, 'Integer')['$==='](self))) {\n        return $$($nesting, 'Rational').$new(self, 1)\n      } else {\n        \n        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (e = ($a[1] == null ? nil : $a[1])), $b;\n        f = $$($nesting, 'Math').$ldexp(f, $$$($$($nesting, 'Float'), 'MANT_DIG')).$to_i();\n        e = $rb_minus(e, $$$($$($nesting, 'Float'), 'MANT_DIG'));\n        return $rb_times(f, $$$($$($nesting, 'Float'), 'RADIX')['$**'](e)).$to_r();\n      }\n    }, TMP_Number_to_r_64.$$arity = 0);\n    \n    Opal.def(self, '$to_s', TMP_Number_to_s_65 = function $$to_s(base) {\n      var $a, self = this;\n\n      if (base == null) {\n        base = 10;\n      }\n      \n      base = $$($nesting, 'Opal')['$coerce_to!'](base, $$($nesting, 'Integer'), \"to_int\");\n      if ($truthy(($truthy($a = $rb_lt(base, 2)) ? $a : $rb_gt(base, 36)))) {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"invalid radix \" + (base))};\n      return self.toString(base);;\n    }, TMP_Number_to_s_65.$$arity = -1);\n    \n    Opal.def(self, '$truncate', TMP_Number_truncate_66 = function $$truncate(ndigits) {\n      var self = this;\n\n      if (ndigits == null) {\n        ndigits = 0;\n      }\n      \n      var f = self.$to_f();\n\n      if (f % 1 === 0 && ndigits >= 0) {\n        return f;\n      }\n\n      var factor = Math.pow(10, ndigits),\n          result = parseInt(f * factor, 10) / factor;\n\n      if (f % 1 === 0) {\n        result = Math.round(result);\n      }\n\n      return result;\n    \n    }, TMP_Number_truncate_66.$$arity = -1);\n    Opal.alias(self, \"inspect\", \"to_s\");\n    \n    Opal.def(self, '$digits', TMP_Number_digits_67 = function $$digits(base) {\n      var self = this;\n\n      if (base == null) {\n        base = 10;\n      }\n      \n      if ($rb_lt(self, 0)) {\n        self.$raise($$$($$($nesting, 'Math'), 'DomainError'), \"out of domain\")};\n      base = $$($nesting, 'Opal')['$coerce_to!'](base, $$($nesting, 'Integer'), \"to_int\");\n      if ($truthy($rb_lt(base, 2))) {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"invalid radix \" + (base))};\n      \n      var value = self, result = [];\n\n      while (value !== 0) {\n        result.push(value % base);\n        value = parseInt(value / base, 10);\n      }\n\n      return result;\n    ;\n    }, TMP_Number_digits_67.$$arity = -1);\n    \n    Opal.def(self, '$divmod', TMP_Number_divmod_68 = function $$divmod(other) {\n      var $a, self = this, $iter = TMP_Number_divmod_68.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Number_divmod_68.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      if ($truthy(($truthy($a = self['$nan?']()) ? $a : other['$nan?']()))) {\n        return self.$raise($$($nesting, 'FloatDomainError'), \"NaN\")\n      } else if ($truthy(self['$infinite?']())) {\n        return self.$raise($$($nesting, 'FloatDomainError'), \"Infinity\")\n      } else {\n        return $send(self, Opal.find_super_dispatcher(self, 'divmod', TMP_Number_divmod_68, false), $zuper, $iter)\n      }\n    }, TMP_Number_divmod_68.$$arity = 1);\n    \n    Opal.def(self, '$upto', TMP_Number_upto_69 = function $$upto(stop) {\n      var TMP_70, self = this, $iter = TMP_Number_upto_69.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Number_upto_69.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"upto\", stop], (TMP_70 = function(){var self = TMP_70.$$s || this;\n\n        \n          if ($truthy($$($nesting, 'Numeric')['$==='](stop))) {\n          } else {\n            self.$raise($$($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (self.$class()) + \" with \" + (stop.$class()) + \" failed\")\n          };\n          if ($truthy($rb_lt(stop, self))) {\n            return 0\n          } else {\n            return $rb_plus($rb_minus(stop, self), 1)\n          };}, TMP_70.$$s = self, TMP_70.$$arity = 0, TMP_70))\n      };\n      \n      if (!stop.$$is_number) {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"comparison of \" + (self.$class()) + \" with \" + (stop.$class()) + \" failed\")\n      }\n      for (var i = self; i <= stop; i++) {\n        block(i);\n      }\n    ;\n      return self;\n    }, TMP_Number_upto_69.$$arity = 1);\n    \n    Opal.def(self, '$zero?', TMP_Number_zero$q_71 = function() {\n      var self = this;\n\n      return self == 0;\n    }, TMP_Number_zero$q_71.$$arity = 0);\n    \n    Opal.def(self, '$size', TMP_Number_size_72 = function $$size() {\n      var self = this;\n\n      return 4\n    }, TMP_Number_size_72.$$arity = 0);\n    \n    Opal.def(self, '$nan?', TMP_Number_nan$q_73 = function() {\n      var self = this;\n\n      return isNaN(self);\n    }, TMP_Number_nan$q_73.$$arity = 0);\n    \n    Opal.def(self, '$finite?', TMP_Number_finite$q_74 = function() {\n      var self = this;\n\n      return self != Infinity && self != -Infinity && !isNaN(self);\n    }, TMP_Number_finite$q_74.$$arity = 0);\n    \n    Opal.def(self, '$infinite?', TMP_Number_infinite$q_75 = function() {\n      var self = this;\n\n      \n      if (self == Infinity) {\n        return +1;\n      }\n      else if (self == -Infinity) {\n        return -1;\n      }\n      else {\n        return nil;\n      }\n    \n    }, TMP_Number_infinite$q_75.$$arity = 0);\n    \n    Opal.def(self, '$positive?', TMP_Number_positive$q_76 = function() {\n      var self = this;\n\n      return self != 0 && (self == Infinity || 1 / self > 0);\n    }, TMP_Number_positive$q_76.$$arity = 0);\n    return (Opal.def(self, '$negative?', TMP_Number_negative$q_77 = function() {\n      var self = this;\n\n      return self == -Infinity || 1 / self < 0;\n    }, TMP_Number_negative$q_77.$$arity = 0), nil) && 'negative?';\n  })($nesting[0], $$($nesting, 'Numeric'), $nesting);\n  Opal.const_set($nesting[0], 'Fixnum', $$($nesting, 'Number'));\n  (function($base, $super, $parent_nesting) {\n    function $Integer(){};\n    var self = $Integer = $klass($base, $super, 'Integer', $Integer);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    \n    self.$$is_number_class = true;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_allocate_78, TMP_$eq$eq$eq_79, TMP_sqrt_80;\n\n      \n      \n      Opal.def(self, '$allocate', TMP_allocate_78 = function $$allocate() {\n        var self = this;\n\n        return self.$raise($$($nesting, 'TypeError'), \"\" + \"allocator undefined for \" + (self.$name()))\n      }, TMP_allocate_78.$$arity = 0);\n      \n      Opal.udef(self, '$' + \"new\");;\n      \n      Opal.def(self, '$===', TMP_$eq$eq$eq_79 = function(other) {\n        var self = this;\n\n        \n        if (!other.$$is_number) {\n          return false;\n        }\n\n        return (other % 1) === 0;\n      \n      }, TMP_$eq$eq$eq_79.$$arity = 1);\n      return (Opal.def(self, '$sqrt', TMP_sqrt_80 = function $$sqrt(n) {\n        var self = this;\n\n        \n        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), \"to_int\");\n        \n        if (n < 0) {\n          self.$raise($$$($$($nesting, 'Math'), 'DomainError'), \"Numerical argument is out of domain - \\\"isqrt\\\"\")\n        }\n\n        return parseInt(Math.sqrt(n), 10);\n      ;\n      }, TMP_sqrt_80.$$arity = 1), nil) && 'sqrt';\n    })(Opal.get_singleton_class(self), $nesting);\n    Opal.const_set($nesting[0], 'MAX', Math.pow(2, 30) - 1);\n    return Opal.const_set($nesting[0], 'MIN', -Math.pow(2, 30));\n  })($nesting[0], $$($nesting, 'Numeric'), $nesting);\n  return (function($base, $super, $parent_nesting) {\n    function $Float(){};\n    var self = $Float = $klass($base, $super, 'Float', $Float);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    \n    self.$$is_number_class = true;\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_allocate_81, TMP_$eq$eq$eq_82;\n\n      \n      \n      Opal.def(self, '$allocate', TMP_allocate_81 = function $$allocate() {\n        var self = this;\n\n        return self.$raise($$($nesting, 'TypeError'), \"\" + \"allocator undefined for \" + (self.$name()))\n      }, TMP_allocate_81.$$arity = 0);\n      \n      Opal.udef(self, '$' + \"new\");;\n      return (Opal.def(self, '$===', TMP_$eq$eq$eq_82 = function(other) {\n        var self = this;\n\n        return !!other.$$is_number;\n      }, TMP_$eq$eq$eq_82.$$arity = 1), nil) && '===';\n    })(Opal.get_singleton_class(self), $nesting);\n    Opal.const_set($nesting[0], 'INFINITY', Infinity);\n    Opal.const_set($nesting[0], 'MAX', Number.MAX_VALUE);\n    Opal.const_set($nesting[0], 'MIN', Number.MIN_VALUE);\n    Opal.const_set($nesting[0], 'NAN', NaN);\n    Opal.const_set($nesting[0], 'DIG', 15);\n    Opal.const_set($nesting[0], 'MANT_DIG', 53);\n    Opal.const_set($nesting[0], 'RADIX', 2);\n    return Opal.const_set($nesting[0], 'EPSILON', Number.EPSILON || 2.2204460492503130808472633361816E-16);\n  })($nesting[0], $$($nesting, 'Numeric'), $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/range\"] = function(Opal) {\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$include', '$attr_reader', '$raise', '$<=>', '$include?', '$<=', '$<', '$enum_for', '$upto', '$to_proc', '$respond_to?', '$class', '$succ', '$!', '$==', '$===', '$exclude_end?', '$eql?', '$begin', '$end', '$last', '$to_a', '$>', '$-', '$abs', '$to_i', '$coerce_to!', '$ceil', '$/', '$size', '$loop', '$+', '$*', '$>=', '$each_with_index', '$%', '$bsearch', '$inspect', '$[]', '$hash']);\n  \n  self.$require(\"corelib/enumerable\");\n  return (function($base, $super, $parent_nesting) {\n    function $Range(){};\n    var self = $Range = $klass($base, $super, 'Range', $Range);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Range_initialize_1, TMP_Range_$eq$eq_2, TMP_Range_$eq$eq$eq_3, TMP_Range_cover$q_4, TMP_Range_each_5, TMP_Range_eql$q_6, TMP_Range_exclude_end$q_7, TMP_Range_first_8, TMP_Range_last_9, TMP_Range_max_10, TMP_Range_min_11, TMP_Range_size_12, TMP_Range_step_13, TMP_Range_bsearch_17, TMP_Range_to_s_18, TMP_Range_inspect_19, TMP_Range_marshal_load_20, TMP_Range_hash_21;\n\n    def.begin = def.end = def.excl = nil;\n    \n    self.$include($$($nesting, 'Enumerable'));\n    def.$$is_range = true;\n    self.$attr_reader(\"begin\", \"end\");\n    \n    Opal.def(self, '$initialize', TMP_Range_initialize_1 = function $$initialize(first, last, exclude) {\n      var self = this;\n\n      if (exclude == null) {\n        exclude = false;\n      }\n      \n      if ($truthy(self.begin)) {\n        self.$raise($$($nesting, 'NameError'), \"'initialize' called twice\")};\n      if ($truthy(first['$<=>'](last))) {\n      } else {\n        self.$raise($$($nesting, 'ArgumentError'), \"bad value for range\")\n      };\n      self.begin = first;\n      self.end = last;\n      return (self.excl = exclude);\n    }, TMP_Range_initialize_1.$$arity = -3);\n    \n    Opal.def(self, '$==', TMP_Range_$eq$eq_2 = function(other) {\n      var self = this;\n\n      \n      if (!other.$$is_range) {\n        return false;\n      }\n\n      return self.excl  === other.excl &&\n             self.begin ==  other.begin &&\n             self.end   ==  other.end;\n    \n    }, TMP_Range_$eq$eq_2.$$arity = 1);\n    \n    Opal.def(self, '$===', TMP_Range_$eq$eq$eq_3 = function(value) {\n      var self = this;\n\n      return self['$include?'](value)\n    }, TMP_Range_$eq$eq$eq_3.$$arity = 1);\n    \n    Opal.def(self, '$cover?', TMP_Range_cover$q_4 = function(value) {\n      var $a, self = this, beg_cmp = nil, end_cmp = nil;\n\n      \n      beg_cmp = self.begin['$<=>'](value);\n      if ($truthy(($truthy($a = beg_cmp) ? $rb_le(beg_cmp, 0) : $a))) {\n      } else {\n        return false\n      };\n      end_cmp = value['$<=>'](self.end);\n      if ($truthy(self.excl)) {\n        return ($truthy($a = end_cmp) ? $rb_lt(end_cmp, 0) : $a)\n      } else {\n        return ($truthy($a = end_cmp) ? $rb_le(end_cmp, 0) : $a)\n      };\n    }, TMP_Range_cover$q_4.$$arity = 1);\n    \n    Opal.def(self, '$each', TMP_Range_each_5 = function $$each() {\n      var $a, self = this, $iter = TMP_Range_each_5.$$p, block = $iter || nil, current = nil, last = nil;\n\n      if ($iter) TMP_Range_each_5.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return self.$enum_for(\"each\")\n      };\n      \n      var i, limit;\n\n      if (self.begin.$$is_number && self.end.$$is_number) {\n        if (self.begin % 1 !== 0 || self.end % 1 !== 0) {\n          self.$raise($$($nesting, 'TypeError'), \"can't iterate from Float\")\n        }\n\n        for (i = self.begin, limit = self.end + (function() {if ($truthy(self.excl)) {\n        return 0\n      } else {\n        return 1\n      }; return nil; })(); i < limit; i++) {\n          block(i);\n        }\n\n        return self;\n      }\n\n      if (self.begin.$$is_string && self.end.$$is_string) {\n        $send(self.begin, 'upto', [self.end, self.excl], block.$to_proc())\n        return self;\n      }\n    ;\n      current = self.begin;\n      last = self.end;\n      if ($truthy(current['$respond_to?'](\"succ\"))) {\n      } else {\n        self.$raise($$($nesting, 'TypeError'), \"\" + \"can't iterate from \" + (current.$class()))\n      };\n      while ($truthy($rb_lt(current['$<=>'](last), 0))) {\n        \n        Opal.yield1(block, current);\n        current = current.$succ();\n      };\n      if ($truthy(($truthy($a = self.excl['$!']()) ? current['$=='](last) : $a))) {\n        Opal.yield1(block, current)};\n      return self;\n    }, TMP_Range_each_5.$$arity = 0);\n    \n    Opal.def(self, '$eql?', TMP_Range_eql$q_6 = function(other) {\n      var $a, $b, self = this;\n\n      \n      if ($truthy($$($nesting, 'Range')['$==='](other))) {\n      } else {\n        return false\n      };\n      return ($truthy($a = ($truthy($b = self.excl['$==='](other['$exclude_end?']())) ? self.begin['$eql?'](other.$begin()) : $b)) ? self.end['$eql?'](other.$end()) : $a);\n    }, TMP_Range_eql$q_6.$$arity = 1);\n    \n    Opal.def(self, '$exclude_end?', TMP_Range_exclude_end$q_7 = function() {\n      var self = this;\n\n      return self.excl\n    }, TMP_Range_exclude_end$q_7.$$arity = 0);\n    \n    Opal.def(self, '$first', TMP_Range_first_8 = function $$first(n) {\n      var self = this, $iter = TMP_Range_first_8.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Range_first_8.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      \n      if ($truthy(n == null)) {\n        return self.begin};\n      return $send(self, Opal.find_super_dispatcher(self, 'first', TMP_Range_first_8, false), $zuper, $iter);\n    }, TMP_Range_first_8.$$arity = -1);\n    Opal.alias(self, \"include?\", \"cover?\");\n    \n    Opal.def(self, '$last', TMP_Range_last_9 = function $$last(n) {\n      var self = this;\n\n      \n      if ($truthy(n == null)) {\n        return self.end};\n      return self.$to_a().$last(n);\n    }, TMP_Range_last_9.$$arity = -1);\n    \n    Opal.def(self, '$max', TMP_Range_max_10 = function $$max() {\n      var $a, self = this, $iter = TMP_Range_max_10.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Range_max_10.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      if (($yield !== nil)) {\n        return $send(self, Opal.find_super_dispatcher(self, 'max', TMP_Range_max_10, false), $zuper, $iter)\n      } else if ($truthy($rb_gt(self.begin, self.end))) {\n        return nil\n      } else if ($truthy(($truthy($a = self.excl) ? self.begin['$=='](self.end) : $a))) {\n        return nil\n      } else {\n        return self.excl ? self.end - 1 : self.end\n      }\n    }, TMP_Range_max_10.$$arity = 0);\n    Opal.alias(self, \"member?\", \"cover?\");\n    \n    Opal.def(self, '$min', TMP_Range_min_11 = function $$min() {\n      var $a, self = this, $iter = TMP_Range_min_11.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Range_min_11.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      if (($yield !== nil)) {\n        return $send(self, Opal.find_super_dispatcher(self, 'min', TMP_Range_min_11, false), $zuper, $iter)\n      } else if ($truthy($rb_gt(self.begin, self.end))) {\n        return nil\n      } else if ($truthy(($truthy($a = self.excl) ? self.begin['$=='](self.end) : $a))) {\n        return nil\n      } else {\n        return self.begin\n      }\n    }, TMP_Range_min_11.$$arity = 0);\n    \n    Opal.def(self, '$size', TMP_Range_size_12 = function $$size() {\n      var $a, self = this, range_begin = nil, range_end = nil, infinity = nil;\n\n      \n      range_begin = self.begin;\n      range_end = self.end;\n      if ($truthy(self.excl)) {\n        range_end = $rb_minus(range_end, 1)};\n      if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](range_begin)) ? $$($nesting, 'Numeric')['$==='](range_end) : $a))) {\n      } else {\n        return nil\n      };\n      if ($truthy($rb_lt(range_end, range_begin))) {\n        return 0};\n      infinity = $$$($$($nesting, 'Float'), 'INFINITY');\n      if ($truthy([range_begin.$abs(), range_end.$abs()]['$include?'](infinity))) {\n        return infinity};\n      return (Math.abs(range_end - range_begin) + 1).$to_i();\n    }, TMP_Range_size_12.$$arity = 0);\n    \n    Opal.def(self, '$step', TMP_Range_step_13 = function $$step(n) {\n      var TMP_14, TMP_15, TMP_16, self = this, $iter = TMP_Range_step_13.$$p, $yield = $iter || nil, i = nil;\n\n      if (n == null) {\n        n = 1;\n      }\n      if ($iter) TMP_Range_step_13.$$p = null;\n      \n      \n      function coerceStepSize() {\n        if (!n.$$is_number) {\n          n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), \"to_int\")\n        }\n\n        if (n < 0) {\n          self.$raise($$($nesting, 'ArgumentError'), \"step can't be negative\")\n        } else if (n === 0) {\n          self.$raise($$($nesting, 'ArgumentError'), \"step can't be 0\")\n        }\n      }\n\n      function enumeratorSize() {\n        if (!self.begin['$respond_to?'](\"succ\")) {\n          return nil;\n        }\n\n        if (self.begin.$$is_string && self.end.$$is_string) {\n          return nil;\n        }\n\n        if (n % 1 === 0) {\n          return $rb_divide(self.$size(), n).$ceil();\n        } else {\n          // n is a float\n          var begin = self.begin, end = self.end,\n              abs = Math.abs, floor = Math.floor,\n              err = (abs(begin) + abs(end) + abs(end - begin)) / abs(n) * $$$($$($nesting, 'Float'), 'EPSILON'),\n              size;\n\n          if (err > 0.5) {\n            err = 0.5;\n          }\n\n          if (self.excl) {\n            size = floor((end - begin) / n - err);\n            if (size * n + begin < end) {\n              size++;\n            }\n          } else {\n            size = floor((end - begin) / n + err) + 1\n          }\n\n          return size;\n        }\n      }\n    ;\n      if (($yield !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"step\", n], (TMP_14 = function(){var self = TMP_14.$$s || this;\n\n        \n          coerceStepSize();\n          return enumeratorSize();\n        }, TMP_14.$$s = self, TMP_14.$$arity = 0, TMP_14))\n      };\n      coerceStepSize();\n      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {\n        \n        i = 0;\n        (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], (TMP_15 = function(){var self = TMP_15.$$s || this, current = nil;\n          if (self.begin == null) self.begin = nil;\n          if (self.excl == null) self.excl = nil;\n          if (self.end == null) self.end = nil;\n\n        \n          current = $rb_plus(self.begin, $rb_times(i, n));\n          if ($truthy(self.excl)) {\n            if ($truthy($rb_ge(current, self.end))) {\n              \n              Opal.brk(nil, $brk)}\n          } else if ($truthy($rb_gt(current, self.end))) {\n            \n            Opal.brk(nil, $brk)};\n          Opal.yield1($yield, current);\n          return (i = $rb_plus(i, 1));}, TMP_15.$$s = self, TMP_15.$$brk = $brk, TMP_15.$$arity = 0, TMP_15))\n        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();\n      } else {\n        \n        \n        if (self.begin.$$is_string && self.end.$$is_string && n % 1 !== 0) {\n          self.$raise($$($nesting, 'TypeError'), \"no implicit conversion to float from string\")\n        }\n      ;\n        $send(self, 'each_with_index', [], (TMP_16 = function(value, idx){var self = TMP_16.$$s || this;\nif (value == null) value = nil;if (idx == null) idx = nil;\n        if (idx['$%'](n)['$=='](0)) {\n            return Opal.yield1($yield, value);\n          } else {\n            return nil\n          }}, TMP_16.$$s = self, TMP_16.$$arity = 2, TMP_16));\n      };\n      return self;\n    }, TMP_Range_step_13.$$arity = -1);\n    \n    Opal.def(self, '$bsearch', TMP_Range_bsearch_17 = function $$bsearch() {\n      var self = this, $iter = TMP_Range_bsearch_17.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Range_bsearch_17.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return self.$enum_for(\"bsearch\")\n      };\n      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {\n      } else {\n        self.$raise($$($nesting, 'TypeError'), \"\" + \"can't do binary search for \" + (self.begin.$class()))\n      };\n      return $send(self.$to_a(), 'bsearch', [], block.$to_proc());\n    }, TMP_Range_bsearch_17.$$arity = 0);\n    \n    Opal.def(self, '$to_s', TMP_Range_to_s_18 = function $$to_s() {\n      var self = this;\n\n      return \"\" + (self.begin) + ((function() {if ($truthy(self.excl)) {\n        return \"...\"\n      } else {\n        return \"..\"\n      }; return nil; })()) + (self.end)\n    }, TMP_Range_to_s_18.$$arity = 0);\n    \n    Opal.def(self, '$inspect', TMP_Range_inspect_19 = function $$inspect() {\n      var self = this;\n\n      return \"\" + (self.begin.$inspect()) + ((function() {if ($truthy(self.excl)) {\n        return \"...\"\n      } else {\n        return \"..\"\n      }; return nil; })()) + (self.end.$inspect())\n    }, TMP_Range_inspect_19.$$arity = 0);\n    \n    Opal.def(self, '$marshal_load', TMP_Range_marshal_load_20 = function $$marshal_load(args) {\n      var self = this;\n\n      \n      self.begin = args['$[]'](\"begin\");\n      self.end = args['$[]'](\"end\");\n      return (self.excl = args['$[]'](\"excl\"));\n    }, TMP_Range_marshal_load_20.$$arity = 1);\n    return (Opal.def(self, '$hash', TMP_Range_hash_21 = function $$hash() {\n      var self = this;\n\n      return [self.begin, self.end, self.excl].$hash()\n    }, TMP_Range_hash_21.$$arity = 0), nil) && 'hash';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/proc\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$raise', '$coerce_to!']);\n  return (function($base, $super, $parent_nesting) {\n    function $Proc(){};\n    var self = $Proc = $klass($base, $super, 'Proc', $Proc);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Proc_new_1, TMP_Proc_call_2, TMP_Proc_to_proc_3, TMP_Proc_lambda$q_4, TMP_Proc_arity_5, TMP_Proc_source_location_6, TMP_Proc_binding_7, TMP_Proc_parameters_8, TMP_Proc_curry_9, TMP_Proc_dup_10;\n\n    \n    def.$$is_proc = true;\n    def.$$is_lambda = false;\n    Opal.defs(self, '$new', TMP_Proc_new_1 = function() {\n      var self = this, $iter = TMP_Proc_new_1.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Proc_new_1.$$p = null;\n      \n      if ($truthy(block)) {\n      } else {\n        self.$raise($$($nesting, 'ArgumentError'), \"tried to create a Proc object without a block\")\n      };\n      return block;\n    }, TMP_Proc_new_1.$$arity = 0);\n    \n    Opal.def(self, '$call', TMP_Proc_call_2 = function $$call($a_rest) {\n      var self = this, args, $iter = TMP_Proc_call_2.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Proc_call_2.$$p = null;\n      \n      if (block !== nil) {\n        self.$$p = block;\n      }\n\n      var result, $brk = self.$$brk;\n\n      if ($brk) {\n        try {\n          if (self.$$is_lambda) {\n            result = self.apply(null, args);\n          }\n          else {\n            result = Opal.yieldX(self, args);\n          }\n        } catch (err) {\n          if (err === $brk) {\n            return $brk.$v\n          }\n          else {\n            throw err\n          }\n        }\n      }\n      else {\n        if (self.$$is_lambda) {\n          result = self.apply(null, args);\n        }\n        else {\n          result = Opal.yieldX(self, args);\n        }\n      }\n\n      return result;\n    \n    }, TMP_Proc_call_2.$$arity = -1);\n    Opal.alias(self, \"[]\", \"call\");\n    Opal.alias(self, \"===\", \"call\");\n    Opal.alias(self, \"yield\", \"call\");\n    \n    Opal.def(self, '$to_proc', TMP_Proc_to_proc_3 = function $$to_proc() {\n      var self = this;\n\n      return self\n    }, TMP_Proc_to_proc_3.$$arity = 0);\n    \n    Opal.def(self, '$lambda?', TMP_Proc_lambda$q_4 = function() {\n      var self = this;\n\n      return !!self.$$is_lambda;\n    }, TMP_Proc_lambda$q_4.$$arity = 0);\n    \n    Opal.def(self, '$arity', TMP_Proc_arity_5 = function $$arity() {\n      var self = this;\n\n      \n      if (self.$$is_curried) {\n        return -1;\n      } else {\n        return self.$$arity;\n      }\n    \n    }, TMP_Proc_arity_5.$$arity = 0);\n    \n    Opal.def(self, '$source_location', TMP_Proc_source_location_6 = function $$source_location() {\n      var self = this;\n\n      \n      if (self.$$is_curried) { return nil; };\n      return nil;\n    }, TMP_Proc_source_location_6.$$arity = 0);\n    \n    Opal.def(self, '$binding', TMP_Proc_binding_7 = function $$binding() {\n      var self = this;\n\n      \n      if (self.$$is_curried) { self.$raise($$($nesting, 'ArgumentError'), \"Can't create Binding\") };\n      return nil;\n    }, TMP_Proc_binding_7.$$arity = 0);\n    \n    Opal.def(self, '$parameters', TMP_Proc_parameters_8 = function $$parameters() {\n      var self = this;\n\n      \n      if (self.$$is_curried) {\n        return [[\"rest\"]];\n      } else if (self.$$parameters) {\n        if (self.$$is_lambda) {\n          return self.$$parameters;\n        } else {\n          var result = [], i, length;\n\n          for (i = 0, length = self.$$parameters.length; i < length; i++) {\n            var parameter = self.$$parameters[i];\n\n            if (parameter[0] === 'req') {\n              // required arguments always have name\n              parameter = ['opt', parameter[1]];\n            }\n\n            result.push(parameter);\n          }\n\n          return result;\n        }\n      } else {\n        return [];\n      }\n    \n    }, TMP_Proc_parameters_8.$$arity = 0);\n    \n    Opal.def(self, '$curry', TMP_Proc_curry_9 = function $$curry(arity) {\n      var self = this;\n\n      \n      if (arity === undefined) {\n        arity = self.length;\n      }\n      else {\n        arity = $$($nesting, 'Opal')['$coerce_to!'](arity, $$($nesting, 'Integer'), \"to_int\");\n        if (self.$$is_lambda && arity !== self.length) {\n          self.$raise($$($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (arity) + \" for \" + (self.length) + \")\")\n        }\n      }\n\n      function curried () {\n        var args = $slice.call(arguments),\n            length = args.length,\n            result;\n\n        if (length > arity && self.$$is_lambda && !self.$$is_curried) {\n          self.$raise($$($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (length) + \" for \" + (arity) + \")\")\n        }\n\n        if (length >= arity) {\n          return self.$call.apply(self, args);\n        }\n\n        result = function () {\n          return curried.apply(null,\n            args.concat($slice.call(arguments)));\n        }\n        result.$$is_lambda = self.$$is_lambda;\n        result.$$is_curried = true;\n\n        return result;\n      };\n\n      curried.$$is_lambda = self.$$is_lambda;\n      curried.$$is_curried = true;\n      return curried;\n    \n    }, TMP_Proc_curry_9.$$arity = -1);\n    \n    Opal.def(self, '$dup', TMP_Proc_dup_10 = function $$dup() {\n      var self = this;\n\n      \n      var original_proc = self.$$original_proc || self,\n          proc = function () {\n            return original_proc.apply(this, arguments);\n          };\n\n      for (var prop in self) {\n        if (self.hasOwnProperty(prop)) {\n          proc[prop] = self[prop];\n        }\n      }\n\n      return proc;\n    \n    }, TMP_Proc_dup_10.$$arity = 0);\n    return Opal.alias(self, \"clone\", \"dup\");\n  })($nesting[0], Function, $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/method\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$attr_reader', '$arity', '$new', '$class', '$join', '$source_location', '$raise']);\n  \n  (function($base, $super, $parent_nesting) {\n    function $Method(){};\n    var self = $Method = $klass($base, $super, 'Method', $Method);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Method_initialize_1, TMP_Method_arity_2, TMP_Method_parameters_3, TMP_Method_source_location_4, TMP_Method_comments_5, TMP_Method_call_6, TMP_Method_unbind_7, TMP_Method_to_proc_8, TMP_Method_inspect_9;\n\n    def.method = def.receiver = def.owner = def.name = nil;\n    \n    self.$attr_reader(\"owner\", \"receiver\", \"name\");\n    \n    Opal.def(self, '$initialize', TMP_Method_initialize_1 = function $$initialize(receiver, owner, method, name) {\n      var self = this;\n\n      \n      self.receiver = receiver;\n      self.owner = owner;\n      self.name = name;\n      return (self.method = method);\n    }, TMP_Method_initialize_1.$$arity = 4);\n    \n    Opal.def(self, '$arity', TMP_Method_arity_2 = function $$arity() {\n      var self = this;\n\n      return self.method.$arity()\n    }, TMP_Method_arity_2.$$arity = 0);\n    \n    Opal.def(self, '$parameters', TMP_Method_parameters_3 = function $$parameters() {\n      var self = this;\n\n      return self.method.$$parameters\n    }, TMP_Method_parameters_3.$$arity = 0);\n    \n    Opal.def(self, '$source_location', TMP_Method_source_location_4 = function $$source_location() {\n      var $a, self = this;\n\n      return ($truthy($a = self.method.$$source_location) ? $a : [\"(eval)\", 0])\n    }, TMP_Method_source_location_4.$$arity = 0);\n    \n    Opal.def(self, '$comments', TMP_Method_comments_5 = function $$comments() {\n      var $a, self = this;\n\n      return ($truthy($a = self.method.$$comments) ? $a : [])\n    }, TMP_Method_comments_5.$$arity = 0);\n    \n    Opal.def(self, '$call', TMP_Method_call_6 = function $$call($a_rest) {\n      var self = this, args, $iter = TMP_Method_call_6.$$p, block = $iter || nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Method_call_6.$$p = null;\n      \n      self.method.$$p = block;\n\n      return self.method.apply(self.receiver, args);\n    \n    }, TMP_Method_call_6.$$arity = -1);\n    Opal.alias(self, \"[]\", \"call\");\n    \n    Opal.def(self, '$unbind', TMP_Method_unbind_7 = function $$unbind() {\n      var self = this;\n\n      return $$($nesting, 'UnboundMethod').$new(self.receiver.$class(), self.owner, self.method, self.name)\n    }, TMP_Method_unbind_7.$$arity = 0);\n    \n    Opal.def(self, '$to_proc', TMP_Method_to_proc_8 = function $$to_proc() {\n      var self = this;\n\n      \n      var proc = self.$call.bind(self);\n      proc.$$unbound = self.method;\n      proc.$$is_lambda = true;\n      return proc;\n    \n    }, TMP_Method_to_proc_8.$$arity = 0);\n    return (Opal.def(self, '$inspect', TMP_Method_inspect_9 = function $$inspect() {\n      var self = this;\n\n      return \"\" + \"#<\" + (self.$class()) + \": \" + (self.receiver.$class()) + \"#\" + (self.name) + \" (defined in \" + (self.owner) + \" in \" + (self.$source_location().$join(\":\")) + \")>\"\n    }, TMP_Method_inspect_9.$$arity = 0), nil) && 'inspect';\n  })($nesting[0], null, $nesting);\n  return (function($base, $super, $parent_nesting) {\n    function $UnboundMethod(){};\n    var self = $UnboundMethod = $klass($base, $super, 'UnboundMethod', $UnboundMethod);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_UnboundMethod_initialize_10, TMP_UnboundMethod_arity_11, TMP_UnboundMethod_parameters_12, TMP_UnboundMethod_source_location_13, TMP_UnboundMethod_comments_14, TMP_UnboundMethod_bind_15, TMP_UnboundMethod_inspect_16;\n\n    def.method = def.owner = def.name = def.source = nil;\n    \n    self.$attr_reader(\"source\", \"owner\", \"name\");\n    \n    Opal.def(self, '$initialize', TMP_UnboundMethod_initialize_10 = function $$initialize(source, owner, method, name) {\n      var self = this;\n\n      \n      self.source = source;\n      self.owner = owner;\n      self.method = method;\n      return (self.name = name);\n    }, TMP_UnboundMethod_initialize_10.$$arity = 4);\n    \n    Opal.def(self, '$arity', TMP_UnboundMethod_arity_11 = function $$arity() {\n      var self = this;\n\n      return self.method.$arity()\n    }, TMP_UnboundMethod_arity_11.$$arity = 0);\n    \n    Opal.def(self, '$parameters', TMP_UnboundMethod_parameters_12 = function $$parameters() {\n      var self = this;\n\n      return self.method.$$parameters\n    }, TMP_UnboundMethod_parameters_12.$$arity = 0);\n    \n    Opal.def(self, '$source_location', TMP_UnboundMethod_source_location_13 = function $$source_location() {\n      var $a, self = this;\n\n      return ($truthy($a = self.method.$$source_location) ? $a : [\"(eval)\", 0])\n    }, TMP_UnboundMethod_source_location_13.$$arity = 0);\n    \n    Opal.def(self, '$comments', TMP_UnboundMethod_comments_14 = function $$comments() {\n      var $a, self = this;\n\n      return ($truthy($a = self.method.$$comments) ? $a : [])\n    }, TMP_UnboundMethod_comments_14.$$arity = 0);\n    \n    Opal.def(self, '$bind', TMP_UnboundMethod_bind_15 = function $$bind(object) {\n      var self = this;\n\n      \n      if (self.owner.$$is_module || Opal.is_a(object, self.owner)) {\n        return $$($nesting, 'Method').$new(object, self.owner, self.method, self.name);\n      }\n      else {\n        self.$raise($$($nesting, 'TypeError'), \"\" + \"can't bind singleton method to a different class (expected \" + (object) + \".kind_of?(\" + (self.owner) + \" to be true)\");\n      }\n    \n    }, TMP_UnboundMethod_bind_15.$$arity = 1);\n    return (Opal.def(self, '$inspect', TMP_UnboundMethod_inspect_16 = function $$inspect() {\n      var self = this;\n\n      return \"\" + \"#<\" + (self.$class()) + \": \" + (self.source) + \"#\" + (self.name) + \" (defined in \" + (self.owner) + \" in \" + (self.$source_location().$join(\":\")) + \")>\"\n    }, TMP_UnboundMethod_inspect_16.$$arity = 0), nil) && 'inspect';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/variables\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $gvars = Opal.gvars, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$new']);\n  \n  $gvars['&'] = $gvars['~'] = $gvars['`'] = $gvars[\"'\"] = nil;\n  $gvars.LOADED_FEATURES = ($gvars[\"\\\"\"] = Opal.loaded_features);\n  $gvars.LOAD_PATH = ($gvars[\":\"] = []);\n  $gvars[\"/\"] = \"\\n\";\n  $gvars[\",\"] = nil;\n  Opal.const_set($nesting[0], 'ARGV', []);\n  Opal.const_set($nesting[0], 'ARGF', $$($nesting, 'Object').$new());\n  Opal.const_set($nesting[0], 'ENV', $hash2([], {}));\n  $gvars.VERBOSE = false;\n  $gvars.DEBUG = false;\n  return ($gvars.SAFE = 0);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"opal/regexp_anchors\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;\n\n  Opal.add_stubs(['$==', '$new']);\n  return (function($base, $parent_nesting) {\n    var $Opal, self = $Opal = $module($base, 'Opal');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    \n    Opal.const_set($nesting[0], 'REGEXP_START', (function() {if ($$($nesting, 'RUBY_ENGINE')['$=='](\"opal\")) {\n      return \"^\"\n    } else {\n      return nil\n    }; return nil; })());\n    Opal.const_set($nesting[0], 'REGEXP_END', (function() {if ($$($nesting, 'RUBY_ENGINE')['$=='](\"opal\")) {\n      return \"$\"\n    } else {\n      return nil\n    }; return nil; })());\n    Opal.const_set($nesting[0], 'FORBIDDEN_STARTING_IDENTIFIER_CHARS', \"\\\\u0001-\\\\u002F\\\\u003A-\\\\u0040\\\\u005B-\\\\u005E\\\\u0060\\\\u007B-\\\\u007F\");\n    Opal.const_set($nesting[0], 'FORBIDDEN_ENDING_IDENTIFIER_CHARS', \"\\\\u0001-\\\\u0020\\\\u0022-\\\\u002F\\\\u003A-\\\\u003E\\\\u0040\\\\u005B-\\\\u005E\\\\u0060\\\\u007B-\\\\u007F\");\n    Opal.const_set($nesting[0], 'INLINE_IDENTIFIER_REGEXP', $$($nesting, 'Regexp').$new(\"\" + \"[^\" + ($$($nesting, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS')) + \"]*[^\" + ($$($nesting, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS')) + \"]\"));\n    Opal.const_set($nesting[0], 'FORBIDDEN_CONST_NAME_CHARS', \"\\\\u0001-\\\\u0020\\\\u0021-\\\\u002F\\\\u003B-\\\\u003F\\\\u0040\\\\u005B-\\\\u005E\\\\u0060\\\\u007B-\\\\u007F\");\n    Opal.const_set($nesting[0], 'CONST_NAME_REGEXP', $$($nesting, 'Regexp').$new(\"\" + ($$($nesting, 'REGEXP_START')) + \"(::)?[A-Z][^\" + ($$($nesting, 'FORBIDDEN_CONST_NAME_CHARS')) + \"]*\" + ($$($nesting, 'REGEXP_END'))));\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"opal/mini\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;\n\n  Opal.add_stubs(['$require']);\n  \n  self.$require(\"opal/base\");\n  self.$require(\"corelib/nil\");\n  self.$require(\"corelib/boolean\");\n  self.$require(\"corelib/string\");\n  self.$require(\"corelib/comparable\");\n  self.$require(\"corelib/enumerable\");\n  self.$require(\"corelib/enumerator\");\n  self.$require(\"corelib/array\");\n  self.$require(\"corelib/hash\");\n  self.$require(\"corelib/number\");\n  self.$require(\"corelib/range\");\n  self.$require(\"corelib/proc\");\n  self.$require(\"corelib/method\");\n  self.$require(\"corelib/regexp\");\n  self.$require(\"corelib/variables\");\n  return self.$require(\"opal/regexp_anchors\");\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/string/inheritance\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$require', '$new', '$allocate', '$initialize', '$to_proc', '$__send__', '$class', '$clone', '$respond_to?', '$==', '$to_s', '$inspect', '$+', '$*', '$map', '$split', '$enum_for', '$each_line', '$to_a', '$%', '$-']);\n  \n  self.$require(\"corelib/string\");\n  (function($base, $super, $parent_nesting) {\n    function $String(){};\n    var self = $String = $klass($base, $super, 'String', $String);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String_inherited_1;\n\n    return (Opal.defs(self, '$inherited', TMP_String_inherited_1 = function $$inherited(klass) {\n      var self = this, replace = nil;\n\n      \n      replace = $$($nesting, 'Class').$new($$$($$($nesting, 'String'), 'Wrapper'));\n      \n      klass.$$proto         = replace.$$proto;\n      klass.$$proto.$$class = klass;\n      klass.$$alloc         = replace.$$alloc;\n      klass.$$parent        = $$$($$($nesting, 'String'), 'Wrapper');\n\n      klass.$allocate = replace.$allocate;\n      klass.$new      = replace.$new;\n    ;\n    }, TMP_String_inherited_1.$$arity = 1), nil) && 'inherited'\n  })($nesting[0], null, $nesting);\n  return (function($base, $super, $parent_nesting) {\n    function $Wrapper(){};\n    var self = $Wrapper = $klass($base, $super, 'Wrapper', $Wrapper);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Wrapper_allocate_2, TMP_Wrapper_new_3, TMP_Wrapper_$$_4, TMP_Wrapper_initialize_5, TMP_Wrapper_method_missing_6, TMP_Wrapper_initialize_copy_7, TMP_Wrapper_respond_to$q_8, TMP_Wrapper_$eq$eq_9, TMP_Wrapper_to_s_10, TMP_Wrapper_inspect_11, TMP_Wrapper_$_12, TMP_Wrapper_$_13, TMP_Wrapper_split_15, TMP_Wrapper_replace_16, TMP_Wrapper_each_line_17, TMP_Wrapper_lines_19, TMP_Wrapper_$_20, TMP_Wrapper_instance_variables_21;\n\n    def.literal = nil;\n    \n    def.$$is_string = true;\n    Opal.defs(self, '$allocate', TMP_Wrapper_allocate_2 = function $$allocate(string) {\n      var self = this, $iter = TMP_Wrapper_allocate_2.$$p, $yield = $iter || nil, obj = nil;\n\n      if (string == null) {\n        string = \"\";\n      }\n      if ($iter) TMP_Wrapper_allocate_2.$$p = null;\n      \n      obj = $send(self, Opal.find_super_dispatcher(self, 'allocate', TMP_Wrapper_allocate_2, false, $Wrapper), [], null);\n      obj.literal = string;\n      return obj;\n    }, TMP_Wrapper_allocate_2.$$arity = -1);\n    Opal.defs(self, '$new', TMP_Wrapper_new_3 = function($a_rest) {\n      var self = this, args, $iter = TMP_Wrapper_new_3.$$p, block = $iter || nil, obj = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Wrapper_new_3.$$p = null;\n      \n      obj = self.$allocate();\n      $send(obj, 'initialize', Opal.to_a(args), block.$to_proc());\n      return obj;\n    }, TMP_Wrapper_new_3.$$arity = -1);\n    Opal.defs(self, '$[]', TMP_Wrapper_$$_4 = function($a_rest) {\n      var self = this, objects;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      objects = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        objects[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return self.$allocate(objects)\n    }, TMP_Wrapper_$$_4.$$arity = -1);\n    \n    Opal.def(self, '$initialize', TMP_Wrapper_initialize_5 = function $$initialize(string) {\n      var self = this;\n\n      if (string == null) {\n        string = \"\";\n      }\n      return (self.literal = string)\n    }, TMP_Wrapper_initialize_5.$$arity = -1);\n    \n    Opal.def(self, '$method_missing', TMP_Wrapper_method_missing_6 = function $$method_missing($a_rest) {\n      var self = this, args, $iter = TMP_Wrapper_method_missing_6.$$p, block = $iter || nil, result = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Wrapper_method_missing_6.$$p = null;\n      \n      result = $send(self.literal, '__send__', Opal.to_a(args), block.$to_proc());\n      if ($truthy(result.$$is_string != null)) {\n        if ($truthy(result == self.literal)) {\n          return self\n        } else {\n          return self.$class().$allocate(result)\n        }\n      } else {\n        return result\n      };\n    }, TMP_Wrapper_method_missing_6.$$arity = -1);\n    \n    Opal.def(self, '$initialize_copy', TMP_Wrapper_initialize_copy_7 = function $$initialize_copy(other) {\n      var self = this;\n\n      return (self.literal = (other.literal).$clone())\n    }, TMP_Wrapper_initialize_copy_7.$$arity = 1);\n    \n    Opal.def(self, '$respond_to?', TMP_Wrapper_respond_to$q_8 = function(name, $a_rest) {\n      var $b, self = this, $iter = TMP_Wrapper_respond_to$q_8.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Wrapper_respond_to$q_8.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      return ($truthy($b = $send(self, Opal.find_super_dispatcher(self, 'respond_to?', TMP_Wrapper_respond_to$q_8, false), $zuper, $iter)) ? $b : self.literal['$respond_to?'](name))\n    }, TMP_Wrapper_respond_to$q_8.$$arity = -2);\n    \n    Opal.def(self, '$==', TMP_Wrapper_$eq$eq_9 = function(other) {\n      var self = this;\n\n      return self.literal['$=='](other)\n    }, TMP_Wrapper_$eq$eq_9.$$arity = 1);\n    Opal.alias(self, \"eql?\", \"==\");\n    Opal.alias(self, \"===\", \"==\");\n    \n    Opal.def(self, '$to_s', TMP_Wrapper_to_s_10 = function $$to_s() {\n      var self = this;\n\n      return self.literal.$to_s()\n    }, TMP_Wrapper_to_s_10.$$arity = 0);\n    Opal.alias(self, \"to_str\", \"to_s\");\n    \n    Opal.def(self, '$inspect', TMP_Wrapper_inspect_11 = function $$inspect() {\n      var self = this;\n\n      return self.literal.$inspect()\n    }, TMP_Wrapper_inspect_11.$$arity = 0);\n    \n    Opal.def(self, '$+', TMP_Wrapper_$_12 = function(other) {\n      var self = this;\n\n      return $rb_plus(self.literal, other)\n    }, TMP_Wrapper_$_12.$$arity = 1);\n    \n    Opal.def(self, '$*', TMP_Wrapper_$_13 = function(other) {\n      var self = this;\n\n      \n      var result = $rb_times(self.literal, other);\n\n      if (result.$$is_string) {\n        return self.$class().$allocate(result)\n      }\n      else {\n        return result;\n      }\n    \n    }, TMP_Wrapper_$_13.$$arity = 1);\n    \n    Opal.def(self, '$split', TMP_Wrapper_split_15 = function $$split(pattern, limit) {\n      var TMP_14, self = this;\n\n      return $send(self.literal.$split(pattern, limit), 'map', [], (TMP_14 = function(str){var self = TMP_14.$$s || this;\nif (str == null) str = nil;\n      return self.$class().$allocate(str)}, TMP_14.$$s = self, TMP_14.$$arity = 1, TMP_14))\n    }, TMP_Wrapper_split_15.$$arity = -1);\n    \n    Opal.def(self, '$replace', TMP_Wrapper_replace_16 = function $$replace(string) {\n      var self = this;\n\n      return (self.literal = string)\n    }, TMP_Wrapper_replace_16.$$arity = 1);\n    \n    Opal.def(self, '$each_line', TMP_Wrapper_each_line_17 = function $$each_line(separator) {\n      var TMP_18, self = this, $iter = TMP_Wrapper_each_line_17.$$p, $yield = $iter || nil;\n      if ($gvars[\"/\"] == null) $gvars[\"/\"] = nil;\n\n      if (separator == null) {\n        separator = $gvars[\"/\"];\n      }\n      if ($iter) TMP_Wrapper_each_line_17.$$p = null;\n      \n      if (($yield !== nil)) {\n      } else {\n        return self.$enum_for(\"each_line\", separator)\n      };\n      return $send(self.literal, 'each_line', [separator], (TMP_18 = function(str){var self = TMP_18.$$s || this;\nif (str == null) str = nil;\n      return Opal.yield1($yield, self.$class().$allocate(str));}, TMP_18.$$s = self, TMP_18.$$arity = 1, TMP_18));\n    }, TMP_Wrapper_each_line_17.$$arity = -1);\n    \n    Opal.def(self, '$lines', TMP_Wrapper_lines_19 = function $$lines(separator) {\n      var self = this, $iter = TMP_Wrapper_lines_19.$$p, block = $iter || nil, e = nil;\n      if ($gvars[\"/\"] == null) $gvars[\"/\"] = nil;\n\n      if (separator == null) {\n        separator = $gvars[\"/\"];\n      }\n      if ($iter) TMP_Wrapper_lines_19.$$p = null;\n      \n      e = $send(self, 'each_line', [separator], block.$to_proc());\n      if ($truthy(block)) {\n        return self\n      } else {\n        return e.$to_a()\n      };\n    }, TMP_Wrapper_lines_19.$$arity = -1);\n    \n    Opal.def(self, '$%', TMP_Wrapper_$_20 = function(data) {\n      var self = this;\n\n      return self.literal['$%'](data)\n    }, TMP_Wrapper_$_20.$$arity = 1);\n    return (Opal.def(self, '$instance_variables', TMP_Wrapper_instance_variables_21 = function $$instance_variables() {\n      var self = this, $iter = TMP_Wrapper_instance_variables_21.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n      if ($iter) TMP_Wrapper_instance_variables_21.$$p = null;\n      // Prepare super implicit arguments\n      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n        $zuper[$zuper_i] = arguments[$zuper_i];\n      }\n      return $rb_minus($send(self, Opal.find_super_dispatcher(self, 'instance_variables', TMP_Wrapper_instance_variables_21, false), $zuper, $iter), [\"@literal\"])\n    }, TMP_Wrapper_instance_variables_21.$$arity = 0), nil) && 'instance_variables';\n  })($$($nesting, 'String'), null, $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/string/encoding\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var TMP_12, TMP_15, TMP_18, TMP_21, TMP_24, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$+', '$[]', '$new', '$to_proc', '$each', '$const_set', '$sub', '$==', '$default_external', '$upcase', '$raise', '$attr_accessor', '$attr_reader', '$register', '$length', '$bytes', '$to_a', '$each_byte', '$bytesize', '$enum_for', '$force_encoding', '$dup', '$coerce_to!', '$find', '$getbyte']);\n  \n  self.$require(\"corelib/string\");\n  (function($base, $super, $parent_nesting) {\n    function $Encoding(){};\n    var self = $Encoding = $klass($base, $super, 'Encoding', $Encoding);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Encoding_register_1, TMP_Encoding_find_3, TMP_Encoding_initialize_4, TMP_Encoding_ascii_compatible$q_5, TMP_Encoding_dummy$q_6, TMP_Encoding_to_s_7, TMP_Encoding_inspect_8, TMP_Encoding_each_byte_9, TMP_Encoding_getbyte_10, TMP_Encoding_bytesize_11;\n\n    def.ascii = def.dummy = def.name = nil;\n    \n    self[\"$$register\"] = {};\n    Opal.defs(self, '$register', TMP_Encoding_register_1 = function $$register(name, options) {\n      var $a, TMP_2, self = this, $iter = TMP_Encoding_register_1.$$p, block = $iter || nil, names = nil, encoding = nil, register = nil;\n\n      if (options == null) {\n        options = $hash2([], {});\n      }\n      if ($iter) TMP_Encoding_register_1.$$p = null;\n      \n      names = $rb_plus([name], ($truthy($a = options['$[]'](\"aliases\")) ? $a : []));\n      encoding = $send($$($nesting, 'Class'), 'new', [self], block.$to_proc()).$new(name, names, ($truthy($a = options['$[]'](\"ascii\")) ? $a : false), ($truthy($a = options['$[]'](\"dummy\")) ? $a : false));\n      register = self[\"$$register\"];\n      return $send(names, 'each', [], (TMP_2 = function(encoding_name){var self = TMP_2.$$s || this;\nif (encoding_name == null) encoding_name = nil;\n      \n        self.$const_set(encoding_name.$sub(\"-\", \"_\"), encoding);\n        return register[\"\" + \"$$\" + (encoding_name)] = encoding;}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2));\n    }, TMP_Encoding_register_1.$$arity = -2);\n    Opal.defs(self, '$find', TMP_Encoding_find_3 = function $$find(name) {\n      var $a, self = this, register = nil, encoding = nil;\n\n      \n      if (name['$=='](\"default_external\")) {\n        return self.$default_external()};\n      register = self[\"$$register\"];\n      encoding = ($truthy($a = register[\"\" + \"$$\" + (name)]) ? $a : register[\"\" + \"$$\" + (name.$upcase())]);\n      if ($truthy(encoding)) {\n      } else {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"unknown encoding name - \" + (name))\n      };\n      return encoding;\n    }, TMP_Encoding_find_3.$$arity = 1);\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$attr_accessor(\"default_external\")\n    })(Opal.get_singleton_class(self), $nesting);\n    self.$attr_reader(\"name\", \"names\");\n    \n    Opal.def(self, '$initialize', TMP_Encoding_initialize_4 = function $$initialize(name, names, ascii, dummy) {\n      var self = this;\n\n      \n      self.name = name;\n      self.names = names;\n      self.ascii = ascii;\n      return (self.dummy = dummy);\n    }, TMP_Encoding_initialize_4.$$arity = 4);\n    \n    Opal.def(self, '$ascii_compatible?', TMP_Encoding_ascii_compatible$q_5 = function() {\n      var self = this;\n\n      return self.ascii\n    }, TMP_Encoding_ascii_compatible$q_5.$$arity = 0);\n    \n    Opal.def(self, '$dummy?', TMP_Encoding_dummy$q_6 = function() {\n      var self = this;\n\n      return self.dummy\n    }, TMP_Encoding_dummy$q_6.$$arity = 0);\n    \n    Opal.def(self, '$to_s', TMP_Encoding_to_s_7 = function $$to_s() {\n      var self = this;\n\n      return self.name\n    }, TMP_Encoding_to_s_7.$$arity = 0);\n    \n    Opal.def(self, '$inspect', TMP_Encoding_inspect_8 = function $$inspect() {\n      var self = this;\n\n      return \"\" + \"#<Encoding:\" + (self.name) + ((function() {if ($truthy(self.dummy)) {\n        return \" (dummy)\"\n      } else {\n        return nil\n      }; return nil; })()) + \">\"\n    }, TMP_Encoding_inspect_8.$$arity = 0);\n    \n    Opal.def(self, '$each_byte', TMP_Encoding_each_byte_9 = function $$each_byte($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'))\n    }, TMP_Encoding_each_byte_9.$$arity = -1);\n    \n    Opal.def(self, '$getbyte', TMP_Encoding_getbyte_10 = function $$getbyte($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'))\n    }, TMP_Encoding_getbyte_10.$$arity = -1);\n    \n    Opal.def(self, '$bytesize', TMP_Encoding_bytesize_11 = function $$bytesize($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'))\n    }, TMP_Encoding_bytesize_11.$$arity = -1);\n    (function($base, $super, $parent_nesting) {\n      function $EncodingError(){};\n      var self = $EncodingError = $klass($base, $super, 'EncodingError', $EncodingError);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return nil\n    })($nesting[0], $$($nesting, 'StandardError'), $nesting);\n    return (function($base, $super, $parent_nesting) {\n      function $CompatibilityError(){};\n      var self = $CompatibilityError = $klass($base, $super, 'CompatibilityError', $CompatibilityError);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return nil\n    })($nesting[0], $$($nesting, 'EncodingError'), $nesting);\n  })($nesting[0], null, $nesting);\n  $send($$($nesting, 'Encoding'), 'register', [\"UTF-8\", $hash2([\"aliases\", \"ascii\"], {\"aliases\": [\"CP65001\"], \"ascii\": true})], (TMP_12 = function(){var self = TMP_12.$$s || this, TMP_each_byte_13, TMP_bytesize_14;\n\n  \n    \n    Opal.def(self, '$each_byte', TMP_each_byte_13 = function $$each_byte(string) {\n      var self = this, $iter = TMP_each_byte_13.$$p, block = $iter || nil;\n\n      if ($iter) TMP_each_byte_13.$$p = null;\n      \n      for (var i = 0, length = string.length; i < length; i++) {\n        var code = string.charCodeAt(i);\n\n        if (code <= 0x7f) {\n          Opal.yield1(block, code);\n        }\n        else {\n          var encoded = encodeURIComponent(string.charAt(i)).substr(1).split('%');\n\n          for (var j = 0, encoded_length = encoded.length; j < encoded_length; j++) {\n            Opal.yield1(block, parseInt(encoded[j], 16));\n          }\n        }\n      }\n    \n    }, TMP_each_byte_13.$$arity = 1);\n    return (Opal.def(self, '$bytesize', TMP_bytesize_14 = function $$bytesize(string) {\n      var self = this;\n\n      return string.$bytes().$length()\n    }, TMP_bytesize_14.$$arity = 1), nil) && 'bytesize';}, TMP_12.$$s = self, TMP_12.$$arity = 0, TMP_12));\n  $send($$($nesting, 'Encoding'), 'register', [\"UTF-16LE\"], (TMP_15 = function(){var self = TMP_15.$$s || this, TMP_each_byte_16, TMP_bytesize_17;\n\n  \n    \n    Opal.def(self, '$each_byte', TMP_each_byte_16 = function $$each_byte(string) {\n      var self = this, $iter = TMP_each_byte_16.$$p, block = $iter || nil;\n\n      if ($iter) TMP_each_byte_16.$$p = null;\n      \n      for (var i = 0, length = string.length; i < length; i++) {\n        var code = string.charCodeAt(i);\n\n        Opal.yield1(block, code & 0xff);\n        Opal.yield1(block, code >> 8);\n      }\n    \n    }, TMP_each_byte_16.$$arity = 1);\n    return (Opal.def(self, '$bytesize', TMP_bytesize_17 = function $$bytesize(string) {\n      var self = this;\n\n      return string.$bytes().$length()\n    }, TMP_bytesize_17.$$arity = 1), nil) && 'bytesize';}, TMP_15.$$s = self, TMP_15.$$arity = 0, TMP_15));\n  $send($$($nesting, 'Encoding'), 'register', [\"UTF-16BE\"], (TMP_18 = function(){var self = TMP_18.$$s || this, TMP_each_byte_19, TMP_bytesize_20;\n\n  \n    \n    Opal.def(self, '$each_byte', TMP_each_byte_19 = function $$each_byte(string) {\n      var self = this, $iter = TMP_each_byte_19.$$p, block = $iter || nil;\n\n      if ($iter) TMP_each_byte_19.$$p = null;\n      \n      for (var i = 0, length = string.length; i < length; i++) {\n        var code = string.charCodeAt(i);\n\n        Opal.yield1(block, code >> 8);\n        Opal.yield1(block, code & 0xff);\n      }\n    \n    }, TMP_each_byte_19.$$arity = 1);\n    return (Opal.def(self, '$bytesize', TMP_bytesize_20 = function $$bytesize(string) {\n      var self = this;\n\n      return string.$bytes().$length()\n    }, TMP_bytesize_20.$$arity = 1), nil) && 'bytesize';}, TMP_18.$$s = self, TMP_18.$$arity = 0, TMP_18));\n  $send($$($nesting, 'Encoding'), 'register', [\"UTF-32LE\"], (TMP_21 = function(){var self = TMP_21.$$s || this, TMP_each_byte_22, TMP_bytesize_23;\n\n  \n    \n    Opal.def(self, '$each_byte', TMP_each_byte_22 = function $$each_byte(string) {\n      var self = this, $iter = TMP_each_byte_22.$$p, block = $iter || nil;\n\n      if ($iter) TMP_each_byte_22.$$p = null;\n      \n      for (var i = 0, length = string.length; i < length; i++) {\n        var code = string.charCodeAt(i);\n\n        Opal.yield1(block, code & 0xff);\n        Opal.yield1(block, code >> 8);\n      }\n    \n    }, TMP_each_byte_22.$$arity = 1);\n    return (Opal.def(self, '$bytesize', TMP_bytesize_23 = function $$bytesize(string) {\n      var self = this;\n\n      return string.$bytes().$length()\n    }, TMP_bytesize_23.$$arity = 1), nil) && 'bytesize';}, TMP_21.$$s = self, TMP_21.$$arity = 0, TMP_21));\n  $send($$($nesting, 'Encoding'), 'register', [\"ASCII-8BIT\", $hash2([\"aliases\", \"ascii\", \"dummy\"], {\"aliases\": [\"BINARY\", \"US-ASCII\", \"ASCII\"], \"ascii\": true, \"dummy\": true})], (TMP_24 = function(){var self = TMP_24.$$s || this, TMP_each_byte_25, TMP_bytesize_26;\n\n  \n    \n    Opal.def(self, '$each_byte', TMP_each_byte_25 = function $$each_byte(string) {\n      var self = this, $iter = TMP_each_byte_25.$$p, block = $iter || nil;\n\n      if ($iter) TMP_each_byte_25.$$p = null;\n      \n      for (var i = 0, length = string.length; i < length; i++) {\n        var code = string.charCodeAt(i);\n        Opal.yield1(block, code & 0xff);\n        Opal.yield1(block, code >> 8);\n      }\n    \n    }, TMP_each_byte_25.$$arity = 1);\n    return (Opal.def(self, '$bytesize', TMP_bytesize_26 = function $$bytesize(string) {\n      var self = this;\n\n      return string.$bytes().$length()\n    }, TMP_bytesize_26.$$arity = 1), nil) && 'bytesize';}, TMP_24.$$s = self, TMP_24.$$arity = 0, TMP_24));\n  return (function($base, $super, $parent_nesting) {\n    function $String(){};\n    var self = $String = $klass($base, $super, 'String', $String);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String_bytes_27, TMP_String_bytesize_28, TMP_String_each_byte_29, TMP_String_encode_30, TMP_String_force_encoding_31, TMP_String_getbyte_32, TMP_String_valid_encoding$q_33;\n\n    def.encoding = nil;\n    \n    self.$attr_reader(\"encoding\");\n    String.prototype.encoding = $$$($$($nesting, 'Encoding'), 'UTF_16LE');\n    \n    Opal.def(self, '$bytes', TMP_String_bytes_27 = function $$bytes() {\n      var self = this;\n\n      return self.$each_byte().$to_a()\n    }, TMP_String_bytes_27.$$arity = 0);\n    \n    Opal.def(self, '$bytesize', TMP_String_bytesize_28 = function $$bytesize() {\n      var self = this;\n\n      return self.encoding.$bytesize(self)\n    }, TMP_String_bytesize_28.$$arity = 0);\n    \n    Opal.def(self, '$each_byte', TMP_String_each_byte_29 = function $$each_byte() {\n      var self = this, $iter = TMP_String_each_byte_29.$$p, block = $iter || nil;\n\n      if ($iter) TMP_String_each_byte_29.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return self.$enum_for(\"each_byte\")\n      };\n      $send(self.encoding, 'each_byte', [self], block.$to_proc());\n      return self;\n    }, TMP_String_each_byte_29.$$arity = 0);\n    \n    Opal.def(self, '$encode', TMP_String_encode_30 = function $$encode(encoding) {\n      var self = this;\n\n      return self.$dup().$force_encoding(encoding)\n    }, TMP_String_encode_30.$$arity = 1);\n    \n    Opal.def(self, '$force_encoding', TMP_String_force_encoding_31 = function $$force_encoding(encoding) {\n      var self = this;\n\n      \n      if (encoding === self.encoding) { return self; }\n\n      encoding = $$($nesting, 'Opal')['$coerce_to!'](encoding, $$($nesting, 'String'), \"to_s\");\n      encoding = $$($nesting, 'Encoding').$find(encoding);\n\n      if (encoding === self.encoding) { return self; }\n\n      self.encoding = encoding;\n      return self;\n    \n    }, TMP_String_force_encoding_31.$$arity = 1);\n    \n    Opal.def(self, '$getbyte', TMP_String_getbyte_32 = function $$getbyte(idx) {\n      var self = this;\n\n      return self.encoding.$getbyte(self, idx)\n    }, TMP_String_getbyte_32.$$arity = 1);\n    return (Opal.def(self, '$valid_encoding?', TMP_String_valid_encoding$q_33 = function() {\n      var self = this;\n\n      return true\n    }, TMP_String_valid_encoding$q_33.$$arity = 0), nil) && 'valid_encoding?';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/math\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$new', '$raise', '$Float', '$type_error', '$Integer', '$module_function', '$checked', '$float!', '$===', '$gamma', '$-', '$integer!', '$/', '$infinite?']);\n  return (function($base, $parent_nesting) {\n    var $Math, self = $Math = $module($base, 'Math');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Math_checked_1, TMP_Math_float$B_2, TMP_Math_integer$B_3, TMP_Math_acos_4, TMP_Math_acosh_5, TMP_Math_asin_6, TMP_Math_asinh_7, TMP_Math_atan_8, TMP_Math_atan2_9, TMP_Math_atanh_10, TMP_Math_cbrt_11, TMP_Math_cos_12, TMP_Math_cosh_13, TMP_Math_erf_14, TMP_Math_erfc_15, TMP_Math_exp_16, TMP_Math_frexp_17, TMP_Math_gamma_18, TMP_Math_hypot_19, TMP_Math_ldexp_20, TMP_Math_lgamma_21, TMP_Math_log_22, TMP_Math_log10_23, TMP_Math_log2_24, TMP_Math_sin_25, TMP_Math_sinh_26, TMP_Math_sqrt_27, TMP_Math_tan_28, TMP_Math_tanh_29;\n\n    \n    Opal.const_set($nesting[0], 'E', Math.E);\n    Opal.const_set($nesting[0], 'PI', Math.PI);\n    Opal.const_set($nesting[0], 'DomainError', $$($nesting, 'Class').$new($$($nesting, 'StandardError')));\n    Opal.defs(self, '$checked', TMP_Math_checked_1 = function $$checked(method, $a_rest) {\n      var self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      \n      if (isNaN(args[0]) || (args.length == 2 && isNaN(args[1]))) {\n        return NaN;\n      }\n\n      var result = Math[method].apply(null, args);\n\n      if (isNaN(result)) {\n        self.$raise($$($nesting, 'DomainError'), \"\" + \"Numerical argument is out of domain - \\\"\" + (method) + \"\\\"\");\n      }\n\n      return result;\n    \n    }, TMP_Math_checked_1.$$arity = -2);\n    Opal.defs(self, '$float!', TMP_Math_float$B_2 = function(value) {\n      var self = this;\n\n      try {\n        return self.$Float(value)\n      } catch ($err) {\n        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {\n          try {\n            return self.$raise($$($nesting, 'Opal').$type_error(value, $$($nesting, 'Float')))\n          } finally { Opal.pop_exception() }\n        } else { throw $err; }\n      }\n    }, TMP_Math_float$B_2.$$arity = 1);\n    Opal.defs(self, '$integer!', TMP_Math_integer$B_3 = function(value) {\n      var self = this;\n\n      try {\n        return self.$Integer(value)\n      } catch ($err) {\n        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {\n          try {\n            return self.$raise($$($nesting, 'Opal').$type_error(value, $$($nesting, 'Integer')))\n          } finally { Opal.pop_exception() }\n        } else { throw $err; }\n      }\n    }, TMP_Math_integer$B_3.$$arity = 1);\n    self.$module_function();\n    \n    Opal.def(self, '$acos', TMP_Math_acos_4 = function $$acos(x) {\n      var self = this;\n\n      return $$($nesting, 'Math').$checked(\"acos\", $$($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_acos_4.$$arity = 1);\n    if ($truthy((typeof(Math.acosh) !== \"undefined\"))) {\n    } else {\n      \n      Math.acosh = function(x) {\n        return Math.log(x + Math.sqrt(x * x - 1));\n      }\n    \n    };\n    \n    Opal.def(self, '$acosh', TMP_Math_acosh_5 = function $$acosh(x) {\n      var self = this;\n\n      return $$($nesting, 'Math').$checked(\"acosh\", $$($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_acosh_5.$$arity = 1);\n    \n    Opal.def(self, '$asin', TMP_Math_asin_6 = function $$asin(x) {\n      var self = this;\n\n      return $$($nesting, 'Math').$checked(\"asin\", $$($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_asin_6.$$arity = 1);\n    if ($truthy((typeof(Math.asinh) !== \"undefined\"))) {\n    } else {\n      \n      Math.asinh = function(x) {\n        return Math.log(x + Math.sqrt(x * x + 1))\n      }\n    \n    };\n    \n    Opal.def(self, '$asinh', TMP_Math_asinh_7 = function $$asinh(x) {\n      var self = this;\n\n      return $$($nesting, 'Math').$checked(\"asinh\", $$($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_asinh_7.$$arity = 1);\n    \n    Opal.def(self, '$atan', TMP_Math_atan_8 = function $$atan(x) {\n      var self = this;\n\n      return $$($nesting, 'Math').$checked(\"atan\", $$($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_atan_8.$$arity = 1);\n    \n    Opal.def(self, '$atan2', TMP_Math_atan2_9 = function $$atan2(y, x) {\n      var self = this;\n\n      return $$($nesting, 'Math').$checked(\"atan2\", $$($nesting, 'Math')['$float!'](y), $$($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_atan2_9.$$arity = 2);\n    if ($truthy((typeof(Math.atanh) !== \"undefined\"))) {\n    } else {\n      \n      Math.atanh = function(x) {\n        return 0.5 * Math.log((1 + x) / (1 - x));\n      }\n    \n    };\n    \n    Opal.def(self, '$atanh', TMP_Math_atanh_10 = function $$atanh(x) {\n      var self = this;\n\n      return $$($nesting, 'Math').$checked(\"atanh\", $$($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_atanh_10.$$arity = 1);\n    if ($truthy((typeof(Math.cbrt) !== \"undefined\"))) {\n    } else {\n      \n      Math.cbrt = function(x) {\n        if (x == 0) {\n          return 0;\n        }\n\n        if (x < 0) {\n          return -Math.cbrt(-x);\n        }\n\n        var r  = x,\n            ex = 0;\n\n        while (r < 0.125) {\n          r *= 8;\n          ex--;\n        }\n\n        while (r > 1.0) {\n          r *= 0.125;\n          ex++;\n        }\n\n        r = (-0.46946116 * r + 1.072302) * r + 0.3812513;\n\n        while (ex < 0) {\n          r *= 0.5;\n          ex++;\n        }\n\n        while (ex > 0) {\n          r *= 2;\n          ex--;\n        }\n\n        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);\n        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);\n        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);\n        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);\n\n        return r;\n      }\n    \n    };\n    \n    Opal.def(self, '$cbrt', TMP_Math_cbrt_11 = function $$cbrt(x) {\n      var self = this;\n\n      return $$($nesting, 'Math').$checked(\"cbrt\", $$($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_cbrt_11.$$arity = 1);\n    \n    Opal.def(self, '$cos', TMP_Math_cos_12 = function $$cos(x) {\n      var self = this;\n\n      return $$($nesting, 'Math').$checked(\"cos\", $$($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_cos_12.$$arity = 1);\n    if ($truthy((typeof(Math.cosh) !== \"undefined\"))) {\n    } else {\n      \n      Math.cosh = function(x) {\n        return (Math.exp(x) + Math.exp(-x)) / 2;\n      }\n    \n    };\n    \n    Opal.def(self, '$cosh', TMP_Math_cosh_13 = function $$cosh(x) {\n      var self = this;\n\n      return $$($nesting, 'Math').$checked(\"cosh\", $$($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_cosh_13.$$arity = 1);\n    if ($truthy((typeof(Math.erf) !== \"undefined\"))) {\n    } else {\n      \n      Math.erf = function(x) {\n        var A1 =  0.254829592,\n            A2 = -0.284496736,\n            A3 =  1.421413741,\n            A4 = -1.453152027,\n            A5 =  1.061405429,\n            P  =  0.3275911;\n\n        var sign = 1;\n\n        if (x < 0) {\n            sign = -1;\n        }\n\n        x = Math.abs(x);\n\n        var t = 1.0 / (1.0 + P * x);\n        var y = 1.0 - (((((A5 * t + A4) * t) + A3) * t + A2) * t + A1) * t * Math.exp(-x * x);\n\n        return sign * y;\n      }\n    \n    };\n    \n    Opal.def(self, '$erf', TMP_Math_erf_14 = function $$erf(x) {\n      var self = this;\n\n      return $$($nesting, 'Math').$checked(\"erf\", $$($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_erf_14.$$arity = 1);\n    if ($truthy((typeof(Math.erfc) !== \"undefined\"))) {\n    } else {\n      \n      Math.erfc = function(x) {\n        var z = Math.abs(x),\n            t = 1.0 / (0.5 * z + 1.0);\n\n        var A1 = t * 0.17087277 + -0.82215223,\n            A2 = t * A1 + 1.48851587,\n            A3 = t * A2 + -1.13520398,\n            A4 = t * A3 + 0.27886807,\n            A5 = t * A4 + -0.18628806,\n            A6 = t * A5 + 0.09678418,\n            A7 = t * A6 + 0.37409196,\n            A8 = t * A7 + 1.00002368,\n            A9 = t * A8,\n            A10 = -z * z - 1.26551223 + A9;\n\n        var a = t * Math.exp(A10);\n\n        if (x < 0.0) {\n          return 2.0 - a;\n        }\n        else {\n          return a;\n        }\n      }\n    \n    };\n    \n    Opal.def(self, '$erfc', TMP_Math_erfc_15 = function $$erfc(x) {\n      var self = this;\n\n      return $$($nesting, 'Math').$checked(\"erfc\", $$($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_erfc_15.$$arity = 1);\n    \n    Opal.def(self, '$exp', TMP_Math_exp_16 = function $$exp(x) {\n      var self = this;\n\n      return $$($nesting, 'Math').$checked(\"exp\", $$($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_exp_16.$$arity = 1);\n    \n    Opal.def(self, '$frexp', TMP_Math_frexp_17 = function $$frexp(x) {\n      var self = this;\n\n      \n      x = $$($nesting, 'Math')['$float!'](x);\n      \n      if (isNaN(x)) {\n        return [NaN, 0];\n      }\n\n      var ex   = Math.floor(Math.log(Math.abs(x)) / Math.log(2)) + 1,\n          frac = x / Math.pow(2, ex);\n\n      return [frac, ex];\n    ;\n    }, TMP_Math_frexp_17.$$arity = 1);\n    \n    Opal.def(self, '$gamma', TMP_Math_gamma_18 = function $$gamma(n) {\n      var self = this;\n\n      \n      n = $$($nesting, 'Math')['$float!'](n);\n      \n      var i, t, x, value, result, twoN, threeN, fourN, fiveN;\n\n      var G = 4.7421875;\n\n      var P = [\n         0.99999999999999709182,\n         57.156235665862923517,\n        -59.597960355475491248,\n         14.136097974741747174,\n        -0.49191381609762019978,\n         0.33994649984811888699e-4,\n         0.46523628927048575665e-4,\n        -0.98374475304879564677e-4,\n         0.15808870322491248884e-3,\n        -0.21026444172410488319e-3,\n         0.21743961811521264320e-3,\n        -0.16431810653676389022e-3,\n         0.84418223983852743293e-4,\n        -0.26190838401581408670e-4,\n         0.36899182659531622704e-5\n      ];\n\n\n      if (isNaN(n)) {\n        return NaN;\n      }\n\n      if (n === 0 && 1 / n < 0) {\n        return -Infinity;\n      }\n\n      if (n === -1 || n === -Infinity) {\n        self.$raise($$($nesting, 'DomainError'), \"Numerical argument is out of domain - \\\"gamma\\\"\");\n      }\n\n      if ($$($nesting, 'Integer')['$==='](n)) {\n        if (n <= 0) {\n          return isFinite(n) ? Infinity : NaN;\n        }\n\n        if (n > 171) {\n          return Infinity;\n        }\n\n        value  = n - 2;\n        result = n - 1;\n\n        while (value > 1) {\n          result *= value;\n          value--;\n        }\n\n        if (result == 0) {\n          result = 1;\n        }\n\n        return result;\n      }\n\n      if (n < 0.5) {\n        return Math.PI / (Math.sin(Math.PI * n) * $$($nesting, 'Math').$gamma($rb_minus(1, n)));\n      }\n\n      if (n >= 171.35) {\n        return Infinity;\n      }\n\n      if (n > 85.0) {\n        twoN   = n * n;\n        threeN = twoN * n;\n        fourN  = threeN * n;\n        fiveN  = fourN * n;\n\n        return Math.sqrt(2 * Math.PI / n) * Math.pow((n / Math.E), n) *\n          (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) -\n          571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) +\n          5246819 / (75246796800 * fiveN * n));\n      }\n\n      n -= 1;\n      x  = P[0];\n\n      for (i = 1; i < P.length; ++i) {\n        x += P[i] / (n + i);\n      }\n\n      t = n + G + 0.5;\n\n      return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;\n    ;\n    }, TMP_Math_gamma_18.$$arity = 1);\n    if ($truthy((typeof(Math.hypot) !== \"undefined\"))) {\n    } else {\n      \n      Math.hypot = function(x, y) {\n        return Math.sqrt(x * x + y * y)\n      }\n    \n    };\n    \n    Opal.def(self, '$hypot', TMP_Math_hypot_19 = function $$hypot(x, y) {\n      var self = this;\n\n      return $$($nesting, 'Math').$checked(\"hypot\", $$($nesting, 'Math')['$float!'](x), $$($nesting, 'Math')['$float!'](y))\n    }, TMP_Math_hypot_19.$$arity = 2);\n    \n    Opal.def(self, '$ldexp', TMP_Math_ldexp_20 = function $$ldexp(mantissa, exponent) {\n      var self = this;\n\n      \n      mantissa = $$($nesting, 'Math')['$float!'](mantissa);\n      exponent = $$($nesting, 'Math')['$integer!'](exponent);\n      \n      if (isNaN(exponent)) {\n        self.$raise($$($nesting, 'RangeError'), \"float NaN out of range of integer\");\n      }\n\n      return mantissa * Math.pow(2, exponent);\n    ;\n    }, TMP_Math_ldexp_20.$$arity = 2);\n    \n    Opal.def(self, '$lgamma', TMP_Math_lgamma_21 = function $$lgamma(n) {\n      var self = this;\n\n      \n      if (n == -1) {\n        return [Infinity, 1];\n      }\n      else {\n        return [Math.log(Math.abs($$($nesting, 'Math').$gamma(n))), $$($nesting, 'Math').$gamma(n) < 0 ? -1 : 1];\n      }\n    \n    }, TMP_Math_lgamma_21.$$arity = 1);\n    \n    Opal.def(self, '$log', TMP_Math_log_22 = function $$log(x, base) {\n      var self = this;\n\n      \n      if ($truthy($$($nesting, 'String')['$==='](x))) {\n        self.$raise($$($nesting, 'Opal').$type_error(x, $$($nesting, 'Float')))};\n      if ($truthy(base == null)) {\n        return $$($nesting, 'Math').$checked(\"log\", $$($nesting, 'Math')['$float!'](x))\n      } else {\n        \n        if ($truthy($$($nesting, 'String')['$==='](base))) {\n          self.$raise($$($nesting, 'Opal').$type_error(base, $$($nesting, 'Float')))};\n        return $rb_divide($$($nesting, 'Math').$checked(\"log\", $$($nesting, 'Math')['$float!'](x)), $$($nesting, 'Math').$checked(\"log\", $$($nesting, 'Math')['$float!'](base)));\n      };\n    }, TMP_Math_log_22.$$arity = -2);\n    if ($truthy((typeof(Math.log10) !== \"undefined\"))) {\n    } else {\n      \n      Math.log10 = function(x) {\n        return Math.log(x) / Math.LN10;\n      }\n    \n    };\n    \n    Opal.def(self, '$log10', TMP_Math_log10_23 = function $$log10(x) {\n      var self = this;\n\n      \n      if ($truthy($$($nesting, 'String')['$==='](x))) {\n        self.$raise($$($nesting, 'Opal').$type_error(x, $$($nesting, 'Float')))};\n      return $$($nesting, 'Math').$checked(\"log10\", $$($nesting, 'Math')['$float!'](x));\n    }, TMP_Math_log10_23.$$arity = 1);\n    if ($truthy((typeof(Math.log2) !== \"undefined\"))) {\n    } else {\n      \n      Math.log2 = function(x) {\n        return Math.log(x) / Math.LN2;\n      }\n    \n    };\n    \n    Opal.def(self, '$log2', TMP_Math_log2_24 = function $$log2(x) {\n      var self = this;\n\n      \n      if ($truthy($$($nesting, 'String')['$==='](x))) {\n        self.$raise($$($nesting, 'Opal').$type_error(x, $$($nesting, 'Float')))};\n      return $$($nesting, 'Math').$checked(\"log2\", $$($nesting, 'Math')['$float!'](x));\n    }, TMP_Math_log2_24.$$arity = 1);\n    \n    Opal.def(self, '$sin', TMP_Math_sin_25 = function $$sin(x) {\n      var self = this;\n\n      return $$($nesting, 'Math').$checked(\"sin\", $$($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_sin_25.$$arity = 1);\n    if ($truthy((typeof(Math.sinh) !== \"undefined\"))) {\n    } else {\n      \n      Math.sinh = function(x) {\n        return (Math.exp(x) - Math.exp(-x)) / 2;\n      }\n    \n    };\n    \n    Opal.def(self, '$sinh', TMP_Math_sinh_26 = function $$sinh(x) {\n      var self = this;\n\n      return $$($nesting, 'Math').$checked(\"sinh\", $$($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_sinh_26.$$arity = 1);\n    \n    Opal.def(self, '$sqrt', TMP_Math_sqrt_27 = function $$sqrt(x) {\n      var self = this;\n\n      return $$($nesting, 'Math').$checked(\"sqrt\", $$($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_sqrt_27.$$arity = 1);\n    \n    Opal.def(self, '$tan', TMP_Math_tan_28 = function $$tan(x) {\n      var self = this;\n\n      \n      x = $$($nesting, 'Math')['$float!'](x);\n      if ($truthy(x['$infinite?']())) {\n        return $$$($$($nesting, 'Float'), 'NAN')};\n      return $$($nesting, 'Math').$checked(\"tan\", $$($nesting, 'Math')['$float!'](x));\n    }, TMP_Math_tan_28.$$arity = 1);\n    if ($truthy((typeof(Math.tanh) !== \"undefined\"))) {\n    } else {\n      \n      Math.tanh = function(x) {\n        if (x == Infinity) {\n          return 1;\n        }\n        else if (x == -Infinity) {\n          return -1;\n        }\n        else {\n          return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));\n        }\n      }\n    \n    };\n    \n    Opal.def(self, '$tanh', TMP_Math_tanh_29 = function $$tanh(x) {\n      var self = this;\n\n      return $$($nesting, 'Math').$checked(\"tanh\", $$($nesting, 'Math')['$float!'](x))\n    }, TMP_Math_tanh_29.$$arity = 1);\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/complex\"] = function(Opal) {\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $module = Opal.module;\n\n  Opal.add_stubs(['$require', '$===', '$real?', '$raise', '$new', '$*', '$cos', '$sin', '$attr_reader', '$class', '$==', '$real', '$imag', '$Complex', '$-@', '$+', '$__coerced__', '$-', '$nan?', '$/', '$conj', '$abs2', '$quo', '$polar', '$exp', '$log', '$>', '$!=', '$divmod', '$**', '$hypot', '$atan2', '$lcm', '$denominator', '$finite?', '$infinite?', '$numerator', '$abs', '$arg', '$rationalize', '$to_f', '$to_i', '$to_r', '$inspect', '$positive?', '$zero?']);\n  \n  self.$require(\"corelib/numeric\");\n  (function($base, $super, $parent_nesting) {\n    function $Complex(){};\n    var self = $Complex = $klass($base, $super, 'Complex', $Complex);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Complex_rect_1, TMP_Complex_polar_2, TMP_Complex_initialize_3, TMP_Complex_coerce_4, TMP_Complex_$eq$eq_5, TMP_Complex_$$_6, TMP_Complex_$_7, TMP_Complex_$_8, TMP_Complex_$_9, TMP_Complex_$_10, TMP_Complex_$$_11, TMP_Complex_abs_12, TMP_Complex_abs2_13, TMP_Complex_angle_14, TMP_Complex_conj_15, TMP_Complex_denominator_16, TMP_Complex_eql$q_17, TMP_Complex_fdiv_18, TMP_Complex_finite$q_19, TMP_Complex_hash_20, TMP_Complex_infinite$q_21, TMP_Complex_inspect_22, TMP_Complex_numerator_23, TMP_Complex_polar_24, TMP_Complex_rationalize_25, TMP_Complex_real$q_26, TMP_Complex_rect_27, TMP_Complex_to_f_28, TMP_Complex_to_i_29, TMP_Complex_to_r_30, TMP_Complex_to_s_31;\n\n    def.real = def.imag = nil;\n    \n    Opal.defs(self, '$rect', TMP_Complex_rect_1 = function $$rect(real, imag) {\n      var $a, $b, $c, self = this;\n\n      if (imag == null) {\n        imag = 0;\n      }\n      \n      if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = $$($nesting, 'Numeric')['$==='](real)) ? real['$real?']() : $c)) ? $$($nesting, 'Numeric')['$==='](imag) : $b)) ? imag['$real?']() : $a))) {\n      } else {\n        self.$raise($$($nesting, 'TypeError'), \"not a real\")\n      };\n      return self.$new(real, imag);\n    }, TMP_Complex_rect_1.$$arity = -2);\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return Opal.alias(self, \"rectangular\", \"rect\")\n    })(Opal.get_singleton_class(self), $nesting);\n    Opal.defs(self, '$polar', TMP_Complex_polar_2 = function $$polar(r, theta) {\n      var $a, $b, $c, self = this;\n\n      if (theta == null) {\n        theta = 0;\n      }\n      \n      if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = $$($nesting, 'Numeric')['$==='](r)) ? r['$real?']() : $c)) ? $$($nesting, 'Numeric')['$==='](theta) : $b)) ? theta['$real?']() : $a))) {\n      } else {\n        self.$raise($$($nesting, 'TypeError'), \"not a real\")\n      };\n      return self.$new($rb_times(r, $$($nesting, 'Math').$cos(theta)), $rb_times(r, $$($nesting, 'Math').$sin(theta)));\n    }, TMP_Complex_polar_2.$$arity = -2);\n    self.$attr_reader(\"real\", \"imag\");\n    \n    Opal.def(self, '$initialize', TMP_Complex_initialize_3 = function $$initialize(real, imag) {\n      var self = this;\n\n      if (imag == null) {\n        imag = 0;\n      }\n      \n      self.real = real;\n      return (self.imag = imag);\n    }, TMP_Complex_initialize_3.$$arity = -2);\n    \n    Opal.def(self, '$coerce', TMP_Complex_coerce_4 = function $$coerce(other) {\n      var $a, self = this;\n\n      if ($truthy($$($nesting, 'Complex')['$==='](other))) {\n        return [other, self]\n      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {\n        return [$$($nesting, 'Complex').$new(other, 0), self]\n      } else {\n        return self.$raise($$($nesting, 'TypeError'), \"\" + (other.$class()) + \" can't be coerced into Complex\")\n      }\n    }, TMP_Complex_coerce_4.$$arity = 1);\n    \n    Opal.def(self, '$==', TMP_Complex_$eq$eq_5 = function(other) {\n      var $a, self = this;\n\n      if ($truthy($$($nesting, 'Complex')['$==='](other))) {\n        return (($a = self.real['$=='](other.$real())) ? self.imag['$=='](other.$imag()) : self.real['$=='](other.$real()))\n      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {\n        return (($a = self.real['$=='](other)) ? self.imag['$=='](0) : self.real['$=='](other))\n      } else {\n        return other['$=='](self)\n      }\n    }, TMP_Complex_$eq$eq_5.$$arity = 1);\n    \n    Opal.def(self, '$-@', TMP_Complex_$$_6 = function() {\n      var self = this;\n\n      return self.$Complex(self.real['$-@'](), self.imag['$-@']())\n    }, TMP_Complex_$$_6.$$arity = 0);\n    \n    Opal.def(self, '$+', TMP_Complex_$_7 = function(other) {\n      var $a, self = this;\n\n      if ($truthy($$($nesting, 'Complex')['$==='](other))) {\n        return self.$Complex($rb_plus(self.real, other.$real()), $rb_plus(self.imag, other.$imag()))\n      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {\n        return self.$Complex($rb_plus(self.real, other), self.imag)\n      } else {\n        return self.$__coerced__(\"+\", other)\n      }\n    }, TMP_Complex_$_7.$$arity = 1);\n    \n    Opal.def(self, '$-', TMP_Complex_$_8 = function(other) {\n      var $a, self = this;\n\n      if ($truthy($$($nesting, 'Complex')['$==='](other))) {\n        return self.$Complex($rb_minus(self.real, other.$real()), $rb_minus(self.imag, other.$imag()))\n      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {\n        return self.$Complex($rb_minus(self.real, other), self.imag)\n      } else {\n        return self.$__coerced__(\"-\", other)\n      }\n    }, TMP_Complex_$_8.$$arity = 1);\n    \n    Opal.def(self, '$*', TMP_Complex_$_9 = function(other) {\n      var $a, self = this;\n\n      if ($truthy($$($nesting, 'Complex')['$==='](other))) {\n        return self.$Complex($rb_minus($rb_times(self.real, other.$real()), $rb_times(self.imag, other.$imag())), $rb_plus($rb_times(self.real, other.$imag()), $rb_times(self.imag, other.$real())))\n      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {\n        return self.$Complex($rb_times(self.real, other), $rb_times(self.imag, other))\n      } else {\n        return self.$__coerced__(\"*\", other)\n      }\n    }, TMP_Complex_$_9.$$arity = 1);\n    \n    Opal.def(self, '$/', TMP_Complex_$_10 = function(other) {\n      var $a, $b, $c, $d, self = this;\n\n      if ($truthy($$($nesting, 'Complex')['$==='](other))) {\n        if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = $$($nesting, 'Number')['$==='](self.real)) ? self.real['$nan?']() : $d)) ? $c : ($truthy($d = $$($nesting, 'Number')['$==='](self.imag)) ? self.imag['$nan?']() : $d))) ? $b : ($truthy($c = $$($nesting, 'Number')['$==='](other.$real())) ? other.$real()['$nan?']() : $c))) ? $a : ($truthy($b = $$($nesting, 'Number')['$==='](other.$imag())) ? other.$imag()['$nan?']() : $b)))) {\n          return $$($nesting, 'Complex').$new($$$($$($nesting, 'Float'), 'NAN'), $$$($$($nesting, 'Float'), 'NAN'))\n        } else {\n          return $rb_divide($rb_times(self, other.$conj()), other.$abs2())\n        }\n      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {\n        return self.$Complex(self.real.$quo(other), self.imag.$quo(other))\n      } else {\n        return self.$__coerced__(\"/\", other)\n      }\n    }, TMP_Complex_$_10.$$arity = 1);\n    \n    Opal.def(self, '$**', TMP_Complex_$$_11 = function(other) {\n      var $a, $b, $c, $d, self = this, r = nil, theta = nil, ore = nil, oim = nil, nr = nil, ntheta = nil, x = nil, z = nil, n = nil, div = nil, mod = nil;\n\n      \n      if (other['$=='](0)) {\n        return $$($nesting, 'Complex').$new(1, 0)};\n      if ($truthy($$($nesting, 'Complex')['$==='](other))) {\n        \n        $b = self.$polar(), $a = Opal.to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;\n        ore = other.$real();\n        oim = other.$imag();\n        nr = $$($nesting, 'Math').$exp($rb_minus($rb_times(ore, $$($nesting, 'Math').$log(r)), $rb_times(oim, theta)));\n        ntheta = $rb_plus($rb_times(theta, ore), $rb_times(oim, $$($nesting, 'Math').$log(r)));\n        return $$($nesting, 'Complex').$polar(nr, ntheta);\n      } else if ($truthy($$($nesting, 'Integer')['$==='](other))) {\n        if ($truthy($rb_gt(other, 0))) {\n          \n          x = self;\n          z = x;\n          n = $rb_minus(other, 1);\n          while ($truthy(n['$!='](0))) {\n            \n            $c = n.$divmod(2), $b = Opal.to_ary($c), (div = ($b[0] == null ? nil : $b[0])), (mod = ($b[1] == null ? nil : $b[1])), $c;\n            while (mod['$=='](0)) {\n              \n              x = self.$Complex($rb_minus($rb_times(x.$real(), x.$real()), $rb_times(x.$imag(), x.$imag())), $rb_times($rb_times(2, x.$real()), x.$imag()));\n              n = div;\n              $d = n.$divmod(2), $c = Opal.to_ary($d), (div = ($c[0] == null ? nil : $c[0])), (mod = ($c[1] == null ? nil : $c[1])), $d;\n            };\n            z = $rb_times(z, x);\n            n = $rb_minus(n, 1);\n          };\n          return z;\n        } else {\n          return $rb_divide($$($nesting, 'Rational').$new(1, 1), self)['$**'](other['$-@']())\n        }\n      } else if ($truthy(($truthy($a = $$($nesting, 'Float')['$==='](other)) ? $a : $$($nesting, 'Rational')['$==='](other)))) {\n        \n        $b = self.$polar(), $a = Opal.to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;\n        return $$($nesting, 'Complex').$polar(r['$**'](other), $rb_times(theta, other));\n      } else {\n        return self.$__coerced__(\"**\", other)\n      };\n    }, TMP_Complex_$$_11.$$arity = 1);\n    \n    Opal.def(self, '$abs', TMP_Complex_abs_12 = function $$abs() {\n      var self = this;\n\n      return $$($nesting, 'Math').$hypot(self.real, self.imag)\n    }, TMP_Complex_abs_12.$$arity = 0);\n    \n    Opal.def(self, '$abs2', TMP_Complex_abs2_13 = function $$abs2() {\n      var self = this;\n\n      return $rb_plus($rb_times(self.real, self.real), $rb_times(self.imag, self.imag))\n    }, TMP_Complex_abs2_13.$$arity = 0);\n    \n    Opal.def(self, '$angle', TMP_Complex_angle_14 = function $$angle() {\n      var self = this;\n\n      return $$($nesting, 'Math').$atan2(self.imag, self.real)\n    }, TMP_Complex_angle_14.$$arity = 0);\n    Opal.alias(self, \"arg\", \"angle\");\n    \n    Opal.def(self, '$conj', TMP_Complex_conj_15 = function $$conj() {\n      var self = this;\n\n      return self.$Complex(self.real, self.imag['$-@']())\n    }, TMP_Complex_conj_15.$$arity = 0);\n    Opal.alias(self, \"conjugate\", \"conj\");\n    \n    Opal.def(self, '$denominator', TMP_Complex_denominator_16 = function $$denominator() {\n      var self = this;\n\n      return self.real.$denominator().$lcm(self.imag.$denominator())\n    }, TMP_Complex_denominator_16.$$arity = 0);\n    Opal.alias(self, \"divide\", \"/\");\n    \n    Opal.def(self, '$eql?', TMP_Complex_eql$q_17 = function(other) {\n      var $a, $b, self = this;\n\n      return ($truthy($a = ($truthy($b = $$($nesting, 'Complex')['$==='](other)) ? self.real.$class()['$=='](self.imag.$class()) : $b)) ? self['$=='](other) : $a)\n    }, TMP_Complex_eql$q_17.$$arity = 1);\n    \n    Opal.def(self, '$fdiv', TMP_Complex_fdiv_18 = function $$fdiv(other) {\n      var self = this;\n\n      \n      if ($truthy($$($nesting, 'Numeric')['$==='](other))) {\n      } else {\n        self.$raise($$($nesting, 'TypeError'), \"\" + (other.$class()) + \" can't be coerced into Complex\")\n      };\n      return $rb_divide(self, other);\n    }, TMP_Complex_fdiv_18.$$arity = 1);\n    \n    Opal.def(self, '$finite?', TMP_Complex_finite$q_19 = function() {\n      var $a, self = this;\n\n      return ($truthy($a = self.real['$finite?']()) ? self.imag['$finite?']() : $a)\n    }, TMP_Complex_finite$q_19.$$arity = 0);\n    \n    Opal.def(self, '$hash', TMP_Complex_hash_20 = function $$hash() {\n      var self = this;\n\n      return \"\" + \"Complex:\" + (self.real) + \":\" + (self.imag)\n    }, TMP_Complex_hash_20.$$arity = 0);\n    Opal.alias(self, \"imaginary\", \"imag\");\n    \n    Opal.def(self, '$infinite?', TMP_Complex_infinite$q_21 = function() {\n      var $a, self = this;\n\n      return ($truthy($a = self.real['$infinite?']()) ? $a : self.imag['$infinite?']())\n    }, TMP_Complex_infinite$q_21.$$arity = 0);\n    \n    Opal.def(self, '$inspect', TMP_Complex_inspect_22 = function $$inspect() {\n      var self = this;\n\n      return \"\" + \"(\" + (self) + \")\"\n    }, TMP_Complex_inspect_22.$$arity = 0);\n    Opal.alias(self, \"magnitude\", \"abs\");\n    \n    Opal.udef(self, '$' + \"negative?\");;\n    \n    Opal.def(self, '$numerator', TMP_Complex_numerator_23 = function $$numerator() {\n      var self = this, d = nil;\n\n      \n      d = self.$denominator();\n      return self.$Complex($rb_times(self.real.$numerator(), $rb_divide(d, self.real.$denominator())), $rb_times(self.imag.$numerator(), $rb_divide(d, self.imag.$denominator())));\n    }, TMP_Complex_numerator_23.$$arity = 0);\n    Opal.alias(self, \"phase\", \"arg\");\n    \n    Opal.def(self, '$polar', TMP_Complex_polar_24 = function $$polar() {\n      var self = this;\n\n      return [self.$abs(), self.$arg()]\n    }, TMP_Complex_polar_24.$$arity = 0);\n    \n    Opal.udef(self, '$' + \"positive?\");;\n    Opal.alias(self, \"quo\", \"/\");\n    \n    Opal.def(self, '$rationalize', TMP_Complex_rationalize_25 = function $$rationalize(eps) {\n      var self = this;\n\n      \n      \n      if (arguments.length > 1) {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (arguments.length) + \" for 0..1)\");\n      }\n    ;\n      if ($truthy(self.imag['$!='](0))) {\n        self.$raise($$($nesting, 'RangeError'), \"\" + \"can't' convert \" + (self) + \" into Rational\")};\n      return self.$real().$rationalize(eps);\n    }, TMP_Complex_rationalize_25.$$arity = -1);\n    \n    Opal.def(self, '$real?', TMP_Complex_real$q_26 = function() {\n      var self = this;\n\n      return false\n    }, TMP_Complex_real$q_26.$$arity = 0);\n    \n    Opal.def(self, '$rect', TMP_Complex_rect_27 = function $$rect() {\n      var self = this;\n\n      return [self.real, self.imag]\n    }, TMP_Complex_rect_27.$$arity = 0);\n    Opal.alias(self, \"rectangular\", \"rect\");\n    \n    Opal.def(self, '$to_f', TMP_Complex_to_f_28 = function $$to_f() {\n      var self = this;\n\n      \n      if (self.imag['$=='](0)) {\n      } else {\n        self.$raise($$($nesting, 'RangeError'), \"\" + \"can't convert \" + (self) + \" into Float\")\n      };\n      return self.real.$to_f();\n    }, TMP_Complex_to_f_28.$$arity = 0);\n    \n    Opal.def(self, '$to_i', TMP_Complex_to_i_29 = function $$to_i() {\n      var self = this;\n\n      \n      if (self.imag['$=='](0)) {\n      } else {\n        self.$raise($$($nesting, 'RangeError'), \"\" + \"can't convert \" + (self) + \" into Integer\")\n      };\n      return self.real.$to_i();\n    }, TMP_Complex_to_i_29.$$arity = 0);\n    \n    Opal.def(self, '$to_r', TMP_Complex_to_r_30 = function $$to_r() {\n      var self = this;\n\n      \n      if (self.imag['$=='](0)) {\n      } else {\n        self.$raise($$($nesting, 'RangeError'), \"\" + \"can't convert \" + (self) + \" into Rational\")\n      };\n      return self.real.$to_r();\n    }, TMP_Complex_to_r_30.$$arity = 0);\n    \n    Opal.def(self, '$to_s', TMP_Complex_to_s_31 = function $$to_s() {\n      var $a, $b, $c, self = this, result = nil;\n\n      \n      result = self.real.$inspect();\n      result = $rb_plus(result, (function() {if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = $$($nesting, 'Number')['$==='](self.imag)) ? self.imag['$nan?']() : $c)) ? $b : self.imag['$positive?']())) ? $a : self.imag['$zero?']()))) {\n        return \"+\"\n      } else {\n        return \"-\"\n      }; return nil; })());\n      result = $rb_plus(result, self.imag.$abs().$inspect());\n      if ($truthy(($truthy($a = $$($nesting, 'Number')['$==='](self.imag)) ? ($truthy($b = self.imag['$nan?']()) ? $b : self.imag['$infinite?']()) : $a))) {\n        result = $rb_plus(result, \"*\")};\n      return $rb_plus(result, \"i\");\n    }, TMP_Complex_to_s_31.$$arity = 0);\n    return Opal.const_set($nesting[0], 'I', self.$new(0, 1));\n  })($nesting[0], $$($nesting, 'Numeric'), $nesting);\n  return (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_Complex_32;\n\n    \n    Opal.def(self, '$Complex', TMP_Kernel_Complex_32 = function $$Complex(real, imag) {\n      var self = this;\n\n      if (imag == null) {\n        imag = nil;\n      }\n      if ($truthy(imag)) {\n        return $$($nesting, 'Complex').$new(real, imag)\n      } else {\n        return $$($nesting, 'Complex').$new(real, 0)\n      }\n    }, TMP_Kernel_Complex_32.$$arity = -2)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/rational\"] = function(Opal) {\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $module = Opal.module;\n\n  Opal.add_stubs(['$require', '$to_i', '$==', '$raise', '$<', '$-@', '$new', '$gcd', '$/', '$nil?', '$===', '$reduce', '$to_r', '$equal?', '$!', '$coerce_to!', '$to_f', '$numerator', '$denominator', '$<=>', '$-', '$*', '$__coerced__', '$+', '$Rational', '$>', '$**', '$abs', '$ceil', '$with_precision', '$floor', '$<=', '$truncate', '$send', '$convert']);\n  \n  self.$require(\"corelib/numeric\");\n  (function($base, $super, $parent_nesting) {\n    function $Rational(){};\n    var self = $Rational = $klass($base, $super, 'Rational', $Rational);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Rational_reduce_1, TMP_Rational_convert_2, TMP_Rational_initialize_3, TMP_Rational_numerator_4, TMP_Rational_denominator_5, TMP_Rational_coerce_6, TMP_Rational_$eq$eq_7, TMP_Rational_$lt$eq$gt_8, TMP_Rational_$_9, TMP_Rational_$_10, TMP_Rational_$_11, TMP_Rational_$_12, TMP_Rational_$$_13, TMP_Rational_abs_14, TMP_Rational_ceil_15, TMP_Rational_floor_16, TMP_Rational_hash_17, TMP_Rational_inspect_18, TMP_Rational_rationalize_19, TMP_Rational_round_20, TMP_Rational_to_f_21, TMP_Rational_to_i_22, TMP_Rational_to_r_23, TMP_Rational_to_s_24, TMP_Rational_truncate_25, TMP_Rational_with_precision_26;\n\n    def.num = def.den = nil;\n    \n    Opal.defs(self, '$reduce', TMP_Rational_reduce_1 = function $$reduce(num, den) {\n      var self = this, gcd = nil;\n\n      \n      num = num.$to_i();\n      den = den.$to_i();\n      if (den['$=='](0)) {\n        self.$raise($$($nesting, 'ZeroDivisionError'), \"divided by 0\")\n      } else if ($truthy($rb_lt(den, 0))) {\n        \n        num = num['$-@']();\n        den = den['$-@']();\n      } else if (den['$=='](1)) {\n        return self.$new(num, den)};\n      gcd = num.$gcd(den);\n      return self.$new($rb_divide(num, gcd), $rb_divide(den, gcd));\n    }, TMP_Rational_reduce_1.$$arity = 2);\n    Opal.defs(self, '$convert', TMP_Rational_convert_2 = function $$convert(num, den) {\n      var $a, $b, self = this;\n\n      \n      if ($truthy(($truthy($a = num['$nil?']()) ? $a : den['$nil?']()))) {\n        self.$raise($$($nesting, 'TypeError'), \"cannot convert nil into Rational\")};\n      if ($truthy(($truthy($a = $$($nesting, 'Integer')['$==='](num)) ? $$($nesting, 'Integer')['$==='](den) : $a))) {\n        return self.$reduce(num, den)};\n      if ($truthy(($truthy($a = ($truthy($b = $$($nesting, 'Float')['$==='](num)) ? $b : $$($nesting, 'String')['$==='](num))) ? $a : $$($nesting, 'Complex')['$==='](num)))) {\n        num = num.$to_r()};\n      if ($truthy(($truthy($a = ($truthy($b = $$($nesting, 'Float')['$==='](den)) ? $b : $$($nesting, 'String')['$==='](den))) ? $a : $$($nesting, 'Complex')['$==='](den)))) {\n        den = den.$to_r()};\n      if ($truthy(($truthy($a = den['$equal?'](1)) ? $$($nesting, 'Integer')['$==='](num)['$!']() : $a))) {\n        return $$($nesting, 'Opal')['$coerce_to!'](num, $$($nesting, 'Rational'), \"to_r\")\n      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](num)) ? $$($nesting, 'Numeric')['$==='](den) : $a))) {\n        return $rb_divide(num, den)\n      } else {\n        return self.$reduce(num, den)\n      };\n    }, TMP_Rational_convert_2.$$arity = 2);\n    \n    Opal.def(self, '$initialize', TMP_Rational_initialize_3 = function $$initialize(num, den) {\n      var self = this;\n\n      \n      self.num = num;\n      return (self.den = den);\n    }, TMP_Rational_initialize_3.$$arity = 2);\n    \n    Opal.def(self, '$numerator', TMP_Rational_numerator_4 = function $$numerator() {\n      var self = this;\n\n      return self.num\n    }, TMP_Rational_numerator_4.$$arity = 0);\n    \n    Opal.def(self, '$denominator', TMP_Rational_denominator_5 = function $$denominator() {\n      var self = this;\n\n      return self.den\n    }, TMP_Rational_denominator_5.$$arity = 0);\n    \n    Opal.def(self, '$coerce', TMP_Rational_coerce_6 = function $$coerce(other) {\n      var self = this, $case = nil;\n\n      return (function() {$case = other;\n      if ($$($nesting, 'Rational')['$===']($case)) {return [other, self]}\n      else if ($$($nesting, 'Integer')['$===']($case)) {return [other.$to_r(), self]}\n      else if ($$($nesting, 'Float')['$===']($case)) {return [other, self.$to_f()]}\n      else { return nil }})()\n    }, TMP_Rational_coerce_6.$$arity = 1);\n    \n    Opal.def(self, '$==', TMP_Rational_$eq$eq_7 = function(other) {\n      var $a, self = this, $case = nil;\n\n      return (function() {$case = other;\n      if ($$($nesting, 'Rational')['$===']($case)) {return (($a = self.num['$=='](other.$numerator())) ? self.den['$=='](other.$denominator()) : self.num['$=='](other.$numerator()))}\n      else if ($$($nesting, 'Integer')['$===']($case)) {return (($a = self.num['$=='](other)) ? self.den['$=='](1) : self.num['$=='](other))}\n      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$=='](other)}\n      else {return other['$=='](self)}})()\n    }, TMP_Rational_$eq$eq_7.$$arity = 1);\n    \n    Opal.def(self, '$<=>', TMP_Rational_$lt$eq$gt_8 = function(other) {\n      var self = this, $case = nil;\n\n      return (function() {$case = other;\n      if ($$($nesting, 'Rational')['$===']($case)) {return $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()))['$<=>'](0)}\n      else if ($$($nesting, 'Integer')['$===']($case)) {return $rb_minus(self.num, $rb_times(self.den, other))['$<=>'](0)}\n      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$<=>'](other)}\n      else {return self.$__coerced__(\"<=>\", other)}})()\n    }, TMP_Rational_$lt$eq$gt_8.$$arity = 1);\n    \n    Opal.def(self, '$+', TMP_Rational_$_9 = function(other) {\n      var self = this, $case = nil, num = nil, den = nil;\n\n      return (function() {$case = other;\n      if ($$($nesting, 'Rational')['$===']($case)) {\n      num = $rb_plus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));\n      den = $rb_times(self.den, other.$denominator());\n      return self.$Rational(num, den);}\n      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_plus(self.num, $rb_times(other, self.den)), self.den)}\n      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_plus(self.$to_f(), other)}\n      else {return self.$__coerced__(\"+\", other)}})()\n    }, TMP_Rational_$_9.$$arity = 1);\n    \n    Opal.def(self, '$-', TMP_Rational_$_10 = function(other) {\n      var self = this, $case = nil, num = nil, den = nil;\n\n      return (function() {$case = other;\n      if ($$($nesting, 'Rational')['$===']($case)) {\n      num = $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));\n      den = $rb_times(self.den, other.$denominator());\n      return self.$Rational(num, den);}\n      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_minus(self.num, $rb_times(other, self.den)), self.den)}\n      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_minus(self.$to_f(), other)}\n      else {return self.$__coerced__(\"-\", other)}})()\n    }, TMP_Rational_$_10.$$arity = 1);\n    \n    Opal.def(self, '$*', TMP_Rational_$_11 = function(other) {\n      var self = this, $case = nil, num = nil, den = nil;\n\n      return (function() {$case = other;\n      if ($$($nesting, 'Rational')['$===']($case)) {\n      num = $rb_times(self.num, other.$numerator());\n      den = $rb_times(self.den, other.$denominator());\n      return self.$Rational(num, den);}\n      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_times(self.num, other), self.den)}\n      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_times(self.$to_f(), other)}\n      else {return self.$__coerced__(\"*\", other)}})()\n    }, TMP_Rational_$_11.$$arity = 1);\n    \n    Opal.def(self, '$/', TMP_Rational_$_12 = function(other) {\n      var self = this, $case = nil, num = nil, den = nil;\n\n      return (function() {$case = other;\n      if ($$($nesting, 'Rational')['$===']($case)) {\n      num = $rb_times(self.num, other.$denominator());\n      den = $rb_times(self.den, other.$numerator());\n      return self.$Rational(num, den);}\n      else if ($$($nesting, 'Integer')['$===']($case)) {if (other['$=='](0)) {\n        return $rb_divide(self.$to_f(), 0.0)\n      } else {\n        return self.$Rational(self.num, $rb_times(self.den, other))\n      }}\n      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_divide(self.$to_f(), other)}\n      else {return self.$__coerced__(\"/\", other)}})()\n    }, TMP_Rational_$_12.$$arity = 1);\n    \n    Opal.def(self, '$**', TMP_Rational_$$_13 = function(other) {\n      var $a, self = this, $case = nil;\n\n      return (function() {$case = other;\n      if ($$($nesting, 'Integer')['$===']($case)) {if ($truthy((($a = self['$=='](0)) ? $rb_lt(other, 0) : self['$=='](0)))) {\n        return $$$($$($nesting, 'Float'), 'INFINITY')\n      } else if ($truthy($rb_gt(other, 0))) {\n        return self.$Rational(self.num['$**'](other), self.den['$**'](other))\n      } else if ($truthy($rb_lt(other, 0))) {\n        return self.$Rational(self.den['$**'](other['$-@']()), self.num['$**'](other['$-@']()))\n      } else {\n        return self.$Rational(1, 1)\n      }}\n      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$**'](other)}\n      else if ($$($nesting, 'Rational')['$===']($case)) {if (other['$=='](0)) {\n        return self.$Rational(1, 1)\n      } else if (other.$denominator()['$=='](1)) {\n        if ($truthy($rb_lt(other, 0))) {\n          return self.$Rational(self.den['$**'](other.$numerator().$abs()), self.num['$**'](other.$numerator().$abs()))\n        } else {\n          return self.$Rational(self.num['$**'](other.$numerator()), self.den['$**'](other.$numerator()))\n        }\n      } else if ($truthy((($a = self['$=='](0)) ? $rb_lt(other, 0) : self['$=='](0)))) {\n        return self.$raise($$($nesting, 'ZeroDivisionError'), \"divided by 0\")\n      } else {\n        return self.$to_f()['$**'](other)\n      }}\n      else {return self.$__coerced__(\"**\", other)}})()\n    }, TMP_Rational_$$_13.$$arity = 1);\n    \n    Opal.def(self, '$abs', TMP_Rational_abs_14 = function $$abs() {\n      var self = this;\n\n      return self.$Rational(self.num.$abs(), self.den.$abs())\n    }, TMP_Rational_abs_14.$$arity = 0);\n    \n    Opal.def(self, '$ceil', TMP_Rational_ceil_15 = function $$ceil(precision) {\n      var self = this;\n\n      if (precision == null) {\n        precision = 0;\n      }\n      if (precision['$=='](0)) {\n        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$ceil()\n      } else {\n        return self.$with_precision(\"ceil\", precision)\n      }\n    }, TMP_Rational_ceil_15.$$arity = -1);\n    Opal.alias(self, \"divide\", \"/\");\n    \n    Opal.def(self, '$floor', TMP_Rational_floor_16 = function $$floor(precision) {\n      var self = this;\n\n      if (precision == null) {\n        precision = 0;\n      }\n      if (precision['$=='](0)) {\n        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$floor()\n      } else {\n        return self.$with_precision(\"floor\", precision)\n      }\n    }, TMP_Rational_floor_16.$$arity = -1);\n    \n    Opal.def(self, '$hash', TMP_Rational_hash_17 = function $$hash() {\n      var self = this;\n\n      return \"\" + \"Rational:\" + (self.num) + \":\" + (self.den)\n    }, TMP_Rational_hash_17.$$arity = 0);\n    \n    Opal.def(self, '$inspect', TMP_Rational_inspect_18 = function $$inspect() {\n      var self = this;\n\n      return \"\" + \"(\" + (self) + \")\"\n    }, TMP_Rational_inspect_18.$$arity = 0);\n    Opal.alias(self, \"quo\", \"/\");\n    \n    Opal.def(self, '$rationalize', TMP_Rational_rationalize_19 = function $$rationalize(eps) {\n      var self = this;\n\n      \n      if (arguments.length > 1) {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (\" + (arguments.length) + \" for 0..1)\");\n      }\n\n      if (eps == null) {\n        return self;\n      }\n\n      var e = eps.$abs(),\n          a = $rb_minus(self, e),\n          b = $rb_plus(self, e);\n\n      var p0 = 0,\n          p1 = 1,\n          q0 = 1,\n          q1 = 0,\n          p2, q2;\n\n      var c, k, t;\n\n      while (true) {\n        c = (a).$ceil();\n\n        if ($rb_le(c, b)) {\n          break;\n        }\n\n        k  = c - 1;\n        p2 = k * p1 + p0;\n        q2 = k * q1 + q0;\n        t  = $rb_divide(1, $rb_minus(b, k));\n        b  = $rb_divide(1, $rb_minus(a, k));\n        a  = t;\n\n        p0 = p1;\n        q0 = q1;\n        p1 = p2;\n        q1 = q2;\n      }\n\n      return self.$Rational(c * p1 + p0, c * q1 + q0);\n    \n    }, TMP_Rational_rationalize_19.$$arity = -1);\n    \n    Opal.def(self, '$round', TMP_Rational_round_20 = function $$round(precision) {\n      var self = this, num = nil, den = nil, approx = nil;\n\n      if (precision == null) {\n        precision = 0;\n      }\n      \n      if (precision['$=='](0)) {\n      } else {\n        return self.$with_precision(\"round\", precision)\n      };\n      if (self.num['$=='](0)) {\n        return 0};\n      if (self.den['$=='](1)) {\n        return self.num};\n      num = $rb_plus($rb_times(self.num.$abs(), 2), self.den);\n      den = $rb_times(self.den, 2);\n      approx = $rb_divide(num, den).$truncate();\n      if ($truthy($rb_lt(self.num, 0))) {\n        return approx['$-@']()\n      } else {\n        return approx\n      };\n    }, TMP_Rational_round_20.$$arity = -1);\n    \n    Opal.def(self, '$to_f', TMP_Rational_to_f_21 = function $$to_f() {\n      var self = this;\n\n      return $rb_divide(self.num, self.den)\n    }, TMP_Rational_to_f_21.$$arity = 0);\n    \n    Opal.def(self, '$to_i', TMP_Rational_to_i_22 = function $$to_i() {\n      var self = this;\n\n      return self.$truncate()\n    }, TMP_Rational_to_i_22.$$arity = 0);\n    \n    Opal.def(self, '$to_r', TMP_Rational_to_r_23 = function $$to_r() {\n      var self = this;\n\n      return self\n    }, TMP_Rational_to_r_23.$$arity = 0);\n    \n    Opal.def(self, '$to_s', TMP_Rational_to_s_24 = function $$to_s() {\n      var self = this;\n\n      return \"\" + (self.num) + \"/\" + (self.den)\n    }, TMP_Rational_to_s_24.$$arity = 0);\n    \n    Opal.def(self, '$truncate', TMP_Rational_truncate_25 = function $$truncate(precision) {\n      var self = this;\n\n      if (precision == null) {\n        precision = 0;\n      }\n      if (precision['$=='](0)) {\n        if ($truthy($rb_lt(self.num, 0))) {\n          return self.$ceil()\n        } else {\n          return self.$floor()\n        }\n      } else {\n        return self.$with_precision(\"truncate\", precision)\n      }\n    }, TMP_Rational_truncate_25.$$arity = -1);\n    return (Opal.def(self, '$with_precision', TMP_Rational_with_precision_26 = function $$with_precision(method, precision) {\n      var self = this, p = nil, s = nil;\n\n      \n      if ($truthy($$($nesting, 'Integer')['$==='](precision))) {\n      } else {\n        self.$raise($$($nesting, 'TypeError'), \"not an Integer\")\n      };\n      p = (10)['$**'](precision);\n      s = $rb_times(self, p);\n      if ($truthy($rb_lt(precision, 1))) {\n        return $rb_divide(s.$send(method), p).$to_i()\n      } else {\n        return self.$Rational(s.$send(method), p)\n      };\n    }, TMP_Rational_with_precision_26.$$arity = 2), nil) && 'with_precision';\n  })($nesting[0], $$($nesting, 'Numeric'), $nesting);\n  return (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_Rational_27;\n\n    \n    Opal.def(self, '$Rational', TMP_Kernel_Rational_27 = function $$Rational(numerator, denominator) {\n      var self = this;\n\n      if (denominator == null) {\n        denominator = 1;\n      }\n      return $$($nesting, 'Rational').$convert(numerator, denominator)\n    }, TMP_Kernel_Rational_27.$$arity = -2)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/time\"] = function(Opal) {\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range;\n\n  Opal.add_stubs(['$require', '$include', '$===', '$raise', '$coerce_to!', '$respond_to?', '$to_str', '$to_i', '$new', '$<=>', '$to_f', '$nil?', '$>', '$<', '$strftime', '$year', '$month', '$day', '$+', '$round', '$/', '$-', '$copy_instance_variables', '$initialize_dup', '$is_a?', '$zero?', '$wday', '$utc?', '$mon', '$yday', '$hour', '$min', '$sec', '$rjust', '$ljust', '$zone', '$to_s', '$[]', '$cweek_cyear', '$isdst', '$<=', '$!=', '$==', '$ceil']);\n  \n  self.$require(\"corelib/comparable\");\n  return (function($base, $super, $parent_nesting) {\n    function $Time(){};\n    var self = $Time = $klass($base, $super, 'Time', $Time);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Time_at_1, TMP_Time_new_2, TMP_Time_local_3, TMP_Time_gm_4, TMP_Time_now_5, TMP_Time_$_6, TMP_Time_$_7, TMP_Time_$lt$eq$gt_8, TMP_Time_$eq$eq_9, TMP_Time_asctime_10, TMP_Time_day_11, TMP_Time_yday_12, TMP_Time_isdst_13, TMP_Time_dup_14, TMP_Time_eql$q_15, TMP_Time_friday$q_16, TMP_Time_hash_17, TMP_Time_hour_18, TMP_Time_inspect_19, TMP_Time_min_20, TMP_Time_mon_21, TMP_Time_monday$q_22, TMP_Time_saturday$q_23, TMP_Time_sec_24, TMP_Time_succ_25, TMP_Time_usec_26, TMP_Time_zone_27, TMP_Time_getgm_28, TMP_Time_gmtime_29, TMP_Time_gmt$q_30, TMP_Time_gmt_offset_31, TMP_Time_strftime_32, TMP_Time_sunday$q_33, TMP_Time_thursday$q_34, TMP_Time_to_a_35, TMP_Time_to_f_36, TMP_Time_to_i_37, TMP_Time_tuesday$q_38, TMP_Time_wday_39, TMP_Time_wednesday$q_40, TMP_Time_year_41, TMP_Time_cweek_cyear_42;\n\n    \n    self.$include($$($nesting, 'Comparable'));\n    \n    var days_of_week = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"],\n        short_days   = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n        short_months = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n        long_months  = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n  ;\n    Opal.defs(self, '$at', TMP_Time_at_1 = function $$at(seconds, frac) {\n      var self = this;\n\n      \n      var result;\n\n      if ($$($nesting, 'Time')['$==='](seconds)) {\n        if (frac !== undefined) {\n          self.$raise($$($nesting, 'TypeError'), \"can't convert Time into an exact number\")\n        }\n        result = new Date(seconds.getTime());\n        result.is_utc = seconds.is_utc;\n        return result;\n      }\n\n      if (!seconds.$$is_number) {\n        seconds = $$($nesting, 'Opal')['$coerce_to!'](seconds, $$($nesting, 'Integer'), \"to_int\");\n      }\n\n      if (frac === undefined) {\n        return new Date(seconds * 1000);\n      }\n\n      if (!frac.$$is_number) {\n        frac = $$($nesting, 'Opal')['$coerce_to!'](frac, $$($nesting, 'Integer'), \"to_int\");\n      }\n\n      return new Date(seconds * 1000 + (frac / 1000));\n    \n    }, TMP_Time_at_1.$$arity = -2);\n    \n    function time_params(year, month, day, hour, min, sec) {\n      if (year.$$is_string) {\n        year = parseInt(year, 10);\n      } else {\n        year = $$($nesting, 'Opal')['$coerce_to!'](year, $$($nesting, 'Integer'), \"to_int\");\n      }\n\n      if (month === nil) {\n        month = 1;\n      } else if (!month.$$is_number) {\n        if ((month)['$respond_to?'](\"to_str\")) {\n          month = (month).$to_str();\n          switch (month.toLowerCase()) {\n          case 'jan': month =  1; break;\n          case 'feb': month =  2; break;\n          case 'mar': month =  3; break;\n          case 'apr': month =  4; break;\n          case 'may': month =  5; break;\n          case 'jun': month =  6; break;\n          case 'jul': month =  7; break;\n          case 'aug': month =  8; break;\n          case 'sep': month =  9; break;\n          case 'oct': month = 10; break;\n          case 'nov': month = 11; break;\n          case 'dec': month = 12; break;\n          default: month = (month).$to_i();\n          }\n        } else {\n          month = $$($nesting, 'Opal')['$coerce_to!'](month, $$($nesting, 'Integer'), \"to_int\");\n        }\n      }\n\n      if (month < 1 || month > 12) {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"month out of range: \" + (month))\n      }\n      month = month - 1;\n\n      if (day === nil) {\n        day = 1;\n      } else if (day.$$is_string) {\n        day = parseInt(day, 10);\n      } else {\n        day = $$($nesting, 'Opal')['$coerce_to!'](day, $$($nesting, 'Integer'), \"to_int\");\n      }\n\n      if (day < 1 || day > 31) {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"day out of range: \" + (day))\n      }\n\n      if (hour === nil) {\n        hour = 0;\n      } else if (hour.$$is_string) {\n        hour = parseInt(hour, 10);\n      } else {\n        hour = $$($nesting, 'Opal')['$coerce_to!'](hour, $$($nesting, 'Integer'), \"to_int\");\n      }\n\n      if (hour < 0 || hour > 24) {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"hour out of range: \" + (hour))\n      }\n\n      if (min === nil) {\n        min = 0;\n      } else if (min.$$is_string) {\n        min = parseInt(min, 10);\n      } else {\n        min = $$($nesting, 'Opal')['$coerce_to!'](min, $$($nesting, 'Integer'), \"to_int\");\n      }\n\n      if (min < 0 || min > 59) {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"min out of range: \" + (min))\n      }\n\n      if (sec === nil) {\n        sec = 0;\n      } else if (!sec.$$is_number) {\n        if (sec.$$is_string) {\n          sec = parseInt(sec, 10);\n        } else {\n          sec = $$($nesting, 'Opal')['$coerce_to!'](sec, $$($nesting, 'Integer'), \"to_int\");\n        }\n      }\n\n      if (sec < 0 || sec > 60) {\n        self.$raise($$($nesting, 'ArgumentError'), \"\" + \"sec out of range: \" + (sec))\n      }\n\n      return [year, month, day, hour, min, sec];\n    }\n  ;\n    Opal.defs(self, '$new', TMP_Time_new_2 = function(year, month, day, hour, min, sec, utc_offset) {\n      var self = this;\n\n      if (month == null) {\n        month = nil;\n      }\n      if (day == null) {\n        day = nil;\n      }\n      if (hour == null) {\n        hour = nil;\n      }\n      if (min == null) {\n        min = nil;\n      }\n      if (sec == null) {\n        sec = nil;\n      }\n      if (utc_offset == null) {\n        utc_offset = nil;\n      }\n      \n      var args, result;\n\n      if (year === undefined) {\n        return new Date();\n      }\n\n      if (utc_offset !== nil) {\n        self.$raise($$($nesting, 'ArgumentError'), \"Opal does not support explicitly specifying UTC offset for Time\")\n      }\n\n      args  = time_params(year, month, day, hour, min, sec);\n      year  = args[0];\n      month = args[1];\n      day   = args[2];\n      hour  = args[3];\n      min   = args[4];\n      sec   = args[5];\n\n      result = new Date(year, month, day, hour, min, 0, sec * 1000);\n      if (year < 100) {\n        result.setFullYear(year);\n      }\n      return result;\n    \n    }, TMP_Time_new_2.$$arity = -1);\n    Opal.defs(self, '$local', TMP_Time_local_3 = function $$local(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {\n      var self = this;\n\n      if (month == null) {\n        month = nil;\n      }\n      if (day == null) {\n        day = nil;\n      }\n      if (hour == null) {\n        hour = nil;\n      }\n      if (min == null) {\n        min = nil;\n      }\n      if (sec == null) {\n        sec = nil;\n      }\n      if (millisecond == null) {\n        millisecond = nil;\n      }\n      if (_dummy1 == null) {\n        _dummy1 = nil;\n      }\n      if (_dummy2 == null) {\n        _dummy2 = nil;\n      }\n      if (_dummy3 == null) {\n        _dummy3 = nil;\n      }\n      \n      var args, result;\n\n      if (arguments.length === 10) {\n        args  = $slice.call(arguments);\n        year  = args[5];\n        month = args[4];\n        day   = args[3];\n        hour  = args[2];\n        min   = args[1];\n        sec   = args[0];\n      }\n\n      args  = time_params(year, month, day, hour, min, sec);\n      year  = args[0];\n      month = args[1];\n      day   = args[2];\n      hour  = args[3];\n      min   = args[4];\n      sec   = args[5];\n\n      result = new Date(year, month, day, hour, min, 0, sec * 1000);\n      if (year < 100) {\n        result.setFullYear(year);\n      }\n      return result;\n    \n    }, TMP_Time_local_3.$$arity = -2);\n    Opal.defs(self, '$gm', TMP_Time_gm_4 = function $$gm(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {\n      var self = this;\n\n      if (month == null) {\n        month = nil;\n      }\n      if (day == null) {\n        day = nil;\n      }\n      if (hour == null) {\n        hour = nil;\n      }\n      if (min == null) {\n        min = nil;\n      }\n      if (sec == null) {\n        sec = nil;\n      }\n      if (millisecond == null) {\n        millisecond = nil;\n      }\n      if (_dummy1 == null) {\n        _dummy1 = nil;\n      }\n      if (_dummy2 == null) {\n        _dummy2 = nil;\n      }\n      if (_dummy3 == null) {\n        _dummy3 = nil;\n      }\n      \n      var args, result;\n\n      if (arguments.length === 10) {\n        args  = $slice.call(arguments);\n        year  = args[5];\n        month = args[4];\n        day   = args[3];\n        hour  = args[2];\n        min   = args[1];\n        sec   = args[0];\n      }\n\n      args  = time_params(year, month, day, hour, min, sec);\n      year  = args[0];\n      month = args[1];\n      day   = args[2];\n      hour  = args[3];\n      min   = args[4];\n      sec   = args[5];\n\n      result = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));\n      if (year < 100) {\n        result.setUTCFullYear(year);\n      }\n      result.is_utc = true;\n      return result;\n    \n    }, TMP_Time_gm_4.$$arity = -2);\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      Opal.alias(self, \"mktime\", \"local\");\n      return Opal.alias(self, \"utc\", \"gm\");\n    })(Opal.get_singleton_class(self), $nesting);\n    Opal.defs(self, '$now', TMP_Time_now_5 = function $$now() {\n      var self = this;\n\n      return self.$new()\n    }, TMP_Time_now_5.$$arity = 0);\n    \n    Opal.def(self, '$+', TMP_Time_$_6 = function(other) {\n      var self = this;\n\n      \n      if ($truthy($$($nesting, 'Time')['$==='](other))) {\n        self.$raise($$($nesting, 'TypeError'), \"time + time?\")};\n      \n      if (!other.$$is_number) {\n        other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Integer'), \"to_int\");\n      }\n      var result = new Date(self.getTime() + (other * 1000));\n      result.is_utc = self.is_utc;\n      return result;\n    ;\n    }, TMP_Time_$_6.$$arity = 1);\n    \n    Opal.def(self, '$-', TMP_Time_$_7 = function(other) {\n      var self = this;\n\n      \n      if ($truthy($$($nesting, 'Time')['$==='](other))) {\n        return (self.getTime() - other.getTime()) / 1000};\n      \n      if (!other.$$is_number) {\n        other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Integer'), \"to_int\");\n      }\n      var result = new Date(self.getTime() - (other * 1000));\n      result.is_utc = self.is_utc;\n      return result;\n    ;\n    }, TMP_Time_$_7.$$arity = 1);\n    \n    Opal.def(self, '$<=>', TMP_Time_$lt$eq$gt_8 = function(other) {\n      var self = this, r = nil;\n\n      if ($truthy($$($nesting, 'Time')['$==='](other))) {\n        return self.$to_f()['$<=>'](other.$to_f())\n      } else {\n        \n        r = other['$<=>'](self);\n        if ($truthy(r['$nil?']())) {\n          return nil\n        } else if ($truthy($rb_gt(r, 0))) {\n          return -1\n        } else if ($truthy($rb_lt(r, 0))) {\n          return 1\n        } else {\n          return 0\n        };\n      }\n    }, TMP_Time_$lt$eq$gt_8.$$arity = 1);\n    \n    Opal.def(self, '$==', TMP_Time_$eq$eq_9 = function(other) {\n      var $a, self = this;\n\n      return ($truthy($a = $$($nesting, 'Time')['$==='](other)) ? self.$to_f() === other.$to_f() : $a)\n    }, TMP_Time_$eq$eq_9.$$arity = 1);\n    \n    Opal.def(self, '$asctime', TMP_Time_asctime_10 = function $$asctime() {\n      var self = this;\n\n      return self.$strftime(\"%a %b %e %H:%M:%S %Y\")\n    }, TMP_Time_asctime_10.$$arity = 0);\n    Opal.alias(self, \"ctime\", \"asctime\");\n    \n    Opal.def(self, '$day', TMP_Time_day_11 = function $$day() {\n      var self = this;\n\n      return self.is_utc ? self.getUTCDate() : self.getDate();\n    }, TMP_Time_day_11.$$arity = 0);\n    \n    Opal.def(self, '$yday', TMP_Time_yday_12 = function $$yday() {\n      var self = this, start_of_year = nil, start_of_day = nil, one_day = nil;\n\n      \n      start_of_year = $$($nesting, 'Time').$new(self.$year()).$to_i();\n      start_of_day = $$($nesting, 'Time').$new(self.$year(), self.$month(), self.$day()).$to_i();\n      one_day = 86400;\n      return $rb_plus($rb_divide($rb_minus(start_of_day, start_of_year), one_day).$round(), 1);\n    }, TMP_Time_yday_12.$$arity = 0);\n    \n    Opal.def(self, '$isdst', TMP_Time_isdst_13 = function $$isdst() {\n      var self = this;\n\n      \n      var jan = new Date(self.getFullYear(), 0, 1),\n          jul = new Date(self.getFullYear(), 6, 1);\n      return self.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());\n    \n    }, TMP_Time_isdst_13.$$arity = 0);\n    Opal.alias(self, \"dst?\", \"isdst\");\n    \n    Opal.def(self, '$dup', TMP_Time_dup_14 = function $$dup() {\n      var self = this, copy = nil;\n\n      \n      copy = new Date(self.getTime());\n      copy.$copy_instance_variables(self);\n      copy.$initialize_dup(self);\n      return copy;\n    }, TMP_Time_dup_14.$$arity = 0);\n    \n    Opal.def(self, '$eql?', TMP_Time_eql$q_15 = function(other) {\n      var $a, self = this;\n\n      return ($truthy($a = other['$is_a?']($$($nesting, 'Time'))) ? self['$<=>'](other)['$zero?']() : $a)\n    }, TMP_Time_eql$q_15.$$arity = 1);\n    \n    Opal.def(self, '$friday?', TMP_Time_friday$q_16 = function() {\n      var self = this;\n\n      return self.$wday() == 5\n    }, TMP_Time_friday$q_16.$$arity = 0);\n    \n    Opal.def(self, '$hash', TMP_Time_hash_17 = function $$hash() {\n      var self = this;\n\n      return 'Time:' + self.getTime();\n    }, TMP_Time_hash_17.$$arity = 0);\n    \n    Opal.def(self, '$hour', TMP_Time_hour_18 = function $$hour() {\n      var self = this;\n\n      return self.is_utc ? self.getUTCHours() : self.getHours();\n    }, TMP_Time_hour_18.$$arity = 0);\n    \n    Opal.def(self, '$inspect', TMP_Time_inspect_19 = function $$inspect() {\n      var self = this;\n\n      if ($truthy(self['$utc?']())) {\n        return self.$strftime(\"%Y-%m-%d %H:%M:%S UTC\")\n      } else {\n        return self.$strftime(\"%Y-%m-%d %H:%M:%S %z\")\n      }\n    }, TMP_Time_inspect_19.$$arity = 0);\n    Opal.alias(self, \"mday\", \"day\");\n    \n    Opal.def(self, '$min', TMP_Time_min_20 = function $$min() {\n      var self = this;\n\n      return self.is_utc ? self.getUTCMinutes() : self.getMinutes();\n    }, TMP_Time_min_20.$$arity = 0);\n    \n    Opal.def(self, '$mon', TMP_Time_mon_21 = function $$mon() {\n      var self = this;\n\n      return (self.is_utc ? self.getUTCMonth() : self.getMonth()) + 1;\n    }, TMP_Time_mon_21.$$arity = 0);\n    \n    Opal.def(self, '$monday?', TMP_Time_monday$q_22 = function() {\n      var self = this;\n\n      return self.$wday() == 1\n    }, TMP_Time_monday$q_22.$$arity = 0);\n    Opal.alias(self, \"month\", \"mon\");\n    \n    Opal.def(self, '$saturday?', TMP_Time_saturday$q_23 = function() {\n      var self = this;\n\n      return self.$wday() == 6\n    }, TMP_Time_saturday$q_23.$$arity = 0);\n    \n    Opal.def(self, '$sec', TMP_Time_sec_24 = function $$sec() {\n      var self = this;\n\n      return self.is_utc ? self.getUTCSeconds() : self.getSeconds();\n    }, TMP_Time_sec_24.$$arity = 0);\n    \n    Opal.def(self, '$succ', TMP_Time_succ_25 = function $$succ() {\n      var self = this;\n\n      \n      var result = new Date(self.getTime() + 1000);\n      result.is_utc = self.is_utc;\n      return result;\n    \n    }, TMP_Time_succ_25.$$arity = 0);\n    \n    Opal.def(self, '$usec', TMP_Time_usec_26 = function $$usec() {\n      var self = this;\n\n      return self.getMilliseconds() * 1000;\n    }, TMP_Time_usec_26.$$arity = 0);\n    \n    Opal.def(self, '$zone', TMP_Time_zone_27 = function $$zone() {\n      var self = this;\n\n      \n      var string = self.toString(),\n          result;\n\n      if (string.indexOf('(') == -1) {\n        result = string.match(/[A-Z]{3,4}/)[0];\n      }\n      else {\n        result = string.match(/\\((.+)\\)(?:\\s|$)/)[1]\n      }\n\n      if (result == \"GMT\" && /(GMT\\W*\\d{4})/.test(string)) {\n        return RegExp.$1;\n      }\n      else {\n        return result;\n      }\n    \n    }, TMP_Time_zone_27.$$arity = 0);\n    \n    Opal.def(self, '$getgm', TMP_Time_getgm_28 = function $$getgm() {\n      var self = this;\n\n      \n      var result = new Date(self.getTime());\n      result.is_utc = true;\n      return result;\n    \n    }, TMP_Time_getgm_28.$$arity = 0);\n    Opal.alias(self, \"getutc\", \"getgm\");\n    \n    Opal.def(self, '$gmtime', TMP_Time_gmtime_29 = function $$gmtime() {\n      var self = this;\n\n      \n      self.is_utc = true;\n      return self;\n    \n    }, TMP_Time_gmtime_29.$$arity = 0);\n    Opal.alias(self, \"utc\", \"gmtime\");\n    \n    Opal.def(self, '$gmt?', TMP_Time_gmt$q_30 = function() {\n      var self = this;\n\n      return self.is_utc === true;\n    }, TMP_Time_gmt$q_30.$$arity = 0);\n    \n    Opal.def(self, '$gmt_offset', TMP_Time_gmt_offset_31 = function $$gmt_offset() {\n      var self = this;\n\n      return -self.getTimezoneOffset() * 60;\n    }, TMP_Time_gmt_offset_31.$$arity = 0);\n    \n    Opal.def(self, '$strftime', TMP_Time_strftime_32 = function $$strftime(format) {\n      var self = this;\n\n      \n      return format.replace(/%([\\-_#^0]*:{0,2})(\\d+)?([EO]*)(.)/g, function(full, flags, width, _, conv) {\n        var result = \"\",\n            zero   = flags.indexOf('0') !== -1,\n            pad    = flags.indexOf('-') === -1,\n            blank  = flags.indexOf('_') !== -1,\n            upcase = flags.indexOf('^') !== -1,\n            invert = flags.indexOf('#') !== -1,\n            colons = (flags.match(':') || []).length;\n\n        width = parseInt(width, 10);\n\n        if (zero && blank) {\n          if (flags.indexOf('0') < flags.indexOf('_')) {\n            zero = false;\n          }\n          else {\n            blank = false;\n          }\n        }\n\n        switch (conv) {\n          case 'Y':\n            result += self.$year();\n            break;\n\n          case 'C':\n            zero    = !blank;\n            result += Math.round(self.$year() / 100);\n            break;\n\n          case 'y':\n            zero    = !blank;\n            result += (self.$year() % 100);\n            break;\n\n          case 'm':\n            zero    = !blank;\n            result += self.$mon();\n            break;\n\n          case 'B':\n            result += long_months[self.$mon() - 1];\n            break;\n\n          case 'b':\n          case 'h':\n            blank   = !zero;\n            result += short_months[self.$mon() - 1];\n            break;\n\n          case 'd':\n            zero    = !blank\n            result += self.$day();\n            break;\n\n          case 'e':\n            blank   = !zero\n            result += self.$day();\n            break;\n\n          case 'j':\n            result += self.$yday();\n            break;\n\n          case 'H':\n            zero    = !blank;\n            result += self.$hour();\n            break;\n\n          case 'k':\n            blank   = !zero;\n            result += self.$hour();\n            break;\n\n          case 'I':\n            zero    = !blank;\n            result += (self.$hour() % 12 || 12);\n            break;\n\n          case 'l':\n            blank   = !zero;\n            result += (self.$hour() % 12 || 12);\n            break;\n\n          case 'P':\n            result += (self.$hour() >= 12 ? \"pm\" : \"am\");\n            break;\n\n          case 'p':\n            result += (self.$hour() >= 12 ? \"PM\" : \"AM\");\n            break;\n\n          case 'M':\n            zero    = !blank;\n            result += self.$min();\n            break;\n\n          case 'S':\n            zero    = !blank;\n            result += self.$sec()\n            break;\n\n          case 'L':\n            zero    = !blank;\n            width   = isNaN(width) ? 3 : width;\n            result += self.getMilliseconds();\n            break;\n\n          case 'N':\n            width   = isNaN(width) ? 9 : width;\n            result += (self.getMilliseconds().toString()).$rjust(3, \"0\");\n            result  = (result).$ljust(width, \"0\");\n            break;\n\n          case 'z':\n            var offset  = self.getTimezoneOffset(),\n                hours   = Math.floor(Math.abs(offset) / 60),\n                minutes = Math.abs(offset) % 60;\n\n            result += offset < 0 ? \"+\" : \"-\";\n            result += hours < 10 ? \"0\" : \"\";\n            result += hours;\n\n            if (colons > 0) {\n              result += \":\";\n            }\n\n            result += minutes < 10 ? \"0\" : \"\";\n            result += minutes;\n\n            if (colons > 1) {\n              result += \":00\";\n            }\n\n            break;\n\n          case 'Z':\n            result += self.$zone();\n            break;\n\n          case 'A':\n            result += days_of_week[self.$wday()];\n            break;\n\n          case 'a':\n            result += short_days[self.$wday()];\n            break;\n\n          case 'u':\n            result += (self.$wday() + 1);\n            break;\n\n          case 'w':\n            result += self.$wday();\n            break;\n\n          case 'V':\n            result += self.$cweek_cyear()['$[]'](0).$to_s().$rjust(2, \"0\");\n            break;\n\n          case 'G':\n            result += self.$cweek_cyear()['$[]'](1);\n            break;\n\n          case 'g':\n            result += self.$cweek_cyear()['$[]'](1)['$[]']($range(-2, -1, false));\n            break;\n\n          case 's':\n            result += self.$to_i();\n            break;\n\n          case 'n':\n            result += \"\\n\";\n            break;\n\n          case 't':\n            result += \"\\t\";\n            break;\n\n          case '%':\n            result += \"%\";\n            break;\n\n          case 'c':\n            result += self.$strftime(\"%a %b %e %T %Y\");\n            break;\n\n          case 'D':\n          case 'x':\n            result += self.$strftime(\"%m/%d/%y\");\n            break;\n\n          case 'F':\n            result += self.$strftime(\"%Y-%m-%d\");\n            break;\n\n          case 'v':\n            result += self.$strftime(\"%e-%^b-%4Y\");\n            break;\n\n          case 'r':\n            result += self.$strftime(\"%I:%M:%S %p\");\n            break;\n\n          case 'R':\n            result += self.$strftime(\"%H:%M\");\n            break;\n\n          case 'T':\n          case 'X':\n            result += self.$strftime(\"%H:%M:%S\");\n            break;\n\n          default:\n            return full;\n        }\n\n        if (upcase) {\n          result = result.toUpperCase();\n        }\n\n        if (invert) {\n          result = result.replace(/[A-Z]/, function(c) { c.toLowerCase() }).\n                          replace(/[a-z]/, function(c) { c.toUpperCase() });\n        }\n\n        if (pad && (zero || blank)) {\n          result = (result).$rjust(isNaN(width) ? 2 : width, blank ? \" \" : \"0\");\n        }\n\n        return result;\n      });\n    \n    }, TMP_Time_strftime_32.$$arity = 1);\n    \n    Opal.def(self, '$sunday?', TMP_Time_sunday$q_33 = function() {\n      var self = this;\n\n      return self.$wday() == 0\n    }, TMP_Time_sunday$q_33.$$arity = 0);\n    \n    Opal.def(self, '$thursday?', TMP_Time_thursday$q_34 = function() {\n      var self = this;\n\n      return self.$wday() == 4\n    }, TMP_Time_thursday$q_34.$$arity = 0);\n    \n    Opal.def(self, '$to_a', TMP_Time_to_a_35 = function $$to_a() {\n      var self = this;\n\n      return [self.$sec(), self.$min(), self.$hour(), self.$day(), self.$month(), self.$year(), self.$wday(), self.$yday(), self.$isdst(), self.$zone()]\n    }, TMP_Time_to_a_35.$$arity = 0);\n    \n    Opal.def(self, '$to_f', TMP_Time_to_f_36 = function $$to_f() {\n      var self = this;\n\n      return self.getTime() / 1000;\n    }, TMP_Time_to_f_36.$$arity = 0);\n    \n    Opal.def(self, '$to_i', TMP_Time_to_i_37 = function $$to_i() {\n      var self = this;\n\n      return parseInt(self.getTime() / 1000, 10);\n    }, TMP_Time_to_i_37.$$arity = 0);\n    Opal.alias(self, \"to_s\", \"inspect\");\n    \n    Opal.def(self, '$tuesday?', TMP_Time_tuesday$q_38 = function() {\n      var self = this;\n\n      return self.$wday() == 2\n    }, TMP_Time_tuesday$q_38.$$arity = 0);\n    Opal.alias(self, \"tv_sec\", \"to_i\");\n    Opal.alias(self, \"tv_usec\", \"usec\");\n    Opal.alias(self, \"utc?\", \"gmt?\");\n    Opal.alias(self, \"gmtoff\", \"gmt_offset\");\n    Opal.alias(self, \"utc_offset\", \"gmt_offset\");\n    \n    Opal.def(self, '$wday', TMP_Time_wday_39 = function $$wday() {\n      var self = this;\n\n      return self.is_utc ? self.getUTCDay() : self.getDay();\n    }, TMP_Time_wday_39.$$arity = 0);\n    \n    Opal.def(self, '$wednesday?', TMP_Time_wednesday$q_40 = function() {\n      var self = this;\n\n      return self.$wday() == 3\n    }, TMP_Time_wednesday$q_40.$$arity = 0);\n    \n    Opal.def(self, '$year', TMP_Time_year_41 = function $$year() {\n      var self = this;\n\n      return self.is_utc ? self.getUTCFullYear() : self.getFullYear();\n    }, TMP_Time_year_41.$$arity = 0);\n    return (Opal.def(self, '$cweek_cyear', TMP_Time_cweek_cyear_42 = function $$cweek_cyear() {\n      var $a, self = this, jan01 = nil, jan01_wday = nil, first_monday = nil, year = nil, offset = nil, week = nil, dec31 = nil, dec31_wday = nil;\n\n      \n      jan01 = $$($nesting, 'Time').$new(self.$year(), 1, 1);\n      jan01_wday = jan01.$wday();\n      first_monday = 0;\n      year = self.$year();\n      if ($truthy(($truthy($a = $rb_le(jan01_wday, 4)) ? jan01_wday['$!='](0) : $a))) {\n        offset = $rb_minus(jan01_wday, 1)\n      } else {\n        \n        offset = $rb_minus($rb_minus(jan01_wday, 7), 1);\n        if (offset['$=='](-8)) {\n          offset = -1};\n      };\n      week = $rb_divide($rb_plus(self.$yday(), offset), 7.0).$ceil();\n      if ($truthy($rb_le(week, 0))) {\n        return $$($nesting, 'Time').$new($rb_minus(self.$year(), 1), 12, 31).$cweek_cyear()\n      } else if (week['$=='](53)) {\n        \n        dec31 = $$($nesting, 'Time').$new(self.$year(), 12, 31);\n        dec31_wday = dec31.$wday();\n        if ($truthy(($truthy($a = $rb_le(dec31_wday, 3)) ? dec31_wday['$!='](0) : $a))) {\n          \n          week = 1;\n          year = $rb_plus(year, 1);};};\n      return [week, year];\n    }, TMP_Time_cweek_cyear_42.$$arity = 0), nil) && 'cweek_cyear';\n  })($nesting[0], Date, $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/struct\"] = function(Opal) {\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$require', '$include', '$const_name!', '$unshift', '$map', '$coerce_to!', '$new', '$each', '$define_struct_attribute', '$allocate', '$initialize', '$alias_method', '$module_eval', '$to_proc', '$const_set', '$==', '$raise', '$<<', '$members', '$define_method', '$instance_eval', '$class', '$last', '$>', '$length', '$-', '$keys', '$any?', '$join', '$[]', '$[]=', '$each_with_index', '$hash', '$===', '$<', '$-@', '$size', '$>=', '$include?', '$to_sym', '$instance_of?', '$__id__', '$eql?', '$enum_for', '$name', '$+', '$each_pair', '$inspect', '$each_with_object', '$flatten', '$to_a', '$respond_to?', '$dig']);\n  \n  self.$require(\"corelib/enumerable\");\n  return (function($base, $super, $parent_nesting) {\n    function $Struct(){};\n    var self = $Struct = $klass($base, $super, 'Struct', $Struct);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Struct_new_1, TMP_Struct_define_struct_attribute_8, TMP_Struct_members_9, TMP_Struct_inherited_11, TMP_Struct_initialize_14, TMP_Struct_members_15, TMP_Struct_hash_16, TMP_Struct_$$_17, TMP_Struct_$$$eq_18, TMP_Struct_$eq$eq_19, TMP_Struct_eql$q_20, TMP_Struct_each_21, TMP_Struct_each_pair_24, TMP_Struct_length_27, TMP_Struct_to_a_29, TMP_Struct_inspect_31, TMP_Struct_to_h_33, TMP_Struct_values_at_35, TMP_Struct_dig_36;\n\n    \n    self.$include($$($nesting, 'Enumerable'));\n    Opal.defs(self, '$new', TMP_Struct_new_1 = function(const_name, $a_rest, $kwargs) {\n      var TMP_2, TMP_3, self = this, $post_args, keyword_init, args, $iter = TMP_Struct_new_1.$$p, block = $iter || nil, klass = nil;\n\n      $post_args = Opal.slice.call(arguments, 1, arguments.length);\n      $kwargs = Opal.extract_kwargs($post_args);\n      if ($kwargs == null || !$kwargs.$$is_hash) {\n        if ($kwargs == null) {\n          $kwargs = $hash2([], {});\n        } else {\n          throw Opal.ArgumentError.$new('expected kwargs');\n        }\n      }\n      keyword_init = $kwargs.$$smap[\"keyword_init\"];\n      if (keyword_init == null) {\n        keyword_init = false\n      }\n      if (0 < $post_args.length) {\n        args = $post_args.splice(0, $post_args.length - 0);\n      } else {\n        args = [];\n      }\n      if ($iter) TMP_Struct_new_1.$$p = null;\n      \n      if ($truthy(const_name)) {\n        \n        try {\n          const_name = $$($nesting, 'Opal')['$const_name!'](const_name)\n        } catch ($err) {\n          if (Opal.rescue($err, [$$($nesting, 'TypeError'), $$($nesting, 'NameError')])) {\n            try {\n              \n              args.$unshift(const_name);\n              const_name = nil;\n            } finally { Opal.pop_exception() }\n          } else { throw $err; }\n        };};\n      $send(args, 'map', [], (TMP_2 = function(arg){var self = TMP_2.$$s || this;\nif (arg == null) arg = nil;\n      return $$($nesting, 'Opal')['$coerce_to!'](arg, $$($nesting, 'String'), \"to_str\")}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2));\n      klass = $send($$($nesting, 'Class'), 'new', [self], (TMP_3 = function(){var self = TMP_3.$$s || this, TMP_4;\n\n      \n        $send(args, 'each', [], (TMP_4 = function(arg){var self = TMP_4.$$s || this;\nif (arg == null) arg = nil;\n        return self.$define_struct_attribute(arg)}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4));\n        return (function(self, $parent_nesting) {\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_new_5;\n\n          \n          \n          Opal.def(self, '$new', TMP_new_5 = function($a_rest) {\n            var self = this, args, instance = nil;\n\n            var $args_len = arguments.length, $rest_len = $args_len - 0;\n            if ($rest_len < 0) { $rest_len = 0; }\n            args = new Array($rest_len);\n            for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n              args[$arg_idx - 0] = arguments[$arg_idx];\n            }\n            \n            instance = self.$allocate();\n            instance.$$data = {};\n            $send(instance, 'initialize', Opal.to_a(args));\n            return instance;\n          }, TMP_new_5.$$arity = -1);\n          return self.$alias_method(\"[]\", \"new\");\n        })(Opal.get_singleton_class(self), $nesting);}, TMP_3.$$s = self, TMP_3.$$arity = 0, TMP_3));\n      if ($truthy(block)) {\n        $send(klass, 'module_eval', [], block.$to_proc())};\n      klass.$$keyword_init = keyword_init;\n      if ($truthy(const_name)) {\n        $$($nesting, 'Struct').$const_set(const_name, klass)};\n      return klass;\n    }, TMP_Struct_new_1.$$arity = -2);\n    Opal.defs(self, '$define_struct_attribute', TMP_Struct_define_struct_attribute_8 = function $$define_struct_attribute(name) {\n      var TMP_6, TMP_7, self = this;\n\n      \n      if (self['$==']($$($nesting, 'Struct'))) {\n        self.$raise($$($nesting, 'ArgumentError'), \"you cannot define attributes to the Struct class\")};\n      self.$members()['$<<'](name);\n      $send(self, 'define_method', [name], (TMP_6 = function(){var self = TMP_6.$$s || this;\n\n      return self.$$data[name];}, TMP_6.$$s = self, TMP_6.$$arity = 0, TMP_6));\n      return $send(self, 'define_method', [\"\" + (name) + \"=\"], (TMP_7 = function(value){var self = TMP_7.$$s || this;\nif (value == null) value = nil;\n      return self.$$data[name] = value;}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7));\n    }, TMP_Struct_define_struct_attribute_8.$$arity = 1);\n    Opal.defs(self, '$members', TMP_Struct_members_9 = function $$members() {\n      var $a, self = this;\n      if (self.members == null) self.members = nil;\n\n      \n      if (self['$==']($$($nesting, 'Struct'))) {\n        self.$raise($$($nesting, 'ArgumentError'), \"the Struct class has no members\")};\n      return (self.members = ($truthy($a = self.members) ? $a : []));\n    }, TMP_Struct_members_9.$$arity = 0);\n    Opal.defs(self, '$inherited', TMP_Struct_inherited_11 = function $$inherited(klass) {\n      var TMP_10, self = this, members = nil;\n      if (self.members == null) self.members = nil;\n\n      \n      members = self.members;\n      return $send(klass, 'instance_eval', [], (TMP_10 = function(){var self = TMP_10.$$s || this;\n\n      return (self.members = members)}, TMP_10.$$s = self, TMP_10.$$arity = 0, TMP_10));\n    }, TMP_Struct_inherited_11.$$arity = 1);\n    \n    Opal.def(self, '$initialize', TMP_Struct_initialize_14 = function $$initialize($a_rest) {\n      var $b, TMP_12, TMP_13, self = this, args, kwargs = nil, extra = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      if ($truthy(self.$class().$$keyword_init)) {\n        \n        kwargs = ($truthy($b = args.$last()) ? $b : $hash2([], {}));\n        if ($truthy(($truthy($b = $rb_gt(args.$length(), 1)) ? $b : (args.length === 1 && !kwargs.$$is_hash)))) {\n          self.$raise($$($nesting, 'ArgumentError'), \"\" + \"wrong number of arguments (given \" + (args.$length()) + \", expected 0)\")};\n        extra = $rb_minus(kwargs.$keys(), self.$class().$members());\n        if ($truthy(extra['$any?']())) {\n          self.$raise($$($nesting, 'ArgumentError'), \"\" + \"unknown keywords: \" + (extra.$join(\", \")))};\n        return $send(self.$class().$members(), 'each', [], (TMP_12 = function(name){var self = TMP_12.$$s || this, $writer = nil;\nif (name == null) name = nil;\n        \n          $writer = [name, kwargs['$[]'](name)];\n          $send(self, '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12));\n      } else {\n        \n        if ($truthy($rb_gt(args.$length(), self.$class().$members().$length()))) {\n          self.$raise($$($nesting, 'ArgumentError'), \"struct size differs\")};\n        return $send(self.$class().$members(), 'each_with_index', [], (TMP_13 = function(name, index){var self = TMP_13.$$s || this, $writer = nil;\nif (name == null) name = nil;if (index == null) index = nil;\n        \n          $writer = [name, args['$[]'](index)];\n          $send(self, '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_13.$$s = self, TMP_13.$$arity = 2, TMP_13));\n      }\n    }, TMP_Struct_initialize_14.$$arity = -1);\n    \n    Opal.def(self, '$members', TMP_Struct_members_15 = function $$members() {\n      var self = this;\n\n      return self.$class().$members()\n    }, TMP_Struct_members_15.$$arity = 0);\n    \n    Opal.def(self, '$hash', TMP_Struct_hash_16 = function $$hash() {\n      var self = this;\n\n      return $$($nesting, 'Hash').$new(self.$$data).$hash()\n    }, TMP_Struct_hash_16.$$arity = 0);\n    \n    Opal.def(self, '$[]', TMP_Struct_$$_17 = function(name) {\n      var self = this;\n\n      \n      if ($truthy($$($nesting, 'Integer')['$==='](name))) {\n        \n        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {\n          self.$raise($$($nesting, 'IndexError'), \"\" + \"offset \" + (name) + \" too small for struct(size:\" + (self.$class().$members().$size()) + \")\")};\n        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {\n          self.$raise($$($nesting, 'IndexError'), \"\" + \"offset \" + (name) + \" too large for struct(size:\" + (self.$class().$members().$size()) + \")\")};\n        name = self.$class().$members()['$[]'](name);\n      } else if ($truthy($$($nesting, 'String')['$==='](name))) {\n        \n        if(!self.$$data.hasOwnProperty(name)) {\n          self.$raise($$($nesting, 'NameError').$new(\"\" + \"no member '\" + (name) + \"' in struct\", name))\n        }\n      \n      } else {\n        self.$raise($$($nesting, 'TypeError'), \"\" + \"no implicit conversion of \" + (name.$class()) + \" into Integer\")\n      };\n      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), \"to_str\");\n      return self.$$data[name];;\n    }, TMP_Struct_$$_17.$$arity = 1);\n    \n    Opal.def(self, '$[]=', TMP_Struct_$$$eq_18 = function(name, value) {\n      var self = this;\n\n      \n      if ($truthy($$($nesting, 'Integer')['$==='](name))) {\n        \n        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {\n          self.$raise($$($nesting, 'IndexError'), \"\" + \"offset \" + (name) + \" too small for struct(size:\" + (self.$class().$members().$size()) + \")\")};\n        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {\n          self.$raise($$($nesting, 'IndexError'), \"\" + \"offset \" + (name) + \" too large for struct(size:\" + (self.$class().$members().$size()) + \")\")};\n        name = self.$class().$members()['$[]'](name);\n      } else if ($truthy($$($nesting, 'String')['$==='](name))) {\n        if ($truthy(self.$class().$members()['$include?'](name.$to_sym()))) {\n        } else {\n          self.$raise($$($nesting, 'NameError').$new(\"\" + \"no member '\" + (name) + \"' in struct\", name))\n        }\n      } else {\n        self.$raise($$($nesting, 'TypeError'), \"\" + \"no implicit conversion of \" + (name.$class()) + \" into Integer\")\n      };\n      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), \"to_str\");\n      return self.$$data[name] = value;;\n    }, TMP_Struct_$$$eq_18.$$arity = 2);\n    \n    Opal.def(self, '$==', TMP_Struct_$eq$eq_19 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(other['$instance_of?'](self.$class()))) {\n      } else {\n        return false\n      };\n      \n      var recursed1 = {}, recursed2 = {};\n\n      function _eqeq(struct, other) {\n        var key, a, b;\n\n        recursed1[(struct).$__id__()] = true;\n        recursed2[(other).$__id__()] = true;\n\n        for (key in struct.$$data) {\n          a = struct.$$data[key];\n          b = other.$$data[key];\n\n          if ($$($nesting, 'Struct')['$==='](a)) {\n            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {\n              if (!_eqeq(a, b)) {\n                return false;\n              }\n            }\n          } else {\n            if (!(a)['$=='](b)) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n      }\n\n      return _eqeq(self, other);\n    ;\n    }, TMP_Struct_$eq$eq_19.$$arity = 1);\n    \n    Opal.def(self, '$eql?', TMP_Struct_eql$q_20 = function(other) {\n      var self = this;\n\n      \n      if ($truthy(other['$instance_of?'](self.$class()))) {\n      } else {\n        return false\n      };\n      \n      var recursed1 = {}, recursed2 = {};\n\n      function _eqeq(struct, other) {\n        var key, a, b;\n\n        recursed1[(struct).$__id__()] = true;\n        recursed2[(other).$__id__()] = true;\n\n        for (key in struct.$$data) {\n          a = struct.$$data[key];\n          b = other.$$data[key];\n\n          if ($$($nesting, 'Struct')['$==='](a)) {\n            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {\n              if (!_eqeq(a, b)) {\n                return false;\n              }\n            }\n          } else {\n            if (!(a)['$eql?'](b)) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n      }\n\n      return _eqeq(self, other);\n    ;\n    }, TMP_Struct_eql$q_20.$$arity = 1);\n    \n    Opal.def(self, '$each', TMP_Struct_each_21 = function $$each() {\n      var TMP_22, TMP_23, self = this, $iter = TMP_Struct_each_21.$$p, $yield = $iter || nil;\n\n      if ($iter) TMP_Struct_each_21.$$p = null;\n      \n      if (($yield !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"each\"], (TMP_22 = function(){var self = TMP_22.$$s || this;\n\n        return self.$size()}, TMP_22.$$s = self, TMP_22.$$arity = 0, TMP_22))\n      };\n      $send(self.$class().$members(), 'each', [], (TMP_23 = function(name){var self = TMP_23.$$s || this;\nif (name == null) name = nil;\n      return Opal.yield1($yield, self['$[]'](name));}, TMP_23.$$s = self, TMP_23.$$arity = 1, TMP_23));\n      return self;\n    }, TMP_Struct_each_21.$$arity = 0);\n    \n    Opal.def(self, '$each_pair', TMP_Struct_each_pair_24 = function $$each_pair() {\n      var TMP_25, TMP_26, self = this, $iter = TMP_Struct_each_pair_24.$$p, $yield = $iter || nil;\n\n      if ($iter) TMP_Struct_each_pair_24.$$p = null;\n      \n      if (($yield !== nil)) {\n      } else {\n        return $send(self, 'enum_for', [\"each_pair\"], (TMP_25 = function(){var self = TMP_25.$$s || this;\n\n        return self.$size()}, TMP_25.$$s = self, TMP_25.$$arity = 0, TMP_25))\n      };\n      $send(self.$class().$members(), 'each', [], (TMP_26 = function(name){var self = TMP_26.$$s || this;\nif (name == null) name = nil;\n      return Opal.yield1($yield, [name, self['$[]'](name)]);}, TMP_26.$$s = self, TMP_26.$$arity = 1, TMP_26));\n      return self;\n    }, TMP_Struct_each_pair_24.$$arity = 0);\n    \n    Opal.def(self, '$length', TMP_Struct_length_27 = function $$length() {\n      var self = this;\n\n      return self.$class().$members().$length()\n    }, TMP_Struct_length_27.$$arity = 0);\n    Opal.alias(self, \"size\", \"length\");\n    \n    Opal.def(self, '$to_a', TMP_Struct_to_a_29 = function $$to_a() {\n      var TMP_28, self = this;\n\n      return $send(self.$class().$members(), 'map', [], (TMP_28 = function(name){var self = TMP_28.$$s || this;\nif (name == null) name = nil;\n      return self['$[]'](name)}, TMP_28.$$s = self, TMP_28.$$arity = 1, TMP_28))\n    }, TMP_Struct_to_a_29.$$arity = 0);\n    Opal.alias(self, \"values\", \"to_a\");\n    \n    Opal.def(self, '$inspect', TMP_Struct_inspect_31 = function $$inspect() {\n      var $a, TMP_30, self = this, result = nil;\n\n      \n      result = \"#<struct \";\n      if ($truthy(($truthy($a = $$($nesting, 'Struct')['$==='](self)) ? self.$class().$name() : $a))) {\n        result = $rb_plus(result, \"\" + (self.$class()) + \" \")};\n      result = $rb_plus(result, $send(self.$each_pair(), 'map', [], (TMP_30 = function(name, value){var self = TMP_30.$$s || this;\nif (name == null) name = nil;if (value == null) value = nil;\n      return \"\" + (name) + \"=\" + (value.$inspect())}, TMP_30.$$s = self, TMP_30.$$arity = 2, TMP_30)).$join(\", \"));\n      result = $rb_plus(result, \">\");\n      return result;\n    }, TMP_Struct_inspect_31.$$arity = 0);\n    Opal.alias(self, \"to_s\", \"inspect\");\n    \n    Opal.def(self, '$to_h', TMP_Struct_to_h_33 = function $$to_h() {\n      var TMP_32, self = this;\n\n      return $send(self.$class().$members(), 'each_with_object', [$hash2([], {})], (TMP_32 = function(name, h){var self = TMP_32.$$s || this, $writer = nil;\nif (name == null) name = nil;if (h == null) h = nil;\n      \n        $writer = [name, self['$[]'](name)];\n        $send(h, '[]=', Opal.to_a($writer));\n        return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_32.$$s = self, TMP_32.$$arity = 2, TMP_32))\n    }, TMP_Struct_to_h_33.$$arity = 0);\n    \n    Opal.def(self, '$values_at', TMP_Struct_values_at_35 = function $$values_at($a_rest) {\n      var TMP_34, self = this, args;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      args = $send(args, 'map', [], (TMP_34 = function(arg){var self = TMP_34.$$s || this;\nif (arg == null) arg = nil;\n      return arg.$$is_range ? arg.$to_a() : arg}, TMP_34.$$s = self, TMP_34.$$arity = 1, TMP_34)).$flatten();\n      \n      var result = [];\n      for (var i = 0, len = args.length; i < len; i++) {\n        if (!args[i].$$is_number) {\n          self.$raise($$($nesting, 'TypeError'), \"\" + \"no implicit conversion of \" + ((args[i]).$class()) + \" into Integer\")\n        }\n        result.push(self['$[]'](args[i]));\n      }\n      return result;\n    ;\n    }, TMP_Struct_values_at_35.$$arity = -1);\n    return (Opal.def(self, '$dig', TMP_Struct_dig_36 = function $$dig(key, $a_rest) {\n      var self = this, keys, item = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      keys = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        keys[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      \n      item = (function() {if ($truthy(key.$$is_string && self.$$data.hasOwnProperty(key))) {\n        return self.$$data[key] || nil;\n      } else {\n        return nil\n      }; return nil; })();\n      \n      if (item === nil || keys.length === 0) {\n        return item;\n      }\n    ;\n      if ($truthy(item['$respond_to?'](\"dig\"))) {\n      } else {\n        self.$raise($$($nesting, 'TypeError'), \"\" + (item.$class()) + \" does not have #dig method\")\n      };\n      return $send(item, 'dig', Opal.to_a(keys));\n    }, TMP_Struct_dig_36.$$arity = -2), nil) && 'dig';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/io\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $module = Opal.module, $send = Opal.send, $gvars = Opal.gvars, $truthy = Opal.truthy, $writer = nil;\n\n  Opal.add_stubs(['$attr_accessor', '$size', '$write', '$join', '$map', '$String', '$empty?', '$concat', '$chomp', '$getbyte', '$getc', '$raise', '$new', '$write_proc=', '$-', '$extend']);\n  \n  (function($base, $super, $parent_nesting) {\n    function $IO(){};\n    var self = $IO = $klass($base, $super, 'IO', $IO);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_IO_tty$q_1, TMP_IO_closed$q_2, TMP_IO_write_3, TMP_IO_flush_4;\n\n    def.tty = def.closed = nil;\n    \n    Opal.const_set($nesting[0], 'SEEK_SET', 0);\n    Opal.const_set($nesting[0], 'SEEK_CUR', 1);\n    Opal.const_set($nesting[0], 'SEEK_END', 2);\n    \n    Opal.def(self, '$tty?', TMP_IO_tty$q_1 = function() {\n      var self = this;\n\n      return self.tty\n    }, TMP_IO_tty$q_1.$$arity = 0);\n    \n    Opal.def(self, '$closed?', TMP_IO_closed$q_2 = function() {\n      var self = this;\n\n      return self.closed\n    }, TMP_IO_closed$q_2.$$arity = 0);\n    self.$attr_accessor(\"write_proc\");\n    \n    Opal.def(self, '$write', TMP_IO_write_3 = function $$write(string) {\n      var self = this;\n\n      \n      self.write_proc(string);\n      return string.$size();\n    }, TMP_IO_write_3.$$arity = 1);\n    self.$attr_accessor(\"sync\", \"tty\");\n    \n    Opal.def(self, '$flush', TMP_IO_flush_4 = function $$flush() {\n      var self = this;\n\n      return nil\n    }, TMP_IO_flush_4.$$arity = 0);\n    (function($base, $parent_nesting) {\n      var $Writable, self = $Writable = $module($base, 'Writable');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Writable_$lt$lt_5, TMP_Writable_print_7, TMP_Writable_puts_9;\n\n      \n      \n      Opal.def(self, '$<<', TMP_Writable_$lt$lt_5 = function(string) {\n        var self = this;\n\n        \n        self.$write(string);\n        return self;\n      }, TMP_Writable_$lt$lt_5.$$arity = 1);\n      \n      Opal.def(self, '$print', TMP_Writable_print_7 = function $$print($a_rest) {\n        var TMP_6, self = this, args;\n        if ($gvars[\",\"] == null) $gvars[\",\"] = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n        \n        self.$write($send(args, 'map', [], (TMP_6 = function(arg){var self = TMP_6.$$s || this;\nif (arg == null) arg = nil;\n        return self.$String(arg)}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6)).$join($gvars[\",\"]));\n        return nil;\n      }, TMP_Writable_print_7.$$arity = -1);\n      \n      Opal.def(self, '$puts', TMP_Writable_puts_9 = function $$puts($a_rest) {\n        var TMP_8, self = this, args, newline = nil;\n        if ($gvars[\"/\"] == null) $gvars[\"/\"] = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        args = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          args[$arg_idx - 0] = arguments[$arg_idx];\n        }\n        \n        newline = $gvars[\"/\"];\n        if ($truthy(args['$empty?']())) {\n          self.$write($gvars[\"/\"])\n        } else {\n          self.$write($send(args, 'map', [], (TMP_8 = function(arg){var self = TMP_8.$$s || this;\nif (arg == null) arg = nil;\n          return self.$String(arg).$chomp()}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8)).$concat([nil]).$join(newline))\n        };\n        return nil;\n      }, TMP_Writable_puts_9.$$arity = -1);\n    })($nesting[0], $nesting);\n    return (function($base, $parent_nesting) {\n      var $Readable, self = $Readable = $module($base, 'Readable');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Readable_readbyte_10, TMP_Readable_readchar_11, TMP_Readable_readline_12, TMP_Readable_readpartial_13;\n\n      \n      \n      Opal.def(self, '$readbyte', TMP_Readable_readbyte_10 = function $$readbyte() {\n        var self = this;\n\n        return self.$getbyte()\n      }, TMP_Readable_readbyte_10.$$arity = 0);\n      \n      Opal.def(self, '$readchar', TMP_Readable_readchar_11 = function $$readchar() {\n        var self = this;\n\n        return self.$getc()\n      }, TMP_Readable_readchar_11.$$arity = 0);\n      \n      Opal.def(self, '$readline', TMP_Readable_readline_12 = function $$readline(sep) {\n        var self = this;\n        if ($gvars[\"/\"] == null) $gvars[\"/\"] = nil;\n\n        if (sep == null) {\n          sep = $gvars[\"/\"];\n        }\n        return self.$raise($$($nesting, 'NotImplementedError'))\n      }, TMP_Readable_readline_12.$$arity = -1);\n      \n      Opal.def(self, '$readpartial', TMP_Readable_readpartial_13 = function $$readpartial(integer, outbuf) {\n        var self = this;\n\n        if (outbuf == null) {\n          outbuf = nil;\n        }\n        return self.$raise($$($nesting, 'NotImplementedError'))\n      }, TMP_Readable_readpartial_13.$$arity = -2);\n    })($nesting[0], $nesting);\n  })($nesting[0], null, $nesting);\n  Opal.const_set($nesting[0], 'STDERR', ($gvars.stderr = $$($nesting, 'IO').$new()));\n  Opal.const_set($nesting[0], 'STDIN', ($gvars.stdin = $$($nesting, 'IO').$new()));\n  Opal.const_set($nesting[0], 'STDOUT', ($gvars.stdout = $$($nesting, 'IO').$new()));\n  var console = Opal.global.console;\n  \n  $writer = [typeof(process) === 'object' && typeof(process.stdout) === 'object' ? function(s){process.stdout.write(s)} : function(s){console.log(s)}];\n  $send($$($nesting, 'STDOUT'), 'write_proc=', Opal.to_a($writer));\n  $writer[$rb_minus($writer[\"length\"], 1)];;\n  \n  $writer = [typeof(process) === 'object' && typeof(process.stderr) === 'object' ? function(s){process.stderr.write(s)} : function(s){console.warn(s)}];\n  $send($$($nesting, 'STDERR'), 'write_proc=', Opal.to_a($writer));\n  $writer[$rb_minus($writer[\"length\"], 1)];;\n  $$($nesting, 'STDOUT').$extend($$$($$($nesting, 'IO'), 'Writable'));\n  return $$($nesting, 'STDERR').$extend($$$($$($nesting, 'IO'), 'Writable'));\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/main\"] = function(Opal) {\n  var TMP_to_s_1, TMP_include_2, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;\n\n  Opal.add_stubs(['$include']);\n  \n  Opal.defs(self, '$to_s', TMP_to_s_1 = function $$to_s() {\n    var self = this;\n\n    return \"main\"\n  }, TMP_to_s_1.$$arity = 0);\n  return (Opal.defs(self, '$include', TMP_include_2 = function $$include(mod) {\n    var self = this;\n\n    return $$($nesting, 'Object').$include(mod)\n  }, TMP_include_2.$$arity = 1), nil) && 'include';\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/dir\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$[]']);\n  return (function($base, $super, $parent_nesting) {\n    function $Dir(){};\n    var self = $Dir = $klass($base, $super, 'Dir', $Dir);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    return (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_chdir_1, TMP_pwd_2, TMP_home_3;\n\n      \n      \n      Opal.def(self, '$chdir', TMP_chdir_1 = function $$chdir(dir) {\n        var self = this, $iter = TMP_chdir_1.$$p, $yield = $iter || nil, prev_cwd = nil;\n\n        if ($iter) TMP_chdir_1.$$p = null;\n        return (function() { try {\n        \n        prev_cwd = Opal.current_dir;\n        Opal.current_dir = dir;\n        return Opal.yieldX($yield, []);;\n        } finally {\n          Opal.current_dir = prev_cwd\n        }; })()\n      }, TMP_chdir_1.$$arity = 1);\n      \n      Opal.def(self, '$pwd', TMP_pwd_2 = function $$pwd() {\n        var self = this;\n\n        return Opal.current_dir || '.';\n      }, TMP_pwd_2.$$arity = 0);\n      Opal.alias(self, \"getwd\", \"pwd\");\n      return (Opal.def(self, '$home', TMP_home_3 = function $$home() {\n        var $a, self = this;\n\n        return ($truthy($a = $$($nesting, 'ENV')['$[]'](\"HOME\")) ? $a : \".\")\n      }, TMP_home_3.$$arity = 0), nil) && 'home';\n    })(Opal.get_singleton_class(self), $nesting)\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/file\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $send = Opal.send;\n\n  Opal.add_stubs(['$home', '$raise', '$start_with?', '$+', '$sub', '$pwd', '$split', '$unshift', '$join', '$respond_to?', '$coerce_to!', '$basename', '$empty?', '$rindex', '$[]', '$nil?', '$==', '$-', '$length', '$gsub', '$find', '$=~', '$map', '$each_with_index', '$flatten', '$reject', '$to_proc', '$end_with?']);\n  return (function($base, $super, $parent_nesting) {\n    function $File(){};\n    var self = $File = $klass($base, $super, 'File', $File);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), windows_root_rx = nil;\n\n    \n    Opal.const_set($nesting[0], 'Separator', Opal.const_set($nesting[0], 'SEPARATOR', \"/\"));\n    Opal.const_set($nesting[0], 'ALT_SEPARATOR', nil);\n    Opal.const_set($nesting[0], 'PATH_SEPARATOR', \":\");\n    Opal.const_set($nesting[0], 'FNM_SYSCASE', 0);\n    windows_root_rx = /^[a-zA-Z]:(?:\\\\|\\/)/;\n    return (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_expand_path_1, TMP_dirname_2, TMP_basename_3, TMP_extname_4, TMP_exist$q_5, TMP_directory$q_7, TMP_join_10, TMP_split_11;\n\n      \n      \n      Opal.def(self, '$expand_path', TMP_expand_path_1 = function $$expand_path(path, basedir) {\n        var $a, self = this, sep = nil, sep_chars = nil, new_parts = nil, home = nil, home_path_regexp = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;\n\n        if (basedir == null) {\n          basedir = nil;\n        }\n        \n        sep = $$($nesting, 'SEPARATOR');\n        sep_chars = $sep_chars();\n        new_parts = [];\n        if ($truthy(path[0] === '~' || (basedir && basedir[0] === '~'))) {\n          \n          home = $$($nesting, 'Dir').$home();\n          if ($truthy(home)) {\n          } else {\n            self.$raise($$($nesting, 'ArgumentError'), \"couldn't find HOME environment -- expanding `~'\")\n          };\n          if ($truthy(home['$start_with?'](sep))) {\n          } else {\n            self.$raise($$($nesting, 'ArgumentError'), \"non-absolute home\")\n          };\n          home = $rb_plus(home, sep);\n          home_path_regexp = new RegExp(\"\" + \"^\\\\~(?:\" + (sep) + \"|$)\");\n          path = path.$sub(home_path_regexp, home);\n          if ($truthy(basedir)) {\n            basedir = basedir.$sub(home_path_regexp, home)};};\n        basedir = ($truthy($a = basedir) ? $a : $$($nesting, 'Dir').$pwd());\n        path_abs = path.substr(0, sep.length) === sep || windows_root_rx.test(path);\n        basedir_abs = basedir.substr(0, sep.length) === sep || windows_root_rx.test(basedir);\n        if ($truthy(path_abs)) {\n          \n          parts = path.$split(new RegExp(\"\" + \"[\" + (sep_chars) + \"]\"));\n          leading_sep = windows_root_rx.test(path) ? '' : path.$sub(new RegExp(\"\" + \"^([\" + (sep_chars) + \"]+).*$\"), \"\\\\1\");\n          abs = true;\n        } else {\n          \n          parts = $rb_plus(basedir.$split(new RegExp(\"\" + \"[\" + (sep_chars) + \"]\")), path.$split(new RegExp(\"\" + \"[\" + (sep_chars) + \"]\")));\n          leading_sep = windows_root_rx.test(basedir) ? '' : basedir.$sub(new RegExp(\"\" + \"^([\" + (sep_chars) + \"]+).*$\"), \"\\\\1\");\n          abs = basedir_abs;\n        };\n        \n        var part;\n        for (var i = 0, ii = parts.length; i < ii; i++) {\n          part = parts[i];\n\n          if (\n            (part === nil) ||\n            (part === ''  && ((new_parts.length === 0) || abs)) ||\n            (part === '.' && ((new_parts.length === 0) || abs))\n          ) {\n            continue;\n          }\n          if (part === '..') {\n            new_parts.pop();\n          } else {\n            new_parts.push(part);\n          }\n        }\n\n        if (!abs && parts[0] !== '.') {\n          new_parts.$unshift(\".\")\n        }\n      ;\n        new_path = new_parts.$join(sep);\n        if ($truthy(abs)) {\n          new_path = $rb_plus(leading_sep, new_path)};\n        return new_path;\n      }, TMP_expand_path_1.$$arity = -2);\n      Opal.alias(self, \"realpath\", \"expand_path\");\n      \n      // Coerce a given path to a path string using #to_path and #to_str\n      function $coerce_to_path(path) {\n        if ($truthy((path)['$respond_to?'](\"to_path\"))) {\n          path = path.$to_path();\n        }\n\n        path = $$($nesting, 'Opal')['$coerce_to!'](path, $$($nesting, 'String'), \"to_str\");\n\n        return path;\n      }\n\n      // Return a RegExp compatible char class\n      function $sep_chars() {\n        if ($$($nesting, 'ALT_SEPARATOR') === nil) {\n          return Opal.escape_regexp($$($nesting, 'SEPARATOR'));\n        } else {\n          return Opal.escape_regexp($rb_plus($$($nesting, 'SEPARATOR'), $$($nesting, 'ALT_SEPARATOR')));\n        }\n      }\n    ;\n      \n      Opal.def(self, '$dirname', TMP_dirname_2 = function $$dirname(path) {\n        var self = this, sep_chars = nil;\n\n        \n        sep_chars = $sep_chars();\n        path = $coerce_to_path(path);\n        \n        var absolute = path.match(new RegExp(\"\" + \"^[\" + (sep_chars) + \"]\"));\n\n        path = path.replace(new RegExp(\"\" + \"[\" + (sep_chars) + \"]+$\"), ''); // remove trailing separators\n        path = path.replace(new RegExp(\"\" + \"[^\" + (sep_chars) + \"]+$\"), ''); // remove trailing basename\n        path = path.replace(new RegExp(\"\" + \"[\" + (sep_chars) + \"]+$\"), ''); // remove final trailing separators\n\n        if (path === '') {\n          return absolute ? '/' : '.';\n        }\n\n        return path;\n      ;\n      }, TMP_dirname_2.$$arity = 1);\n      \n      Opal.def(self, '$basename', TMP_basename_3 = function $$basename(name, suffix) {\n        var self = this, sep_chars = nil;\n\n        if (suffix == null) {\n          suffix = nil;\n        }\n        \n        sep_chars = $sep_chars();\n        name = $coerce_to_path(name);\n        \n        if (name.length == 0) {\n          return name;\n        }\n\n        if (suffix !== nil) {\n          suffix = $$($nesting, 'Opal')['$coerce_to!'](suffix, $$($nesting, 'String'), \"to_str\")\n        } else {\n          suffix = null;\n        }\n\n        name = name.replace(new RegExp(\"\" + \"(.)[\" + (sep_chars) + \"]*$\"), '$1');\n        name = name.replace(new RegExp(\"\" + \"^(?:.*[\" + (sep_chars) + \"])?([^\" + (sep_chars) + \"]+)$\"), '$1');\n\n        if (suffix === \".*\") {\n          name = name.replace(/\\.[^\\.]+$/, '');\n        } else if(suffix !== null) {\n          suffix = Opal.escape_regexp(suffix);\n          name = name.replace(new RegExp(\"\" + (suffix) + \"$\"), '');\n        }\n\n        return name;\n      ;\n      }, TMP_basename_3.$$arity = -2);\n      \n      Opal.def(self, '$extname', TMP_extname_4 = function $$extname(path) {\n        var $a, self = this, filename = nil, last_dot_idx = nil;\n\n        \n        path = $coerce_to_path(path);\n        filename = self.$basename(path);\n        if ($truthy(filename['$empty?']())) {\n          return \"\"};\n        last_dot_idx = filename['$[]']($range(1, -1, false)).$rindex(\".\");\n        if ($truthy(($truthy($a = last_dot_idx['$nil?']()) ? $a : $rb_plus(last_dot_idx, 1)['$==']($rb_minus(filename.$length(), 1))))) {\n          return \"\"\n        } else {\n          return filename['$[]'](Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false))\n        };\n      }, TMP_extname_4.$$arity = 1);\n      \n      Opal.def(self, '$exist?', TMP_exist$q_5 = function(path) {\n        var self = this;\n\n        return Opal.modules[path] != null\n      }, TMP_exist$q_5.$$arity = 1);\n      Opal.alias(self, \"exists?\", \"exist?\");\n      \n      Opal.def(self, '$directory?', TMP_directory$q_7 = function(path) {\n        var TMP_6, self = this, files = nil, file = nil;\n\n        \n        files = [];\n        \n        for (var key in Opal.modules) {\n          files.push(key)\n        }\n      ;\n        path = path.$gsub(new RegExp(\"\" + \"(^.\" + ($$($nesting, 'SEPARATOR')) + \"+|\" + ($$($nesting, 'SEPARATOR')) + \"+$)\"));\n        file = $send(files, 'find', [], (TMP_6 = function(f){var self = TMP_6.$$s || this;\nif (f == null) f = nil;\n        return f['$=~'](new RegExp(\"\" + \"^\" + (path)))}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6));\n        return file;\n      }, TMP_directory$q_7.$$arity = 1);\n      \n      Opal.def(self, '$join', TMP_join_10 = function $$join($a_rest) {\n        var TMP_8, TMP_9, self = this, paths, result = nil;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 0;\n        if ($rest_len < 0) { $rest_len = 0; }\n        paths = new Array($rest_len);\n        for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n          paths[$arg_idx - 0] = arguments[$arg_idx];\n        }\n        \n        if ($truthy(paths['$empty?']())) {\n          return \"\"};\n        result = \"\";\n        paths = $send(paths.$flatten().$each_with_index(), 'map', [], (TMP_8 = function(item, index){var self = TMP_8.$$s || this, $a;\nif (item == null) item = nil;if (index == null) index = nil;\n        if ($truthy((($a = index['$=='](0)) ? item['$empty?']() : index['$=='](0)))) {\n            return $$($nesting, 'SEPARATOR')\n          } else if ($truthy((($a = paths.$length()['$==']($rb_plus(index, 1))) ? item['$empty?']() : paths.$length()['$==']($rb_plus(index, 1))))) {\n            return $$($nesting, 'SEPARATOR')\n          } else {\n            return item\n          }}, TMP_8.$$s = self, TMP_8.$$arity = 2, TMP_8));\n        paths = $send(paths, 'reject', [], \"empty?\".$to_proc());\n        $send(paths, 'each_with_index', [], (TMP_9 = function(item, index){var self = TMP_9.$$s || this, $a, next_item = nil;\nif (item == null) item = nil;if (index == null) index = nil;\n        \n          next_item = paths['$[]']($rb_plus(index, 1));\n          if ($truthy(next_item['$nil?']())) {\n            return (result = \"\" + (result) + (item))\n          } else {\n            \n            if ($truthy(($truthy($a = item['$end_with?']($$($nesting, 'SEPARATOR'))) ? next_item['$start_with?']($$($nesting, 'SEPARATOR')) : $a))) {\n              item = item.$sub(new RegExp(\"\" + ($$($nesting, 'SEPARATOR')) + \"+$\"), \"\")};\n            return (result = (function() {if ($truthy(($truthy($a = item['$end_with?']($$($nesting, 'SEPARATOR'))) ? $a : next_item['$start_with?']($$($nesting, 'SEPARATOR'))))) {\n              return \"\" + (result) + (item)\n            } else {\n              return \"\" + (result) + (item) + ($$($nesting, 'SEPARATOR'))\n            }; return nil; })());\n          };}, TMP_9.$$s = self, TMP_9.$$arity = 2, TMP_9));\n        return result;\n      }, TMP_join_10.$$arity = -1);\n      return (Opal.def(self, '$split', TMP_split_11 = function $$split(path) {\n        var self = this;\n\n        return path.$split($$($nesting, 'SEPARATOR'))\n      }, TMP_split_11.$$arity = 1), nil) && 'split';\n    })(Opal.get_singleton_class(self), $nesting);\n  })($nesting[0], $$($nesting, 'IO'), $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/process\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$const_set', '$size', '$<<', '$__register_clock__', '$to_f', '$now', '$new', '$[]', '$raise']);\n  \n  (function($base, $super, $parent_nesting) {\n    function $Process(){};\n    var self = $Process = $klass($base, $super, 'Process', $Process);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Process___register_clock___1, TMP_Process_pid_2, TMP_Process_times_3, TMP_Process_clock_gettime_4, monotonic = nil;\n\n    \n    self.__clocks__ = [];\n    Opal.defs(self, '$__register_clock__', TMP_Process___register_clock___1 = function $$__register_clock__(name, func) {\n      var self = this;\n      if (self.__clocks__ == null) self.__clocks__ = nil;\n\n      \n      self.$const_set(name, self.__clocks__.$size());\n      return self.__clocks__['$<<'](func);\n    }, TMP_Process___register_clock___1.$$arity = 2);\n    self.$__register_clock__(\"CLOCK_REALTIME\", function() { return Date.now() });\n    monotonic = false;\n    \n    if (Opal.global.performance) {\n      monotonic = function() {\n        return performance.now()\n      };\n    }\n    else if (Opal.global.process && process.hrtime) {\n      // let now be the base to get smaller numbers\n      var hrtime_base = process.hrtime();\n\n      monotonic = function() {\n        var hrtime = process.hrtime(hrtime_base);\n        var us = (hrtime[1] / 1000) | 0; // cut below microsecs;\n        return ((hrtime[0] * 1000) + (us / 1000));\n      };\n    }\n  ;\n    if ($truthy(monotonic)) {\n      self.$__register_clock__(\"CLOCK_MONOTONIC\", monotonic)};\n    Opal.defs(self, '$pid', TMP_Process_pid_2 = function $$pid() {\n      var self = this;\n\n      return 0\n    }, TMP_Process_pid_2.$$arity = 0);\n    Opal.defs(self, '$times', TMP_Process_times_3 = function $$times() {\n      var self = this, t = nil;\n\n      \n      t = $$($nesting, 'Time').$now().$to_f();\n      return $$$($$($nesting, 'Benchmark'), 'Tms').$new(t, t, t, t, t);\n    }, TMP_Process_times_3.$$arity = 0);\n    return (Opal.defs(self, '$clock_gettime', TMP_Process_clock_gettime_4 = function $$clock_gettime(clock_id, unit) {\n      var $a, self = this, clock = nil;\n      if (self.__clocks__ == null) self.__clocks__ = nil;\n\n      if (unit == null) {\n        unit = \"float_second\";\n      }\n      \n      ($truthy($a = (clock = self.__clocks__['$[]'](clock_id))) ? $a : self.$raise($$$($$($nesting, 'Errno'), 'EINVAL'), \"\" + \"clock_gettime(\" + (clock_id) + \") \" + (self.__clocks__['$[]'](clock_id))));\n      \n      var ms = clock();\n      switch (unit) {\n        case 'float_second':      return  (ms / 1000);         // number of seconds as a float (default)\n        case 'float_millisecond': return  (ms / 1);            // number of milliseconds as a float\n        case 'float_microsecond': return  (ms * 1000);         // number of microseconds as a float\n        case 'second':            return ((ms / 1000)    | 0); // number of seconds as an integer\n        case 'millisecond':       return ((ms / 1)       | 0); // number of milliseconds as an integer\n        case 'microsecond':       return ((ms * 1000)    | 0); // number of microseconds as an integer\n        case 'nanosecond':        return ((ms * 1000000) | 0); // number of nanoseconds as an integer\n        default: self.$raise($$($nesting, 'ArgumentError'), \"\" + \"unexpected unit: \" + (unit))\n      }\n    ;\n    }, TMP_Process_clock_gettime_4.$$arity = -2), nil) && 'clock_gettime';\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Signal(){};\n    var self = $Signal = $klass($base, $super, 'Signal', $Signal);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Signal_trap_5;\n\n    return (Opal.defs(self, '$trap', TMP_Signal_trap_5 = function $$trap($a_rest) {\n      var self = this;\n\n      return nil\n    }, TMP_Signal_trap_5.$$arity = -1), nil) && 'trap'\n  })($nesting[0], null, $nesting);\n  return (function($base, $super, $parent_nesting) {\n    function $GC(){};\n    var self = $GC = $klass($base, $super, 'GC', $GC);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_GC_start_6;\n\n    return (Opal.defs(self, '$start', TMP_GC_start_6 = function $$start() {\n      var self = this;\n\n      return nil\n    }, TMP_GC_start_6.$$arity = 0), nil) && 'start'\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/random/seedrandom\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass;\n\n  return (function($base, $super, $parent_nesting) {\n    function $Random(){};\n    var self = $Random = $klass($base, $super, 'Random', $Random);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    \n    /* jshint ignore:start */\n    /*\n    seedrandom.min.js 2.4.1 (original source: https://github.com/davidbau/seedrandom/blob/2.4.1/seedrandom.min.js)\n    How to update:\n     . Chekout the latest release from GitHub: https://github.com/davidbau/seedrandom\n     . Apply the following commits:\n     .. Check for hasOwnProperty in flatten(): https://github.com/iliabylich/seedrandom/commit/06a94f59ae3d3956c8b1a2488334cafab6744b04\n     .. Add a module id for the RequireJS `define` method: https://github.com/Mogztter/seedrandom/commit/e047540c3d81f955cab9a01d17b8141d439fbd7d\n    */\n    !function(a,b){function c(c,j,k){var n=[];j=1==j?{entropy:!0}:j||{};var s=g(f(j.entropy?[c,i(a)]:null==c?h():c,3),n),t=new d(n),u=function(){for(var a=t.g(m),b=p,c=0;a<q;)a=(a+c)*l,b*=l,c=t.g(1);for(;a>=r;)a/=2,b/=2,c>>>=1;return(a+c)/b};return u.int32=function(){return 0|t.g(4)},u.quick=function(){return t.g(4)/4294967296},u.double=u,g(i(t.S),a),(j.pass||k||function(a,c,d,f){return f&&(f.S&&e(f,t),a.state=function(){return e(t,{})}),d?(b[o]=a,c):a})(u,s,\"global\"in j?j.global:this==b,j.state)}function d(a){var b,c=a.length,d=this,e=0,f=d.i=d.j=0,g=d.S=[];for(c||(a=[c++]);e<l;)g[e]=e++;for(e=0;e<l;e++)g[e]=g[f=s&f+a[e%c]+(b=g[e])],g[f]=b;(d.g=function(a){for(var b,c=0,e=d.i,f=d.j,g=d.S;a--;)b=g[e=s&e+1],c=c*l+g[s&(g[e]=g[f=s&f+b])+(g[f]=b)];return d.i=e,d.j=f,c})(l)}function e(a,b){return b.i=a.i,b.j=a.j,b.S=a.S.slice(),b}function f(a,b){var c,d=[],e=typeof a;if(b&&\"object\"==e)for(c in a)if(a.hasOwnProperty(c))try{d.push(f(a[c],b-1))}catch(a){}return d.length?d:\"string\"==e?a:a+\"\\0\"}function g(a,b){for(var c,d=a+\"\",e=0;e<d.length;)b[s&e]=s&(c^=19*b[s&e])+d.charCodeAt(e++);return i(b)}function h(){try{if(j)return i(j.randomBytes(l));var b=new Uint8Array(l);return(k.crypto||k.msCrypto).getRandomValues(b),i(b)}catch(b){var c=k.navigator,d=c&&c.plugins;return[+new Date,k,d,k.screen,i(a)]}}function i(a){return String.fromCharCode.apply(0,a)}var j,k=this,l=256,m=6,n=52,o=\"random\",p=b.pow(l,m),q=b.pow(2,n),r=2*q,s=l-1;if(b[\"seed\"+o]=c,g(b.random(),a),\"object\"==typeof module&&module.exports){module.exports=c;try{j=require(\"crypto\")}catch(a){}}else\"function\"==typeof define&&define.amd&&define('seekrandom',function(){return c})}([],Math);\n    /* jshint ignore:end */\n  \n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/random\"] = function(Opal) {\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$require', '$attr_reader', '$coerce_to!', '$reseed', '$new_seed', '$rand', '$seed', '$<', '$raise', '$encode', '$join', '$new', '$chr', '$===', '$==', '$state']);\n  \n  self.$require(\"corelib/random/seedrandom.js\");\n  return (function($base, $super, $parent_nesting) {\n    function $Random(){};\n    var self = $Random = $klass($base, $super, 'Random', $Random);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Random_initialize_1, TMP_Random_reseed_2, TMP_Random_new_seed_3, TMP_Random_rand_4, TMP_Random_srand_5, TMP_Random_urandom_7, TMP_Random_$eq$eq_8, TMP_Random_bytes_10, TMP_Random_rand_11;\n\n    \n    self.$attr_reader(\"seed\", \"state\");\n    \n    Opal.def(self, '$initialize', TMP_Random_initialize_1 = function $$initialize(seed) {\n      var self = this;\n\n      if (seed == null) {\n        seed = $$($nesting, 'Random').$new_seed();\n      }\n      \n      seed = $$($nesting, 'Opal')['$coerce_to!'](seed, $$($nesting, 'Integer'), \"to_int\");\n      self.state = seed;\n      return self.$reseed(seed);\n    }, TMP_Random_initialize_1.$$arity = -1);\n    \n    Opal.def(self, '$reseed', TMP_Random_reseed_2 = function $$reseed(seed) {\n      var self = this;\n\n      \n      self.seed = seed;\n      return self.$rng = new Math.seedrandom(seed);;\n    }, TMP_Random_reseed_2.$$arity = 1);\n    var $seed_generator = new Math.seedrandom('opal', { entropy: true });\n    Opal.defs(self, '$new_seed', TMP_Random_new_seed_3 = function $$new_seed() {\n      var self = this;\n\n      return Math.abs($seed_generator.int32());\n    }, TMP_Random_new_seed_3.$$arity = 0);\n    Opal.defs(self, '$rand', TMP_Random_rand_4 = function $$rand(limit) {\n      var self = this;\n\n      return $$($nesting, 'DEFAULT').$rand(limit)\n    }, TMP_Random_rand_4.$$arity = -1);\n    Opal.defs(self, '$srand', TMP_Random_srand_5 = function $$srand(n) {\n      var self = this, previous_seed = nil;\n\n      if (n == null) {\n        n = $$($nesting, 'Random').$new_seed();\n      }\n      \n      n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), \"to_int\");\n      previous_seed = $$($nesting, 'DEFAULT').$seed();\n      $$($nesting, 'DEFAULT').$reseed(n);\n      return previous_seed;\n    }, TMP_Random_srand_5.$$arity = -1);\n    Opal.defs(self, '$urandom', TMP_Random_urandom_7 = function $$urandom(size) {\n      var TMP_6, self = this;\n\n      \n      size = $$($nesting, 'Opal')['$coerce_to!'](size, $$($nesting, 'Integer'), \"to_int\");\n      if ($truthy($rb_lt(size, 0))) {\n        self.$raise($$($nesting, 'ArgumentError'), \"negative string size (or size too big)\")};\n      return $send($$($nesting, 'Array'), 'new', [size], (TMP_6 = function(){var self = TMP_6.$$s || this;\n\n      return self.$rand(255).$chr()}, TMP_6.$$s = self, TMP_6.$$arity = 0, TMP_6)).$join().$encode(\"ASCII-8BIT\");\n    }, TMP_Random_urandom_7.$$arity = 1);\n    Opal.const_set($nesting[0], 'DEFAULT', self.$new(self.$new_seed()));\n    \n    Opal.def(self, '$==', TMP_Random_$eq$eq_8 = function(other) {\n      var $a, self = this;\n\n      \n      if ($truthy($$($nesting, 'Random')['$==='](other))) {\n      } else {\n        return false\n      };\n      return (($a = self.$seed()['$=='](other.$seed())) ? self.$state()['$=='](other.$state()) : self.$seed()['$=='](other.$seed()));\n    }, TMP_Random_$eq$eq_8.$$arity = 1);\n    \n    Opal.def(self, '$bytes', TMP_Random_bytes_10 = function $$bytes(length) {\n      var TMP_9, self = this;\n\n      \n      length = $$($nesting, 'Opal')['$coerce_to!'](length, $$($nesting, 'Integer'), \"to_int\");\n      return $send($$($nesting, 'Array'), 'new', [length], (TMP_9 = function(){var self = TMP_9.$$s || this;\n\n      return self.$rand(255).$chr()}, TMP_9.$$s = self, TMP_9.$$arity = 0, TMP_9)).$join().$encode(\"ASCII-8BIT\");\n    }, TMP_Random_bytes_10.$$arity = 1);\n    return (Opal.def(self, '$rand', TMP_Random_rand_11 = function $$rand(limit) {\n      var self = this;\n\n      \n      function randomFloat() {\n        self.state++;\n        return self.$rng.quick();\n      }\n\n      function randomInt() {\n        return Math.floor(randomFloat() * limit);\n      }\n\n      function randomRange() {\n        var min = limit.begin,\n            max = limit.end;\n\n        if (min === nil || max === nil) {\n          return nil;\n        }\n\n        var length = max - min;\n\n        if (length < 0) {\n          return nil;\n        }\n\n        if (length === 0) {\n          return min;\n        }\n\n        if (max % 1 === 0 && min % 1 === 0 && !limit.excl) {\n          length++;\n        }\n\n        return self.$rand(length) + min;\n      }\n\n      if (limit == null) {\n        return randomFloat();\n      } else if (limit.$$is_range) {\n        return randomRange();\n      } else if (limit.$$is_number) {\n        if (limit <= 0) {\n          self.$raise($$($nesting, 'ArgumentError'), \"\" + \"invalid argument - \" + (limit))\n        }\n\n        if (limit % 1 === 0) {\n          // integer\n          return randomInt();\n        } else {\n          return randomFloat() * limit;\n        }\n      } else {\n        limit = $$($nesting, 'Opal')['$coerce_to!'](limit, $$($nesting, 'Integer'), \"to_int\");\n\n        if (limit <= 0) {\n          self.$raise($$($nesting, 'ArgumentError'), \"\" + \"invalid argument - \" + (limit))\n        }\n\n        return randomInt();\n      }\n    \n    }, TMP_Random_rand_11.$$arity = -1), nil) && 'rand';\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"corelib/unsupported\"] = function(Opal) {\n  var TMP_public_31, TMP_private_32, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $module = Opal.module;\n\n  Opal.add_stubs(['$raise', '$warn', '$%']);\n  \n  \n  var warnings = {};\n\n  function handle_unsupported_feature(message) {\n    switch (Opal.config.unsupported_features_severity) {\n    case 'error':\n      $$($nesting, 'Kernel').$raise($$($nesting, 'NotImplementedError'), message)\n      break;\n    case 'warning':\n      warn(message)\n      break;\n    default: // ignore\n      // noop\n    }\n  }\n\n  function warn(string) {\n    if (warnings[string]) {\n      return;\n    }\n\n    warnings[string] = true;\n    self.$warn(string);\n  }\n;\n  (function($base, $super, $parent_nesting) {\n    function $String(){};\n    var self = $String = $klass($base, $super, 'String', $String);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String_$lt$lt_1, TMP_String_capitalize$B_2, TMP_String_chomp$B_3, TMP_String_chop$B_4, TMP_String_downcase$B_5, TMP_String_gsub$B_6, TMP_String_lstrip$B_7, TMP_String_next$B_8, TMP_String_reverse$B_9, TMP_String_slice$B_10, TMP_String_squeeze$B_11, TMP_String_strip$B_12, TMP_String_sub$B_13, TMP_String_succ$B_14, TMP_String_swapcase$B_15, TMP_String_tr$B_16, TMP_String_tr_s$B_17, TMP_String_upcase$B_18, TMP_String_prepend_19;\n\n    \n    var ERROR = \"String#%s not supported. Mutable String methods are not supported in Opal.\";\n    \n    Opal.def(self, '$<<', TMP_String_$lt$lt_1 = function($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%'](\"<<\"))\n    }, TMP_String_$lt$lt_1.$$arity = -1);\n    \n    Opal.def(self, '$capitalize!', TMP_String_capitalize$B_2 = function($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%'](\"capitalize!\"))\n    }, TMP_String_capitalize$B_2.$$arity = -1);\n    \n    Opal.def(self, '$chomp!', TMP_String_chomp$B_3 = function($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%'](\"chomp!\"))\n    }, TMP_String_chomp$B_3.$$arity = -1);\n    \n    Opal.def(self, '$chop!', TMP_String_chop$B_4 = function($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%'](\"chop!\"))\n    }, TMP_String_chop$B_4.$$arity = -1);\n    \n    Opal.def(self, '$downcase!', TMP_String_downcase$B_5 = function($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%'](\"downcase!\"))\n    }, TMP_String_downcase$B_5.$$arity = -1);\n    \n    Opal.def(self, '$gsub!', TMP_String_gsub$B_6 = function($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%'](\"gsub!\"))\n    }, TMP_String_gsub$B_6.$$arity = -1);\n    \n    Opal.def(self, '$lstrip!', TMP_String_lstrip$B_7 = function($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%'](\"lstrip!\"))\n    }, TMP_String_lstrip$B_7.$$arity = -1);\n    \n    Opal.def(self, '$next!', TMP_String_next$B_8 = function($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%'](\"next!\"))\n    }, TMP_String_next$B_8.$$arity = -1);\n    \n    Opal.def(self, '$reverse!', TMP_String_reverse$B_9 = function($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%'](\"reverse!\"))\n    }, TMP_String_reverse$B_9.$$arity = -1);\n    \n    Opal.def(self, '$slice!', TMP_String_slice$B_10 = function($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%'](\"slice!\"))\n    }, TMP_String_slice$B_10.$$arity = -1);\n    \n    Opal.def(self, '$squeeze!', TMP_String_squeeze$B_11 = function($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%'](\"squeeze!\"))\n    }, TMP_String_squeeze$B_11.$$arity = -1);\n    \n    Opal.def(self, '$strip!', TMP_String_strip$B_12 = function($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%'](\"strip!\"))\n    }, TMP_String_strip$B_12.$$arity = -1);\n    \n    Opal.def(self, '$sub!', TMP_String_sub$B_13 = function($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%'](\"sub!\"))\n    }, TMP_String_sub$B_13.$$arity = -1);\n    \n    Opal.def(self, '$succ!', TMP_String_succ$B_14 = function($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%'](\"succ!\"))\n    }, TMP_String_succ$B_14.$$arity = -1);\n    \n    Opal.def(self, '$swapcase!', TMP_String_swapcase$B_15 = function($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%'](\"swapcase!\"))\n    }, TMP_String_swapcase$B_15.$$arity = -1);\n    \n    Opal.def(self, '$tr!', TMP_String_tr$B_16 = function($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%'](\"tr!\"))\n    }, TMP_String_tr$B_16.$$arity = -1);\n    \n    Opal.def(self, '$tr_s!', TMP_String_tr_s$B_17 = function($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%'](\"tr_s!\"))\n    }, TMP_String_tr_s$B_17.$$arity = -1);\n    \n    Opal.def(self, '$upcase!', TMP_String_upcase$B_18 = function($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%'](\"upcase!\"))\n    }, TMP_String_upcase$B_18.$$arity = -1);\n    return (Opal.def(self, '$prepend', TMP_String_prepend_19 = function $$prepend($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%'](\"prepend\"))\n    }, TMP_String_prepend_19.$$arity = -1), nil) && 'prepend';\n  })($nesting[0], null, $nesting);\n  (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_freeze_20, TMP_Kernel_frozen$q_21;\n\n    \n    var ERROR = \"Object freezing is not supported by Opal\";\n    \n    Opal.def(self, '$freeze', TMP_Kernel_freeze_20 = function $$freeze() {\n      var self = this;\n\n      \n      handle_unsupported_feature(ERROR);\n      return self;\n    }, TMP_Kernel_freeze_20.$$arity = 0);\n    \n    Opal.def(self, '$frozen?', TMP_Kernel_frozen$q_21 = function() {\n      var self = this;\n\n      \n      handle_unsupported_feature(ERROR);\n      return false;\n    }, TMP_Kernel_frozen$q_21.$$arity = 0);\n  })($nesting[0], $nesting);\n  (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_taint_22, TMP_Kernel_untaint_23, TMP_Kernel_tainted$q_24;\n\n    \n    var ERROR = \"Object tainting is not supported by Opal\";\n    \n    Opal.def(self, '$taint', TMP_Kernel_taint_22 = function $$taint() {\n      var self = this;\n\n      \n      handle_unsupported_feature(ERROR);\n      return self;\n    }, TMP_Kernel_taint_22.$$arity = 0);\n    \n    Opal.def(self, '$untaint', TMP_Kernel_untaint_23 = function $$untaint() {\n      var self = this;\n\n      \n      handle_unsupported_feature(ERROR);\n      return self;\n    }, TMP_Kernel_untaint_23.$$arity = 0);\n    \n    Opal.def(self, '$tainted?', TMP_Kernel_tainted$q_24 = function() {\n      var self = this;\n\n      \n      handle_unsupported_feature(ERROR);\n      return false;\n    }, TMP_Kernel_tainted$q_24.$$arity = 0);\n  })($nesting[0], $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Module(){};\n    var self = $Module = $klass($base, $super, 'Module', $Module);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Module_public_25, TMP_Module_private_class_method_26, TMP_Module_private_method_defined$q_27, TMP_Module_private_constant_28;\n\n    \n    \n    Opal.def(self, '$public', TMP_Module_public_25 = function($a_rest) {\n      var self = this, methods;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      methods = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        methods[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      \n      if (methods.length === 0) {\n        self.$$module_function = false;\n      }\n\n      return nil;\n    \n    }, TMP_Module_public_25.$$arity = -1);\n    Opal.alias(self, \"private\", \"public\");\n    Opal.alias(self, \"protected\", \"public\");\n    Opal.alias(self, \"nesting\", \"public\");\n    \n    Opal.def(self, '$private_class_method', TMP_Module_private_class_method_26 = function $$private_class_method($a_rest) {\n      var self = this;\n\n      return self\n    }, TMP_Module_private_class_method_26.$$arity = -1);\n    Opal.alias(self, \"public_class_method\", \"private_class_method\");\n    \n    Opal.def(self, '$private_method_defined?', TMP_Module_private_method_defined$q_27 = function(obj) {\n      var self = this;\n\n      return false\n    }, TMP_Module_private_method_defined$q_27.$$arity = 1);\n    \n    Opal.def(self, '$private_constant', TMP_Module_private_constant_28 = function $$private_constant($a_rest) {\n      var self = this;\n\n      return nil\n    }, TMP_Module_private_constant_28.$$arity = -1);\n    Opal.alias(self, \"protected_method_defined?\", \"private_method_defined?\");\n    Opal.alias(self, \"public_instance_methods\", \"instance_methods\");\n    return Opal.alias(self, \"public_method_defined?\", \"method_defined?\");\n  })($nesting[0], null, $nesting);\n  (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_private_methods_29;\n\n    \n    \n    Opal.def(self, '$private_methods', TMP_Kernel_private_methods_29 = function $$private_methods($a_rest) {\n      var self = this;\n\n      return []\n    }, TMP_Kernel_private_methods_29.$$arity = -1);\n    Opal.alias(self, \"private_instance_methods\", \"private_methods\");\n  })($nesting[0], $nesting);\n  (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_eval_30;\n\n    \n    Opal.def(self, '$eval', TMP_Kernel_eval_30 = function($a_rest) {\n      var self = this;\n\n      return self.$raise($$($nesting, 'NotImplementedError'), \"\" + \"To use Kernel#eval, you must first require 'opal-parser'. \" + (\"\" + \"See https://github.com/opal/opal/blob/\" + ($$($nesting, 'RUBY_ENGINE_VERSION')) + \"/docs/opal_parser.md for details.\"))\n    }, TMP_Kernel_eval_30.$$arity = -1)\n  })($nesting[0], $nesting);\n  Opal.defs(self, '$public', TMP_public_31 = function($a_rest) {\n    var self = this;\n\n    return nil\n  }, TMP_public_31.$$arity = -1);\n  return (Opal.defs(self, '$private', TMP_private_32 = function($a_rest) {\n    var self = this;\n\n    return nil\n  }, TMP_private_32.$$arity = -1), nil) && 'private';\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"opal\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;\n\n  Opal.add_stubs(['$require']);\n  \n  self.$require(\"opal/base\");\n  self.$require(\"opal/mini\");\n  self.$require(\"corelib/string/inheritance\");\n  self.$require(\"corelib/string/encoding\");\n  self.$require(\"corelib/math\");\n  self.$require(\"corelib/complex\");\n  self.$require(\"corelib/rational\");\n  self.$require(\"corelib/time\");\n  self.$require(\"corelib/struct\");\n  self.$require(\"corelib/io\");\n  self.$require(\"corelib/main\");\n  self.$require(\"corelib/dir\");\n  self.$require(\"corelib/file\");\n  self.$require(\"corelib/process\");\n  self.$require(\"corelib/random\");\n  return self.$require(\"corelib/unsupported\");\n};\n\n  Opal.require('opal');\n}\n\n// UMD Module\n(function (root, factory) {\n  if (typeof module === 'object' && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory;\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register a named module.\n    define('asciidoctor', ['module'], function (module) {\n      return factory(module.config());\n    });\n  } else {\n    // Browser globals (root is window)\n    root.Asciidoctor = factory;\n  }\n// eslint-disable-next-line no-unused-vars\n}(this, function (moduleConfig) {\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/js/opal_ext/browser/file\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass;\n\n  Opal.add_stubs(['$new']);\n  return (function($base, $super, $parent_nesting) {\n    function $File(){};\n    var self = $File = $klass($base, $super, 'File', $File);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_File_read_1;\n\n    return (Opal.defs(self, '$read', TMP_File_read_1 = function $$read(path) {\n      var self = this;\n\n      \n      var data = '';\n      var status = -1;\n      try {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', path, false);\n        xhr.addEventListener('load', function() {\n          status = this.status;\n          // status is 0 for local file mode (i.e., file://)\n          if (status === 0 || status === 200) {\n            data = this.responseText;\n          }\n        });\n        xhr.overrideMimeType('text/plain');\n        xhr.send();\n      }\n      catch (e) {\n        throw $$($nesting, 'IOError').$new('Error reading file or directory: ' + path + '; reason: ' + e.message);\n      }\n      // assume that no data in local file mode means it doesn't exist\n      if (status === 404 || (status === 0 && !data)) {\n        throw $$($nesting, 'IOError').$new('No such file or directory: ' + path);\n      }\n      return data;\n    \n    }, TMP_File_read_1.$$arity = 1), nil) && 'read'\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/js/opal_ext/browser\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;\n\n  Opal.add_stubs(['$require']);\n  \n  \n  var platform, engine, framework, ioModule;\n\n  if (typeof moduleConfig === 'object' && typeof moduleConfig.runtime === 'object') {\n    var runtime = moduleConfig.runtime;\n    platform = runtime.platform;\n    engine = runtime.engine;\n    framework = runtime.framework;\n    ioModule = runtime.ioModule;\n  }\n  ioModule = ioModule || 'xmlhttprequest';\n  platform = platform || 'browser';\n  engine = engine || '';\n  framework = framework || '';\n;\n  Opal.const_set($nesting[0], 'JAVASCRIPT_IO_MODULE', ioModule);\n  Opal.const_set($nesting[0], 'JAVASCRIPT_PLATFORM', platform);\n  Opal.const_set($nesting[0], 'JAVASCRIPT_ENGINE', engine);\n  Opal.const_set($nesting[0], 'JAVASCRIPT_FRAMEWORK', framework);\n  return self.$require(\"asciidoctor/js/opal_ext/browser/file\");\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"set\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $module = Opal.module;\n\n  Opal.add_stubs(['$include', '$new', '$nil?', '$===', '$raise', '$each', '$add', '$merge', '$class', '$respond_to?', '$subtract', '$dup', '$join', '$to_a', '$equal?', '$instance_of?', '$==', '$instance_variable_get', '$is_a?', '$size', '$all?', '$include?', '$[]=', '$-', '$enum_for', '$[]', '$<<', '$replace', '$delete', '$select', '$each_key', '$to_proc', '$empty?', '$eql?', '$instance_eval', '$clear', '$<', '$<=', '$keys']);\n  \n  (function($base, $super, $parent_nesting) {\n    function $Set(){};\n    var self = $Set = $klass($base, $super, 'Set', $Set);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Set_$$_1, TMP_Set_initialize_2, TMP_Set_dup_4, TMP_Set_$_5, TMP_Set_inspect_6, TMP_Set_$eq$eq_8, TMP_Set_add_9, TMP_Set_classify_10, TMP_Set_collect$B_13, TMP_Set_delete_15, TMP_Set_delete$q_16, TMP_Set_delete_if_17, TMP_Set_add$q_20, TMP_Set_each_21, TMP_Set_empty$q_22, TMP_Set_eql$q_24, TMP_Set_clear_25, TMP_Set_include$q_26, TMP_Set_merge_28, TMP_Set_replace_29, TMP_Set_size_30, TMP_Set_subtract_32, TMP_Set_$_33, TMP_Set_superset$q_35, TMP_Set_proper_superset$q_37, TMP_Set_subset$q_39, TMP_Set_proper_subset$q_41, TMP_Set_to_a_42;\n\n    def.hash = nil;\n    \n    self.$include($$($nesting, 'Enumerable'));\n    Opal.defs(self, '$[]', TMP_Set_$$_1 = function($a_rest) {\n      var self = this, ary;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 0;\n      if ($rest_len < 0) { $rest_len = 0; }\n      ary = new Array($rest_len);\n      for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n        ary[$arg_idx - 0] = arguments[$arg_idx];\n      }\n      return self.$new(ary)\n    }, TMP_Set_$$_1.$$arity = -1);\n    \n    Opal.def(self, '$initialize', TMP_Set_initialize_2 = function $$initialize(enum$) {\n      var TMP_3, self = this, $iter = TMP_Set_initialize_2.$$p, block = $iter || nil;\n\n      if (enum$ == null) {\n        enum$ = nil;\n      }\n      if ($iter) TMP_Set_initialize_2.$$p = null;\n      \n      self.hash = $hash2([], {});\n      if ($truthy(enum$['$nil?']())) {\n        return nil};\n      if ($truthy($$($nesting, 'Enumerable')['$==='](enum$))) {\n      } else {\n        self.$raise($$($nesting, 'ArgumentError'), \"value must be enumerable\")\n      };\n      if ($truthy(block)) {\n        return $send(enum$, 'each', [], (TMP_3 = function(item){var self = TMP_3.$$s || this;\nif (item == null) item = nil;\n        return self.$add(Opal.yield1(block, item))}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3))\n      } else {\n        return self.$merge(enum$)\n      };\n    }, TMP_Set_initialize_2.$$arity = -1);\n    \n    Opal.def(self, '$dup', TMP_Set_dup_4 = function $$dup() {\n      var self = this, result = nil;\n\n      \n      result = self.$class().$new();\n      return result.$merge(self);\n    }, TMP_Set_dup_4.$$arity = 0);\n    \n    Opal.def(self, '$-', TMP_Set_$_5 = function(enum$) {\n      var self = this;\n\n      \n      if ($truthy(enum$['$respond_to?'](\"each\"))) {\n      } else {\n        self.$raise($$($nesting, 'ArgumentError'), \"value must be enumerable\")\n      };\n      return self.$dup().$subtract(enum$);\n    }, TMP_Set_$_5.$$arity = 1);\n    Opal.alias(self, \"difference\", \"-\");\n    \n    Opal.def(self, '$inspect', TMP_Set_inspect_6 = function $$inspect() {\n      var self = this;\n\n      return \"\" + \"#<Set: {\" + (self.$to_a().$join(\",\")) + \"}>\"\n    }, TMP_Set_inspect_6.$$arity = 0);\n    \n    Opal.def(self, '$==', TMP_Set_$eq$eq_8 = function(other) {\n      var $a, TMP_7, self = this;\n\n      if ($truthy(self['$equal?'](other))) {\n        return true\n      } else if ($truthy(other['$instance_of?'](self.$class()))) {\n        return self.hash['$=='](other.$instance_variable_get(\"@hash\"))\n      } else if ($truthy(($truthy($a = other['$is_a?']($$($nesting, 'Set'))) ? self.$size()['$=='](other.$size()) : $a))) {\n        return $send(other, 'all?', [], (TMP_7 = function(o){var self = TMP_7.$$s || this;\n          if (self.hash == null) self.hash = nil;\nif (o == null) o = nil;\n        return self.hash['$include?'](o)}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7))\n      } else {\n        return false\n      }\n    }, TMP_Set_$eq$eq_8.$$arity = 1);\n    \n    Opal.def(self, '$add', TMP_Set_add_9 = function $$add(o) {\n      var self = this, $writer = nil;\n\n      \n      \n      $writer = [o, true];\n      $send(self.hash, '[]=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      return self;\n    }, TMP_Set_add_9.$$arity = 1);\n    Opal.alias(self, \"<<\", \"add\");\n    \n    Opal.def(self, '$classify', TMP_Set_classify_10 = function $$classify() {\n      var TMP_11, TMP_12, self = this, $iter = TMP_Set_classify_10.$$p, block = $iter || nil, result = nil;\n\n      if ($iter) TMP_Set_classify_10.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return self.$enum_for(\"classify\")\n      };\n      result = $send($$($nesting, 'Hash'), 'new', [], (TMP_11 = function(h, k){var self = TMP_11.$$s || this, $writer = nil;\nif (h == null) h = nil;if (k == null) k = nil;\n      \n        $writer = [k, self.$class().$new()];\n        $send(h, '[]=', Opal.to_a($writer));\n        return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_11.$$s = self, TMP_11.$$arity = 2, TMP_11));\n      $send(self, 'each', [], (TMP_12 = function(item){var self = TMP_12.$$s || this;\nif (item == null) item = nil;\n      return result['$[]'](Opal.yield1(block, item)).$add(item)}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12));\n      return result;\n    }, TMP_Set_classify_10.$$arity = 0);\n    \n    Opal.def(self, '$collect!', TMP_Set_collect$B_13 = function() {\n      var TMP_14, self = this, $iter = TMP_Set_collect$B_13.$$p, block = $iter || nil, result = nil;\n\n      if ($iter) TMP_Set_collect$B_13.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return self.$enum_for(\"collect!\")\n      };\n      result = self.$class().$new();\n      $send(self, 'each', [], (TMP_14 = function(item){var self = TMP_14.$$s || this;\nif (item == null) item = nil;\n      return result['$<<'](Opal.yield1(block, item))}, TMP_14.$$s = self, TMP_14.$$arity = 1, TMP_14));\n      return self.$replace(result);\n    }, TMP_Set_collect$B_13.$$arity = 0);\n    Opal.alias(self, \"map!\", \"collect!\");\n    \n    Opal.def(self, '$delete', TMP_Set_delete_15 = function(o) {\n      var self = this;\n\n      \n      self.hash.$delete(o);\n      return self;\n    }, TMP_Set_delete_15.$$arity = 1);\n    \n    Opal.def(self, '$delete?', TMP_Set_delete$q_16 = function(o) {\n      var self = this;\n\n      if ($truthy(self['$include?'](o))) {\n        \n        self.$delete(o);\n        return self;\n      } else {\n        return nil\n      }\n    }, TMP_Set_delete$q_16.$$arity = 1);\n    \n    Opal.def(self, '$delete_if', TMP_Set_delete_if_17 = function $$delete_if() {\n      var TMP_18, TMP_19, self = this, $iter = TMP_Set_delete_if_17.$$p, $yield = $iter || nil;\n\n      if ($iter) TMP_Set_delete_if_17.$$p = null;\n      \n      if (($yield !== nil)) {\n      } else {\n        return self.$enum_for(\"delete_if\")\n      };\n      $send($send(self, 'select', [], (TMP_18 = function(o){var self = TMP_18.$$s || this;\nif (o == null) o = nil;\n      return Opal.yield1($yield, o);}, TMP_18.$$s = self, TMP_18.$$arity = 1, TMP_18)), 'each', [], (TMP_19 = function(o){var self = TMP_19.$$s || this;\n        if (self.hash == null) self.hash = nil;\nif (o == null) o = nil;\n      return self.hash.$delete(o)}, TMP_19.$$s = self, TMP_19.$$arity = 1, TMP_19));\n      return self;\n    }, TMP_Set_delete_if_17.$$arity = 0);\n    \n    Opal.def(self, '$add?', TMP_Set_add$q_20 = function(o) {\n      var self = this;\n\n      if ($truthy(self['$include?'](o))) {\n        return nil\n      } else {\n        return self.$add(o)\n      }\n    }, TMP_Set_add$q_20.$$arity = 1);\n    \n    Opal.def(self, '$each', TMP_Set_each_21 = function $$each() {\n      var self = this, $iter = TMP_Set_each_21.$$p, block = $iter || nil;\n\n      if ($iter) TMP_Set_each_21.$$p = null;\n      \n      if ((block !== nil)) {\n      } else {\n        return self.$enum_for(\"each\")\n      };\n      $send(self.hash, 'each_key', [], block.$to_proc());\n      return self;\n    }, TMP_Set_each_21.$$arity = 0);\n    \n    Opal.def(self, '$empty?', TMP_Set_empty$q_22 = function() {\n      var self = this;\n\n      return self.hash['$empty?']()\n    }, TMP_Set_empty$q_22.$$arity = 0);\n    \n    Opal.def(self, '$eql?', TMP_Set_eql$q_24 = function(other) {\n      var TMP_23, self = this;\n\n      return self.hash['$eql?']($send(other, 'instance_eval', [], (TMP_23 = function(){var self = TMP_23.$$s || this;\n        if (self.hash == null) self.hash = nil;\n\n      return self.hash}, TMP_23.$$s = self, TMP_23.$$arity = 0, TMP_23)))\n    }, TMP_Set_eql$q_24.$$arity = 1);\n    \n    Opal.def(self, '$clear', TMP_Set_clear_25 = function $$clear() {\n      var self = this;\n\n      \n      self.hash.$clear();\n      return self;\n    }, TMP_Set_clear_25.$$arity = 0);\n    \n    Opal.def(self, '$include?', TMP_Set_include$q_26 = function(o) {\n      var self = this;\n\n      return self.hash['$include?'](o)\n    }, TMP_Set_include$q_26.$$arity = 1);\n    Opal.alias(self, \"member?\", \"include?\");\n    \n    Opal.def(self, '$merge', TMP_Set_merge_28 = function $$merge(enum$) {\n      var TMP_27, self = this;\n\n      \n      $send(enum$, 'each', [], (TMP_27 = function(item){var self = TMP_27.$$s || this;\nif (item == null) item = nil;\n      return self.$add(item)}, TMP_27.$$s = self, TMP_27.$$arity = 1, TMP_27));\n      return self;\n    }, TMP_Set_merge_28.$$arity = 1);\n    \n    Opal.def(self, '$replace', TMP_Set_replace_29 = function $$replace(enum$) {\n      var self = this;\n\n      \n      self.$clear();\n      self.$merge(enum$);\n      return self;\n    }, TMP_Set_replace_29.$$arity = 1);\n    \n    Opal.def(self, '$size', TMP_Set_size_30 = function $$size() {\n      var self = this;\n\n      return self.hash.$size()\n    }, TMP_Set_size_30.$$arity = 0);\n    Opal.alias(self, \"length\", \"size\");\n    \n    Opal.def(self, '$subtract', TMP_Set_subtract_32 = function $$subtract(enum$) {\n      var TMP_31, self = this;\n\n      \n      $send(enum$, 'each', [], (TMP_31 = function(item){var self = TMP_31.$$s || this;\nif (item == null) item = nil;\n      return self.$delete(item)}, TMP_31.$$s = self, TMP_31.$$arity = 1, TMP_31));\n      return self;\n    }, TMP_Set_subtract_32.$$arity = 1);\n    \n    Opal.def(self, '$|', TMP_Set_$_33 = function(enum$) {\n      var self = this;\n\n      \n      if ($truthy(enum$['$respond_to?'](\"each\"))) {\n      } else {\n        self.$raise($$($nesting, 'ArgumentError'), \"value must be enumerable\")\n      };\n      return self.$dup().$merge(enum$);\n    }, TMP_Set_$_33.$$arity = 1);\n    \n    Opal.def(self, '$superset?', TMP_Set_superset$q_35 = function(set) {\n      var $a, TMP_34, self = this;\n\n      \n      ($truthy($a = set['$is_a?']($$($nesting, 'Set'))) ? $a : self.$raise($$($nesting, 'ArgumentError'), \"value must be a set\"));\n      if ($truthy($rb_lt(self.$size(), set.$size()))) {\n        return false};\n      return $send(set, 'all?', [], (TMP_34 = function(o){var self = TMP_34.$$s || this;\nif (o == null) o = nil;\n      return self['$include?'](o)}, TMP_34.$$s = self, TMP_34.$$arity = 1, TMP_34));\n    }, TMP_Set_superset$q_35.$$arity = 1);\n    Opal.alias(self, \">=\", \"superset?\");\n    \n    Opal.def(self, '$proper_superset?', TMP_Set_proper_superset$q_37 = function(set) {\n      var $a, TMP_36, self = this;\n\n      \n      ($truthy($a = set['$is_a?']($$($nesting, 'Set'))) ? $a : self.$raise($$($nesting, 'ArgumentError'), \"value must be a set\"));\n      if ($truthy($rb_le(self.$size(), set.$size()))) {\n        return false};\n      return $send(set, 'all?', [], (TMP_36 = function(o){var self = TMP_36.$$s || this;\nif (o == null) o = nil;\n      return self['$include?'](o)}, TMP_36.$$s = self, TMP_36.$$arity = 1, TMP_36));\n    }, TMP_Set_proper_superset$q_37.$$arity = 1);\n    Opal.alias(self, \">\", \"proper_superset?\");\n    \n    Opal.def(self, '$subset?', TMP_Set_subset$q_39 = function(set) {\n      var $a, TMP_38, self = this;\n\n      \n      ($truthy($a = set['$is_a?']($$($nesting, 'Set'))) ? $a : self.$raise($$($nesting, 'ArgumentError'), \"value must be a set\"));\n      if ($truthy($rb_lt(set.$size(), self.$size()))) {\n        return false};\n      return $send(self, 'all?', [], (TMP_38 = function(o){var self = TMP_38.$$s || this;\nif (o == null) o = nil;\n      return set['$include?'](o)}, TMP_38.$$s = self, TMP_38.$$arity = 1, TMP_38));\n    }, TMP_Set_subset$q_39.$$arity = 1);\n    Opal.alias(self, \"<=\", \"subset?\");\n    \n    Opal.def(self, '$proper_subset?', TMP_Set_proper_subset$q_41 = function(set) {\n      var $a, TMP_40, self = this;\n\n      \n      ($truthy($a = set['$is_a?']($$($nesting, 'Set'))) ? $a : self.$raise($$($nesting, 'ArgumentError'), \"value must be a set\"));\n      if ($truthy($rb_le(set.$size(), self.$size()))) {\n        return false};\n      return $send(self, 'all?', [], (TMP_40 = function(o){var self = TMP_40.$$s || this;\nif (o == null) o = nil;\n      return set['$include?'](o)}, TMP_40.$$s = self, TMP_40.$$arity = 1, TMP_40));\n    }, TMP_Set_proper_subset$q_41.$$arity = 1);\n    Opal.alias(self, \"<\", \"proper_subset?\");\n    Opal.alias(self, \"+\", \"|\");\n    Opal.alias(self, \"union\", \"|\");\n    return (Opal.def(self, '$to_a', TMP_Set_to_a_42 = function $$to_a() {\n      var self = this;\n\n      return self.hash.$keys()\n    }, TMP_Set_to_a_42.$$arity = 0), nil) && 'to_a';\n  })($nesting[0], null, $nesting);\n  return (function($base, $parent_nesting) {\n    var $Enumerable, self = $Enumerable = $module($base, 'Enumerable');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Enumerable_to_set_43;\n\n    \n    Opal.def(self, '$to_set', TMP_Enumerable_to_set_43 = function $$to_set(klass, $a_rest) {\n      var self = this, args, $iter = TMP_Enumerable_to_set_43.$$p, block = $iter || nil;\n\n      if (klass == null) {\n        klass = $$($nesting, 'Set');\n      }\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      args = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        args[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Enumerable_to_set_43.$$p = null;\n      return $send(klass, 'new', [self].concat(Opal.to_a(args)), block.$to_proc())\n    }, TMP_Enumerable_to_set_43.$$arity = -1)\n  })($nesting[0], $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/js/opal_ext/file\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send, $klass = Opal.klass, $truthy = Opal.truthy, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$new', '$attr_reader', '$delete', '$gsub', '$read', '$size', '$to_enum', '$chomp', '$each_line', '$readlines', '$split']);\n  \n  (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_open_1;\n\n    \n    Opal.def(self, '$open', TMP_Kernel_open_1 = function $$open(path, $a_rest) {\n      var self = this, rest, $iter = TMP_Kernel_open_1.$$p, $yield = $iter || nil, file = nil;\n\n      var $args_len = arguments.length, $rest_len = $args_len - 1;\n      if ($rest_len < 0) { $rest_len = 0; }\n      rest = new Array($rest_len);\n      for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n        rest[$arg_idx - 1] = arguments[$arg_idx];\n      }\n      if ($iter) TMP_Kernel_open_1.$$p = null;\n      \n      file = $send($$($nesting, 'File'), 'new', [path].concat(Opal.to_a(rest)));\n      if (($yield !== nil)) {\n        return Opal.yield1($yield, file);\n      } else {\n        return file\n      };\n    }, TMP_Kernel_open_1.$$arity = -2)\n  })($nesting[0], $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $File(){};\n    var self = $File = $klass($base, $super, 'File', $File);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_File_initialize_2, TMP_File_read_3, TMP_File_each_line_4, TMP_File_readlines_5;\n\n    def.eof = def.path = nil;\n    \n    self.$attr_reader(\"eof\");\n    self.$attr_reader(\"lineno\");\n    self.$attr_reader(\"path\");\n    \n    Opal.def(self, '$initialize', TMP_File_initialize_2 = function $$initialize(path, flags) {\n      var self = this, encoding_flag_regexp = nil;\n\n      if (flags == null) {\n        flags = \"r\";\n      }\n      \n      self.path = path;\n      self.contents = nil;\n      self.eof = false;\n      self.lineno = 0;\n      flags = flags.$delete(\"b\");\n      encoding_flag_regexp = /:(.*)/;\n      flags = flags.$gsub(encoding_flag_regexp, \"\");\n      return (self.flags = flags);\n    }, TMP_File_initialize_2.$$arity = -2);\n    \n    Opal.def(self, '$read', TMP_File_read_3 = function $$read() {\n      var self = this, res = nil;\n\n      if ($truthy(self.eof)) {\n        return \"\"\n      } else {\n        \n        res = $$($nesting, 'File').$read(self.path);\n        self.eof = true;\n        self.lineno = res.$size();\n        return res;\n      }\n    }, TMP_File_read_3.$$arity = 0);\n    \n    Opal.def(self, '$each_line', TMP_File_each_line_4 = function $$each_line(separator) {\n      var self = this, $iter = TMP_File_each_line_4.$$p, block = $iter || nil, lines = nil;\n      if ($gvars[\"/\"] == null) $gvars[\"/\"] = nil;\n\n      if (separator == null) {\n        separator = $gvars[\"/\"];\n      }\n      if ($iter) TMP_File_each_line_4.$$p = null;\n      \n      if ($truthy(self.eof)) {\n        return (function() {if ((block !== nil)) {\n          return self\n        } else {\n          return [].$to_enum()\n        }; return nil; })()};\n      if ((block !== nil)) {\n        \n        lines = $$($nesting, 'File').$read(self.path);\n        \n        self.eof = false;\n        self.lineno = 0;\n        var chomped  = lines.$chomp(),\n            trailing = lines.length != chomped.length,\n            splitted = chomped.split(separator);\n        for (var i = 0, length = splitted.length; i < length; i++) {\n          self.lineno += 1;\n          if (i < length - 1 || trailing) {\n            Opal.yield1(block, splitted[i] + separator);\n          }\n          else {\n            Opal.yield1(block, splitted[i]);\n          }\n        }\n        self.eof = true;\n      ;\n        return self;\n      } else {\n        return self.$read().$each_line()\n      };\n    }, TMP_File_each_line_4.$$arity = -1);\n    \n    Opal.def(self, '$readlines', TMP_File_readlines_5 = function $$readlines() {\n      var self = this;\n\n      return $$($nesting, 'File').$readlines(self.path)\n    }, TMP_File_readlines_5.$$arity = 0);\n    return (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_readlines_6, TMP_file$q_7, TMP_readable$q_8, TMP_read_9;\n\n      \n      \n      Opal.def(self, '$readlines', TMP_readlines_6 = function $$readlines(path, separator) {\n        var self = this, content = nil;\n        if ($gvars[\"/\"] == null) $gvars[\"/\"] = nil;\n\n        if (separator == null) {\n          separator = $gvars[\"/\"];\n        }\n        \n        content = $$($nesting, 'File').$read(path);\n        return content.$split(separator);\n      }, TMP_readlines_6.$$arity = -2);\n      \n      Opal.def(self, '$file?', TMP_file$q_7 = function(path) {\n        var self = this;\n\n        return true\n      }, TMP_file$q_7.$$arity = 1);\n      \n      Opal.def(self, '$readable?', TMP_readable$q_8 = function(path) {\n        var self = this;\n\n        return true\n      }, TMP_readable$q_8.$$arity = 1);\n      return (Opal.def(self, '$read', TMP_read_9 = function $$read(path) {\n        var self = this;\n\n        return \"\"\n      }, TMP_read_9.$$arity = 1), nil) && 'read';\n    })(Opal.get_singleton_class(self), $nesting);\n  })($nesting[0], null, $nesting);\n  return (function($base, $super, $parent_nesting) {\n    function $IO(){};\n    var self = $IO = $klass($base, $super, 'IO', $IO);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_IO_read_10;\n\n    return (Opal.defs(self, '$read', TMP_IO_read_10 = function $$read(path) {\n      var self = this;\n\n      return $$($nesting, 'File').$read(path)\n    }, TMP_IO_read_10.$$arity = 1), nil) && 'read'\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/js/opal_ext/match_data\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$[]=', '$-']);\n  return (function($base, $super, $parent_nesting) {\n    function $MatchData(){};\n    var self = $MatchData = $klass($base, $super, 'MatchData', $MatchData);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_MatchData_$$$eq_1;\n\n    def.matches = nil;\n    return (Opal.def(self, '$[]=', TMP_MatchData_$$$eq_1 = function(idx, val) {\n      var self = this, $writer = nil;\n\n      \n      $writer = [idx, val];\n      $send(self.matches, '[]=', Opal.to_a($writer));\n      return $writer[$rb_minus($writer[\"length\"], 1)];\n    }, TMP_MatchData_$$$eq_1.$$arity = 2), nil) && '[]='\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/js/opal_ext/kernel\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;\n\n  return (function($base, $parent_nesting) {\n    var $Kernel, self = $Kernel = $module($base, 'Kernel');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Kernel_freeze_1;\n\n    \n    Opal.def(self, '$freeze', TMP_Kernel_freeze_1 = function $$freeze() {\n      var self = this;\n\n      return self\n    }, TMP_Kernel_freeze_1.$$arity = 0)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/js/opal_ext/thread_safe\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;\n\n  return (function($base, $parent_nesting) {\n    var $ThreadSafe, self = $ThreadSafe = $module($base, 'ThreadSafe');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Cache(){};\n      var self = $Cache = $klass($base, $super, 'Cache', $Cache);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return nil\n    })($nesting[0], $$$('::', 'Hash'), $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/js/opal_ext/string\"] = function(Opal) {\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$method_defined?', '$<', '$length', '$bytes', '$to_s', '$byteslice', '$==', '$with_index', '$select', '$[]', '$even?', '$_original_unpack']);\n  return (function($base, $super, $parent_nesting) {\n    function $String(){};\n    var self = $String = $klass($base, $super, 'String', $String);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String_limit_bytesize_1, TMP_String_unpack_3;\n\n    \n    if ($truthy(self['$method_defined?'](\"limit_bytesize\"))) {\n    } else {\n      \n      Opal.def(self, '$limit_bytesize', TMP_String_limit_bytesize_1 = function $$limit_bytesize(size) {\n        var self = this, result = nil;\n\n        \n        if ($truthy($rb_lt(size, self.$bytes().$length()))) {\n        } else {\n          return self.$to_s()\n        };\n        result = self.$byteslice(0, size);\n        return result.$to_s();\n      }, TMP_String_limit_bytesize_1.$$arity = 1)\n    };\n    if ($truthy(self['$method_defined?'](\"limit\"))) {\n    } else {\n      Opal.alias(self, \"limit\", \"limit_bytesize\")\n    };\n    Opal.alias(self, \"_original_unpack\", \"unpack\");\n    return (Opal.def(self, '$unpack', TMP_String_unpack_3 = function $$unpack(format) {\n      var TMP_2, self = this;\n\n      if (format['$=='](\"C3\")) {\n        return $send(self['$[]'](0, 3).$bytes().$select(), 'with_index', [], (TMP_2 = function(_, i){var self = TMP_2.$$s || this;\nif (_ == null) _ = nil;if (i == null) i = nil;\n        return i['$even?']()}, TMP_2.$$s = self, TMP_2.$$arity = 2, TMP_2))\n      } else {\n        return self.$_original_unpack(format)\n      }\n    }, TMP_String_unpack_3.$$arity = 1), nil) && 'unpack';\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/js/opal_ext/uri\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;\n\n  Opal.add_stubs(['$extend']);\n  return (function($base, $parent_nesting) {\n    var $URI, self = $URI = $module($base, 'URI');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_URI_parse_1, TMP_URI_path_2;\n\n    \n    Opal.defs(self, '$parse', TMP_URI_parse_1 = function $$parse(str) {\n      var self = this;\n\n      return str.$extend($$($nesting, 'URI'))\n    }, TMP_URI_parse_1.$$arity = 1);\n    \n    Opal.def(self, '$path', TMP_URI_path_2 = function $$path() {\n      var self = this;\n\n      return self\n    }, TMP_URI_path_2.$$arity = 0);\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/js/opal_ext\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;\n\n  Opal.add_stubs(['$require']);\n  \n  self.$require(\"asciidoctor/js/opal_ext/file\");\n  self.$require(\"asciidoctor/js/opal_ext/match_data\");\n  self.$require(\"asciidoctor/js/opal_ext/kernel\");\n  self.$require(\"asciidoctor/js/opal_ext/thread_safe\");\n  self.$require(\"asciidoctor/js/opal_ext/string\");\n  self.$require(\"asciidoctor/js/opal_ext/uri\");\n  \n// Load specific implementation\nself.$require(\"asciidoctor/js/opal_ext/browser\");\n;\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/js/rx\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send, $gvars = Opal.gvars, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$gsub', '$+', '$unpack_hex_range']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Asciidoctor_unpack_hex_range_2;\n\n    \n    Opal.const_set($nesting[0], 'HEX_RANGE_RX', /([A-F0-9]{4})(?:-([A-F0-9]{4}))?/);\n    Opal.defs(self, '$unpack_hex_range', TMP_Asciidoctor_unpack_hex_range_2 = function $$unpack_hex_range(str) {\n      var TMP_1, self = this;\n\n      return $send(str, 'gsub', [$$($nesting, 'HEX_RANGE_RX')], (TMP_1 = function(){var self = TMP_1.$$s || this, $a, $b;\n\n      return \"\" + \"\\\\u\" + ((($a = $gvars['~']) === nil ? nil : $a['$[]'](1))) + (($truthy($a = (($b = $gvars['~']) === nil ? nil : $b['$[]'](2))) ? \"\" + \"-\\\\u\" + ((($b = $gvars['~']) === nil ? nil : $b['$[]'](2))) : $a))}, TMP_1.$$s = self, TMP_1.$$arity = 0, TMP_1))\n    }, TMP_Asciidoctor_unpack_hex_range_2.$$arity = 1);\n    Opal.const_set($nesting[0], 'P_L', $rb_plus(\"A-Za-z\", self.$unpack_hex_range(\"00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D037F03860388-038A038C038E-03A103A3-03F503F7-0481048A-052F0531-055605590561-058705D0-05EA05F0-05F20620-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280840-085808A0-08B20904-0939093D09500958-09610971-09800985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10CF10CF20D05-0D0C0D0E-0D100D12-0D3A0D3D0D4E0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC-0EDF0F000F40-0F470F49-0F6C0F88-0F8C1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510C710CD10D0-10FA10FC-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA16F1-16F81700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191E1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1BBA-1BE51C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11CF51CF61D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209C21022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2CF22CF32D00-2D252D272D2D2D30-2D672D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31BA31F0-31FF3400-4DB54E00-9FCCA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A66EA67F-A69DA6A0-A6E5A717-A71FA722-A788A78B-A78EA790-A7ADA7B0A7B1A7F7-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFA9E0-A9E4A9E6-A9EFA9FA-A9FEAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA7E-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDAAE0-AAEAAAF2-AAF4AB01-AB06AB09-AB0EAB11-AB16AB20-AB26AB28-AB2EAB30-AB5AAB5C-AB5FAB64AB65ABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC\")));\n    Opal.const_set($nesting[0], 'P_Nl', self.$unpack_hex_range(\"16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF\"));\n    Opal.const_set($nesting[0], 'P_Nd', $rb_plus(\"0-9\", self.$unpack_hex_range(\"0660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0DE6-0DEF0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19D91A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9A9F0-A9F9AA50-AA59ABF0-ABF9FF10-FF19\")));\n    Opal.const_set($nesting[0], 'P_Pc', self.$unpack_hex_range(\"005F203F20402054FE33FE34FE4D-FE4FFF3F\"));\n    Opal.const_set($nesting[0], 'CC_ALPHA', \"\" + ($$($nesting, 'P_L')) + ($$($nesting, 'P_Nl')));\n    Opal.const_set($nesting[0], 'CG_ALPHA', \"\" + \"[\" + ($$($nesting, 'CC_ALPHA')) + \"]\");\n    Opal.const_set($nesting[0], 'CC_ALNUM', \"\" + ($$($nesting, 'CC_ALPHA')) + ($$($nesting, 'P_Nd')));\n    Opal.const_set($nesting[0], 'CG_ALNUM', \"\" + \"[\" + ($$($nesting, 'CC_ALNUM')) + \"]\");\n    Opal.const_set($nesting[0], 'CC_WORD', \"\" + ($$($nesting, 'CC_ALNUM')) + ($$($nesting, 'P_Pc')));\n    Opal.const_set($nesting[0], 'CG_WORD', \"\" + \"[\" + ($$($nesting, 'CC_WORD')) + \"]\");\n    Opal.const_set($nesting[0], 'CG_BLANK', \"[ \\\\t]\");\n    Opal.const_set($nesting[0], 'CC_EOL', \"(?=\\\\n|$)\");\n    Opal.const_set($nesting[0], 'CG_GRAPH', \"[^\\\\s\\\\x00-\\\\x1F\\\\x7F]\");\n    Opal.const_set($nesting[0], 'CC_ALL', \"[\\\\s\\\\S]\");\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"strscan\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_reader', '$anchor', '$scan_until', '$length', '$size', '$rest', '$pos=', '$-', '$private']);\n  return (function($base, $super, $parent_nesting) {\n    function $StringScanner(){};\n    var self = $StringScanner = $klass($base, $super, 'StringScanner', $StringScanner);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_StringScanner_initialize_1, TMP_StringScanner_beginning_of_line$q_2, TMP_StringScanner_scan_3, TMP_StringScanner_scan_until_4, TMP_StringScanner_$$_5, TMP_StringScanner_check_6, TMP_StringScanner_check_until_7, TMP_StringScanner_peek_8, TMP_StringScanner_eos$q_9, TMP_StringScanner_exist$q_10, TMP_StringScanner_skip_11, TMP_StringScanner_skip_until_12, TMP_StringScanner_get_byte_13, TMP_StringScanner_match$q_14, TMP_StringScanner_pos$eq_15, TMP_StringScanner_matched_size_16, TMP_StringScanner_post_match_17, TMP_StringScanner_pre_match_18, TMP_StringScanner_reset_19, TMP_StringScanner_rest_20, TMP_StringScanner_rest$q_21, TMP_StringScanner_rest_size_22, TMP_StringScanner_terminate_23, TMP_StringScanner_unscan_24, TMP_StringScanner_anchor_25;\n\n    def.pos = def.string = def.working = def.matched = def.prev_pos = def.match = nil;\n    \n    self.$attr_reader(\"pos\");\n    self.$attr_reader(\"matched\");\n    \n    Opal.def(self, '$initialize', TMP_StringScanner_initialize_1 = function $$initialize(string) {\n      var self = this;\n\n      \n      self.string = string;\n      self.pos = 0;\n      self.matched = nil;\n      self.working = string;\n      return (self.match = []);\n    }, TMP_StringScanner_initialize_1.$$arity = 1);\n    self.$attr_reader(\"string\");\n    \n    Opal.def(self, '$beginning_of_line?', TMP_StringScanner_beginning_of_line$q_2 = function() {\n      var self = this;\n\n      return self.pos === 0 || self.string.charAt(self.pos - 1) === \"\\n\"\n    }, TMP_StringScanner_beginning_of_line$q_2.$$arity = 0);\n    Opal.alias(self, \"bol?\", \"beginning_of_line?\");\n    \n    Opal.def(self, '$scan', TMP_StringScanner_scan_3 = function $$scan(pattern) {\n      var self = this;\n\n      \n      pattern = self.$anchor(pattern);\n      \n      var result = pattern.exec(self.working);\n\n      if (result == null) {\n        return self.matched = nil;\n      }\n      else if (typeof(result) === 'object') {\n        self.prev_pos = self.pos;\n        self.pos     += result[0].length;\n        self.working  = self.working.substring(result[0].length);\n        self.matched  = result[0];\n        self.match    = result;\n\n        return result[0];\n      }\n      else if (typeof(result) === 'string') {\n        self.pos     += result.length;\n        self.working  = self.working.substring(result.length);\n\n        return result;\n      }\n      else {\n        return nil;\n      }\n    ;\n    }, TMP_StringScanner_scan_3.$$arity = 1);\n    \n    Opal.def(self, '$scan_until', TMP_StringScanner_scan_until_4 = function $$scan_until(pattern) {\n      var self = this;\n\n      \n      pattern = self.$anchor(pattern);\n      \n      var pos     = self.pos,\n          working = self.working,\n          result;\n\n      while (true) {\n        result   = pattern.exec(working);\n        pos     += 1;\n        working  = working.substr(1);\n\n        if (result == null) {\n          if (working.length === 0) {\n            return self.matched = nil;\n          }\n\n          continue;\n        }\n\n        self.matched  = self.string.substr(self.pos, pos - self.pos - 1 + result[0].length);\n        self.prev_pos = pos - 1;\n        self.pos      = pos;\n        self.working  = working.substr(result[0].length);\n\n        return self.matched;\n      }\n    ;\n    }, TMP_StringScanner_scan_until_4.$$arity = 1);\n    \n    Opal.def(self, '$[]', TMP_StringScanner_$$_5 = function(idx) {\n      var self = this;\n\n      \n      var match = self.match;\n\n      if (idx < 0) {\n        idx += match.length;\n      }\n\n      if (idx < 0 || idx >= match.length) {\n        return nil;\n      }\n\n      if (match[idx] == null) {\n        return nil;\n      }\n\n      return match[idx];\n    \n    }, TMP_StringScanner_$$_5.$$arity = 1);\n    \n    Opal.def(self, '$check', TMP_StringScanner_check_6 = function $$check(pattern) {\n      var self = this;\n\n      \n      pattern = self.$anchor(pattern);\n      \n      var result = pattern.exec(self.working);\n\n      if (result == null) {\n        return self.matched = nil;\n      }\n\n      return self.matched = result[0];\n    ;\n    }, TMP_StringScanner_check_6.$$arity = 1);\n    \n    Opal.def(self, '$check_until', TMP_StringScanner_check_until_7 = function $$check_until(pattern) {\n      var self = this;\n\n      \n      var prev_pos = self.prev_pos,\n          pos      = self.pos;\n\n      var result = self.$scan_until(pattern);\n\n      if (result !== nil) {\n        self.matched = result.substr(-1);\n        self.working = self.string.substr(pos);\n      }\n\n      self.prev_pos = prev_pos;\n      self.pos      = pos;\n\n      return result;\n    \n    }, TMP_StringScanner_check_until_7.$$arity = 1);\n    \n    Opal.def(self, '$peek', TMP_StringScanner_peek_8 = function $$peek(length) {\n      var self = this;\n\n      return self.working.substring(0, length)\n    }, TMP_StringScanner_peek_8.$$arity = 1);\n    \n    Opal.def(self, '$eos?', TMP_StringScanner_eos$q_9 = function() {\n      var self = this;\n\n      return self.working.length === 0\n    }, TMP_StringScanner_eos$q_9.$$arity = 0);\n    \n    Opal.def(self, '$exist?', TMP_StringScanner_exist$q_10 = function(pattern) {\n      var self = this;\n\n      \n      var result = pattern.exec(self.working);\n\n      if (result == null) {\n        return nil;\n      }\n      else if (result.index == 0) {\n        return 0;\n      }\n      else {\n        return result.index + 1;\n      }\n    \n    }, TMP_StringScanner_exist$q_10.$$arity = 1);\n    \n    Opal.def(self, '$skip', TMP_StringScanner_skip_11 = function $$skip(pattern) {\n      var self = this;\n\n      \n      pattern = self.$anchor(pattern);\n      \n      var result = pattern.exec(self.working);\n\n      if (result == null) {\n        return self.matched = nil;\n      }\n      else {\n        var match_str = result[0];\n        var match_len = match_str.length;\n\n        self.matched   = match_str;\n        self.prev_pos  = self.pos;\n        self.pos      += match_len;\n        self.working   = self.working.substring(match_len);\n\n        return match_len;\n      }\n    ;\n    }, TMP_StringScanner_skip_11.$$arity = 1);\n    \n    Opal.def(self, '$skip_until', TMP_StringScanner_skip_until_12 = function $$skip_until(pattern) {\n      var self = this;\n\n      \n      var result = self.$scan_until(pattern);\n\n      if (result === nil) {\n        return nil;\n      }\n      else {\n        self.matched = result.substr(-1);\n\n        return result.length;\n      }\n    \n    }, TMP_StringScanner_skip_until_12.$$arity = 1);\n    \n    Opal.def(self, '$get_byte', TMP_StringScanner_get_byte_13 = function $$get_byte() {\n      var self = this;\n\n      \n      var result = nil;\n\n      if (self.pos < self.string.length) {\n        self.prev_pos  = self.pos;\n        self.pos      += 1;\n        result      = self.matched = self.working.substring(0, 1);\n        self.working   = self.working.substring(1);\n      }\n      else {\n        self.matched = nil;\n      }\n\n      return result;\n    \n    }, TMP_StringScanner_get_byte_13.$$arity = 0);\n    Opal.alias(self, \"getch\", \"get_byte\");\n    \n    Opal.def(self, '$match?', TMP_StringScanner_match$q_14 = function(pattern) {\n      var self = this;\n\n      \n      pattern = self.$anchor(pattern);\n      \n      var result = pattern.exec(self.working);\n\n      if (result == null) {\n        return nil;\n      }\n      else {\n        self.prev_pos = self.pos;\n\n        return result[0].length;\n      }\n    ;\n    }, TMP_StringScanner_match$q_14.$$arity = 1);\n    \n    Opal.def(self, '$pos=', TMP_StringScanner_pos$eq_15 = function(pos) {\n      var self = this;\n\n      \n      \n      if (pos < 0) {\n        pos += self.string.$length();\n      }\n    ;\n      self.pos = pos;\n      return (self.working = self.string.slice(pos));\n    }, TMP_StringScanner_pos$eq_15.$$arity = 1);\n    \n    Opal.def(self, '$matched_size', TMP_StringScanner_matched_size_16 = function $$matched_size() {\n      var self = this;\n\n      \n      if (self.matched === nil) {\n        return nil;\n      }\n\n      return self.matched.length\n    \n    }, TMP_StringScanner_matched_size_16.$$arity = 0);\n    \n    Opal.def(self, '$post_match', TMP_StringScanner_post_match_17 = function $$post_match() {\n      var self = this;\n\n      \n      if (self.matched === nil) {\n        return nil;\n      }\n\n      return self.string.substr(self.pos);\n    \n    }, TMP_StringScanner_post_match_17.$$arity = 0);\n    \n    Opal.def(self, '$pre_match', TMP_StringScanner_pre_match_18 = function $$pre_match() {\n      var self = this;\n\n      \n      if (self.matched === nil) {\n        return nil;\n      }\n\n      return self.string.substr(0, self.prev_pos);\n    \n    }, TMP_StringScanner_pre_match_18.$$arity = 0);\n    \n    Opal.def(self, '$reset', TMP_StringScanner_reset_19 = function $$reset() {\n      var self = this;\n\n      \n      self.working = self.string;\n      self.matched = nil;\n      return (self.pos = 0);\n    }, TMP_StringScanner_reset_19.$$arity = 0);\n    \n    Opal.def(self, '$rest', TMP_StringScanner_rest_20 = function $$rest() {\n      var self = this;\n\n      return self.working\n    }, TMP_StringScanner_rest_20.$$arity = 0);\n    \n    Opal.def(self, '$rest?', TMP_StringScanner_rest$q_21 = function() {\n      var self = this;\n\n      return self.working.length !== 0\n    }, TMP_StringScanner_rest$q_21.$$arity = 0);\n    \n    Opal.def(self, '$rest_size', TMP_StringScanner_rest_size_22 = function $$rest_size() {\n      var self = this;\n\n      return self.$rest().$size()\n    }, TMP_StringScanner_rest_size_22.$$arity = 0);\n    \n    Opal.def(self, '$terminate', TMP_StringScanner_terminate_23 = function $$terminate() {\n      var self = this, $writer = nil;\n\n      \n      self.match = nil;\n      \n      $writer = [self.string.$length()];\n      $send(self, 'pos=', Opal.to_a($writer));\n      return $writer[$rb_minus($writer[\"length\"], 1)];;\n    }, TMP_StringScanner_terminate_23.$$arity = 0);\n    \n    Opal.def(self, '$unscan', TMP_StringScanner_unscan_24 = function $$unscan() {\n      var self = this;\n\n      \n      self.pos = self.prev_pos;\n      self.prev_pos = nil;\n      self.match = nil;\n      return self;\n    }, TMP_StringScanner_unscan_24.$$arity = 0);\n    self.$private();\n    return (Opal.def(self, '$anchor', TMP_StringScanner_anchor_25 = function $$anchor(pattern) {\n      var self = this;\n\n      \n      var flags = pattern.toString().match(/\\/([^\\/]+)$/);\n      flags = flags ? flags[1] : undefined;\n      return new RegExp('^(?:' + pattern.source + ')', flags);\n    \n    }, TMP_StringScanner_anchor_25.$$arity = 1), nil) && 'anchor';\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/js\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;\n\n  Opal.add_stubs(['$require']);\n  \n  self.$require(\"asciidoctor/js/opal_ext\");\n  self.$require(\"asciidoctor/js/rx\");\n  return self.$require(\"strscan\");\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/timings\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$now', '$[]=', '$-', '$delete', '$>', '$+', '$[]', '$puts', '$%', '$to_f', '$read_parse', '$convert', '$read_parse_convert']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Timings(){};\n      var self = $Timings = $klass($base, $super, 'Timings', $Timings);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Timings_initialize_1, TMP_Timings_start_2, TMP_Timings_record_3, TMP_Timings_read_parse_4, TMP_Timings_convert_5, TMP_Timings_read_parse_convert_6, TMP_Timings_total_7, TMP_Timings_print_report_8;\n\n      def.timers = def.log = nil;\n      \n      \n      Opal.def(self, '$initialize', TMP_Timings_initialize_1 = function $$initialize() {\n        var self = this;\n\n        \n        self.log = $hash2([], {});\n        return (self.timers = $hash2([], {}));\n      }, TMP_Timings_initialize_1.$$arity = 0);\n      \n      Opal.def(self, '$start', TMP_Timings_start_2 = function $$start(key) {\n        var self = this, $writer = nil;\n\n        \n        $writer = [key, $$$('::', 'Time').$now()];\n        $send(self.timers, '[]=', Opal.to_a($writer));\n        return $writer[$rb_minus($writer[\"length\"], 1)];\n      }, TMP_Timings_start_2.$$arity = 1);\n      \n      Opal.def(self, '$record', TMP_Timings_record_3 = function $$record(key) {\n        var self = this, $writer = nil;\n\n        \n        $writer = [key, $rb_minus($$$('::', 'Time').$now(), self.timers.$delete(key))];\n        $send(self.log, '[]=', Opal.to_a($writer));\n        return $writer[$rb_minus($writer[\"length\"], 1)];\n      }, TMP_Timings_record_3.$$arity = 1);\n      \n      Opal.def(self, '$read_parse', TMP_Timings_read_parse_4 = function $$read_parse() {\n        var $a, self = this, time = nil;\n\n        if ($truthy($rb_gt((time = $rb_plus(($truthy($a = self.log['$[]'](\"read\")) ? $a : 0), ($truthy($a = self.log['$[]'](\"parse\")) ? $a : 0))), 0))) {\n          return time\n        } else {\n          return nil\n        }\n      }, TMP_Timings_read_parse_4.$$arity = 0);\n      \n      Opal.def(self, '$convert', TMP_Timings_convert_5 = function $$convert() {\n        var $a, self = this;\n\n        return ($truthy($a = self.log['$[]'](\"convert\")) ? $a : 0)\n      }, TMP_Timings_convert_5.$$arity = 0);\n      \n      Opal.def(self, '$read_parse_convert', TMP_Timings_read_parse_convert_6 = function $$read_parse_convert() {\n        var $a, self = this, time = nil;\n\n        if ($truthy($rb_gt((time = $rb_plus($rb_plus(($truthy($a = self.log['$[]'](\"read\")) ? $a : 0), ($truthy($a = self.log['$[]'](\"parse\")) ? $a : 0)), ($truthy($a = self.log['$[]'](\"convert\")) ? $a : 0))), 0))) {\n          return time\n        } else {\n          return nil\n        }\n      }, TMP_Timings_read_parse_convert_6.$$arity = 0);\n      \n      Opal.def(self, '$total', TMP_Timings_total_7 = function $$total() {\n        var $a, self = this, time = nil;\n\n        if ($truthy($rb_gt((time = $rb_plus($rb_plus($rb_plus(($truthy($a = self.log['$[]'](\"read\")) ? $a : 0), ($truthy($a = self.log['$[]'](\"parse\")) ? $a : 0)), ($truthy($a = self.log['$[]'](\"convert\")) ? $a : 0)), ($truthy($a = self.log['$[]'](\"write\")) ? $a : 0))), 0))) {\n          return time\n        } else {\n          return nil\n        }\n      }, TMP_Timings_total_7.$$arity = 0);\n      return (Opal.def(self, '$print_report', TMP_Timings_print_report_8 = function $$print_report(to, subject) {\n        var self = this;\n        if ($gvars.stdout == null) $gvars.stdout = nil;\n\n        if (to == null) {\n          to = $gvars.stdout;\n        }\n        if (subject == null) {\n          subject = nil;\n        }\n        \n        if ($truthy(subject)) {\n          to.$puts(\"\" + \"Input file: \" + (subject))};\n        to.$puts(\"\" + \"  Time to read and parse source: \" + (\"%05.5f\"['$%'](self.$read_parse().$to_f())));\n        to.$puts(\"\" + \"  Time to convert document: \" + (\"%05.5f\"['$%'](self.$convert().$to_f())));\n        return to.$puts(\"\" + \"  Total time (read, parse and convert): \" + (\"%05.5f\"['$%'](self.$read_parse_convert().$to_f())));\n      }, TMP_Timings_print_report_8.$$arity = -1), nil) && 'print_report';\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/version\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;\n\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    Opal.const_set($nesting[0], 'VERSION', \"1.5.6.2\")\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/core_ext/nil_or_empty\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$method_defined?']);\n  \n  (function($base, $super, $parent_nesting) {\n    function $NilClass(){};\n    var self = $NilClass = $klass($base, $super, 'NilClass', $NilClass);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    if ($truthy(self['$method_defined?'](\"nil_or_empty?\"))) {\n      return nil\n    } else {\n      return Opal.alias(self, \"nil_or_empty?\", \"nil?\")\n    }\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $String(){};\n    var self = $String = $klass($base, $super, 'String', $String);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    if ($truthy(self['$method_defined?'](\"nil_or_empty?\"))) {\n      return nil\n    } else {\n      return Opal.alias(self, \"nil_or_empty?\", \"empty?\")\n    }\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Array(){};\n    var self = $Array = $klass($base, $super, 'Array', $Array);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    if ($truthy(self['$method_defined?'](\"nil_or_empty?\"))) {\n      return nil\n    } else {\n      return Opal.alias(self, \"nil_or_empty?\", \"empty?\")\n    }\n  })($nesting[0], null, $nesting);\n  (function($base, $super, $parent_nesting) {\n    function $Hash(){};\n    var self = $Hash = $klass($base, $super, 'Hash', $Hash);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    if ($truthy(self['$method_defined?'](\"nil_or_empty?\"))) {\n      return nil\n    } else {\n      return Opal.alias(self, \"nil_or_empty?\", \"empty?\")\n    }\n  })($nesting[0], null, $nesting);\n  return (function($base, $super, $parent_nesting) {\n    function $Numeric(){};\n    var self = $Numeric = $klass($base, $super, 'Numeric', $Numeric);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    if ($truthy(self['$method_defined?'](\"nil_or_empty?\"))) {\n      return nil\n    } else {\n      return Opal.alias(self, \"nil_or_empty?\", \"nil?\")\n    }\n  })($nesting[0], null, $nesting);\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/core_ext/regexp/is_match\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$method_defined?']);\n  return (function($base, $super, $parent_nesting) {\n    function $Regexp(){};\n    var self = $Regexp = $klass($base, $super, 'Regexp', $Regexp);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    if ($truthy(self['$method_defined?'](\"match?\"))) {\n      return nil\n    } else {\n      return Opal.alias(self, \"match?\", \"===\")\n    }\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/core_ext/string/limit_bytesize\"] = function(Opal) {\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$method_defined?', '$<', '$bytesize', '$valid_encoding?', '$force_encoding', '$byteslice', '$-']);\n  return (function($base, $super, $parent_nesting) {\n    function $String(){};\n    var self = $String = $klass($base, $super, 'String', $String);\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_String_limit_bytesize_1;\n\n    if ($truthy(self['$method_defined?'](\"limit_bytesize\"))) {\n      return nil\n    } else {\n      return (Opal.def(self, '$limit_bytesize', TMP_String_limit_bytesize_1 = function $$limit_bytesize(size) {\n        var $a, self = this, result = nil;\n\n        \n        if ($truthy($rb_lt(size, self.$bytesize()))) {\n        } else {\n          return self\n        };\n        while (!($truthy((result = self.$byteslice(0, size)).$force_encoding($$$($$$('::', 'Encoding'), 'UTF_8'))['$valid_encoding?']()))) {\n          size = $rb_minus(size, 1)\n        };\n        return result;\n      }, TMP_String_limit_bytesize_1.$$arity = 1), nil) && 'limit_bytesize'\n    }\n  })($nesting[0], null, $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/core_ext/1.8.7/io/write\"] = function(Opal) {\n  var TMP_write_2, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$respond_to?', '$open', '$write']);\n  if ($truthy($$($nesting, 'IO')['$respond_to?'](\"write\"))) {\n    return nil\n  } else {\n    return (Opal.defs($$($nesting, 'IO'), '$write', TMP_write_2 = function $$write(name, string, offset, opts) {\n      var TMP_1, self = this;\n\n      if (offset == null) {\n        offset = 0;\n      }\n      if (opts == null) {\n        opts = nil;\n      }\n      return $send($$($nesting, 'File'), 'open', [name, \"w\"], (TMP_1 = function(f){var self = TMP_1.$$s || this;\nif (f == null) f = nil;\n      return f.$write(string)}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1))\n    }, TMP_write_2.$$arity = -3), nil) && 'write'\n  }\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/core_ext\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$require', '$==', '$!=']);\n  \n  self.$require(\"asciidoctor/core_ext/nil_or_empty\");\n  self.$require(\"asciidoctor/core_ext/regexp/is_match\");\n  if ($truthy($$($nesting, 'RUBY_MIN_VERSION_1_9'))) {\n    \n    self.$require(\"asciidoctor/core_ext/string/limit_bytesize\");\n    if ($$($nesting, 'RUBY_ENGINE')['$=='](\"opal\")) {\n      return self.$require(\"asciidoctor/core_ext/1.8.7/io/write\")\n    } else {\n      return nil\n    };\n  } else if ($truthy($$($nesting, 'RUBY_ENGINE')['$!='](\"opal\"))) {\n    return nil\n  } else {\n    return nil\n  };\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/helpers\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$require', '$==', '$===', '$raise', '$warn', '$chomp', '$message', '$class', '$normalize_lines_from_string', '$normalize_lines_array', '$empty?', '$unpack', '$[]', '$slice', '$map', '$each_line', '$encode', '$force_encoding', '$join', '$rstrip', '$[]=', '$-', '$encoding', '$nil_or_empty?', '$include?', '$match?', '$=~', '$gsub', '$each_byte', '$sprintf', '$rindex', '$length', '$basename', '$extname', '$directory?', '$dirname', '$!', '$!=', '$mkdir_p', '$mkdir']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Helpers, self = $Helpers = $module($base, 'Helpers');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Helpers_require_library_1, TMP_Helpers_normalize_lines_2, TMP_Helpers_normalize_lines_array_7, TMP_Helpers_normalize_lines_from_string_9, TMP_Helpers_uriish$q_10, TMP_Helpers_uri_prefix_11, TMP_Helpers_uri_encode_14, TMP_Helpers_rootname_15, TMP_Helpers_basename_16, TMP_Helpers_mkdir_p_17;\n\n      \n      Opal.defs(self, '$require_library', TMP_Helpers_require_library_1 = function $$require_library(name, gem_name, on_failure) {\n        var self = this, e = nil, $case = nil;\n\n        if (gem_name == null) {\n          gem_name = true;\n        }\n        if (on_failure == null) {\n          on_failure = \"abort\";\n        }\n        try {\n          return self.$require(name)\n        } catch ($err) {\n          if (Opal.rescue($err, [$$$('::', 'LoadError')])) {e = $err;\n            try {\n              if ($truthy(gem_name)) {\n                \n                if (gem_name['$=='](true)) {\n                  gem_name = name};\n                return (function() {$case = on_failure;\n                if (\"abort\"['$===']($case)) {return self.$raise($$$('::', 'LoadError'), \"\" + \"asciidoctor: FAILED: required gem '\" + (gem_name) + \"' is not installed. Processing aborted.\")}\n                else if (\"warn\"['$===']($case)) {return self.$warn(\"\" + \"asciidoctor: WARNING: optional gem '\" + (gem_name) + \"' is not installed. Functionality disabled.\")}\n                else { return nil }})();\n              } else {\n                return (function() {$case = on_failure;\n                if (\"abort\"['$===']($case)) {return self.$raise($$$('::', 'LoadError'), \"\" + \"asciidoctor: FAILED: \" + (e.$message().$chomp(\".\")) + \". Processing aborted.\")}\n                else if (\"warn\"['$===']($case)) {return self.$warn(\"\" + \"asciidoctor: WARNING: \" + (e.$message().$chomp(\".\")) + \". Functionality disabled.\")}\n                else { return nil }})()\n              }\n            } finally { Opal.pop_exception() }\n          } else { throw $err; }\n        }\n      }, TMP_Helpers_require_library_1.$$arity = -2);\n      Opal.defs(self, '$normalize_lines', TMP_Helpers_normalize_lines_2 = function $$normalize_lines(data) {\n        var self = this;\n\n        if (data.$class()['$==']($$$('::', 'String'))) {\n          \n          return self.$normalize_lines_from_string(data);\n        } else {\n          \n          return self.$normalize_lines_array(data);\n        }\n      }, TMP_Helpers_normalize_lines_2.$$arity = 1);\n      Opal.defs(self, '$normalize_lines_array', TMP_Helpers_normalize_lines_array_7 = function $$normalize_lines_array(data) {\n        var TMP_3, TMP_4, TMP_5, TMP_6, self = this, leading_bytes = nil, first_line = nil, utf8 = nil, leading_2_bytes = nil, $writer = nil;\n\n        \n        if ($truthy(data['$empty?']())) {\n          return data};\n        leading_bytes = (first_line = data['$[]'](0)).$unpack(\"C3\");\n        if ($truthy($$($nesting, 'COERCE_ENCODING'))) {\n          \n          utf8 = $$$($$$('::', 'Encoding'), 'UTF_8');\n          if ((leading_2_bytes = leading_bytes.$slice(0, 2))['$==']($$($nesting, 'BOM_BYTES_UTF_16LE'))) {\n            return $send(data.$join().$force_encoding($$$($$$('::', 'Encoding'), 'UTF_16LE'))['$[]']($range(1, -1, false)).$encode(utf8).$each_line(), 'map', [], (TMP_3 = function(line){var self = TMP_3.$$s || this;\nif (line == null) line = nil;\n            return line.$rstrip()}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3))\n          } else if (leading_2_bytes['$==']($$($nesting, 'BOM_BYTES_UTF_16BE'))) {\n            \n            \n            $writer = [0, first_line.$force_encoding($$$($$$('::', 'Encoding'), 'UTF_16BE'))['$[]']($range(1, -1, false))];\n            $send(data, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            return $send(data, 'map', [], (TMP_4 = function(line){var self = TMP_4.$$s || this;\nif (line == null) line = nil;\n            return \"\" + (line.$force_encoding($$$($$$('::', 'Encoding'), 'UTF_16BE')).$encode(utf8).$rstrip())}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4));\n          } else if (leading_bytes['$==']($$($nesting, 'BOM_BYTES_UTF_8'))) {\n            \n            $writer = [0, first_line.$force_encoding(utf8)['$[]']($range(1, -1, false))];\n            $send(data, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];};\n          return $send(data, 'map', [], (TMP_5 = function(line){var self = TMP_5.$$s || this;\nif (line == null) line = nil;\n          if (line.$encoding()['$=='](utf8)) {\n              return line.$rstrip()\n            } else {\n              return line.$force_encoding(utf8).$rstrip()\n            }}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));\n        } else {\n          \n          if (leading_bytes['$==']($$($nesting, 'BOM_BYTES_UTF_8'))) {\n            \n            $writer = [0, first_line['$[]']($range(3, -1, false))];\n            $send(data, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];};\n          return $send(data, 'map', [], (TMP_6 = function(line){var self = TMP_6.$$s || this;\nif (line == null) line = nil;\n          return line.$rstrip()}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6));\n        };\n      }, TMP_Helpers_normalize_lines_array_7.$$arity = 1);\n      Opal.defs(self, '$normalize_lines_from_string', TMP_Helpers_normalize_lines_from_string_9 = function $$normalize_lines_from_string(data) {\n        var TMP_8, self = this, leading_bytes = nil, utf8 = nil, leading_2_bytes = nil;\n\n        \n        if ($truthy(data['$nil_or_empty?']())) {\n          return []};\n        leading_bytes = data.$unpack(\"C3\");\n        if ($truthy($$($nesting, 'COERCE_ENCODING'))) {\n          \n          utf8 = $$$($$$('::', 'Encoding'), 'UTF_8');\n          if ((leading_2_bytes = leading_bytes.$slice(0, 2))['$==']($$($nesting, 'BOM_BYTES_UTF_16LE'))) {\n            data = data.$force_encoding($$$($$$('::', 'Encoding'), 'UTF_16LE'))['$[]']($range(1, -1, false)).$encode(utf8)\n          } else if (leading_2_bytes['$==']($$($nesting, 'BOM_BYTES_UTF_16BE'))) {\n            data = data.$force_encoding($$$($$$('::', 'Encoding'), 'UTF_16BE'))['$[]']($range(1, -1, false)).$encode(utf8)\n          } else if (leading_bytes['$==']($$($nesting, 'BOM_BYTES_UTF_8'))) {\n            data = (function() {if (data.$encoding()['$=='](utf8)) {\n              return data['$[]']($range(1, -1, false))\n            } else {\n              return data.$force_encoding(utf8)['$[]']($range(1, -1, false))\n            }; return nil; })()\n          } else if (data.$encoding()['$=='](utf8)) {\n          } else {\n            data = data.$force_encoding(utf8)\n          };\n        } else if (leading_bytes['$==']($$($nesting, 'BOM_BYTES_UTF_8'))) {\n          data = data['$[]']($range(3, -1, false))};\n        return $send(data.$each_line(), 'map', [], (TMP_8 = function(line){var self = TMP_8.$$s || this;\nif (line == null) line = nil;\n        return line.$rstrip()}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8));\n      }, TMP_Helpers_normalize_lines_from_string_9.$$arity = 1);\n      Opal.defs(self, '$uriish?', TMP_Helpers_uriish$q_10 = function(str) {\n        var $a, self = this;\n\n        return ($truthy($a = str['$include?'](\":\")) ? $$($nesting, 'UriSniffRx')['$match?'](str) : $a)\n      }, TMP_Helpers_uriish$q_10.$$arity = 1);\n      Opal.defs(self, '$uri_prefix', TMP_Helpers_uri_prefix_11 = function $$uri_prefix(str) {\n        var $a, self = this;\n\n        if ($truthy(($truthy($a = str['$include?'](\":\")) ? $$($nesting, 'UriSniffRx')['$=~'](str) : $a))) {\n          return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0))\n        } else {\n          return nil\n        }\n      }, TMP_Helpers_uri_prefix_11.$$arity = 1);\n      Opal.const_set($nesting[0], 'REGEXP_ENCODE_URI_CHARS', /[^\\w\\-.!~*';:@=+$,()\\[\\]]/);\n      Opal.defs(self, '$uri_encode', TMP_Helpers_uri_encode_14 = function $$uri_encode(str) {\n        var TMP_12, self = this;\n\n        return $send(str, 'gsub', [$$($nesting, 'REGEXP_ENCODE_URI_CHARS')], (TMP_12 = function(){var self = TMP_12.$$s || this, $a, TMP_13;\n\n        return $send((($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$each_byte(), 'map', [], (TMP_13 = function(c){var self = TMP_13.$$s || this;\nif (c == null) c = nil;\n          return self.$sprintf(\"%%%02X\", c)}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13)).$join()}, TMP_12.$$s = self, TMP_12.$$arity = 0, TMP_12))\n      }, TMP_Helpers_uri_encode_14.$$arity = 1);\n      Opal.defs(self, '$rootname', TMP_Helpers_rootname_15 = function $$rootname(filename) {\n        var $a, self = this;\n\n        return filename.$slice(0, ($truthy($a = filename.$rindex(\".\")) ? $a : filename.$length()))\n      }, TMP_Helpers_rootname_15.$$arity = 1);\n      Opal.defs(self, '$basename', TMP_Helpers_basename_16 = function $$basename(filename, drop_ext) {\n        var self = this;\n\n        if (drop_ext == null) {\n          drop_ext = nil;\n        }\n        if ($truthy(drop_ext)) {\n          return $$$('::', 'File').$basename(filename, (function() {if (drop_ext['$=='](true)) {\n            \n            return $$$('::', 'File').$extname(filename);\n          } else {\n            return drop_ext\n          }; return nil; })())\n        } else {\n          return $$$('::', 'File').$basename(filename)\n        }\n      }, TMP_Helpers_basename_16.$$arity = -2);\n      Opal.defs(self, '$mkdir_p', TMP_Helpers_mkdir_p_17 = function $$mkdir_p(dir) {\n        var $a, self = this, parent_dir = nil;\n\n        if ($truthy($$$('::', 'File')['$directory?'](dir))) {\n          return nil\n        } else {\n          \n          parent_dir = $$$('::', 'File').$dirname(dir);\n          if ($truthy(($truthy($a = $$$('::', 'File')['$directory?']((parent_dir = $$$('::', 'File').$dirname(dir)))['$!']()) ? parent_dir['$!='](\".\") : $a))) {\n            self.$mkdir_p(parent_dir)};\n          return $$$('::', 'Dir').$mkdir(dir);\n        }\n      }, TMP_Helpers_mkdir_p_17.$$arity = 1);\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/substitutors\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2, $hash = Opal.hash, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars, $range = Opal.range;\n\n  Opal.add_stubs(['$freeze', '$+', '$keys', '$attr_reader', '$empty?', '$!', '$===', '$[]', '$each', '$<<', '$*', '$include?', '$extract_passthroughs', '$sub_specialchars', '$sub_quotes', '$sub_attributes', '$split', '$sub_replacements', '$sub_macros', '$highlight_source', '$sub_callouts', '$sub_post_replacements', '$warn', '$restore_passthroughs', '$apply_subs', '$compat_mode', '$gsub', '$==', '$length', '$>', '$-', '$end_with?', '$parse_attributes', '$size', '$[]=', '$unescape_brackets', '$resolve_pass_subs', '$start_with?', '$to_sym', '$nil_or_empty?', '$attributes', '$basebackend?', '$to_i', '$convert', '$new', '$clear', '$match?', '$convert_quoted_text', '$do_replacement', '$sub', '$shift', '$store_attribute', '$fetch', '$attribute_undefined', '$counter', '$key?', '$downcase', '$attribute_missing', '$slice', '$strip', '$index', '$min', '$compact', '$map', '$chop', '$unescape_bracketed_text', '$pop', '$rstrip', '$extensions', '$inline_macros?', '$inline_macros', '$regexp', '$instance', '$names', '$config', '$dup', '$!=', '$process_method', '$register', '$tr', '$basename', '$split_simple_csv', '$normalize_string', '$!~', '$delete', '$uri_encode', '$sub_inline_xrefs', '$sub_inline_anchors', '$find', '$footnotes', '$id', '$text', '$style', '$lstrip', '$rindex', '$catalog', '$key', '$attr?', '$escape', '$attr', '$read_next_id', '$callouts', '$<', '$parse_quoted_text_attributes', '$shorthand_property_syntax', '$concat', '$parse_into', '$parse', '$each_char', '$join', '$chr', '$&', '$resolve_subs', '$nil?', '$require_library', '$set_attr', '$sub_source', '$resolve_highlight_lines', '$highlight', '$find_by_alias', '$find_by_mimetype', '$name', '$option?', '$=~', '$to_a', '$uniq', '$sort', '$resolve_block_subs']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Substitutors, self = $Substitutors = $module($base, 'Substitutors');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Substitutors_apply_subs_3, TMP_Substitutors_apply_normal_subs_4, TMP_Substitutors_apply_title_subs_5, TMP_Substitutors_apply_reftext_subs_6, TMP_Substitutors_apply_header_subs_7, TMP_Substitutors_extract_passthroughs_11, TMP_Substitutors_restore_passthroughs_13, TMP_Substitutors_sub_quotes_16, TMP_Substitutors_sub_replacements_19, TMP_Substitutors_sub_specialchars_20, TMP_Substitutors_do_replacement_21, TMP_Substitutors_sub_attributes_24, TMP_Substitutors_sub_macros_41, TMP_Substitutors_sub_inline_anchors_44, TMP_Substitutors_sub_inline_xrefs_46, TMP_Substitutors_sub_callouts_48, TMP_Substitutors_sub_post_replacements_51, TMP_Substitutors_convert_quoted_text_52, TMP_Substitutors_parse_quoted_text_attributes_53, TMP_Substitutors_parse_attributes_54, TMP_Substitutors_unescape_bracketed_text_55, TMP_Substitutors_normalize_string_56, TMP_Substitutors_unescape_brackets_57, TMP_Substitutors_split_simple_csv_60, TMP_Substitutors_resolve_subs_62, TMP_Substitutors_resolve_block_subs_63, TMP_Substitutors_resolve_pass_subs_64, TMP_Substitutors_highlight_source_69, TMP_Substitutors_resolve_highlight_lines_71, TMP_Substitutors_sub_source_72, TMP_Substitutors_lock_in_subs_73;\n\n      \n      Opal.const_set($nesting[0], 'SpecialCharsRx', /[<&>]/);\n      Opal.const_set($nesting[0], 'SpecialCharsTr', $hash2([\">\", \"<\", \"&\"], {\">\": \"&gt;\", \"<\": \"&lt;\", \"&\": \"&amp;\"}));\n      Opal.const_set($nesting[0], 'QuotedTextSniffRx', $hash(false, /[*_`#^~]/, true, /[*'_+#^~]/));\n      Opal.const_set($nesting[0], 'BASIC_SUBS', [\"specialcharacters\"]).$freeze();\n      Opal.const_set($nesting[0], 'HEADER_SUBS', [\"specialcharacters\", \"attributes\"]).$freeze();\n      Opal.const_set($nesting[0], 'NORMAL_SUBS', [\"specialcharacters\", \"quotes\", \"attributes\", \"replacements\", \"macros\", \"post_replacements\"]).$freeze();\n      Opal.const_set($nesting[0], 'NONE_SUBS', []).$freeze();\n      Opal.const_set($nesting[0], 'TITLE_SUBS', [\"specialcharacters\", \"quotes\", \"replacements\", \"macros\", \"attributes\", \"post_replacements\"]).$freeze();\n      Opal.const_set($nesting[0], 'REFTEXT_SUBS', [\"specialcharacters\", \"quotes\", \"replacements\"]).$freeze();\n      Opal.const_set($nesting[0], 'VERBATIM_SUBS', [\"specialcharacters\", \"callouts\"]).$freeze();\n      Opal.const_set($nesting[0], 'SUB_GROUPS', $hash2([\"none\", \"normal\", \"verbatim\", \"specialchars\"], {\"none\": $$($nesting, 'NONE_SUBS'), \"normal\": $$($nesting, 'NORMAL_SUBS'), \"verbatim\": $$($nesting, 'VERBATIM_SUBS'), \"specialchars\": $$($nesting, 'BASIC_SUBS')}));\n      Opal.const_set($nesting[0], 'SUB_HINTS', $hash2([\"a\", \"m\", \"n\", \"p\", \"q\", \"r\", \"c\", \"v\"], {\"a\": \"attributes\", \"m\": \"macros\", \"n\": \"normal\", \"p\": \"post_replacements\", \"q\": \"quotes\", \"r\": \"replacements\", \"c\": \"specialcharacters\", \"v\": \"verbatim\"}));\n      Opal.const_set($nesting[0], 'SUB_OPTIONS', $hash2([\"block\", \"inline\"], {\"block\": $rb_plus($rb_plus($$($nesting, 'SUB_GROUPS').$keys(), $$($nesting, 'NORMAL_SUBS')), [\"callouts\"]), \"inline\": $rb_plus($$($nesting, 'SUB_GROUPS').$keys(), $$($nesting, 'NORMAL_SUBS'))}));\n      Opal.const_set($nesting[0], 'SUB_HIGHLIGHT', [\"coderay\", \"pygments\"]);\n      Opal.const_set($nesting[0], 'PASS_START', \"\\u0096\");\n      Opal.const_set($nesting[0], 'PASS_END', \"\\u0097\");\n      Opal.const_set($nesting[0], 'PassSlotRx', new RegExp(\"\" + ($$($nesting, 'PASS_START')) + \"(\\\\d+)\" + ($$($nesting, 'PASS_END'))));\n      Opal.const_set($nesting[0], 'HighlightedPassSlotRx', new RegExp(\"\" + \"<span\\\\b[^>]*>\" + ($$($nesting, 'PASS_START')) + \"</span>[^\\\\d]*(\\\\d+)[^\\\\d]*<span\\\\b[^>]*>\" + ($$($nesting, 'PASS_END')) + \"</span>\"));\n      Opal.const_set($nesting[0], 'RS', \"\\\\\");\n      Opal.const_set($nesting[0], 'R_SB', \"]\");\n      Opal.const_set($nesting[0], 'ESC_R_SB', \"\\\\]\");\n      Opal.const_set($nesting[0], 'PLUS', \"+\");\n      Opal.const_set($nesting[0], 'PygmentsWrapperDivRx', /<div class=\"pyhl\">(.*)<\\/div>/m);\n      Opal.const_set($nesting[0], 'PygmentsWrapperPreRx', /<pre\\b[^>]*?>(.*?)<\\/pre>\\s*/m);\n      self.$attr_reader(\"passthroughs\");\n      \n      Opal.def(self, '$apply_subs', TMP_Substitutors_apply_subs_3 = function $$apply_subs(source, subs, expand) {\n        var $a, TMP_1, TMP_2, self = this, effective_subs = nil, text = nil, multiline = nil, has_passthroughs = nil;\n        if (self.passthroughs == null) self.passthroughs = nil;\n\n        if (subs == null) {\n          subs = $$($nesting, 'NORMAL_SUBS');\n        }\n        if (expand == null) {\n          expand = nil;\n        }\n        \n        if ($truthy(($truthy($a = source['$empty?']()) ? $a : subs['$!']()))) {\n          return source\n        } else if ($truthy(expand)) {\n          if ($truthy($$$('::', 'Symbol')['$==='](subs))) {\n            subs = ($truthy($a = $$($nesting, 'SUB_GROUPS')['$[]'](subs)) ? $a : [subs])\n          } else {\n            \n            effective_subs = [];\n            $send(subs, 'each', [], (TMP_1 = function(key){var self = TMP_1.$$s || this, sub_group = nil;\nif (key == null) key = nil;\n            if ($truthy((sub_group = $$($nesting, 'SUB_GROUPS')['$[]'](key)))) {\n                if ($truthy(sub_group['$empty?']())) {\n                  return nil\n                } else {\n                  return (effective_subs = $rb_plus(effective_subs, sub_group))\n                }\n              } else {\n                return effective_subs['$<<'](key)\n              }}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1));\n            if ($truthy((subs = effective_subs)['$empty?']())) {\n              return source};\n          }\n        } else if ($truthy(subs['$empty?']())) {\n          return source};\n        text = (function() {if ($truthy((multiline = $$$('::', 'Array')['$==='](source)))) {\n          return $rb_times(source, $$($nesting, 'LF'))\n        } else {\n          return source\n        }; return nil; })();\n        if ($truthy((has_passthroughs = subs['$include?'](\"macros\")))) {\n          \n          text = self.$extract_passthroughs(text);\n          if ($truthy(self.passthroughs['$empty?']())) {\n            has_passthroughs = false};};\n        $send(subs, 'each', [], (TMP_2 = function(type){var self = TMP_2.$$s || this, $case = nil;\nif (type == null) type = nil;\n        return (function() {$case = type;\n          if (\"specialcharacters\"['$===']($case)) {return (text = self.$sub_specialchars(text))}\n          else if (\"quotes\"['$===']($case)) {return (text = self.$sub_quotes(text))}\n          else if (\"attributes\"['$===']($case)) {if ($truthy(text['$include?']($$($nesting, 'ATTR_REF_HEAD')))) {\n            return (text = $rb_times(self.$sub_attributes(text.$split($$($nesting, 'LF'), -1)), $$($nesting, 'LF')))\n          } else {\n            return nil\n          }}\n          else if (\"replacements\"['$===']($case)) {return (text = self.$sub_replacements(text))}\n          else if (\"macros\"['$===']($case)) {return (text = self.$sub_macros(text))}\n          else if (\"highlight\"['$===']($case)) {return (text = self.$highlight_source(text, subs['$include?'](\"callouts\")))}\n          else if (\"callouts\"['$===']($case)) {if ($truthy(subs['$include?'](\"highlight\"))) {\n            return nil\n          } else {\n            return (text = self.$sub_callouts(text))\n          }}\n          else if (\"post_replacements\"['$===']($case)) {return (text = self.$sub_post_replacements(text))}\n          else {return self.$warn(\"\" + \"asciidoctor: WARNING: unknown substitution type \" + (type))}})()}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2));\n        if ($truthy(has_passthroughs)) {\n          text = self.$restore_passthroughs(text)};\n        if ($truthy(multiline)) {\n          \n          return text.$split($$($nesting, 'LF'), -1);\n        } else {\n          return text\n        };\n      }, TMP_Substitutors_apply_subs_3.$$arity = -2);\n      \n      Opal.def(self, '$apply_normal_subs', TMP_Substitutors_apply_normal_subs_4 = function $$apply_normal_subs(text) {\n        var self = this;\n\n        return self.$apply_subs(text)\n      }, TMP_Substitutors_apply_normal_subs_4.$$arity = 1);\n      \n      Opal.def(self, '$apply_title_subs', TMP_Substitutors_apply_title_subs_5 = function $$apply_title_subs(title) {\n        var self = this;\n\n        return self.$apply_subs(title, $$($nesting, 'TITLE_SUBS'))\n      }, TMP_Substitutors_apply_title_subs_5.$$arity = 1);\n      \n      Opal.def(self, '$apply_reftext_subs', TMP_Substitutors_apply_reftext_subs_6 = function $$apply_reftext_subs(text) {\n        var self = this;\n\n        return self.$apply_subs(text, $$($nesting, 'REFTEXT_SUBS'))\n      }, TMP_Substitutors_apply_reftext_subs_6.$$arity = 1);\n      \n      Opal.def(self, '$apply_header_subs', TMP_Substitutors_apply_header_subs_7 = function $$apply_header_subs(text) {\n        var self = this;\n\n        return self.$apply_subs(text, $$($nesting, 'HEADER_SUBS'))\n      }, TMP_Substitutors_apply_header_subs_7.$$arity = 1);\n      \n      Opal.def(self, '$extract_passthroughs', TMP_Substitutors_extract_passthroughs_11 = function $$extract_passthroughs(text) {\n        var $a, $b, TMP_8, TMP_9, TMP_10, self = this, compat_mode = nil, pass_inline_char1 = nil, pass_inline_char2 = nil, pass_inline_rx = nil;\n        if (self.document == null) self.document = nil;\n\n        \n        compat_mode = self.document.$compat_mode();\n        if ($truthy(($truthy($a = ($truthy($b = text['$include?'](\"++\")) ? $b : text['$include?'](\"$$\"))) ? $a : text['$include?'](\"ss:\")))) {\n          text = $send(text, 'gsub', [$$($nesting, 'InlinePassMacroRx')], (TMP_8 = function(){var self = TMP_8.$$s || this, $c, m = nil, preceding = nil, boundary = nil, attributes = nil, escape_count = nil, content = nil, old_behavior = nil, subs = nil, pass_key = nil, $writer = nil;\n            if (self.passthroughs == null) self.passthroughs = nil;\n            if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n          \n            m = $gvars[\"~\"];\n            preceding = nil;\n            if ($truthy((boundary = m['$[]'](4)))) {\n              \n              if ($truthy(($truthy($c = compat_mode) ? boundary['$=='](\"++\") : $c))) {\n                return (function() {if ($truthy(m['$[]'](2))) {\n                  return \"\" + (m['$[]'](1)) + \"[\" + (m['$[]'](2)) + \"]\" + (m['$[]'](3)) + \"++\" + (self.$extract_passthroughs(m['$[]'](5))) + \"++\"\n                } else {\n                  return \"\" + (m['$[]'](1)) + (m['$[]'](3)) + \"++\" + (self.$extract_passthroughs(m['$[]'](5))) + \"++\"\n                }; return nil; })();};\n              attributes = m['$[]'](2);\n              escape_count = m['$[]'](3).$length();\n              content = m['$[]'](5);\n              old_behavior = false;\n              if ($truthy(attributes)) {\n                if ($truthy($rb_gt(escape_count, 0))) {\n                  return \"\" + (m['$[]'](1)) + \"[\" + (attributes) + \"]\" + ($rb_times($$($nesting, 'RS'), $rb_minus(escape_count, 1))) + (boundary) + (m['$[]'](5)) + (boundary);\n                } else if (m['$[]'](1)['$==']($$($nesting, 'RS'))) {\n                  \n                  preceding = \"\" + \"[\" + (attributes) + \"]\";\n                  attributes = nil;\n                } else {\n                  \n                  if ($truthy((($c = boundary['$=='](\"++\")) ? attributes['$end_with?'](\"x-\") : boundary['$=='](\"++\")))) {\n                    \n                    old_behavior = true;\n                    attributes = attributes['$[]']($range(0, -2, true));};\n                  attributes = self.$parse_attributes(attributes);\n                }\n              } else if ($truthy($rb_gt(escape_count, 0))) {\n                return \"\" + ($rb_times($$($nesting, 'RS'), $rb_minus(escape_count, 1))) + (boundary) + (m['$[]'](5)) + (boundary);};\n              subs = (function() {if (boundary['$=='](\"+++\")) {\n                return []\n              } else {\n                return $$($nesting, 'BASIC_SUBS')\n              }; return nil; })();\n              pass_key = self.passthroughs.$size();\n              if ($truthy(attributes)) {\n                if ($truthy(old_behavior)) {\n                  \n                  $writer = [pass_key, $hash2([\"text\", \"subs\", \"type\", \"attributes\"], {\"text\": content, \"subs\": $$($nesting, 'NORMAL_SUBS'), \"type\": \"monospaced\", \"attributes\": attributes})];\n                  $send(self.passthroughs, '[]=', Opal.to_a($writer));\n                  $writer[$rb_minus($writer[\"length\"], 1)];\n                } else {\n                  \n                  $writer = [pass_key, $hash2([\"text\", \"subs\", \"type\", \"attributes\"], {\"text\": content, \"subs\": subs, \"type\": \"unquoted\", \"attributes\": attributes})];\n                  $send(self.passthroughs, '[]=', Opal.to_a($writer));\n                  $writer[$rb_minus($writer[\"length\"], 1)];\n                }\n              } else {\n                \n                $writer = [pass_key, $hash2([\"text\", \"subs\"], {\"text\": content, \"subs\": subs})];\n                $send(self.passthroughs, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];\n              };\n            } else {\n              \n              if (m['$[]'](6)['$==']($$($nesting, 'RS'))) {\n                return m['$[]'](0)['$[]']($range(1, -1, false));};\n              \n              $writer = [(pass_key = self.passthroughs.$size()), $hash2([\"text\", \"subs\"], {\"text\": self.$unescape_brackets(m['$[]'](8)), \"subs\": (function() {if ($truthy(m['$[]'](7))) {\n                \n                return self.$resolve_pass_subs(m['$[]'](7));\n              } else {\n                return []\n              }; return nil; })()})];\n              $send(self.passthroughs, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n            };\n            return \"\" + (preceding) + ($$($nesting, 'PASS_START')) + (pass_key) + ($$($nesting, 'PASS_END'));}, TMP_8.$$s = self, TMP_8.$$arity = 0, TMP_8))};\n        $b = $$($nesting, 'PassInlineRx')['$[]'](compat_mode), $a = Opal.to_ary($b), (pass_inline_char1 = ($a[0] == null ? nil : $a[0])), (pass_inline_char2 = ($a[1] == null ? nil : $a[1])), (pass_inline_rx = ($a[2] == null ? nil : $a[2])), $b;\n        if ($truthy(($truthy($a = text['$include?'](pass_inline_char1)) ? $a : ($truthy($b = pass_inline_char2) ? text['$include?'](pass_inline_char2) : $b)))) {\n          text = $send(text, 'gsub', [pass_inline_rx], (TMP_9 = function(){var self = TMP_9.$$s || this, $c, m = nil, preceding = nil, attributes = nil, escape_mark = nil, format_mark = nil, content = nil, old_behavior = nil, pass_key = nil, $writer = nil, subs = nil;\n            if (self.passthroughs == null) self.passthroughs = nil;\n            if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n          \n            m = $gvars[\"~\"];\n            preceding = m['$[]'](1);\n            attributes = m['$[]'](2);\n            if ($truthy(m['$[]'](3)['$start_with?']($$($nesting, 'RS')))) {\n              escape_mark = $$($nesting, 'RS')};\n            format_mark = m['$[]'](4);\n            content = m['$[]'](5);\n            if ($truthy(compat_mode)) {\n              old_behavior = true\n            } else if ($truthy((old_behavior = ($truthy($c = attributes) ? attributes['$end_with?'](\"x-\") : $c)))) {\n              attributes = attributes['$[]']($range(0, -2, true))};\n            if ($truthy(attributes)) {\n              \n              if ($truthy((($c = format_mark['$=='](\"`\")) ? old_behavior['$!']() : format_mark['$=='](\"`\")))) {\n                return \"\" + (preceding) + \"[\" + (attributes) + \"]\" + (escape_mark) + \"`\" + (self.$extract_passthroughs(content)) + \"`\";};\n              if ($truthy(escape_mark)) {\n                return \"\" + (preceding) + \"[\" + (attributes) + \"]\" + (m['$[]'](3)['$[]']($range(1, -1, false)));\n              } else if (preceding['$==']($$($nesting, 'RS'))) {\n                \n                preceding = \"\" + \"[\" + (attributes) + \"]\";\n                attributes = nil;\n              } else {\n                attributes = self.$parse_attributes(attributes)\n              };\n            } else if ($truthy((($c = format_mark['$=='](\"`\")) ? old_behavior['$!']() : format_mark['$=='](\"`\")))) {\n              return \"\" + (preceding) + (escape_mark) + \"`\" + (self.$extract_passthroughs(content)) + \"`\";\n            } else if ($truthy(escape_mark)) {\n              return \"\" + (preceding) + (m['$[]'](3)['$[]']($range(1, -1, false)));};\n            pass_key = self.passthroughs.$size();\n            if ($truthy(compat_mode)) {\n              \n              $writer = [pass_key, $hash2([\"text\", \"subs\", \"attributes\", \"type\"], {\"text\": content, \"subs\": $$($nesting, 'BASIC_SUBS'), \"attributes\": attributes, \"type\": \"monospaced\"})];\n              $send(self.passthroughs, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];\n            } else if ($truthy(attributes)) {\n              if ($truthy(old_behavior)) {\n                \n                subs = (function() {if (format_mark['$=='](\"`\")) {\n                  return $$($nesting, 'BASIC_SUBS')\n                } else {\n                  return $$($nesting, 'NORMAL_SUBS')\n                }; return nil; })();\n                \n                $writer = [pass_key, $hash2([\"text\", \"subs\", \"attributes\", \"type\"], {\"text\": content, \"subs\": subs, \"attributes\": attributes, \"type\": \"monospaced\"})];\n                $send(self.passthroughs, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];;\n              } else {\n                \n                $writer = [pass_key, $hash2([\"text\", \"subs\", \"attributes\", \"type\"], {\"text\": content, \"subs\": $$($nesting, 'BASIC_SUBS'), \"attributes\": attributes, \"type\": \"unquoted\"})];\n                $send(self.passthroughs, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];\n              }\n            } else {\n              \n              $writer = [pass_key, $hash2([\"text\", \"subs\"], {\"text\": content, \"subs\": $$($nesting, 'BASIC_SUBS')})];\n              $send(self.passthroughs, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];\n            };\n            return \"\" + (preceding) + ($$($nesting, 'PASS_START')) + (pass_key) + ($$($nesting, 'PASS_END'));}, TMP_9.$$s = self, TMP_9.$$arity = 0, TMP_9))};\n        if ($truthy(($truthy($a = text['$include?'](\":\")) ? ($truthy($b = text['$include?'](\"stem:\")) ? $b : text['$include?'](\"math:\")) : $a))) {\n          text = $send(text, 'gsub', [$$($nesting, 'InlineStemMacroRx')], (TMP_10 = function(){var self = TMP_10.$$s || this, m = nil, type = nil, default_stem_type = nil, content = nil, subs = nil, $writer = nil, pass_key = nil;\n            if (self.document == null) self.document = nil;\n            if (self.passthroughs == null) self.passthroughs = nil;\n            if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n          \n            m = $gvars[\"~\"];\n            if ($truthy(m['$[]'](0)['$start_with?']($$($nesting, 'RS')))) {\n              return m['$[]'](0)['$[]']($range(1, -1, false));};\n            if ((type = m['$[]'](1).$to_sym())['$=='](\"stem\")) {\n              type = (function() {if ($truthy((default_stem_type = self.document.$attributes()['$[]'](\"stem\"))['$nil_or_empty?']())) {\n                return \"asciimath\"\n              } else {\n                return default_stem_type\n              }; return nil; })().$to_sym()};\n            content = self.$unescape_brackets(m['$[]'](3));\n            subs = (function() {if ($truthy(m['$[]'](2))) {\n              \n              return self.$resolve_pass_subs(m['$[]'](2));\n            } else {\n              \n              if ($truthy(self.document['$basebackend?'](\"html\"))) {\n                return $$($nesting, 'BASIC_SUBS')\n              } else {\n                return []\n              };\n            }; return nil; })();\n            \n            $writer = [(pass_key = self.passthroughs.$size()), $hash2([\"text\", \"subs\", \"type\"], {\"text\": content, \"subs\": subs, \"type\": type})];\n            $send(self.passthroughs, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            return \"\" + ($$($nesting, 'PASS_START')) + (pass_key) + ($$($nesting, 'PASS_END'));}, TMP_10.$$s = self, TMP_10.$$arity = 0, TMP_10))};\n        return text;\n      }, TMP_Substitutors_extract_passthroughs_11.$$arity = 1);\n      \n      Opal.def(self, '$restore_passthroughs', TMP_Substitutors_restore_passthroughs_13 = function $$restore_passthroughs(text, outer) {\n        var $a, $b, TMP_12, self = this;\n        if (self.passthroughs == null) self.passthroughs = nil;\n\n        if (outer == null) {\n          outer = true;\n        }\n        return (function() { try {\n        \n        if ($truthy(($truthy($a = outer) ? ($truthy($b = self.passthroughs['$empty?']()) ? $b : text['$include?']($$($nesting, 'PASS_START'))['$!']()) : $a))) {\n          return text};\n        return $send(text, 'gsub', [$$($nesting, 'PassSlotRx')], (TMP_12 = function(){var self = TMP_12.$$s || this, $c, pass = nil, subbed_text = nil, type = nil;\n          if (self.passthroughs == null) self.passthroughs = nil;\n\n        \n          pass = self.passthroughs['$[]']((($c = $gvars['~']) === nil ? nil : $c['$[]'](1)).$to_i());\n          subbed_text = self.$apply_subs(pass['$[]'](\"text\"), pass['$[]'](\"subs\"));\n          if ($truthy((type = pass['$[]'](\"type\")))) {\n            subbed_text = $$($nesting, 'Inline').$new(self, \"quoted\", subbed_text, $hash2([\"type\", \"attributes\"], {\"type\": type, \"attributes\": pass['$[]'](\"attributes\")})).$convert()};\n          if ($truthy(subbed_text['$include?']($$($nesting, 'PASS_START')))) {\n            return self.$restore_passthroughs(subbed_text, false)\n          } else {\n            return subbed_text\n          };}, TMP_12.$$s = self, TMP_12.$$arity = 0, TMP_12));\n        } finally {\n          (function() {if ($truthy(outer)) {\n            return self.passthroughs.$clear()\n          } else {\n            return nil\n          }; return nil; })()\n        }; })()\n      }, TMP_Substitutors_restore_passthroughs_13.$$arity = -2);\n      if ($$($nesting, 'RUBY_ENGINE')['$=='](\"opal\")) {\n        \n        \n        Opal.def(self, '$sub_quotes', TMP_Substitutors_sub_quotes_16 = function $$sub_quotes(text) {\n          var TMP_14, self = this, compat = nil;\n          if (self.document == null) self.document = nil;\n\n          \n          if ($truthy($$($nesting, 'QuotedTextSniffRx')['$[]']((compat = self.document.$compat_mode()))['$match?'](text))) {\n            $send($$($nesting, 'QUOTE_SUBS')['$[]'](compat), 'each', [], (TMP_14 = function(type, scope, pattern){var self = TMP_14.$$s || this, TMP_15;\nif (type == null) type = nil;if (scope == null) scope = nil;if (pattern == null) pattern = nil;\n            return (text = $send(text, 'gsub', [pattern], (TMP_15 = function(){var self = TMP_15.$$s || this;\n                if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n              return self.$convert_quoted_text($gvars[\"~\"], type, scope)}, TMP_15.$$s = self, TMP_15.$$arity = 0, TMP_15)))}, TMP_14.$$s = self, TMP_14.$$arity = 3, TMP_14))};\n          return text;\n        }, TMP_Substitutors_sub_quotes_16.$$arity = 1);\n        \n        Opal.def(self, '$sub_replacements', TMP_Substitutors_sub_replacements_19 = function $$sub_replacements(text) {\n          var TMP_17, self = this;\n\n          \n          if ($truthy($$($nesting, 'ReplaceableTextRx')['$match?'](text))) {\n            $send($$($nesting, 'REPLACEMENTS'), 'each', [], (TMP_17 = function(pattern, replacement, restore){var self = TMP_17.$$s || this, TMP_18;\nif (pattern == null) pattern = nil;if (replacement == null) replacement = nil;if (restore == null) restore = nil;\n            return (text = $send(text, 'gsub', [pattern], (TMP_18 = function(){var self = TMP_18.$$s || this;\n                if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n              return self.$do_replacement($gvars[\"~\"], replacement, restore)}, TMP_18.$$s = self, TMP_18.$$arity = 0, TMP_18)))}, TMP_17.$$s = self, TMP_17.$$arity = 3, TMP_17))};\n          return text;\n        }, TMP_Substitutors_sub_replacements_19.$$arity = 1);\n        \n        Opal.def(self, '$sub_specialchars', TMP_Substitutors_sub_specialchars_20 = function $$sub_specialchars(text) {\n          var $a, $b, self = this;\n\n          if ($truthy(($truthy($a = ($truthy($b = text['$include?'](\"<\")) ? $b : text['$include?'](\"&\"))) ? $a : text['$include?'](\">\")))) {\n            \n            return text.$gsub($$($nesting, 'SpecialCharsRx'), $$($nesting, 'SpecialCharsTr'));\n          } else {\n            return text\n          }\n        }, TMP_Substitutors_sub_specialchars_20.$$arity = 1);\n      } else {\n        nil\n      };\n      Opal.alias(self, \"sub_specialcharacters\", \"sub_specialchars\");\n      \n      Opal.def(self, '$do_replacement', TMP_Substitutors_do_replacement_21 = function $$do_replacement(m, replacement, restore) {\n        var self = this, captured = nil, $case = nil;\n\n        if ($truthy((captured = m['$[]'](0))['$include?']($$($nesting, 'RS')))) {\n          return captured.$sub($$($nesting, 'RS'), \"\")\n        } else {\n          return (function() {$case = restore;\n          if (\"none\"['$===']($case)) {return replacement}\n          else if (\"bounding\"['$===']($case)) {return \"\" + (m['$[]'](1)) + (replacement) + (m['$[]'](2))}\n          else {return \"\" + (m['$[]'](1)) + (replacement)}})()\n        }\n      }, TMP_Substitutors_do_replacement_21.$$arity = 3);\n      \n      Opal.def(self, '$sub_attributes', TMP_Substitutors_sub_attributes_24 = function $$sub_attributes(data, opts) {\n        var $a, TMP_22, self = this, input_is_string = nil, doc_attrs = nil, result = nil;\n        if (self.document == null) self.document = nil;\n\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        \n        if ($truthy((input_is_string = $$$('::', 'String')['$==='](data)))) {\n          data = [data]};\n        $a = [self.document.$attributes(), []], (doc_attrs = $a[0]), (result = $a[1]), $a;\n        (function(){var $brk = Opal.new_brk(); try {return $send(data, 'each', [], (TMP_22 = function(line){var self = TMP_22.$$s || this, TMP_23, $b, $c, reject = nil, reject_if_empty = nil;\nif (line == null) line = nil;\n        \n          reject = (reject_if_empty = false);\n          if ($truthy(line['$include?']($$($nesting, 'ATTR_REF_HEAD')))) {\n            line = (function(){var $brk = Opal.new_brk(); try {return $send(line, 'gsub', [$$($nesting, 'AttributeReferenceRx')], (TMP_23 = function(){var self = TMP_23.$$s || this, $b, $c, $d, $case = nil, args = nil, _ = nil, value = nil, key = nil, attribute_missing = nil;\n              if (self.document == null) self.document = nil;\n\n            if ($truthy(($truthy($b = (($c = $gvars['~']) === nil ? nil : $c['$[]'](1))['$==']($$($nesting, 'RS'))) ? $b : (($c = $gvars['~']) === nil ? nil : $c['$[]'](4))['$==']($$($nesting, 'RS'))))) {\n                return \"\" + \"{\" + ((($b = $gvars['~']) === nil ? nil : $b['$[]'](2))) + \"}\"\n              } else if ($truthy((($b = $gvars['~']) === nil ? nil : $b['$[]'](3)))) {\n                return (function() {$case = (args = (($b = $gvars['~']) === nil ? nil : $b['$[]'](2)).$split(\":\", 3)).$shift();\n                if (\"set\"['$===']($case)) {\n                $c = $$($nesting, 'Parser').$store_attribute(args['$[]'](0), ($truthy($d = args['$[]'](1)) ? $d : \"\"), self.document), $b = Opal.to_ary($c), (_ = ($b[0] == null ? nil : $b[0])), (value = ($b[1] == null ? nil : $b[1])), $c;\n                if ($truthy(value)) {\n                } else if (doc_attrs.$fetch(\"attribute-undefined\", $$($nesting, 'Compliance').$attribute_undefined())['$=='](\"drop-line\")) {\n                  \n                  reject = true;\n                  \n                  Opal.brk(\"\", $brk);};\n                reject_if_empty = true;\n                return \"\";}\n                else if (\"counter2\"['$===']($case)) {\n                $send(self.document, 'counter', Opal.to_a(args));\n                reject_if_empty = true;\n                return \"\";}\n                else {return $send(self.document, 'counter', Opal.to_a(args))}})()\n              } else if ($truthy(doc_attrs['$key?']((key = (($b = $gvars['~']) === nil ? nil : $b['$[]'](2)).$downcase())))) {\n                return doc_attrs['$[]'](key)\n              } else if ($truthy($$($nesting, 'INTRINSIC_ATTRIBUTES')['$key?'](key))) {\n                return $$($nesting, 'INTRINSIC_ATTRIBUTES')['$[]'](key)\n              } else {\n                return (function() {$case = (attribute_missing = ($truthy($b = attribute_missing) ? $b : ($truthy($c = opts['$[]'](\"attribute_missing\")) ? $c : doc_attrs.$fetch(\"attribute-missing\", $$($nesting, 'Compliance').$attribute_missing()))));\n                if (\"drop\"['$===']($case)) {\n                reject_if_empty = true;\n                return \"\";}\n                else if (\"drop-line\"['$===']($case)) {\n                self.$warn(\"\" + \"asciidoctor: WARNING: dropping line containing reference to missing attribute: \" + (key));\n                reject = true;\n                \n                Opal.brk(\"\", $brk);}\n                else if (\"warn\"['$===']($case)) {\n                self.$warn(\"\" + \"asciidoctor: WARNING: skipping reference to missing attribute: \" + (key));\n                return (($b = $gvars['~']) === nil ? nil : $b['$[]'](0));}\n                else {return (($b = $gvars['~']) === nil ? nil : $b['$[]'](0))}})()\n              }}, TMP_23.$$s = self, TMP_23.$$brk = $brk, TMP_23.$$arity = 0, TMP_23))\n            } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})()};\n          if ($truthy(($truthy($b = reject) ? $b : ($truthy($c = reject_if_empty) ? line['$empty?']() : $c)))) {\n            return nil\n          } else {\n            return result['$<<'](line)\n          };}, TMP_22.$$s = self, TMP_22.$$brk = $brk, TMP_22.$$arity = 1, TMP_22))\n        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();\n        if ($truthy(input_is_string)) {\n          return $rb_times(result, $$($nesting, 'LF'))\n        } else {\n          return result\n        };\n      }, TMP_Substitutors_sub_attributes_24.$$arity = -2);\n      \n      Opal.def(self, '$sub_macros', TMP_Substitutors_sub_macros_41 = function $$sub_macros(source) {\n        var $a, $b, TMP_25, TMP_28, TMP_30, TMP_32, TMP_34, TMP_35, TMP_36, TMP_37, TMP_38, TMP_39, self = this, found = nil, found_square_bracket = nil, $writer = nil, found_colon = nil, found_macroish = nil, found_macroish_short = nil, doc_attrs = nil, use_link_attrs = nil, result = nil, extensions = nil;\n        if (self.document == null) self.document = nil;\n\n        \n        found = $hash2([], {});\n        found_square_bracket = (($writer = [\"square_bracket\", source['$include?'](\"[\")]), $send(found, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]);\n        found_colon = source['$include?'](\":\");\n        found_macroish = (($writer = [\"macroish\", ($truthy($a = found_square_bracket) ? found_colon : $a)]), $send(found, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]);\n        found_macroish_short = ($truthy($a = found_macroish) ? source['$include?'](\":[\") : $a);\n        doc_attrs = self.document.$attributes();\n        use_link_attrs = doc_attrs['$key?'](\"linkattrs\");\n        result = source;\n        if ($truthy(doc_attrs['$key?'](\"experimental\"))) {\n          \n          if ($truthy(($truthy($a = found_macroish_short) ? ($truthy($b = result['$include?'](\"kbd:\")) ? $b : result['$include?'](\"btn:\")) : $a))) {\n            result = $send(result, 'gsub', [$$($nesting, 'InlineKbdBtnMacroRx')], (TMP_25 = function(){var self = TMP_25.$$s || this, $c, TMP_26, TMP_27, keys = nil, delim_idx = nil, delim = nil;\n\n            if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](1)))) {\n                return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$slice(1, (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$length())\n              } else if ((($c = $gvars['~']) === nil ? nil : $c['$[]'](2))['$=='](\"kbd\")) {\n                \n                if ($truthy((keys = (($c = $gvars['~']) === nil ? nil : $c['$[]'](3)).$strip())['$include?']($$($nesting, 'R_SB')))) {\n                  keys = keys.$gsub($$($nesting, 'ESC_R_SB'), $$($nesting, 'R_SB'))};\n                if ($truthy(($truthy($c = $rb_gt(keys.$length(), 1)) ? (delim_idx = (function() {if ($truthy((delim_idx = keys.$index(\",\", 1)))) {\n                  return [delim_idx, keys.$index(\"+\", 1)].$compact().$min()\n                } else {\n                  \n                  return keys.$index(\"+\", 1);\n                }; return nil; })()) : $c))) {\n                  \n                  delim = keys.$slice(delim_idx, 1);\n                  if ($truthy(keys['$end_with?'](delim))) {\n                    \n                    keys = $send(keys.$chop().$split(delim, -1), 'map', [], (TMP_26 = function(key){var self = TMP_26.$$s || this;\nif (key == null) key = nil;\n                    return key.$strip()}, TMP_26.$$s = self, TMP_26.$$arity = 1, TMP_26));\n                    \n                    $writer = [-1, \"\" + (keys['$[]'](-1)) + (delim)];\n                    $send(keys, '[]=', Opal.to_a($writer));\n                    $writer[$rb_minus($writer[\"length\"], 1)];;\n                  } else {\n                    keys = $send(keys.$split(delim), 'map', [], (TMP_27 = function(key){var self = TMP_27.$$s || this;\nif (key == null) key = nil;\n                    return key.$strip()}, TMP_27.$$s = self, TMP_27.$$arity = 1, TMP_27))\n                  };\n                } else {\n                  keys = [keys]\n                };\n                return $$($nesting, 'Inline').$new(self, \"kbd\", nil, $hash2([\"attributes\"], {\"attributes\": $hash2([\"keys\"], {\"keys\": keys})})).$convert();\n              } else {\n                return $$($nesting, 'Inline').$new(self, \"button\", self.$unescape_bracketed_text((($c = $gvars['~']) === nil ? nil : $c['$[]'](3)))).$convert()\n              }}, TMP_25.$$s = self, TMP_25.$$arity = 0, TMP_25))};\n          if ($truthy(($truthy($a = found_macroish) ? result['$include?'](\"menu:\") : $a))) {\n            result = $send(result, 'gsub', [$$($nesting, 'InlineMenuMacroRx')], (TMP_28 = function(){var self = TMP_28.$$s || this, $c, TMP_29, m = nil, captured = nil, menu = nil, items = nil, delim = nil, submenus = nil, menuitem = nil;\n              if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n            \n              m = $gvars[\"~\"];\n              if ($truthy((captured = m['$[]'](0))['$start_with?']($$($nesting, 'RS')))) {\n                return captured['$[]']($range(1, -1, false));};\n              $c = [m['$[]'](1), m['$[]'](2)], (menu = $c[0]), (items = $c[1]), $c;\n              if ($truthy(items)) {\n                \n                if ($truthy(items['$include?']($$($nesting, 'R_SB')))) {\n                  items = items.$gsub($$($nesting, 'ESC_R_SB'), $$($nesting, 'R_SB'))};\n                if ($truthy((delim = (function() {if ($truthy(items['$include?'](\"&gt;\"))) {\n                  return \"&gt;\"\n                } else {\n                  \n                  if ($truthy(items['$include?'](\",\"))) {\n                    return \",\"\n                  } else {\n                    return nil\n                  };\n                }; return nil; })()))) {\n                  \n                  submenus = $send(items.$split(delim), 'map', [], (TMP_29 = function(it){var self = TMP_29.$$s || this;\nif (it == null) it = nil;\n                  return it.$strip()}, TMP_29.$$s = self, TMP_29.$$arity = 1, TMP_29));\n                  menuitem = submenus.$pop();\n                } else {\n                  $c = [[], items.$rstrip()], (submenus = $c[0]), (menuitem = $c[1]), $c\n                };\n              } else {\n                $c = [[], nil], (submenus = $c[0]), (menuitem = $c[1]), $c\n              };\n              return $$($nesting, 'Inline').$new(self, \"menu\", nil, $hash2([\"attributes\"], {\"attributes\": $hash2([\"menu\", \"submenus\", \"menuitem\"], {\"menu\": menu, \"submenus\": submenus, \"menuitem\": menuitem})})).$convert();}, TMP_28.$$s = self, TMP_28.$$arity = 0, TMP_28))};\n          if ($truthy(($truthy($a = result['$include?'](\"\\\"\")) ? result['$include?'](\"&gt;\") : $a))) {\n            result = $send(result, 'gsub', [$$($nesting, 'MenuInlineRx')], (TMP_30 = function(){var self = TMP_30.$$s || this, $c, $d, TMP_31, m = nil, captured = nil, input = nil, menu = nil, submenus = nil, menuitem = nil;\n              if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n            \n              m = $gvars[\"~\"];\n              if ($truthy((captured = m['$[]'](0))['$start_with?']($$($nesting, 'RS')))) {\n                return captured['$[]']($range(1, -1, false));};\n              input = m['$[]'](1);\n              $d = $send(input.$split(\"&gt;\"), 'map', [], (TMP_31 = function(it){var self = TMP_31.$$s || this;\nif (it == null) it = nil;\n              return it.$strip()}, TMP_31.$$s = self, TMP_31.$$arity = 1, TMP_31)), $c = Opal.to_ary($d), (menu = ($c[0] == null ? nil : $c[0])), (submenus = $slice.call($c, 1)), $d;\n              menuitem = submenus.$pop();\n              return $$($nesting, 'Inline').$new(self, \"menu\", nil, $hash2([\"attributes\"], {\"attributes\": $hash2([\"menu\", \"submenus\", \"menuitem\"], {\"menu\": menu, \"submenus\": submenus, \"menuitem\": menuitem})})).$convert();}, TMP_30.$$s = self, TMP_30.$$arity = 0, TMP_30))};};\n        if ($truthy(($truthy($a = (extensions = self.document.$extensions())) ? extensions['$inline_macros?']() : $a))) {\n          $send(extensions.$inline_macros(), 'each', [], (TMP_32 = function(extension){var self = TMP_32.$$s || this, TMP_33;\nif (extension == null) extension = nil;\n          return (result = $send(result, 'gsub', [extension.$instance().$regexp()], (TMP_33 = function(){var self = TMP_33.$$s || this, $c, m = nil, target = nil, content = nil, extconf = nil, attributes = nil, replacement = nil;\n              if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n            \n              m = $gvars[\"~\"];\n              if ($truthy(m['$[]'](0)['$start_with?']($$($nesting, 'RS')))) {\n                return m['$[]'](0)['$[]']($range(1, -1, false));};\n              if ($truthy((function() { try {\n                return m.$names()\n              } catch ($err) {\n                if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {\n                  try {\n                    return []\n                  } finally { Opal.pop_exception() }\n                } else { throw $err; }\n              }})()['$empty?']())) {\n                $c = [m['$[]'](1), m['$[]'](2), extension.$config()], (target = $c[0]), (content = $c[1]), (extconf = $c[2]), $c\n              } else {\n                $c = [(function() { try {\n                  return m['$[]'](\"target\")\n                } catch ($err) {\n                  if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {\n                    try {\n                      return nil\n                    } finally { Opal.pop_exception() }\n                  } else { throw $err; }\n                }})(), (function() { try {\n                  return m['$[]'](\"content\")\n                } catch ($err) {\n                  if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {\n                    try {\n                      return nil\n                    } finally { Opal.pop_exception() }\n                  } else { throw $err; }\n                }})(), extension.$config()], (target = $c[0]), (content = $c[1]), (extconf = $c[2]), $c\n              };\n              attributes = (function() {if ($truthy((attributes = extconf['$[]'](\"default_attrs\")))) {\n                return attributes.$dup()\n              } else {\n                return $hash2([], {})\n              }; return nil; })();\n              if ($truthy(content['$nil_or_empty?']())) {\n                if ($truthy(($truthy($c = content) ? extconf['$[]'](\"content_model\")['$!='](\"attributes\") : $c))) {\n                  \n                  $writer = [\"text\", content];\n                  $send(attributes, '[]=', Opal.to_a($writer));\n                  $writer[$rb_minus($writer[\"length\"], 1)];}\n              } else {\n                \n                content = self.$unescape_bracketed_text(content);\n                if (extconf['$[]'](\"content_model\")['$=='](\"attributes\")) {\n                  self.$parse_attributes(content, ($truthy($c = extconf['$[]'](\"pos_attrs\")) ? $c : []), $hash2([\"sub_result\", \"into\"], {\"sub_result\": false, \"into\": attributes}))\n                } else {\n                  \n                  $writer = [\"text\", content];\n                  $send(attributes, '[]=', Opal.to_a($writer));\n                  $writer[$rb_minus($writer[\"length\"], 1)];\n                };\n              };\n              replacement = extension.$process_method()['$[]'](self, ($truthy($c = target) ? $c : content), attributes);\n              if ($truthy($$($nesting, 'Inline')['$==='](replacement))) {\n                return replacement.$convert()\n              } else {\n                return replacement\n              };}, TMP_33.$$s = self, TMP_33.$$arity = 0, TMP_33)))}, TMP_32.$$s = self, TMP_32.$$arity = 1, TMP_32))};\n        if ($truthy(($truthy($a = found_macroish) ? ($truthy($b = result['$include?'](\"image:\")) ? $b : result['$include?'](\"icon:\")) : $a))) {\n          result = $send(result, 'gsub', [$$($nesting, 'InlineImageMacroRx')], (TMP_34 = function(){var self = TMP_34.$$s || this, $c, m = nil, captured = nil, type = nil, posattrs = nil, target = nil, attrs = nil;\n            if (self.document == null) self.document = nil;\n            if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n          \n            m = $gvars[\"~\"];\n            if ($truthy((captured = (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)))['$start_with?']($$($nesting, 'RS')))) {\n              return captured['$[]']($range(1, -1, false));};\n            if ($truthy(captured['$start_with?'](\"icon:\"))) {\n              $c = [\"icon\", [\"size\"]], (type = $c[0]), (posattrs = $c[1]), $c\n            } else {\n              $c = [\"image\", [\"alt\", \"width\", \"height\"]], (type = $c[0]), (posattrs = $c[1]), $c\n            };\n            if ($truthy((target = m['$[]'](1))['$include?']($$($nesting, 'ATTR_REF_HEAD')))) {\n              target = self.$sub_attributes(target)};\n            if (type['$=='](\"icon\")) {\n            } else {\n              self.document.$register(\"images\", target)\n            };\n            attrs = self.$parse_attributes(m['$[]'](2), posattrs, $hash2([\"unescape_input\"], {\"unescape_input\": true}));\n            ($truthy($c = attrs['$[]'](\"alt\")) ? $c : (($writer = [\"alt\", (($writer = [\"default-alt\", $$($nesting, 'Helpers').$basename(target, true).$tr(\"_-\", \" \")]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n            return $$($nesting, 'Inline').$new(self, \"image\", nil, $hash2([\"type\", \"target\", \"attributes\"], {\"type\": type, \"target\": target, \"attributes\": attrs})).$convert();}, TMP_34.$$s = self, TMP_34.$$arity = 0, TMP_34))};\n        if ($truthy(($truthy($a = ($truthy($b = result['$include?'](\"((\")) ? result['$include?'](\"))\") : $b)) ? $a : ($truthy($b = found_macroish_short) ? result['$include?'](\"indexterm\") : $b)))) {\n          result = $send(result, 'gsub', [$$($nesting, 'InlineIndextermMacroRx')], (TMP_35 = function(){var self = TMP_35.$$s || this, $c, m = nil, $case = nil, terms = nil, term = nil, text = nil, visible = nil, before = nil, after = nil;\n            if (self.document == null) self.document = nil;\n            if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n          \n            m = $gvars[\"~\"];\n            if ($truthy(m['$[]'](0)['$start_with?']($$($nesting, 'RS')))) {\n              return m['$[]'](0)['$[]']($range(1, -1, false));};\n            return (function() {$case = m['$[]'](1);\n            if (\"indexterm\"['$===']($case)) {\n            terms = self.$split_simple_csv(self.$normalize_string(m['$[]'](2), true));\n            self.document.$register(\"indexterms\", terms);\n            return $$($nesting, 'Inline').$new(self, \"indexterm\", nil, $hash2([\"attributes\"], {\"attributes\": $hash2([\"terms\"], {\"terms\": terms})})).$convert();}\n            else if (\"indexterm2\"['$===']($case)) {\n            term = self.$normalize_string(m['$[]'](2), true);\n            self.document.$register(\"indexterms\", [term]);\n            return $$($nesting, 'Inline').$new(self, \"indexterm\", term, $hash2([\"type\"], {\"type\": \"visible\"})).$convert();}\n            else {\n            $c = [m['$[]'](3), true, nil, nil], (text = $c[0]), (visible = $c[1]), (before = $c[2]), (after = $c[3]), $c;\n            if ($truthy(text['$start_with?'](\"(\"))) {\n              if ($truthy(text['$end_with?'](\")\"))) {\n                $c = [text.$slice(1, $rb_minus(text.$length(), 2)), false], (text = $c[0]), (visible = $c[1]), $c\n              } else {\n                $c = [text.$slice(1, $rb_minus(text.$length(), 1)), \"(\", \"\"], (text = $c[0]), (before = $c[1]), (after = $c[2]), $c\n              }\n            } else if ($truthy(text['$end_with?'](\")\"))) {\n              if ($truthy(text['$start_with?'](\"(\"))) {\n                $c = [text.$slice(1, $rb_minus(text.$length(), 2)), false], (text = $c[0]), (visible = $c[1]), $c\n              } else {\n                $c = [text.$slice(0, $rb_minus(text.$length(), 1)), \"\", \")\"], (text = $c[0]), (before = $c[1]), (after = $c[2]), $c\n              }};\n            if ($truthy(visible)) {\n              \n              term = self.$normalize_string(text);\n              self.document.$register(\"indexterms\", [term]);\n              result = $$($nesting, 'Inline').$new(self, \"indexterm\", term, $hash2([\"type\"], {\"type\": \"visible\"})).$convert();\n            } else {\n              \n              terms = self.$split_simple_csv(self.$normalize_string(text));\n              self.document.$register(\"indexterms\", terms);\n              result = $$($nesting, 'Inline').$new(self, \"indexterm\", nil, $hash2([\"attributes\"], {\"attributes\": $hash2([\"terms\"], {\"terms\": terms})})).$convert();\n            };\n            if ($truthy(before)) {\n              return \"\" + (before) + (result) + (after)\n            } else {\n              return result\n            };}})();}, TMP_35.$$s = self, TMP_35.$$arity = 0, TMP_35))};\n        if ($truthy(($truthy($a = found_colon) ? result['$include?'](\"://\") : $a))) {\n          result = $send(result, 'gsub', [$$($nesting, 'LinkInlineRx')], (TMP_36 = function(){var self = TMP_36.$$s || this, $c, $d, $e, m = nil, macro = nil, prefix = nil, target = nil, text = nil, suffix = nil, $case = nil, attrs = nil, link_opts = nil;\n            if (self.document == null) self.document = nil;\n            if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n          \n            m = $gvars[\"~\"];\n            if ($truthy(m['$[]'](2)['$start_with?']($$($nesting, 'RS')))) {\n              return \"\" + (m['$[]'](1)) + (m['$[]'](2)['$[]']($range(1, -1, false))) + (m['$[]'](3));};\n            $c = [m['$[]'](1), m['$[]'](2), ($truthy($d = (macro = m['$[]'](3))) ? $d : \"\"), \"\"], (prefix = $c[0]), (target = $c[1]), (text = $c[2]), (suffix = $c[3]), $c;\n            if (prefix['$=='](\"link:\")) {\n              if ($truthy(macro)) {\n                prefix = \"\"\n              } else {\n                return m['$[]'](0);\n              }};\n            if ($truthy(($truthy($c = macro) ? $c : $$($nesting, 'UriTerminatorRx')['$!~'](target)))) {\n            } else {\n              $case = (($c = $gvars['~']) === nil ? nil : $c['$[]'](0));\n              if (\")\"['$===']($case)) {\n              target = target.$chop();\n              suffix = \")\";}\n              else if (\";\"['$===']($case)) {if ($truthy(($truthy($c = prefix['$start_with?'](\"&lt;\")) ? target['$end_with?'](\"&gt;\") : $c))) {\n                \n                prefix = prefix['$[]']($range(4, -1, false));\n                target = target['$[]']($range(0, -4, true));\n              } else if ($truthy((target = target.$chop())['$end_with?'](\")\"))) {\n                \n                target = target.$chop();\n                suffix = \");\";\n              } else {\n                suffix = \";\"\n              }}\n              else if (\":\"['$===']($case)) {if ($truthy((target = target.$chop())['$end_with?'](\")\"))) {\n                \n                target = target.$chop();\n                suffix = \"):\";\n              } else {\n                suffix = \":\"\n              }}\n            };\n            $c = [nil, $hash2([\"type\"], {\"type\": \"link\"})], (attrs = $c[0]), (link_opts = $c[1]), $c;\n            if ($truthy(text['$empty?']())) {\n            } else {\n              \n              if ($truthy(text['$include?']($$($nesting, 'R_SB')))) {\n                text = text.$gsub($$($nesting, 'ESC_R_SB'), $$($nesting, 'R_SB'))};\n              if ($truthy(($truthy($c = use_link_attrs) ? ($truthy($d = text['$start_with?'](\"\\\"\")) ? $d : ($truthy($e = text['$include?'](\",\")) ? text['$include?'](\"=\") : $e)) : $c))) {\n                \n                attrs = self.$parse_attributes(text, []);\n                if ($truthy(attrs['$key?'](\"id\"))) {\n                  \n                  $writer = [\"id\", attrs.$delete(\"id\")];\n                  $send(link_opts, '[]=', Opal.to_a($writer));\n                  $writer[$rb_minus($writer[\"length\"], 1)];};\n                text = ($truthy($c = attrs['$[]'](1)) ? $c : \"\");};\n              if ($truthy(text['$end_with?'](\"^\"))) {\n                \n                text = text.$chop();\n                if ($truthy(attrs)) {\n                  ($truthy($c = attrs['$[]'](\"window\")) ? $c : (($writer = [\"window\", \"_blank\"]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))\n                } else {\n                  attrs = $hash2([\"window\"], {\"window\": \"_blank\"})\n                };};\n            };\n            if ($truthy(text['$empty?']())) {\n              \n              text = (function() {if ($truthy(doc_attrs['$key?'](\"hide-uri-scheme\"))) {\n                \n                return target.$sub($$($nesting, 'UriSniffRx'), \"\");\n              } else {\n                return target\n              }; return nil; })();\n              if ($truthy(attrs)) {\n                \n                $writer = [\"role\", (function() {if ($truthy(attrs['$key?'](\"role\"))) {\n                  return \"\" + \"bare \" + (attrs['$[]'](\"role\"))\n                } else {\n                  return \"bare\"\n                }; return nil; })()];\n                $send(attrs, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];\n              } else {\n                attrs = $hash2([\"role\"], {\"role\": \"bare\"})\n              };};\n            self.document.$register(\"links\", (($writer = [\"target\", target]), $send(link_opts, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n            if ($truthy(attrs)) {\n              \n              $writer = [\"attributes\", attrs];\n              $send(link_opts, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];};\n            return \"\" + (prefix) + ($$($nesting, 'Inline').$new(self, \"anchor\", text, link_opts).$convert()) + (suffix);}, TMP_36.$$s = self, TMP_36.$$arity = 0, TMP_36))};\n        if ($truthy(($truthy($a = found_macroish) ? ($truthy($b = result['$include?'](\"link:\")) ? $b : result['$include?'](\"mailto:\")) : $a))) {\n          result = $send(result, 'gsub', [$$($nesting, 'InlineLinkMacroRx')], (TMP_37 = function(){var self = TMP_37.$$s || this, $c, $d, $e, $f, m = nil, target = nil, mailto = nil, attrs = nil, link_opts = nil, text = nil;\n            if (self.document == null) self.document = nil;\n            if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n          \n            m = $gvars[\"~\"];\n            if ($truthy(m['$[]'](0)['$start_with?']($$($nesting, 'RS')))) {\n              return m['$[]'](0)['$[]']($range(1, -1, false));};\n            target = (function() {if ($truthy((mailto = m['$[]'](1)))) {\n              return \"\" + \"mailto:\" + (m['$[]'](2))\n            } else {\n              return m['$[]'](2)\n            }; return nil; })();\n            $c = [nil, $hash2([\"type\"], {\"type\": \"link\"})], (attrs = $c[0]), (link_opts = $c[1]), $c;\n            if ($truthy((text = m['$[]'](3))['$empty?']())) {\n            } else {\n              \n              if ($truthy(text['$include?']($$($nesting, 'R_SB')))) {\n                text = text.$gsub($$($nesting, 'ESC_R_SB'), $$($nesting, 'R_SB'))};\n              if ($truthy(($truthy($c = use_link_attrs) ? ($truthy($d = text['$start_with?'](\"\\\"\")) ? $d : ($truthy($e = text['$include?'](\",\")) ? ($truthy($f = mailto) ? $f : text['$include?'](\"=\")) : $e)) : $c))) {\n                \n                attrs = self.$parse_attributes(text, []);\n                if ($truthy(attrs['$key?'](\"id\"))) {\n                  \n                  $writer = [\"id\", attrs.$delete(\"id\")];\n                  $send(link_opts, '[]=', Opal.to_a($writer));\n                  $writer[$rb_minus($writer[\"length\"], 1)];};\n                if ($truthy(mailto)) {\n                  if ($truthy(attrs['$key?'](2))) {\n                    if ($truthy(attrs['$key?'](3))) {\n                      target = \"\" + (target) + \"?subject=\" + ($$($nesting, 'Helpers').$uri_encode(attrs['$[]'](2))) + \"&amp;body=\" + ($$($nesting, 'Helpers').$uri_encode(attrs['$[]'](3)))\n                    } else {\n                      target = \"\" + (target) + \"?subject=\" + ($$($nesting, 'Helpers').$uri_encode(attrs['$[]'](2)))\n                    }}};\n                text = ($truthy($c = attrs['$[]'](1)) ? $c : \"\");};\n              if ($truthy(text['$end_with?'](\"^\"))) {\n                \n                text = text.$chop();\n                if ($truthy(attrs)) {\n                  ($truthy($c = attrs['$[]'](\"window\")) ? $c : (($writer = [\"window\", \"_blank\"]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))\n                } else {\n                  attrs = $hash2([\"window\"], {\"window\": \"_blank\"})\n                };};\n            };\n            if ($truthy(text['$empty?']())) {\n              if ($truthy(mailto)) {\n                text = m['$[]'](2)\n              } else {\n                \n                text = (function() {if ($truthy(doc_attrs['$key?'](\"hide-uri-scheme\"))) {\n                  \n                  return target.$sub($$($nesting, 'UriSniffRx'), \"\");\n                } else {\n                  return target\n                }; return nil; })();\n                if ($truthy(attrs)) {\n                  \n                  $writer = [\"role\", (function() {if ($truthy(attrs['$key?'](\"role\"))) {\n                    return \"\" + \"bare \" + (attrs['$[]'](\"role\"))\n                  } else {\n                    return \"bare\"\n                  }; return nil; })()];\n                  $send(attrs, '[]=', Opal.to_a($writer));\n                  $writer[$rb_minus($writer[\"length\"], 1)];\n                } else {\n                  attrs = $hash2([\"role\"], {\"role\": \"bare\"})\n                };\n              }};\n            self.document.$register(\"links\", (($writer = [\"target\", target]), $send(link_opts, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n            if ($truthy(attrs)) {\n              \n              $writer = [\"attributes\", attrs];\n              $send(link_opts, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];};\n            return $$($nesting, 'Inline').$new(self, \"anchor\", text, link_opts).$convert();}, TMP_37.$$s = self, TMP_37.$$arity = 0, TMP_37))};\n        if ($truthy(result['$include?'](\"@\"))) {\n          result = $send(result, 'gsub', [$$($nesting, 'EmailInlineRx')], (TMP_38 = function(){var self = TMP_38.$$s || this, $c, $d, address = nil, tip = nil, target = nil;\n            if (self.document == null) self.document = nil;\n\n          \n            $c = [(($d = $gvars['~']) === nil ? nil : $d['$[]'](0)), (($d = $gvars['~']) === nil ? nil : $d['$[]'](1))], (address = $c[0]), (tip = $c[1]), $c;\n            if ($truthy(tip)) {\n              return (function() {if (tip['$==']($$($nesting, 'RS'))) {\n                return address['$[]']($range(1, -1, false))\n              } else {\n                return address\n              }; return nil; })();};\n            target = \"\" + \"mailto:\" + (address);\n            self.document.$register(\"links\", target);\n            return $$($nesting, 'Inline').$new(self, \"anchor\", address, $hash2([\"type\", \"target\"], {\"type\": \"link\", \"target\": target})).$convert();}, TMP_38.$$s = self, TMP_38.$$arity = 0, TMP_38))};\n        if ($truthy(($truthy($a = found_macroish_short) ? result['$include?'](\"footnote\") : $a))) {\n          result = $send(result, 'gsub', [$$($nesting, 'InlineFootnoteMacroRx')], (TMP_39 = function(){var self = TMP_39.$$s || this, $c, $d, TMP_40, m = nil, id = nil, text = nil, index = nil, type = nil, target = nil, footnote = nil;\n            if (self.document == null) self.document = nil;\n            if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n          \n            m = $gvars[\"~\"];\n            if ($truthy(m['$[]'](0)['$start_with?']($$($nesting, 'RS')))) {\n              return m['$[]'](0)['$[]']($range(1, -1, false));};\n            if (m['$[]'](1)['$=='](\"footnote\")) {\n              \n              id = nil;\n              text = self.$restore_passthroughs(self.$sub_inline_xrefs(self.$sub_inline_anchors(self.$normalize_string(m['$[]'](2), true))), false);\n              index = self.document.$counter(\"footnote-number\");\n              self.document.$register(\"footnotes\", $$$($$($nesting, 'Document'), 'Footnote').$new(index, id, text));\n              type = nil;\n              target = nil;\n            } else {\n              \n              $d = m['$[]'](2).$split(\",\", 2), $c = Opal.to_ary($d), (id = ($c[0] == null ? nil : $c[0])), (text = ($c[1] == null ? nil : $c[1])), $d;\n              id = id.$strip();\n              if ($truthy(text)) {\n                \n                text = self.$restore_passthroughs(self.$sub_inline_xrefs(self.$sub_inline_anchors(self.$normalize_string(text, true))), false);\n                index = self.document.$counter(\"footnote-number\");\n                self.document.$register(\"footnotes\", $$$($$($nesting, 'Document'), 'Footnote').$new(index, id, text));\n                type = \"ref\";\n                target = nil;\n              } else {\n                \n                if ($truthy((footnote = $send(self.document.$footnotes(), 'find', [], (TMP_40 = function(fn){var self = TMP_40.$$s || this;\nif (fn == null) fn = nil;\n                return fn.$id()['$=='](id)}, TMP_40.$$s = self, TMP_40.$$arity = 1, TMP_40))))) {\n                  \n                  index = footnote.$index();\n                  text = footnote.$text();\n                } else {\n                  \n                  index = nil;\n                  text = id;\n                };\n                target = id;\n                id = nil;\n                type = \"xref\";\n              };\n            };\n            return $$($nesting, 'Inline').$new(self, \"footnote\", text, $hash2([\"attributes\", \"id\", \"target\", \"type\"], {\"attributes\": $hash2([\"index\"], {\"index\": index}), \"id\": id, \"target\": target, \"type\": type})).$convert();}, TMP_39.$$s = self, TMP_39.$$arity = 0, TMP_39))};\n        return self.$sub_inline_xrefs(self.$sub_inline_anchors(result, found), found);\n      }, TMP_Substitutors_sub_macros_41.$$arity = 1);\n      \n      Opal.def(self, '$sub_inline_anchors', TMP_Substitutors_sub_inline_anchors_44 = function $$sub_inline_anchors(text, found) {\n        var $a, TMP_42, $b, $c, TMP_43, self = this;\n        if (self.context == null) self.context = nil;\n        if (self.parent == null) self.parent = nil;\n\n        if (found == null) {\n          found = nil;\n        }\n        \n        if ($truthy((($a = self.context['$=='](\"list_item\")) ? self.parent.$style()['$=='](\"bibliography\") : self.context['$=='](\"list_item\")))) {\n          text = $send(text, 'sub', [$$($nesting, 'InlineBiblioAnchorRx')], (TMP_42 = function(){var self = TMP_42.$$s || this, $b, $c;\n\n          return $$($nesting, 'Inline').$new(self, \"anchor\", \"\" + \"[\" + (($truthy($b = (($c = $gvars['~']) === nil ? nil : $c['$[]'](2))) ? $b : (($c = $gvars['~']) === nil ? nil : $c['$[]'](1)))) + \"]\", $hash2([\"type\", \"id\", \"target\"], {\"type\": \"bibref\", \"id\": (($b = $gvars['~']) === nil ? nil : $b['$[]'](1)), \"target\": (($b = $gvars['~']) === nil ? nil : $b['$[]'](1))})).$convert()}, TMP_42.$$s = self, TMP_42.$$arity = 0, TMP_42))};\n        if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = found['$!']()) ? $c : found['$[]'](\"square_bracket\"))) ? text['$include?'](\"[[\") : $b)) ? $a : ($truthy($b = ($truthy($c = found['$!']()) ? $c : found['$[]'](\"macroish\"))) ? text['$include?'](\"or:\") : $b)))) {\n          text = $send(text, 'gsub', [$$($nesting, 'InlineAnchorRx')], (TMP_43 = function(){var self = TMP_43.$$s || this, $d, $e, id = nil, reftext = nil;\n\n          \n            if ($truthy((($d = $gvars['~']) === nil ? nil : $d['$[]'](1)))) {\n              return (($d = $gvars['~']) === nil ? nil : $d['$[]'](0)).$slice(1, (($d = $gvars['~']) === nil ? nil : $d['$[]'](0)).$length());};\n            if ($truthy((id = (($d = $gvars['~']) === nil ? nil : $d['$[]'](2))))) {\n              reftext = (($d = $gvars['~']) === nil ? nil : $d['$[]'](3))\n            } else {\n              \n              id = (($d = $gvars['~']) === nil ? nil : $d['$[]'](4));\n              if ($truthy(($truthy($d = (reftext = (($e = $gvars['~']) === nil ? nil : $e['$[]'](5)))) ? reftext['$include?']($$($nesting, 'R_SB')) : $d))) {\n                reftext = reftext.$gsub($$($nesting, 'ESC_R_SB'), $$($nesting, 'R_SB'))};\n            };\n            return $$($nesting, 'Inline').$new(self, \"anchor\", reftext, $hash2([\"type\", \"id\", \"target\"], {\"type\": \"ref\", \"id\": id, \"target\": id})).$convert();}, TMP_43.$$s = self, TMP_43.$$arity = 0, TMP_43))};\n        return text;\n      }, TMP_Substitutors_sub_inline_anchors_44.$$arity = -2);\n      \n      Opal.def(self, '$sub_inline_xrefs', TMP_Substitutors_sub_inline_xrefs_46 = function $$sub_inline_xrefs(text, found) {\n        var $a, $b, TMP_45, self = this;\n\n        if (found == null) {\n          found = nil;\n        }\n        \n        if ($truthy(($truthy($a = ($truthy($b = (function() {if ($truthy(found)) {\n          return found['$[]'](\"macroish\")\n        } else {\n          \n          return text['$include?'](\"[\");\n        }; return nil; })()) ? text['$include?'](\"xref:\") : $b)) ? $a : ($truthy($b = text['$include?'](\"&\")) ? text['$include?'](\"&lt;&lt;\") : $b)))) {\n          text = $send(text, 'gsub', [$$($nesting, 'InlineXrefMacroRx')], (TMP_45 = function(){var self = TMP_45.$$s || this, $c, $d, m = nil, id = nil, reftext = nil, hash_idx = nil, fragment_len = nil, path = nil, fragment = nil, target = nil, refid = nil, ext_idx = nil, resolved_id = nil;\n            if (self.document == null) self.document = nil;\n            if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n            if ($gvars.VERBOSE == null) $gvars.VERBOSE = nil;\n\n          \n            m = $gvars[\"~\"];\n            if ($truthy(m['$[]'](0)['$start_with?']($$($nesting, 'RS')))) {\n              return m['$[]'](0)['$[]']($range(1, -1, false));};\n            if ($truthy((id = m['$[]'](1)))) {\n              \n              $d = id.$split(\",\", 2), $c = Opal.to_ary($d), (id = ($c[0] == null ? nil : $c[0])), (reftext = ($c[1] == null ? nil : $c[1])), $d;\n              if ($truthy(reftext)) {\n                reftext = reftext.$lstrip()};\n            } else {\n              \n              id = m['$[]'](2);\n              if ($truthy(($truthy($c = (reftext = m['$[]'](3))) ? reftext['$include?']($$($nesting, 'R_SB')) : $c))) {\n                reftext = reftext.$gsub($$($nesting, 'ESC_R_SB'), $$($nesting, 'R_SB'))};\n            };\n            if ($truthy((hash_idx = id.$index(\"#\")))) {\n              if ($truthy($rb_gt(hash_idx, 0))) {\n                if ($truthy($rb_gt((fragment_len = $rb_minus($rb_minus(id.$length(), hash_idx), 1)), 0))) {\n                  $c = [id.$slice(0, hash_idx), id.$slice($rb_plus(hash_idx, 1), fragment_len)], (path = $c[0]), (fragment = $c[1]), $c\n                } else {\n                  $c = [id.$slice(0, hash_idx), nil], (path = $c[0]), (fragment = $c[1]), $c\n                }\n              } else {\n                $c = [id, nil, id.$slice(1, id.$length())], (target = $c[0]), (path = $c[1]), (fragment = $c[2]), $c\n              }\n            } else {\n              $c = [nil, id], (path = $c[0]), (fragment = $c[1]), $c\n            };\n            if ($truthy(target)) {\n              refid = fragment\n            } else if ($truthy(path)) {\n              \n              if ($truthy(($truthy($c = (ext_idx = path.$rindex(\".\"))) ? $$($nesting, 'ASCIIDOC_EXTENSIONS')['$[]'](path.$slice(ext_idx, path.$length())) : $c))) {\n                path = path.$slice(0, ext_idx)};\n              if ($truthy(($truthy($c = self.document.$attributes()['$[]'](\"docname\")['$=='](path)) ? $c : self.document.$catalog()['$[]'](\"includes\")['$include?'](path)))) {\n                $c = [fragment, nil, \"\" + \"#\" + (fragment)], (refid = $c[0]), (path = $c[1]), (target = $c[2]), $c\n              } else {\n                \n                refid = (function() {if ($truthy(fragment)) {\n                  return \"\" + (path) + \"#\" + (fragment)\n                } else {\n                  return path\n                }; return nil; })();\n                path = \"\" + (self.document.$attributes()['$[]'](\"relfileprefix\")) + (path) + (self.document.$attributes().$fetch(\"outfilesuffix\", \".html\"));\n                target = (function() {if ($truthy(fragment)) {\n                  return \"\" + (path) + \"#\" + (fragment)\n                } else {\n                  return path\n                }; return nil; })();\n              };\n            } else {\n              \n              if ($truthy(self.document.$catalog()['$[]'](\"ids\")['$key?'](fragment))) {\n              } else if ($truthy(($truthy($c = ($truthy($d = fragment['$include?'](\" \")) ? $d : fragment.$downcase()['$!='](fragment))) ? (resolved_id = self.document.$catalog()['$[]'](\"ids\").$key(fragment)) : $c))) {\n                fragment = resolved_id\n              } else if ($truthy($gvars.VERBOSE)) {\n                self.$warn(\"\" + \"asciidoctor: WARNING: invalid reference: \" + (fragment))};\n              $c = [fragment, \"\" + \"#\" + (fragment)], (refid = $c[0]), (target = $c[1]), $c;\n            };\n            return $$($nesting, 'Inline').$new(self, \"anchor\", reftext, $hash2([\"type\", \"target\", \"attributes\"], {\"type\": \"xref\", \"target\": target, \"attributes\": $hash2([\"path\", \"fragment\", \"refid\"], {\"path\": path, \"fragment\": fragment, \"refid\": refid})})).$convert();}, TMP_45.$$s = self, TMP_45.$$arity = 0, TMP_45))};\n        return text;\n      }, TMP_Substitutors_sub_inline_xrefs_46.$$arity = -2);\n      \n      Opal.def(self, '$sub_callouts', TMP_Substitutors_sub_callouts_48 = function $$sub_callouts(text) {\n        var TMP_47, self = this, callout_rx = nil;\n\n        \n        callout_rx = (function() {if ($truthy(self['$attr?'](\"line-comment\"))) {\n          return new RegExp(\"\" + \"(?:\" + ($$$('::', 'Regexp').$escape(self.$attr(\"line-comment\"))) + \" )?\" + ($$($nesting, 'CalloutSourceRxt')))\n        } else {\n          return $$($nesting, 'CalloutSourceRx')\n        }; return nil; })();\n        return $send(text, 'gsub', [callout_rx], (TMP_47 = function(){var self = TMP_47.$$s || this, $a;\n          if (self.document == null) self.document = nil;\n\n        \n          if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)))) {\n            return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$sub($$($nesting, 'RS'), \"\");};\n          return $$($nesting, 'Inline').$new(self, \"callout\", (($a = $gvars['~']) === nil ? nil : $a['$[]'](3)), $hash2([\"id\"], {\"id\": self.document.$callouts().$read_next_id()})).$convert();}, TMP_47.$$s = self, TMP_47.$$arity = 0, TMP_47));\n      }, TMP_Substitutors_sub_callouts_48.$$arity = 1);\n      \n      Opal.def(self, '$sub_post_replacements', TMP_Substitutors_sub_post_replacements_51 = function $$sub_post_replacements(text) {\n        var $a, TMP_49, TMP_50, self = this, lines = nil, last = nil;\n        if (self.document == null) self.document = nil;\n        if (self.attributes == null) self.attributes = nil;\n\n        if ($truthy(($truthy($a = self.document.$attributes()['$key?'](\"hardbreaks\")) ? $a : self.attributes['$key?'](\"hardbreaks-option\")))) {\n          \n          lines = text.$split($$($nesting, 'LF'), -1);\n          if ($truthy($rb_lt(lines.$size(), 2))) {\n            return text};\n          last = lines.$pop();\n          return $rb_times($send(lines, 'map', [], (TMP_49 = function(line){var self = TMP_49.$$s || this;\nif (line == null) line = nil;\n          return $$($nesting, 'Inline').$new(self, \"break\", (function() {if ($truthy(line['$end_with?']($$($nesting, 'HARD_LINE_BREAK')))) {\n              \n              return line.$slice(0, $rb_minus(line.$length(), 2));\n            } else {\n              return line\n            }; return nil; })(), $hash2([\"type\"], {\"type\": \"line\"})).$convert()}, TMP_49.$$s = self, TMP_49.$$arity = 1, TMP_49))['$<<'](last), $$($nesting, 'LF'));\n        } else if ($truthy(($truthy($a = text['$include?']($$($nesting, 'PLUS'))) ? text['$include?']($$($nesting, 'HARD_LINE_BREAK')) : $a))) {\n          return $send(text, 'gsub', [$$($nesting, 'HardLineBreakRx')], (TMP_50 = function(){var self = TMP_50.$$s || this, $b;\n\n          return $$($nesting, 'Inline').$new(self, \"break\", (($b = $gvars['~']) === nil ? nil : $b['$[]'](1)), $hash2([\"type\"], {\"type\": \"line\"})).$convert()}, TMP_50.$$s = self, TMP_50.$$arity = 0, TMP_50))\n        } else {\n          return text\n        }\n      }, TMP_Substitutors_sub_post_replacements_51.$$arity = 1);\n      \n      Opal.def(self, '$convert_quoted_text', TMP_Substitutors_convert_quoted_text_52 = function $$convert_quoted_text(match, type, scope) {\n        var $a, self = this, attrs = nil, unescaped_attrs = nil, attrlist = nil, id = nil, attributes = nil;\n\n        \n        if ($truthy(match['$[]'](0)['$start_with?']($$($nesting, 'RS')))) {\n          if ($truthy((($a = scope['$=='](\"constrained\")) ? (attrs = match['$[]'](2)) : scope['$=='](\"constrained\")))) {\n            unescaped_attrs = \"\" + \"[\" + (attrs) + \"]\"\n          } else {\n            return match['$[]'](0)['$[]']($range(1, -1, false))\n          }};\n        if (scope['$=='](\"constrained\")) {\n          if ($truthy(unescaped_attrs)) {\n            return \"\" + (unescaped_attrs) + ($$($nesting, 'Inline').$new(self, \"quoted\", match['$[]'](3), $hash2([\"type\"], {\"type\": type})).$convert())\n          } else {\n            \n            if ($truthy((attrlist = match['$[]'](2)))) {\n              \n              id = (attributes = self.$parse_quoted_text_attributes(attrlist)).$delete(\"id\");\n              if (type['$=='](\"mark\")) {\n                type = \"unquoted\"};};\n            return \"\" + (match['$[]'](1)) + ($$($nesting, 'Inline').$new(self, \"quoted\", match['$[]'](3), $hash2([\"type\", \"id\", \"attributes\"], {\"type\": type, \"id\": id, \"attributes\": attributes})).$convert());\n          }\n        } else {\n          \n          if ($truthy((attrlist = match['$[]'](1)))) {\n            \n            id = (attributes = self.$parse_quoted_text_attributes(attrlist)).$delete(\"id\");\n            if (type['$=='](\"mark\")) {\n              type = \"unquoted\"};};\n          return $$($nesting, 'Inline').$new(self, \"quoted\", match['$[]'](2), $hash2([\"type\", \"id\", \"attributes\"], {\"type\": type, \"id\": id, \"attributes\": attributes})).$convert();\n        };\n      }, TMP_Substitutors_convert_quoted_text_52.$$arity = 3);\n      \n      Opal.def(self, '$parse_quoted_text_attributes', TMP_Substitutors_parse_quoted_text_attributes_53 = function $$parse_quoted_text_attributes(str) {\n        var $a, $b, self = this, segments = nil, id = nil, more_roles = nil, roles = nil, attrs = nil, $writer = nil;\n\n        \n        if ($truthy(str['$include?']($$($nesting, 'ATTR_REF_HEAD')))) {\n          str = self.$sub_attributes(str)};\n        if ($truthy(str['$include?'](\",\"))) {\n          str = str.$slice(0, str.$index(\",\"))};\n        if ($truthy((str = str.$strip())['$empty?']())) {\n          return $hash2([], {})\n        } else if ($truthy(($truthy($a = str['$start_with?'](\".\", \"#\")) ? $$($nesting, 'Compliance').$shorthand_property_syntax() : $a))) {\n          \n          segments = str.$split(\"#\", 2);\n          if ($truthy($rb_gt(segments.$size(), 1))) {\n            $b = segments['$[]'](1).$split(\".\"), $a = Opal.to_ary($b), (id = ($a[0] == null ? nil : $a[0])), (more_roles = $slice.call($a, 1)), $b\n          } else {\n            \n            id = nil;\n            more_roles = [];\n          };\n          roles = (function() {if ($truthy(segments['$[]'](0)['$empty?']())) {\n            return []\n          } else {\n            return segments['$[]'](0).$split(\".\")\n          }; return nil; })();\n          if ($truthy($rb_gt(roles.$size(), 1))) {\n            roles.$shift()};\n          if ($truthy($rb_gt(more_roles.$size(), 0))) {\n            roles.$concat(more_roles)};\n          attrs = $hash2([], {});\n          if ($truthy(id)) {\n            \n            $writer = [\"id\", id];\n            $send(attrs, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];};\n          if ($truthy(roles['$empty?']())) {\n          } else {\n            \n            $writer = [\"role\", $rb_times(roles, \" \")];\n            $send(attrs, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];\n          };\n          return attrs;\n        } else {\n          return $hash2([\"role\"], {\"role\": str})\n        };\n      }, TMP_Substitutors_parse_quoted_text_attributes_53.$$arity = 1);\n      \n      Opal.def(self, '$parse_attributes', TMP_Substitutors_parse_attributes_54 = function $$parse_attributes(attrline, posattrs, opts) {\n        var $a, self = this, block = nil, into = nil;\n        if (self.document == null) self.document = nil;\n\n        if (posattrs == null) {\n          posattrs = [\"role\"];\n        }\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        \n        if ($truthy(attrline)) {\n        } else {\n          return nil\n        };\n        if ($truthy(attrline['$empty?']())) {\n          return $hash2([], {})};\n        if ($truthy(($truthy($a = opts['$[]'](\"sub_input\")) ? attrline['$include?']($$($nesting, 'ATTR_REF_HEAD')) : $a))) {\n          attrline = self.document.$sub_attributes(attrline)};\n        if ($truthy(opts['$[]'](\"unescape_input\"))) {\n          attrline = self.$unescape_bracketed_text(attrline)};\n        block = (function() {if ($truthy(opts.$fetch(\"sub_result\", true))) {\n          return self\n        } else {\n          return nil\n        }; return nil; })();\n        if ($truthy((into = opts['$[]'](\"into\")))) {\n          return $$($nesting, 'AttributeList').$new(attrline, block).$parse_into(into, posattrs)\n        } else {\n          return $$($nesting, 'AttributeList').$new(attrline, block).$parse(posattrs)\n        };\n      }, TMP_Substitutors_parse_attributes_54.$$arity = -2);\n      \n      Opal.def(self, '$unescape_bracketed_text', TMP_Substitutors_unescape_bracketed_text_55 = function $$unescape_bracketed_text(text) {\n        var self = this;\n\n        \n        if ($truthy(text['$empty?']())) {\n        } else if ($truthy((text = text.$strip().$tr($$($nesting, 'LF'), \" \"))['$include?']($$($nesting, 'R_SB')))) {\n          text = text.$gsub($$($nesting, 'ESC_R_SB'), $$($nesting, 'R_SB'))};\n        return text;\n      }, TMP_Substitutors_unescape_bracketed_text_55.$$arity = 1);\n      \n      Opal.def(self, '$normalize_string', TMP_Substitutors_normalize_string_56 = function $$normalize_string(str, unescape_brackets) {\n        var $a, self = this;\n\n        if (unescape_brackets == null) {\n          unescape_brackets = false;\n        }\n        \n        if ($truthy(str['$empty?']())) {\n        } else {\n          \n          str = str.$strip().$tr($$($nesting, 'LF'), \" \");\n          if ($truthy(($truthy($a = unescape_brackets) ? str['$include?']($$($nesting, 'R_SB')) : $a))) {\n            str = str.$gsub($$($nesting, 'ESC_R_SB'), $$($nesting, 'R_SB'))};\n        };\n        return str;\n      }, TMP_Substitutors_normalize_string_56.$$arity = -2);\n      \n      Opal.def(self, '$unescape_brackets', TMP_Substitutors_unescape_brackets_57 = function $$unescape_brackets(str) {\n        var self = this;\n\n        \n        if ($truthy(str['$empty?']())) {\n        } else if ($truthy(str['$include?']($$($nesting, 'RS')))) {\n          str = str.$gsub($$($nesting, 'ESC_R_SB'), $$($nesting, 'R_SB'))};\n        return str;\n      }, TMP_Substitutors_unescape_brackets_57.$$arity = 1);\n      \n      Opal.def(self, '$split_simple_csv', TMP_Substitutors_split_simple_csv_60 = function $$split_simple_csv(str) {\n        var TMP_58, TMP_59, self = this, values = nil, current = nil, quote_open = nil;\n\n        \n        if ($truthy(str['$empty?']())) {\n          values = []\n        } else if ($truthy(str['$include?'](\"\\\"\"))) {\n          \n          values = [];\n          current = [];\n          quote_open = false;\n          $send(str, 'each_char', [], (TMP_58 = function(c){var self = TMP_58.$$s || this, $case = nil;\nif (c == null) c = nil;\n          return (function() {$case = c;\n            if (\",\"['$===']($case)) {if ($truthy(quote_open)) {\n              return current['$<<'](c)\n            } else {\n              \n              values['$<<'](current.$join().$strip());\n              return (current = []);\n            }}\n            else if (\"\\\"\"['$===']($case)) {return (quote_open = quote_open['$!']())}\n            else {return current['$<<'](c)}})()}, TMP_58.$$s = self, TMP_58.$$arity = 1, TMP_58));\n          values['$<<'](current.$join().$strip());\n        } else {\n          values = $send(str.$split(\",\"), 'map', [], (TMP_59 = function(it){var self = TMP_59.$$s || this;\nif (it == null) it = nil;\n          return it.$strip()}, TMP_59.$$s = self, TMP_59.$$arity = 1, TMP_59))\n        };\n        return values;\n      }, TMP_Substitutors_split_simple_csv_60.$$arity = 1);\n      \n      Opal.def(self, '$resolve_subs', TMP_Substitutors_resolve_subs_62 = function $$resolve_subs(subs, type, defaults, subject) {\n        var TMP_61, self = this, candidates = nil, modifiers_present = nil, resolved = nil, invalid = nil;\n\n        if (type == null) {\n          type = \"block\";\n        }\n        if (defaults == null) {\n          defaults = nil;\n        }\n        if (subject == null) {\n          subject = nil;\n        }\n        \n        if ($truthy(subs['$nil_or_empty?']())) {\n          return []};\n        candidates = nil;\n        if ($truthy(subs['$include?'](\" \"))) {\n          subs = subs.$delete(\" \")};\n        modifiers_present = $$($nesting, 'SubModifierSniffRx')['$match?'](subs);\n        $send(subs.$split(\",\"), 'each', [], (TMP_61 = function(key){var self = TMP_61.$$s || this, $a, $b, modifier_operation = nil, first = nil, resolved_keys = nil, resolved_key = nil, candidate = nil, $case = nil;\nif (key == null) key = nil;\n        \n          modifier_operation = nil;\n          if ($truthy(modifiers_present)) {\n            if ((first = key.$chr())['$=='](\"+\")) {\n              \n              modifier_operation = \"append\";\n              key = key['$[]']($range(1, -1, false));\n            } else if (first['$=='](\"-\")) {\n              \n              modifier_operation = \"remove\";\n              key = key['$[]']($range(1, -1, false));\n            } else if ($truthy(key['$end_with?'](\"+\"))) {\n              \n              modifier_operation = \"prepend\";\n              key = key.$chop();}};\n          key = key.$to_sym();\n          if ($truthy((($a = type['$=='](\"inline\")) ? ($truthy($b = key['$=='](\"verbatim\")) ? $b : key['$=='](\"v\")) : type['$=='](\"inline\")))) {\n            resolved_keys = $$($nesting, 'BASIC_SUBS')\n          } else if ($truthy($$($nesting, 'SUB_GROUPS')['$key?'](key))) {\n            resolved_keys = $$($nesting, 'SUB_GROUPS')['$[]'](key)\n          } else if ($truthy(($truthy($a = (($b = type['$=='](\"inline\")) ? key.$length()['$=='](1) : type['$=='](\"inline\"))) ? $$($nesting, 'SUB_HINTS')['$key?'](key) : $a))) {\n            \n            resolved_key = $$($nesting, 'SUB_HINTS')['$[]'](key);\n            if ($truthy((candidate = $$($nesting, 'SUB_GROUPS')['$[]'](resolved_key)))) {\n              resolved_keys = candidate\n            } else {\n              resolved_keys = [resolved_key]\n            };\n          } else {\n            resolved_keys = [key]\n          };\n          if ($truthy(modifier_operation)) {\n            \n            candidates = ($truthy($a = candidates) ? $a : (function() {if ($truthy(defaults)) {\n              return defaults.$dup()\n            } else {\n              return []\n            }; return nil; })());\n            return (function() {$case = modifier_operation;\n            if (\"append\"['$===']($case)) {return (candidates = $rb_plus(candidates, resolved_keys))}\n            else if (\"prepend\"['$===']($case)) {return (candidates = $rb_plus(resolved_keys, candidates))}\n            else if (\"remove\"['$===']($case)) {return (candidates = $rb_minus(candidates, resolved_keys))}\n            else { return nil }})();\n          } else {\n            \n            candidates = ($truthy($a = candidates) ? $a : []);\n            return (candidates = $rb_plus(candidates, resolved_keys));\n          };}, TMP_61.$$s = self, TMP_61.$$arity = 1, TMP_61));\n        if ($truthy(candidates)) {\n        } else {\n          return []\n        };\n        resolved = candidates['$&']($$($nesting, 'SUB_OPTIONS')['$[]'](type));\n        if ($truthy($rb_minus(candidates, resolved)['$empty?']())) {\n        } else {\n          \n          invalid = $rb_minus(candidates, resolved);\n          self.$warn(\"\" + \"asciidoctor: WARNING: invalid substitution type\" + ((function() {if ($truthy($rb_gt(invalid.$size(), 1))) {\n            return \"s\"\n          } else {\n            return \"\"\n          }; return nil; })()) + ((function() {if ($truthy(subject)) {\n            return \" for \"\n          } else {\n            return nil\n          }; return nil; })()) + (subject) + \": \" + ($rb_times(invalid, \", \")));\n        };\n        return resolved;\n      }, TMP_Substitutors_resolve_subs_62.$$arity = -2);\n      \n      Opal.def(self, '$resolve_block_subs', TMP_Substitutors_resolve_block_subs_63 = function $$resolve_block_subs(subs, defaults, subject) {\n        var self = this;\n\n        return self.$resolve_subs(subs, \"block\", defaults, subject)\n      }, TMP_Substitutors_resolve_block_subs_63.$$arity = 3);\n      \n      Opal.def(self, '$resolve_pass_subs', TMP_Substitutors_resolve_pass_subs_64 = function $$resolve_pass_subs(subs) {\n        var self = this;\n\n        return self.$resolve_subs(subs, \"inline\", nil, \"passthrough macro\")\n      }, TMP_Substitutors_resolve_pass_subs_64.$$arity = 1);\n      \n      Opal.def(self, '$highlight_source', TMP_Substitutors_highlight_source_69 = function $$highlight_source(source, process_callouts, highlighter) {\n        var $a, $b, $c, TMP_65, $d, TMP_67, self = this, $case = nil, highlighter_loaded = nil, lineno = nil, callout_on_last = nil, callout_marks = nil, last = nil, callout_rx = nil, linenums_mode = nil, highlight_lines = nil, result = nil, lexer = nil, opts = nil, $writer = nil, reached_code = nil;\n        if (self.document == null) self.document = nil;\n        if (self.passthroughs == null) self.passthroughs = nil;\n\n        if (highlighter == null) {\n          highlighter = nil;\n        }\n        \n        $case = (highlighter = ($truthy($a = highlighter) ? $a : self.document.$attributes()['$[]'](\"source-highlighter\")));\n        if (\"coderay\"['$===']($case)) {if ($truthy(($truthy($a = (highlighter_loaded = (($b = $$$('::', 'CodeRay', 'skip_raise')) ? 'constant' : nil))) ? $a : self.document.$attributes()['$[]'](\"coderay-unavailable\")))) {\n        } else if ($truthy($$($nesting, 'Helpers').$require_library(\"coderay\", true, \"warn\")['$nil?']())) {\n          self.document.$set_attr(\"coderay-unavailable\")\n        } else {\n          highlighter_loaded = true\n        }}\n        else if (\"pygments\"['$===']($case)) {if ($truthy(($truthy($a = (highlighter_loaded = (($c = $$$('::', 'Pygments', 'skip_raise')) ? 'constant' : nil))) ? $a : self.document.$attributes()['$[]'](\"pygments-unavailable\")))) {\n        } else if ($truthy($$($nesting, 'Helpers').$require_library(\"pygments\", \"pygments.rb\", \"warn\")['$nil?']())) {\n          self.document.$set_attr(\"pygments-unavailable\")\n        } else {\n          highlighter_loaded = true\n        }}\n        else {highlighter_loaded = false};\n        if ($truthy(highlighter_loaded)) {\n        } else {\n          return self.$sub_source(source, process_callouts)\n        };\n        lineno = 0;\n        callout_on_last = false;\n        if ($truthy(process_callouts)) {\n          \n          callout_marks = $hash2([], {});\n          last = -1;\n          callout_rx = (function() {if ($truthy(self['$attr?'](\"line-comment\"))) {\n            return new RegExp(\"\" + \"(?:\" + ($$$('::', 'Regexp').$escape(self.$attr(\"line-comment\"))) + \" )?\" + ($$($nesting, 'CalloutExtractRxt')))\n          } else {\n            return $$($nesting, 'CalloutExtractRx')\n          }; return nil; })();\n          source = $rb_times($send(source.$split($$($nesting, 'LF'), -1), 'map', [], (TMP_65 = function(line){var self = TMP_65.$$s || this, TMP_66;\nif (line == null) line = nil;\n          \n            lineno = $rb_plus(lineno, 1);\n            return $send(line, 'gsub', [callout_rx], (TMP_66 = function(){var self = TMP_66.$$s || this, $d, m = nil, $writer = nil;\n              if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n            \n              m = $gvars[\"~\"];\n              if (m['$[]'](1)['$==']($$($nesting, 'RS'))) {\n                return m['$[]'](0).$sub($$($nesting, 'RS'), \"\")\n              } else {\n                \n                ($truthy($d = callout_marks['$[]'](lineno)) ? $d : (($writer = [lineno, []]), $send(callout_marks, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))['$<<'](m['$[]'](3));\n                last = lineno;\n                return nil;\n              };}, TMP_66.$$s = self, TMP_66.$$arity = 0, TMP_66));}, TMP_65.$$s = self, TMP_65.$$arity = 1, TMP_65)), $$($nesting, 'LF'));\n          callout_on_last = last['$=='](lineno);\n          if ($truthy(callout_marks['$empty?']())) {\n            callout_marks = nil};\n        } else {\n          callout_marks = nil\n        };\n        linenums_mode = nil;\n        highlight_lines = nil;\n        $case = highlighter;\n        if (\"coderay\"['$===']($case)) {\n        if ($truthy((linenums_mode = (function() {if ($truthy(self['$attr?'](\"linenums\", nil, false))) {\n          return ($truthy($a = self.document.$attributes()['$[]'](\"coderay-linenums-mode\")) ? $a : \"table\").$to_sym()\n        } else {\n          return nil\n        }; return nil; })()))) {\n          if ($truthy(self['$attr?'](\"highlight\", nil, false))) {\n            highlight_lines = self.$resolve_highlight_lines(self.$attr(\"highlight\", nil, false))}};\n        result = $$$($$$('::', 'CodeRay'), 'Duo')['$[]'](self.$attr(\"language\", \"text\", false).$to_sym(), \"html\", $hash2([\"css\", \"line_numbers\", \"line_number_anchors\", \"highlight_lines\", \"bold_every\"], {\"css\": ($truthy($a = self.document.$attributes()['$[]'](\"coderay-css\")) ? $a : \"class\").$to_sym(), \"line_numbers\": linenums_mode, \"line_number_anchors\": false, \"highlight_lines\": highlight_lines, \"bold_every\": false})).$highlight(source);}\n        else if (\"pygments\"['$===']($case)) {\n        lexer = ($truthy($a = $$$($$$('::', 'Pygments'), 'Lexer').$find_by_alias(self.$attr(\"language\", \"text\", false))) ? $a : $$$($$$('::', 'Pygments'), 'Lexer').$find_by_mimetype(\"text/plain\"));\n        opts = $hash2([\"cssclass\", \"classprefix\", \"nobackground\", \"stripnl\"], {\"cssclass\": \"pyhl\", \"classprefix\": \"tok-\", \"nobackground\": true, \"stripnl\": false});\n        if (lexer.$name()['$=='](\"PHP\")) {\n          \n          $writer = [\"startinline\", self['$option?'](\"mixed\")['$!']()];\n          $send(opts, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];};\n        if (($truthy($a = self.document.$attributes()['$[]'](\"pygments-css\")) ? $a : \"class\")['$=='](\"class\")) {\n        } else {\n          \n          \n          $writer = [\"noclasses\", true];\n          $send(opts, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          \n          $writer = [\"style\", ($truthy($a = self.document.$attributes()['$[]'](\"pygments-style\")) ? $a : $$$($$($nesting, 'Stylesheets'), 'DEFAULT_PYGMENTS_STYLE'))];\n          $send(opts, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n        };\n        if ($truthy(self['$attr?'](\"highlight\", nil, false))) {\n          if ($truthy((highlight_lines = self.$resolve_highlight_lines(self.$attr(\"highlight\", nil, false)))['$empty?']())) {\n          } else {\n            \n            $writer = [\"hl_lines\", $rb_times(highlight_lines, \" \")];\n            $send(opts, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];\n          }};\n        if ($truthy(($truthy($a = self['$attr?'](\"linenums\", nil, false)) ? (($writer = [\"linenos\", ($truthy($d = self.document.$attributes()['$[]'](\"pygments-linenums-mode\")) ? $d : \"table\")]), $send(opts, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])['$=='](\"table\") : $a))) {\n          \n          linenums_mode = \"table\";\n          result = lexer.$highlight(source, $hash2([\"options\"], {\"options\": opts})).$sub($$($nesting, 'PygmentsWrapperDivRx'), \"\\\\1\").$gsub($$($nesting, 'PygmentsWrapperPreRx'), \"\\\\1\");\n        } else if ($truthy($$($nesting, 'PygmentsWrapperPreRx')['$=~']((result = lexer.$highlight(source, $hash2([\"options\"], {\"options\": opts})))))) {\n          result = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1))};};\n        if ($truthy(self.passthroughs['$empty?']())) {\n        } else {\n          result = result.$gsub($$($nesting, 'HighlightedPassSlotRx'), \"\" + ($$($nesting, 'PASS_START')) + \"\\\\1\" + ($$($nesting, 'PASS_END')))\n        };\n        if ($truthy(($truthy($a = process_callouts) ? callout_marks : $a))) {\n          \n          lineno = 0;\n          reached_code = linenums_mode['$!='](\"table\");\n          return $rb_times($send(result.$split($$($nesting, 'LF'), -1), 'map', [], (TMP_67 = function(line){var self = TMP_67.$$s || this, $e, $f, TMP_68, conums = nil, tail = nil, pos = nil, conums_markup = nil;\n            if (self.document == null) self.document = nil;\nif (line == null) line = nil;\n          \n            if ($truthy(reached_code)) {\n            } else {\n              \n              if ($truthy(line['$include?'](\"<td class=\\\"code\\\">\"))) {\n              } else {\n                return line;\n              };\n              reached_code = true;\n            };\n            lineno = $rb_plus(lineno, 1);\n            if ($truthy((conums = callout_marks.$delete(lineno)))) {\n              \n              tail = nil;\n              if ($truthy(($truthy($e = ($truthy($f = callout_on_last) ? callout_marks['$empty?']() : $f)) ? linenums_mode['$=='](\"table\") : $e))) {\n                if ($truthy((($e = highlighter['$=='](\"coderay\")) ? (pos = line.$index(\"</pre>\")) : highlighter['$=='](\"coderay\")))) {\n                  $e = [line.$slice(0, pos), line.$slice(pos, line.$length())], (line = $e[0]), (tail = $e[1]), $e\n                } else if ($truthy((($e = highlighter['$=='](\"pygments\")) ? (pos = line['$start_with?'](\"</td>\")) : highlighter['$=='](\"pygments\")))) {\n                  $e = [\"\", line], (line = $e[0]), (tail = $e[1]), $e}};\n              if (conums.$size()['$=='](1)) {\n                return \"\" + (line) + ($$($nesting, 'Inline').$new(self, \"callout\", conums['$[]'](0), $hash2([\"id\"], {\"id\": self.document.$callouts().$read_next_id()})).$convert()) + (tail)\n              } else {\n                \n                conums_markup = $rb_times($send(conums, 'map', [], (TMP_68 = function(conum){var self = TMP_68.$$s || this;\n                  if (self.document == null) self.document = nil;\nif (conum == null) conum = nil;\n                return $$($nesting, 'Inline').$new(self, \"callout\", conum, $hash2([\"id\"], {\"id\": self.document.$callouts().$read_next_id()})).$convert()}, TMP_68.$$s = self, TMP_68.$$arity = 1, TMP_68)), \" \");\n                return \"\" + (line) + (conums_markup) + (tail);\n              };\n            } else {\n              return line\n            };}, TMP_67.$$s = self, TMP_67.$$arity = 1, TMP_67)), $$($nesting, 'LF'));\n        } else {\n          return result\n        };\n      }, TMP_Substitutors_highlight_source_69.$$arity = -3);\n      \n      Opal.def(self, '$resolve_highlight_lines', TMP_Substitutors_resolve_highlight_lines_71 = function $$resolve_highlight_lines(spec) {\n        var TMP_70, self = this, lines = nil;\n\n        \n        lines = [];\n        $send((function() {if ($truthy(spec['$include?'](\" \"))) {\n          \n          return spec.$delete(\" \");\n        } else {\n          return spec\n        }; return nil; })().$split($$($nesting, 'DataDelimiterRx')), 'map', [], (TMP_70 = function(entry){var self = TMP_70.$$s || this, $a, $b, negate = nil, s = nil, e = nil, line_nums = nil;\nif (entry == null) entry = nil;\n        \n          negate = false;\n          if ($truthy(entry['$start_with?'](\"!\"))) {\n            \n            entry = entry['$[]']($range(1, -1, false));\n            negate = true;};\n          if ($truthy(entry['$include?'](\"-\"))) {\n            \n            $b = entry.$split(\"-\", 2), $a = Opal.to_ary($b), (s = ($a[0] == null ? nil : $a[0])), (e = ($a[1] == null ? nil : $a[1])), $b;\n            line_nums = Opal.Range.$new(s.$to_i(), e.$to_i(), false).$to_a();\n            if ($truthy(negate)) {\n              return (lines = $rb_minus(lines, line_nums))\n            } else {\n              return lines.$concat(line_nums)\n            };\n          } else if ($truthy(negate)) {\n            return lines.$delete(entry.$to_i())\n          } else {\n            return lines['$<<'](entry.$to_i())\n          };}, TMP_70.$$s = self, TMP_70.$$arity = 1, TMP_70));\n        return lines.$sort().$uniq();\n      }, TMP_Substitutors_resolve_highlight_lines_71.$$arity = 1);\n      \n      Opal.def(self, '$sub_source', TMP_Substitutors_sub_source_72 = function $$sub_source(source, process_callouts) {\n        var self = this;\n\n        if ($truthy(process_callouts)) {\n          return self.$sub_callouts(self.$sub_specialchars(source))\n        } else {\n          \n          return self.$sub_specialchars(source);\n        }\n      }, TMP_Substitutors_sub_source_72.$$arity = 2);\n      \n      Opal.def(self, '$lock_in_subs', TMP_Substitutors_lock_in_subs_73 = function $$lock_in_subs() {\n        var $a, $b, $c, $d, $e, self = this, default_subs = nil, $case = nil, custom_subs = nil, idx = nil, $writer = nil;\n        if (self.default_subs == null) self.default_subs = nil;\n        if (self.content_model == null) self.content_model = nil;\n        if (self.context == null) self.context = nil;\n        if (self.subs == null) self.subs = nil;\n        if (self.attributes == null) self.attributes = nil;\n        if (self.style == null) self.style = nil;\n        if (self.document == null) self.document = nil;\n\n        \n        if ($truthy((default_subs = self.default_subs))) {\n        } else {\n          $case = self.content_model;\n          if (\"simple\"['$===']($case)) {default_subs = $$($nesting, 'NORMAL_SUBS')}\n          else if (\"verbatim\"['$===']($case)) {if ($truthy(($truthy($a = self.context['$=='](\"listing\")) ? $a : (($b = self.context['$=='](\"literal\")) ? self['$option?'](\"listparagraph\")['$!']() : self.context['$=='](\"literal\"))))) {\n            default_subs = $$($nesting, 'VERBATIM_SUBS')\n          } else if (self.context['$=='](\"verse\")) {\n            default_subs = $$($nesting, 'NORMAL_SUBS')\n          } else {\n            default_subs = $$($nesting, 'BASIC_SUBS')\n          }}\n          else if (\"raw\"['$===']($case)) {default_subs = (function() {if (self.context['$=='](\"stem\")) {\n            return $$($nesting, 'BASIC_SUBS')\n          } else {\n            return $$($nesting, 'NONE_SUBS')\n          }; return nil; })()}\n          else {return self.subs}\n        };\n        self.subs = (function() {if ($truthy((custom_subs = self.attributes['$[]'](\"subs\")))) {\n          \n          return self.$resolve_block_subs(custom_subs, default_subs, self.context);\n        } else {\n          return default_subs.$dup()\n        }; return nil; })();\n        if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = (($e = self.context['$=='](\"listing\")) ? self.style['$=='](\"source\") : self.context['$=='](\"listing\"))) ? self.attributes['$key?'](\"language\") : $d)) ? self.document['$basebackend?'](\"html\") : $c)) ? $$($nesting, 'SUB_HIGHLIGHT')['$include?'](self.document.$attributes()['$[]'](\"source-highlighter\")) : $b)) ? (idx = self.subs.$index(\"specialcharacters\")) : $a))) {\n          \n          $writer = [idx, \"highlight\"];\n          $send(self.subs, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];};\n        return self.subs;\n      }, TMP_Substitutors_lock_in_subs_73.$$arity = 0);\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/abstract_node\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send, $range = Opal.range;\n\n  Opal.add_stubs(['$include', '$attr_reader', '$attr_accessor', '$==', '$document', '$to_s', '$key?', '$dup', '$[]', '$converter', '$raise', '$attributes', '$nil?', '$[]=', '$-', '$delete', '$update', '$nil_or_empty?', '$split', '$include?', '$empty?', '$*', '$apply_reftext_subs', '$attr?', '$extname', '$image_uri', '$attr', '$<', '$safe', '$uriish?', '$uri_encode_spaces', '$normalize_web_path', '$generate_data_uri_from_uri', '$generate_data_uri', '$normalize_system_path', '$readable?', '$warn', '$encode64', '$binread', '$require_library', '$!', '$open', '$content_type', '$read', '$base_dir', '$new', '$root?', '$join', '$system_path', '$web_path', '$===', '$!=', '$normalize_lines_from_string', '$open_uri', '$fetch', '$read_asset', '$gsub']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $AbstractNode(){};\n      var self = $AbstractNode = $klass($base, $super, 'AbstractNode', $AbstractNode);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_AbstractNode_initialize_1, TMP_AbstractNode_parent$eq_2, TMP_AbstractNode_converter_3, TMP_AbstractNode_block$q_4, TMP_AbstractNode_inline$q_5, TMP_AbstractNode_attr_6, TMP_AbstractNode_attr$q_7, TMP_AbstractNode_set_attr_8, TMP_AbstractNode_remove_attr_9, TMP_AbstractNode_option$q_10, TMP_AbstractNode_set_option_11, TMP_AbstractNode_update_attributes_12, TMP_AbstractNode_role_13, TMP_AbstractNode_roles_14, TMP_AbstractNode_role$q_15, TMP_AbstractNode_has_role$q_16, TMP_AbstractNode_add_role_17, TMP_AbstractNode_remove_role_18, TMP_AbstractNode_reftext_19, TMP_AbstractNode_reftext$q_20, TMP_AbstractNode_icon_uri_21, TMP_AbstractNode_image_uri_22, TMP_AbstractNode_media_uri_23, TMP_AbstractNode_generate_data_uri_24, TMP_AbstractNode_generate_data_uri_from_uri_26, TMP_AbstractNode_normalize_asset_path_27, TMP_AbstractNode_normalize_system_path_28, TMP_AbstractNode_normalize_web_path_29, TMP_AbstractNode_read_asset_30, TMP_AbstractNode_read_contents_32, TMP_AbstractNode_uri_encode_spaces_33, TMP_AbstractNode_is_uri$q_34;\n\n      def.document = def.attributes = def.parent = def.path_resolver = nil;\n      \n      self.$include($$($nesting, 'Substitutors'));\n      self.$attr_reader(\"parent\");\n      self.$attr_reader(\"document\");\n      self.$attr_reader(\"context\");\n      self.$attr_reader(\"node_name\");\n      self.$attr_accessor(\"id\");\n      self.$attr_reader(\"attributes\");\n      \n      Opal.def(self, '$initialize', TMP_AbstractNode_initialize_1 = function $$initialize(parent, context, opts) {\n        var $a, self = this;\n\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        \n        if (context['$=='](\"document\")) {\n          $a = [self, nil], (self.document = $a[0]), (self.parent = $a[1]), $a\n        } else if ($truthy(parent)) {\n          $a = [parent.$document(), parent], (self.document = $a[0]), (self.parent = $a[1]), $a\n        } else {\n          self.document = (self.parent = nil)\n        };\n        self.node_name = (self.context = context).$to_s();\n        self.attributes = (function() {if ($truthy(opts['$key?'](\"attributes\"))) {\n          return opts['$[]'](\"attributes\").$dup()\n        } else {\n          return $hash2([], {})\n        }; return nil; })();\n        return (self.passthroughs = $hash2([], {}));\n      }, TMP_AbstractNode_initialize_1.$$arity = -3);\n      \n      Opal.def(self, '$parent=', TMP_AbstractNode_parent$eq_2 = function(parent) {\n        var $a, self = this;\n\n        \n        $a = [parent, parent.$document()], (self.parent = $a[0]), (self.document = $a[1]), $a;\n        return nil;\n      }, TMP_AbstractNode_parent$eq_2.$$arity = 1);\n      \n      Opal.def(self, '$converter', TMP_AbstractNode_converter_3 = function $$converter() {\n        var self = this;\n\n        return self.document.$converter()\n      }, TMP_AbstractNode_converter_3.$$arity = 0);\n      \n      Opal.def(self, '$block?', TMP_AbstractNode_block$q_4 = function() {\n        var self = this;\n\n        return self.$raise($$$('::', 'NotImplementedError'))\n      }, TMP_AbstractNode_block$q_4.$$arity = 0);\n      \n      Opal.def(self, '$inline?', TMP_AbstractNode_inline$q_5 = function() {\n        var self = this;\n\n        return self.$raise($$$('::', 'NotImplementedError'))\n      }, TMP_AbstractNode_inline$q_5.$$arity = 0);\n      \n      Opal.def(self, '$attr', TMP_AbstractNode_attr_6 = function $$attr(name, default_val, inherit) {\n        var $a, $b, self = this;\n\n        if (default_val == null) {\n          default_val = nil;\n        }\n        if (inherit == null) {\n          inherit = true;\n        }\n        \n        name = name.$to_s();\n        return ($truthy($a = self.attributes['$[]'](name)) ? $a : (function() {if ($truthy(($truthy($b = inherit) ? self.parent : $b))) {\n          return ($truthy($b = self.document.$attributes()['$[]'](name)) ? $b : default_val)\n        } else {\n          return default_val\n        }; return nil; })());\n      }, TMP_AbstractNode_attr_6.$$arity = -2);\n      \n      Opal.def(self, '$attr?', TMP_AbstractNode_attr$q_7 = function(name, expect_val, inherit) {\n        var $a, $b, $c, self = this;\n\n        if (expect_val == null) {\n          expect_val = nil;\n        }\n        if (inherit == null) {\n          inherit = true;\n        }\n        \n        name = name.$to_s();\n        if ($truthy(expect_val['$nil?']())) {\n          return ($truthy($a = self.attributes['$key?'](name)) ? $a : ($truthy($b = ($truthy($c = inherit) ? self.parent : $c)) ? self.document.$attributes()['$key?'](name) : $b))\n        } else {\n          return expect_val['$=='](($truthy($a = self.attributes['$[]'](name)) ? $a : (function() {if ($truthy(($truthy($b = inherit) ? self.parent : $b))) {\n            return self.document.$attributes()['$[]'](name)\n          } else {\n            return nil\n          }; return nil; })()))\n        };\n      }, TMP_AbstractNode_attr$q_7.$$arity = -2);\n      \n      Opal.def(self, '$set_attr', TMP_AbstractNode_set_attr_8 = function $$set_attr(name, value, overwrite) {\n        var $a, self = this, $writer = nil;\n\n        if (value == null) {\n          value = \"\";\n        }\n        if (overwrite == null) {\n          overwrite = true;\n        }\n        if ($truthy((($a = overwrite['$=='](false)) ? self.attributes['$key?'](name) : overwrite['$=='](false)))) {\n          return false\n        } else {\n          \n          \n          $writer = [name, value];\n          $send(self.attributes, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          return true;\n        }\n      }, TMP_AbstractNode_set_attr_8.$$arity = -2);\n      \n      Opal.def(self, '$remove_attr', TMP_AbstractNode_remove_attr_9 = function $$remove_attr(name) {\n        var self = this;\n\n        return self.attributes.$delete(name)\n      }, TMP_AbstractNode_remove_attr_9.$$arity = 1);\n      \n      Opal.def(self, '$option?', TMP_AbstractNode_option$q_10 = function(name) {\n        var self = this;\n\n        return self.attributes['$key?'](\"\" + (name) + \"-option\")\n      }, TMP_AbstractNode_option$q_10.$$arity = 1);\n      \n      Opal.def(self, '$set_option', TMP_AbstractNode_set_option_11 = function $$set_option(name) {\n        var self = this, $writer = nil;\n\n        \n        if ($truthy(self.attributes['$key?'](\"options\"))) {\n          \n          $writer = [\"options\", \"\" + (self.attributes['$[]'](\"options\")) + \",\" + (name)];\n          $send(self.attributes, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];\n        } else {\n          \n          $writer = [\"options\", name];\n          $send(self.attributes, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];\n        };\n        \n        $writer = [\"\" + (name) + \"-option\", \"\"];\n        $send(self.attributes, '[]=', Opal.to_a($writer));\n        return $writer[$rb_minus($writer[\"length\"], 1)];;\n      }, TMP_AbstractNode_set_option_11.$$arity = 1);\n      \n      Opal.def(self, '$update_attributes', TMP_AbstractNode_update_attributes_12 = function $$update_attributes(attributes) {\n        var self = this;\n\n        \n        self.attributes.$update(attributes);\n        return nil;\n      }, TMP_AbstractNode_update_attributes_12.$$arity = 1);\n      \n      Opal.def(self, '$role', TMP_AbstractNode_role_13 = function $$role() {\n        var $a, self = this;\n\n        return ($truthy($a = self.attributes['$[]'](\"role\")) ? $a : self.document.$attributes()['$[]'](\"role\"))\n      }, TMP_AbstractNode_role_13.$$arity = 0);\n      \n      Opal.def(self, '$roles', TMP_AbstractNode_roles_14 = function $$roles() {\n        var $a, self = this, val = nil;\n\n        if ($truthy((val = ($truthy($a = self.attributes['$[]'](\"role\")) ? $a : self.document.$attributes()['$[]'](\"role\")))['$nil_or_empty?']())) {\n          return []\n        } else {\n          return val.$split()\n        }\n      }, TMP_AbstractNode_roles_14.$$arity = 0);\n      \n      Opal.def(self, '$role?', TMP_AbstractNode_role$q_15 = function(expect_val) {\n        var $a, self = this;\n\n        if (expect_val == null) {\n          expect_val = nil;\n        }\n        if ($truthy(expect_val)) {\n          return expect_val['$=='](($truthy($a = self.attributes['$[]'](\"role\")) ? $a : self.document.$attributes()['$[]'](\"role\")))\n        } else {\n          return ($truthy($a = self.attributes['$key?'](\"role\")) ? $a : self.document.$attributes()['$key?'](\"role\"))\n        }\n      }, TMP_AbstractNode_role$q_15.$$arity = -1);\n      \n      Opal.def(self, '$has_role?', TMP_AbstractNode_has_role$q_16 = function(name) {\n        var $a, self = this, val = nil;\n\n        if ($truthy((val = ($truthy($a = self.attributes['$[]'](\"role\")) ? $a : self.document.$attributes()['$[]'](\"role\")))['$nil_or_empty?']())) {\n          return false\n        } else {\n          return (((\"\" + \" \") + (val)) + \" \")['$include?'](\"\" + \" \" + (name) + \" \")\n        }\n      }, TMP_AbstractNode_has_role$q_16.$$arity = 1);\n      \n      Opal.def(self, '$add_role', TMP_AbstractNode_add_role_17 = function $$add_role(name) {\n        var self = this, val = nil, $writer = nil;\n\n        if ($truthy((val = self.attributes['$[]'](\"role\"))['$nil_or_empty?']())) {\n          \n          \n          $writer = [\"role\", name];\n          $send(self.attributes, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          return true;\n        } else if ($truthy((((\"\" + \" \") + (val)) + \" \")['$include?'](\"\" + \" \" + (name) + \" \"))) {\n          return false\n        } else {\n          \n          \n          $writer = [\"role\", \"\" + (val) + \" \" + (name)];\n          $send(self.attributes, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          return true;\n        }\n      }, TMP_AbstractNode_add_role_17.$$arity = 1);\n      \n      Opal.def(self, '$remove_role', TMP_AbstractNode_remove_role_18 = function $$remove_role(name) {\n        var self = this, val = nil, $writer = nil;\n\n        if ($truthy((val = self.attributes['$[]'](\"role\"))['$nil_or_empty?']())) {\n          return false\n        } else if ($truthy((val = val.$split()).$delete(name))) {\n          \n          if ($truthy(val['$empty?']())) {\n            self.attributes.$delete(\"role\")\n          } else {\n            \n            $writer = [\"role\", $rb_times(val, \" \")];\n            $send(self.attributes, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];\n          };\n          return true;\n        } else {\n          return false\n        }\n      }, TMP_AbstractNode_remove_role_18.$$arity = 1);\n      \n      Opal.def(self, '$reftext', TMP_AbstractNode_reftext_19 = function $$reftext() {\n        var self = this, val = nil;\n\n        if ($truthy((val = self.attributes['$[]'](\"reftext\")))) {\n          \n          return self.$apply_reftext_subs(val);\n        } else {\n          return nil\n        }\n      }, TMP_AbstractNode_reftext_19.$$arity = 0);\n      \n      Opal.def(self, '$reftext?', TMP_AbstractNode_reftext$q_20 = function() {\n        var self = this;\n\n        return self.attributes['$key?'](\"reftext\")\n      }, TMP_AbstractNode_reftext$q_20.$$arity = 0);\n      \n      Opal.def(self, '$icon_uri', TMP_AbstractNode_icon_uri_21 = function $$icon_uri(name) {\n        var self = this, uri = nil;\n\n        if ($truthy(self['$attr?'](\"icon\"))) {\n          if ($truthy($$$('::', 'File').$extname((uri = self.$image_uri(self.$attr(\"icon\"), \"iconsdir\")))['$empty?']())) {\n            return \"\" + (uri) + \".\" + (self.document.$attr(\"icontype\", \"png\"))\n          } else {\n            return uri\n          }\n        } else {\n          return self.$image_uri(\"\" + (name) + \".\" + (self.document.$attr(\"icontype\", \"png\")), \"iconsdir\")\n        }\n      }, TMP_AbstractNode_icon_uri_21.$$arity = 1);\n      \n      Opal.def(self, '$image_uri', TMP_AbstractNode_image_uri_22 = function $$image_uri(target_image, asset_dir_key) {\n        var $a, $b, $c, $d, self = this, doc = nil, images_base = nil;\n\n        if (asset_dir_key == null) {\n          asset_dir_key = \"imagesdir\";\n        }\n        if ($truthy(($truthy($a = $rb_lt((doc = self.document).$safe(), $$$($$($nesting, 'SafeMode'), 'SECURE'))) ? doc['$attr?'](\"data-uri\") : $a))) {\n          if ($truthy(($truthy($a = ($truthy($b = $$($nesting, 'Helpers')['$uriish?'](target_image)) ? (target_image = self.$uri_encode_spaces(target_image)) : $b)) ? $a : ($truthy($b = ($truthy($c = ($truthy($d = asset_dir_key) ? (images_base = doc.$attr(asset_dir_key)) : $d)) ? $$($nesting, 'Helpers')['$uriish?'](images_base) : $c)) ? (target_image = self.$normalize_web_path(target_image, images_base, false)) : $b)))) {\n            if ($truthy(doc['$attr?'](\"allow-uri-read\"))) {\n              return self.$generate_data_uri_from_uri(target_image, doc['$attr?'](\"cache-uri\"))\n            } else {\n              return target_image\n            }\n          } else {\n            return self.$generate_data_uri(target_image, asset_dir_key)\n          }\n        } else {\n          return self.$normalize_web_path(target_image, (function() {if ($truthy(asset_dir_key)) {\n            \n            return doc.$attr(asset_dir_key);\n          } else {\n            return nil\n          }; return nil; })())\n        }\n      }, TMP_AbstractNode_image_uri_22.$$arity = -2);\n      \n      Opal.def(self, '$media_uri', TMP_AbstractNode_media_uri_23 = function $$media_uri(target, asset_dir_key) {\n        var self = this;\n\n        if (asset_dir_key == null) {\n          asset_dir_key = \"imagesdir\";\n        }\n        return self.$normalize_web_path(target, (function() {if ($truthy(asset_dir_key)) {\n          return self.document.$attr(asset_dir_key)\n        } else {\n          return nil\n        }; return nil; })())\n      }, TMP_AbstractNode_media_uri_23.$$arity = -2);\n      \n      Opal.def(self, '$generate_data_uri', TMP_AbstractNode_generate_data_uri_24 = function $$generate_data_uri(target_image, asset_dir_key) {\n        var self = this, ext = nil, mimetype = nil, image_path = nil;\n\n        if (asset_dir_key == null) {\n          asset_dir_key = nil;\n        }\n        \n        ext = $$$('::', 'File').$extname(target_image);\n        mimetype = (function() {if (ext['$=='](\".svg\")) {\n          return \"image/svg+xml\"\n        } else {\n          return \"\" + \"image/\" + (ext['$[]']($range(1, -1, false)))\n        }; return nil; })();\n        if ($truthy(asset_dir_key)) {\n          image_path = self.$normalize_system_path(target_image, self.document.$attr(asset_dir_key), nil, $hash2([\"target_name\"], {\"target_name\": \"image\"}))\n        } else {\n          image_path = self.$normalize_system_path(target_image)\n        };\n        if ($truthy($$$('::', 'File')['$readable?'](image_path))) {\n        } else {\n          \n          self.$warn(\"\" + \"asciidoctor: WARNING: image to embed not found or not readable: \" + (image_path));\n          return \"\" + \"data:\" + (mimetype) + \";base64,\";\n        };\n        return \"\" + \"data:\" + (mimetype) + \";base64,\" + ($$$('::', 'Base64').$encode64($$$('::', 'IO').$binread(image_path)).$delete($$($nesting, 'LF')));\n      }, TMP_AbstractNode_generate_data_uri_24.$$arity = -2);\n      \n      Opal.def(self, '$generate_data_uri_from_uri', TMP_AbstractNode_generate_data_uri_from_uri_26 = function $$generate_data_uri_from_uri(image_uri, cache_uri) {\n        var TMP_25, self = this, mimetype = nil, bindata = nil;\n\n        if (cache_uri == null) {\n          cache_uri = false;\n        }\n        \n        if ($truthy(cache_uri)) {\n          $$($nesting, 'Helpers').$require_library(\"open-uri/cached\", \"open-uri-cached\")\n        } else if ($truthy($$$('::', 'RUBY_ENGINE_OPAL')['$!']())) {\n          $$$('::', 'OpenURI')};\n        \n        try {\n          \n          mimetype = nil;\n          bindata = $send(self, 'open', [image_uri, \"rb\"], (TMP_25 = function(fd){var self = TMP_25.$$s || this;\nif (fd == null) fd = nil;\n          \n            mimetype = fd.$content_type();\n            return fd.$read();}, TMP_25.$$s = self, TMP_25.$$arity = 1, TMP_25));\n          return \"\" + \"data:\" + (mimetype) + \";base64,\" + ($$$('::', 'Base64').$encode64(bindata).$delete($$($nesting, 'LF')));\n        } catch ($err) {\n          if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {\n            try {\n              \n              self.$warn(\"\" + \"asciidoctor: WARNING: could not retrieve image data from URI: \" + (image_uri));\n              return image_uri;\n            } finally { Opal.pop_exception() }\n          } else { throw $err; }\n        };;\n      }, TMP_AbstractNode_generate_data_uri_from_uri_26.$$arity = -2);\n      \n      Opal.def(self, '$normalize_asset_path', TMP_AbstractNode_normalize_asset_path_27 = function $$normalize_asset_path(asset_ref, asset_name, autocorrect) {\n        var self = this;\n\n        if (asset_name == null) {\n          asset_name = \"path\";\n        }\n        if (autocorrect == null) {\n          autocorrect = true;\n        }\n        return self.$normalize_system_path(asset_ref, self.document.$base_dir(), nil, $hash2([\"target_name\", \"recover\"], {\"target_name\": asset_name, \"recover\": autocorrect}))\n      }, TMP_AbstractNode_normalize_asset_path_27.$$arity = -2);\n      \n      Opal.def(self, '$normalize_system_path', TMP_AbstractNode_normalize_system_path_28 = function $$normalize_system_path(target, start, jail, opts) {\n        var $a, self = this, path_resolver = nil, doc = nil;\n\n        if (start == null) {\n          start = nil;\n        }\n        if (jail == null) {\n          jail = nil;\n        }\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        \n        path_resolver = (self.path_resolver = ($truthy($a = self.path_resolver) ? $a : $$($nesting, 'PathResolver').$new()));\n        if ($truthy($rb_lt((doc = self.document).$safe(), $$$($$($nesting, 'SafeMode'), 'SAFE')))) {\n          if ($truthy(start)) {\n            if ($truthy(path_resolver['$root?'](start))) {\n            } else {\n              start = $$$('::', 'File').$join(doc.$base_dir(), start)\n            }\n          } else {\n            start = doc.$base_dir()\n          }\n        } else {\n          \n          if ($truthy(start)) {\n          } else {\n            start = doc.$base_dir()\n          };\n          if ($truthy(jail)) {\n          } else {\n            jail = doc.$base_dir()\n          };\n        };\n        return path_resolver.$system_path(target, start, jail, opts);\n      }, TMP_AbstractNode_normalize_system_path_28.$$arity = -2);\n      \n      Opal.def(self, '$normalize_web_path', TMP_AbstractNode_normalize_web_path_29 = function $$normalize_web_path(target, start, preserve_uri_target) {\n        var $a, self = this;\n\n        if (start == null) {\n          start = nil;\n        }\n        if (preserve_uri_target == null) {\n          preserve_uri_target = true;\n        }\n        if ($truthy(($truthy($a = preserve_uri_target) ? $$($nesting, 'Helpers')['$uriish?'](target) : $a))) {\n          return self.$uri_encode_spaces(target)\n        } else {\n          return (self.path_resolver = ($truthy($a = self.path_resolver) ? $a : $$($nesting, 'PathResolver').$new())).$web_path(target, start)\n        }\n      }, TMP_AbstractNode_normalize_web_path_29.$$arity = -2);\n      \n      Opal.def(self, '$read_asset', TMP_AbstractNode_read_asset_30 = function $$read_asset(path, opts) {\n        var $a, self = this;\n\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        \n        if ($truthy($$$('::', 'Hash')['$==='](opts))) {\n        } else {\n          opts = $hash2([\"warn_on_failure\"], {\"warn_on_failure\": opts['$!='](false)})\n        };\n        if ($truthy($$$('::', 'File')['$readable?'](path))) {\n          if ($truthy(opts['$[]'](\"normalize\"))) {\n            return $rb_times($$($nesting, 'Helpers').$normalize_lines_from_string($$$('::', 'IO').$read(path)), $$($nesting, 'LF'))\n          } else {\n            return $$$('::', 'IO').$read(path)\n          }\n        } else if ($truthy(opts['$[]'](\"warn_on_failure\"))) {\n          return self.$warn(\"\" + \"asciidoctor: WARNING: \" + (($truthy($a = self.$attr(\"docfile\")) ? $a : \"<stdin>\")) + \": \" + (($truthy($a = opts['$[]'](\"label\")) ? $a : \"file\")) + \" does not exist or cannot be read: \" + (path))\n        } else {\n          return nil\n        };\n      }, TMP_AbstractNode_read_asset_30.$$arity = -2);\n      \n      Opal.def(self, '$read_contents', TMP_AbstractNode_read_contents_32 = function $$read_contents(target, opts) {\n        var $a, $b, $c, TMP_31, self = this, doc = nil, start = nil, data = nil;\n\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        \n        doc = self.document;\n        if ($truthy(($truthy($a = $$($nesting, 'Helpers')['$uriish?'](target)) ? $a : ($truthy($b = ($truthy($c = (start = opts['$[]'](\"start\"))) ? $$($nesting, 'Helpers')['$uriish?'](start) : $c)) ? (target = (self.path_resolver = ($truthy($c = self.path_resolver) ? $c : $$($nesting, 'PathResolver').$new())).$web_path(target, start)) : $b)))) {\n          if ($truthy(doc['$attr?'](\"allow-uri-read\"))) {\n            \n            if ($truthy(doc['$attr?'](\"cache-uri\"))) {\n              $$($nesting, 'Helpers').$require_library(\"open-uri/cached\", \"open-uri-cached\")};\n            \n            try {\n              \n              data = $send($$$('::', 'OpenURI'), 'open_uri', [target], (TMP_31 = function(fd){var self = TMP_31.$$s || this;\nif (fd == null) fd = nil;\n              return fd.$read()}, TMP_31.$$s = self, TMP_31.$$arity = 1, TMP_31));\n              if ($truthy(opts['$[]'](\"normalize\"))) {\n                data = $rb_times($$($nesting, 'Helpers').$normalize_lines_from_string(data), $$($nesting, 'LF'))};\n            } catch ($err) {\n              if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {\n                try {\n                  \n                  if ($truthy(opts.$fetch(\"warn_on_failure\", true))) {\n                    self.$warn(\"\" + \"asciidoctor: WARNING: could not retrieve contents of \" + (($truthy($a = opts['$[]'](\"label\")) ? $a : \"asset\")) + \" at URI: \" + (target))};\n                  data = nil;\n                } finally { Opal.pop_exception() }\n              } else { throw $err; }\n            };;\n          } else {\n            \n            if ($truthy(opts.$fetch(\"warn_on_failure\", true))) {\n              self.$warn(\"\" + \"asciidoctor: WARNING: cannot retrieve contents of \" + (($truthy($a = opts['$[]'](\"label\")) ? $a : \"asset\")) + \" at URI: \" + (target) + \" (allow-uri-read attribute not enabled)\")};\n            data = nil;\n          }\n        } else {\n          \n          target = self.$normalize_system_path(target, opts['$[]'](\"start\"), nil, $hash2([\"target_name\"], {\"target_name\": ($truthy($a = opts['$[]'](\"label\")) ? $a : \"asset\")}));\n          data = self.$read_asset(target, $hash2([\"normalize\", \"warn_on_failure\", \"label\"], {\"normalize\": opts['$[]'](\"normalize\"), \"warn_on_failure\": opts.$fetch(\"warn_on_failure\", true), \"label\": opts['$[]'](\"label\")}));\n        };\n        return data;\n      }, TMP_AbstractNode_read_contents_32.$$arity = -2);\n      \n      Opal.def(self, '$uri_encode_spaces', TMP_AbstractNode_uri_encode_spaces_33 = function $$uri_encode_spaces(str) {\n        var self = this;\n\n        if ($truthy(str['$include?'](\" \"))) {\n          \n          return str.$gsub(\" \", \"%20\");\n        } else {\n          return str\n        }\n      }, TMP_AbstractNode_uri_encode_spaces_33.$$arity = 1);\n      return (Opal.def(self, '$is_uri?', TMP_AbstractNode_is_uri$q_34 = function(str) {\n        var self = this;\n\n        return $$($nesting, 'Helpers')['$uriish?'](str)\n      }, TMP_AbstractNode_is_uri$q_34.$$arity = 1), nil) && 'is_uri?';\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/abstract_block\"] = function(Opal) {\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$attr_accessor', '$attr_reader', '$attr_writer', '$==', '$!=', '$level', '$to_s', '$playback_attributes', '$convert', '$converter', '$*', '$map', '$file', '$lineno', '$include?', '$apply_title_subs', '$[]', '$title', '$sub_specialchars', '$match?', '$sub_replacements', '$reftext', '$!', '$empty?', '$===', '$sprintf', '$sub_quotes', '$compat_mode', '$attributes', '$chomp', '$<<', '$select', '$context', '$>', '$has_role?', '$header?', '$concat', '$find_by', '$to_proc', '$each', '$flatten', '$blocks', '$parent', '$+', '$find_index', '$next_adjacent_block', '$delete', '$increment_and_store_counter', '$index=', '$-', '$numbered', '$sectname', '$counter', '$number=', '$number', '$caption=', '$enumerate_section', '$reindex_sections']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $AbstractBlock(){};\n      var self = $AbstractBlock = $klass($base, $super, 'AbstractBlock', $AbstractBlock);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_AbstractBlock_initialize_1, TMP_AbstractBlock_block$q_2, TMP_AbstractBlock_inline$q_3, TMP_AbstractBlock_context$eq_4, TMP_AbstractBlock_convert_5, TMP_AbstractBlock_content_7, TMP_AbstractBlock_file_8, TMP_AbstractBlock_lineno_9, TMP_AbstractBlock_sub$q_10, TMP_AbstractBlock_title$q_11, TMP_AbstractBlock_title_12, TMP_AbstractBlock_title$eq_13, TMP_AbstractBlock_caption_14, TMP_AbstractBlock_captioned_title_15, TMP_AbstractBlock_alt_16, TMP_AbstractBlock_xreftext_17, TMP_AbstractBlock_blocks$q_18, TMP_AbstractBlock_$lt$lt_19, TMP_AbstractBlock_sections_21, TMP_AbstractBlock_sections$q_22, TMP_AbstractBlock_find_by_23, TMP_AbstractBlock_next_adjacent_block_26, TMP_AbstractBlock_remove_sub_27, TMP_AbstractBlock_assign_caption_28, TMP_AbstractBlock_enumerate_section_29, TMP_AbstractBlock_list_marker_keyword_30, TMP_AbstractBlock_reindex_sections_32;\n\n      def.document = def.attributes = def.blocks = def.source_location = def.subs = def.title = def.title_converted = def.converted_title = def.context = def.caption = def.number = def.next_section_index = def.style = def.id = def.header = def.next_section_number = nil;\n      \n      self.$attr_accessor(\"content_model\");\n      self.$attr_reader(\"subs\");\n      self.$attr_reader(\"blocks\");\n      self.$attr_accessor(\"level\");\n      self.$attr_accessor(\"style\");\n      self.$attr_writer(\"caption\");\n      self.$attr_accessor(\"number\");\n      self.$attr_accessor(\"source_location\");\n      \n      Opal.def(self, '$initialize', TMP_AbstractBlock_initialize_1 = function $$initialize(parent, context, opts) {\n        var $a, self = this, $iter = TMP_AbstractBlock_initialize_1.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        if ($iter) TMP_AbstractBlock_initialize_1.$$p = null;\n        // Prepare super implicit arguments\n        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n          $zuper[$zuper_i] = arguments[$zuper_i];\n        }\n        \n        $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_AbstractBlock_initialize_1, false), $zuper, $iter);\n        self.content_model = \"compound\";\n        self.blocks = [];\n        self.subs = [];\n        self.id = (self.title = (self.title_converted = (self.caption = (self.number = (self.style = (self.default_subs = (self.source_location = nil)))))));\n        if (context['$=='](\"document\")) {\n          self.level = 0\n        } else if ($truthy(($truthy($a = parent) ? context['$!='](\"section\") : $a))) {\n          self.level = parent.$level()\n        } else {\n          self.level = nil\n        };\n        self.next_section_index = 0;\n        return (self.next_section_number = 1);\n      }, TMP_AbstractBlock_initialize_1.$$arity = -3);\n      \n      Opal.def(self, '$block?', TMP_AbstractBlock_block$q_2 = function() {\n        var self = this;\n\n        return true\n      }, TMP_AbstractBlock_block$q_2.$$arity = 0);\n      \n      Opal.def(self, '$inline?', TMP_AbstractBlock_inline$q_3 = function() {\n        var self = this;\n\n        return false\n      }, TMP_AbstractBlock_inline$q_3.$$arity = 0);\n      \n      Opal.def(self, '$context=', TMP_AbstractBlock_context$eq_4 = function(context) {\n        var self = this;\n\n        \n        self.context = context;\n        return (self.node_name = context.$to_s());\n      }, TMP_AbstractBlock_context$eq_4.$$arity = 1);\n      \n      Opal.def(self, '$convert', TMP_AbstractBlock_convert_5 = function $$convert() {\n        var self = this;\n\n        \n        self.document.$playback_attributes(self.attributes);\n        return self.$converter().$convert(self);\n      }, TMP_AbstractBlock_convert_5.$$arity = 0);\n      Opal.alias(self, \"render\", \"convert\");\n      \n      Opal.def(self, '$content', TMP_AbstractBlock_content_7 = function $$content() {\n        var TMP_6, self = this;\n\n        return $rb_times($send(self.blocks, 'map', [], (TMP_6 = function(b){var self = TMP_6.$$s || this;\nif (b == null) b = nil;\n        return b.$convert()}, TMP_6.$$s = self, TMP_6.$$arity = 1, TMP_6)), $$($nesting, 'LF'))\n      }, TMP_AbstractBlock_content_7.$$arity = 0);\n      \n      Opal.def(self, '$file', TMP_AbstractBlock_file_8 = function $$file() {\n        var self = this;\n\n        if ($truthy(self.source_location)) {\n          return self.source_location.$file()\n        } else {\n          return nil\n        }\n      }, TMP_AbstractBlock_file_8.$$arity = 0);\n      \n      Opal.def(self, '$lineno', TMP_AbstractBlock_lineno_9 = function $$lineno() {\n        var self = this;\n\n        if ($truthy(self.source_location)) {\n          return self.source_location.$lineno()\n        } else {\n          return nil\n        }\n      }, TMP_AbstractBlock_lineno_9.$$arity = 0);\n      \n      Opal.def(self, '$sub?', TMP_AbstractBlock_sub$q_10 = function(name) {\n        var self = this;\n\n        return self.subs['$include?'](name)\n      }, TMP_AbstractBlock_sub$q_10.$$arity = 1);\n      \n      Opal.def(self, '$title?', TMP_AbstractBlock_title$q_11 = function() {\n        var self = this;\n\n        if ($truthy(self.title)) {\n          return true\n        } else {\n          return false\n        }\n      }, TMP_AbstractBlock_title$q_11.$$arity = 0);\n      \n      Opal.def(self, '$title', TMP_AbstractBlock_title_12 = function $$title() {\n        var $a, $b, self = this;\n\n        if ($truthy(self.title_converted)) {\n          return self.converted_title\n        } else {\n          \n          return (self.converted_title = ($truthy($a = ($truthy($b = (self.title_converted = true)) ? self.title : $b)) ? self.$apply_title_subs(self.title) : $a));\n        }\n      }, TMP_AbstractBlock_title_12.$$arity = 0);\n      \n      Opal.def(self, '$title=', TMP_AbstractBlock_title$eq_13 = function(val) {\n        var $a, self = this;\n\n        return $a = [val, nil], (self.title = $a[0]), (self.title_converted = $a[1]), $a\n      }, TMP_AbstractBlock_title$eq_13.$$arity = 1);\n      \n      Opal.def(self, '$caption', TMP_AbstractBlock_caption_14 = function $$caption() {\n        var self = this;\n\n        if (self.context['$=='](\"admonition\")) {\n          return self.attributes['$[]'](\"textlabel\")\n        } else {\n          return self.caption\n        }\n      }, TMP_AbstractBlock_caption_14.$$arity = 0);\n      \n      Opal.def(self, '$captioned_title', TMP_AbstractBlock_captioned_title_15 = function $$captioned_title() {\n        var self = this;\n\n        return \"\" + (self.caption) + (self.$title())\n      }, TMP_AbstractBlock_captioned_title_15.$$arity = 0);\n      \n      Opal.def(self, '$alt', TMP_AbstractBlock_alt_16 = function $$alt() {\n        var self = this, text = nil;\n\n        if ($truthy((text = self.attributes['$[]'](\"alt\")))) {\n          if (text['$=='](self.attributes['$[]'](\"default-alt\"))) {\n            return self.$sub_specialchars(text)\n          } else {\n            \n            text = self.$sub_specialchars(text);\n            if ($truthy($$($nesting, 'ReplaceableTextRx')['$match?'](text))) {\n              \n              return self.$sub_replacements(text);\n            } else {\n              return text\n            };\n          }\n        } else {\n          return nil\n        }\n      }, TMP_AbstractBlock_alt_16.$$arity = 0);\n      \n      Opal.def(self, '$xreftext', TMP_AbstractBlock_xreftext_17 = function $$xreftext(xrefstyle) {\n        var $a, $b, self = this, val = nil, $case = nil, quoted_title = nil, prefix = nil;\n\n        if (xrefstyle == null) {\n          xrefstyle = nil;\n        }\n        if ($truthy(($truthy($a = (val = self.$reftext())) ? val['$empty?']()['$!']() : $a))) {\n          return val\n        } else if ($truthy(($truthy($a = ($truthy($b = xrefstyle) ? self.title : $b)) ? self.caption : $a))) {\n          return (function() {$case = xrefstyle;\n          if (\"full\"['$===']($case)) {\n          quoted_title = self.$sprintf(self.$sub_quotes((function() {if ($truthy(self.document.$compat_mode())) {\n            return \"``%s''\"\n          } else {\n            return \"\\\"`%s`\\\"\"\n          }; return nil; })()), self.$title());\n          if ($truthy(($truthy($a = self.number) ? (prefix = self.document.$attributes()['$[]']((function() {if (self.context['$=='](\"image\")) {\n            return \"figure-caption\"\n          } else {\n            return \"\" + (self.context) + \"-caption\"\n          }; return nil; })())) : $a))) {\n            return \"\" + (prefix) + \" \" + (self.number) + \", \" + (quoted_title)\n          } else {\n            return \"\" + (self.caption.$chomp(\". \")) + \", \" + (quoted_title)\n          };}\n          else if (\"short\"['$===']($case)) {if ($truthy(($truthy($a = self.number) ? (prefix = self.document.$attributes()['$[]']((function() {if (self.context['$=='](\"image\")) {\n            return \"figure-caption\"\n          } else {\n            return \"\" + (self.context) + \"-caption\"\n          }; return nil; })())) : $a))) {\n            return \"\" + (prefix) + \" \" + (self.number)\n          } else {\n            return self.caption.$chomp(\". \")\n          }}\n          else {return self.$title()}})()\n        } else {\n          return self.$title()\n        }\n      }, TMP_AbstractBlock_xreftext_17.$$arity = -1);\n      \n      Opal.def(self, '$blocks?', TMP_AbstractBlock_blocks$q_18 = function() {\n        var self = this;\n\n        return self.blocks['$empty?']()['$!']()\n      }, TMP_AbstractBlock_blocks$q_18.$$arity = 0);\n      \n      Opal.def(self, '$<<', TMP_AbstractBlock_$lt$lt_19 = function(block) {\n        var self = this;\n\n        \n        self.blocks['$<<'](block);\n        return self;\n      }, TMP_AbstractBlock_$lt$lt_19.$$arity = 1);\n      Opal.alias(self, \"append\", \"<<\");\n      \n      Opal.def(self, '$sections', TMP_AbstractBlock_sections_21 = function $$sections() {\n        var TMP_20, self = this;\n\n        return $send(self.blocks, 'select', [], (TMP_20 = function(block){var self = TMP_20.$$s || this;\nif (block == null) block = nil;\n        return block.$context()['$=='](\"section\")}, TMP_20.$$s = self, TMP_20.$$arity = 1, TMP_20))\n      }, TMP_AbstractBlock_sections_21.$$arity = 0);\n      \n      Opal.def(self, '$sections?', TMP_AbstractBlock_sections$q_22 = function() {\n        var self = this;\n\n        return $rb_gt(self.next_section_index, 0)\n      }, TMP_AbstractBlock_sections$q_22.$$arity = 0);\n      \n      Opal.def(self, '$find_by', TMP_AbstractBlock_find_by_23 = function $$find_by(selector) {\n        var $a, $b, $c, $d, TMP_24, TMP_25, self = this, $iter = TMP_AbstractBlock_find_by_23.$$p, block = $iter || nil, result = nil, any_context = nil, context_selector = nil, style_selector = nil, role_selector = nil, id_selector = nil;\n\n        if (selector == null) {\n          selector = $hash2([], {});\n        }\n        if ($iter) TMP_AbstractBlock_find_by_23.$$p = null;\n        \n        result = [];\n        if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = (any_context = (context_selector = selector['$[]'](\"context\"))['$!']())) ? $d : context_selector['$=='](self.context))) ? ($truthy($d = (style_selector = selector['$[]'](\"style\"))['$!']()) ? $d : style_selector['$=='](self.style)) : $c)) ? ($truthy($c = (role_selector = selector['$[]'](\"role\"))['$!']()) ? $c : self['$has_role?'](role_selector)) : $b)) ? ($truthy($b = (id_selector = selector['$[]'](\"id\"))['$!']()) ? $b : id_selector['$=='](self.id)) : $a))) {\n          if ($truthy(id_selector)) {\n            if ((block !== nil)) {\n              return (function() {if ($truthy(Opal.yield1(block, self))) {\n                return [self]\n              } else {\n                return result\n              }; return nil; })()\n            } else {\n              return [self]\n            }\n          } else if ((block !== nil)) {\n            if ($truthy(Opal.yield1(block, self))) {\n              result['$<<'](self)}\n          } else {\n            result['$<<'](self)\n          }};\n        if ($truthy(($truthy($a = (($b = self.context['$=='](\"document\")) ? ($truthy($c = any_context) ? $c : context_selector['$=='](\"section\")) : self.context['$=='](\"document\"))) ? self['$header?']() : $a))) {\n          result.$concat($send(self.header, 'find_by', [selector], block.$to_proc()))};\n        if (context_selector['$=='](\"document\")) {\n        } else if (self.context['$=='](\"dlist\")) {\n          if ($truthy(($truthy($a = any_context) ? $a : context_selector['$!='](\"section\")))) {\n            $send(self.blocks.$flatten(), 'each', [], (TMP_24 = function(li){var self = TMP_24.$$s || this;\nif (li == null) li = nil;\n            if ($truthy(li)) {\n                return result.$concat($send(li, 'find_by', [selector], block.$to_proc()))\n              } else {\n                return nil\n              }}, TMP_24.$$s = self, TMP_24.$$arity = 1, TMP_24))}\n        } else if ($truthy($send(self.blocks, 'each', [], (TMP_25 = function(b){var self = TMP_25.$$s || this, $e;\nif (b == null) b = nil;\n        \n          if ($truthy((($e = context_selector['$=='](\"section\")) ? b.$context()['$!='](\"section\") : context_selector['$=='](\"section\")))) {\n            return nil;};\n          return result.$concat($send(b, 'find_by', [selector], block.$to_proc()));}, TMP_25.$$s = self, TMP_25.$$arity = 1, TMP_25)))) {};\n        return result;\n      }, TMP_AbstractBlock_find_by_23.$$arity = -1);\n      Opal.alias(self, \"query\", \"find_by\");\n      \n      Opal.def(self, '$next_adjacent_block', TMP_AbstractBlock_next_adjacent_block_26 = function $$next_adjacent_block() {\n        var self = this, sib = nil, p = nil;\n\n        if (self.context['$=='](\"document\")) {\n          return nil\n        } else if ($truthy((sib = (p = self.$parent()).$blocks()['$[]']($rb_plus(p.$blocks().$find_index(self), 1))))) {\n          return sib\n        } else {\n          return p.$next_adjacent_block()\n        }\n      }, TMP_AbstractBlock_next_adjacent_block_26.$$arity = 0);\n      \n      Opal.def(self, '$remove_sub', TMP_AbstractBlock_remove_sub_27 = function $$remove_sub(sub) {\n        var self = this;\n\n        \n        self.subs.$delete(sub);\n        return nil;\n      }, TMP_AbstractBlock_remove_sub_27.$$arity = 1);\n      \n      Opal.def(self, '$assign_caption', TMP_AbstractBlock_assign_caption_28 = function $$assign_caption(value, key) {\n        var $a, $b, self = this, prefix = nil;\n\n        if (value == null) {\n          value = nil;\n        }\n        if (key == null) {\n          key = nil;\n        }\n        if ($truthy(($truthy($a = ($truthy($b = self.caption) ? $b : self.title['$!']())) ? $a : (self.caption = ($truthy($b = value) ? $b : self.document.$attributes()['$[]'](\"caption\")))))) {\n          return nil\n        } else if ($truthy((prefix = self.document.$attributes()['$[]'](\"\" + ((key = ($truthy($a = key) ? $a : self.context))) + \"-caption\")))) {\n          \n          self.caption = \"\" + (prefix) + \" \" + ((self.number = self.document.$increment_and_store_counter(\"\" + (key) + \"-number\", self))) + \". \";\n          return nil;\n        } else {\n          return nil\n        }\n      }, TMP_AbstractBlock_assign_caption_28.$$arity = -1);\n      \n      Opal.def(self, '$enumerate_section', TMP_AbstractBlock_enumerate_section_29 = function $$enumerate_section(section) {\n        var self = this, $writer = nil, sectname = nil, caption = nil;\n\n        \n        self.next_section_index = $rb_plus((($writer = [self.next_section_index]), $send(section, 'index=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]), 1);\n        if ($truthy(section.$numbered())) {\n          if ((sectname = section.$sectname())['$=='](\"appendix\")) {\n            \n            \n            $writer = [self.document.$counter(\"appendix-number\", \"A\")];\n            $send(section, 'number=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            if ($truthy((caption = self.document.$attributes()['$[]'](\"appendix-caption\")))) {\n              \n              $writer = [\"\" + (caption) + \" \" + (section.$number()) + \": \"];\n              $send(section, 'caption=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];\n            } else {\n              \n              $writer = [\"\" + (section.$number()) + \". \"];\n              $send(section, 'caption=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];\n            };\n          } else if (sectname['$=='](\"chapter\")) {\n            \n            $writer = [self.document.$counter(\"chapter-number\", 1)];\n            $send(section, 'number=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];\n          } else {\n            self.next_section_number = $rb_plus((($writer = [self.next_section_number]), $send(section, 'number=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]), 1)\n          }};\n        return nil;\n      }, TMP_AbstractBlock_enumerate_section_29.$$arity = 1);\n      \n      Opal.def(self, '$list_marker_keyword', TMP_AbstractBlock_list_marker_keyword_30 = function $$list_marker_keyword(list_type) {\n        var $a, self = this;\n\n        if (list_type == null) {\n          list_type = nil;\n        }\n        return $$($nesting, 'ORDERED_LIST_KEYWORDS')['$[]'](($truthy($a = list_type) ? $a : self.style))\n      }, TMP_AbstractBlock_list_marker_keyword_30.$$arity = -1);\n      return (Opal.def(self, '$reindex_sections', TMP_AbstractBlock_reindex_sections_32 = function $$reindex_sections() {\n        var TMP_31, self = this;\n\n        \n        self.next_section_index = 0;\n        self.next_section_number = 1;\n        return $send(self.blocks, 'each', [], (TMP_31 = function(block){var self = TMP_31.$$s || this;\nif (block == null) block = nil;\n        if (block.$context()['$=='](\"section\")) {\n            \n            self.$enumerate_section(block);\n            return block.$reindex_sections();\n          } else {\n            return nil\n          }}, TMP_31.$$s = self, TMP_31.$$arity = 1, TMP_31));\n      }, TMP_AbstractBlock_reindex_sections_32.$$arity = 0), nil) && 'reindex_sections';\n    })($nesting[0], $$($nesting, 'AbstractNode'), $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/attribute_list\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$new', '$[]', '$update', '$parse', '$parse_attribute', '$eos?', '$skip_delimiter', '$+', '$rekey', '$each_with_index', '$[]=', '$-', '$skip_blank', '$==', '$peek', '$parse_attribute_value', '$get_byte', '$scan_name', '$!', '$!=', '$*', '$scan_to_delimiter', '$===', '$include?', '$delete', '$each', '$split', '$empty?', '$strip', '$apply_subs', '$scan_to_quote', '$gsub', '$skip', '$scan']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $AttributeList(){};\n      var self = $AttributeList = $klass($base, $super, 'AttributeList', $AttributeList);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_AttributeList_initialize_1, TMP_AttributeList_parse_into_2, TMP_AttributeList_parse_3, TMP_AttributeList_rekey_4, TMP_AttributeList_rekey_6, TMP_AttributeList_parse_attribute_8, TMP_AttributeList_parse_attribute_value_9, TMP_AttributeList_skip_blank_10, TMP_AttributeList_skip_delimiter_11, TMP_AttributeList_scan_name_12, TMP_AttributeList_scan_to_delimiter_13, TMP_AttributeList_scan_to_quote_14;\n\n      def.attributes = def.scanner = def.delimiter = def.block = def.delimiter_skip_pattern = def.delimiter_boundary_pattern = nil;\n      \n      Opal.const_set($nesting[0], 'BACKSLASH', \"\\\\\");\n      Opal.const_set($nesting[0], 'BoundaryRxs', $hash2([\"\\\"\", \"'\", \",\"], {\"\\\"\": /.*?[^\\\\](?=\")/, \"'\": /.*?[^\\\\](?=')/, \",\": /.*?(?=[ \\t]*(,|$))/}));\n      Opal.const_set($nesting[0], 'EscapedQuotes', $hash2([\"\\\"\", \"'\"], {\"\\\"\": \"\\\\\\\"\", \"'\": \"\\\\'\"}));\n      Opal.const_set($nesting[0], 'NameRx', new RegExp(\"\" + ($$($nesting, 'CG_WORD')) + \"[\" + ($$($nesting, 'CC_WORD')) + \"\\\\-.]*\"));\n      Opal.const_set($nesting[0], 'BlankRx', /[ \\t]+/);\n      Opal.const_set($nesting[0], 'SkipRxs', $hash2([\"blank\", \",\"], {\"blank\": $$($nesting, 'BlankRx'), \",\": /[ \\t]*(,|$)/}));\n      \n      Opal.def(self, '$initialize', TMP_AttributeList_initialize_1 = function $$initialize(source, block, delimiter) {\n        var self = this;\n\n        if (block == null) {\n          block = nil;\n        }\n        if (delimiter == null) {\n          delimiter = \",\";\n        }\n        \n        self.scanner = $$$('::', 'StringScanner').$new(source);\n        self.block = block;\n        self.delimiter = delimiter;\n        self.delimiter_skip_pattern = $$($nesting, 'SkipRxs')['$[]'](delimiter);\n        self.delimiter_boundary_pattern = $$($nesting, 'BoundaryRxs')['$[]'](delimiter);\n        return (self.attributes = nil);\n      }, TMP_AttributeList_initialize_1.$$arity = -2);\n      \n      Opal.def(self, '$parse_into', TMP_AttributeList_parse_into_2 = function $$parse_into(attributes, posattrs) {\n        var self = this;\n\n        if (posattrs == null) {\n          posattrs = [];\n        }\n        return attributes.$update(self.$parse(posattrs))\n      }, TMP_AttributeList_parse_into_2.$$arity = -2);\n      \n      Opal.def(self, '$parse', TMP_AttributeList_parse_3 = function $$parse(posattrs) {\n        var $a, self = this, index = nil;\n\n        if (posattrs == null) {\n          posattrs = [];\n        }\n        \n        if ($truthy(self.attributes)) {\n          return self.attributes};\n        self.attributes = $hash2([], {});\n        index = 0;\n        while ($truthy(self.$parse_attribute(index, posattrs))) {\n          \n          if ($truthy(self.scanner['$eos?']())) {\n            break;};\n          self.$skip_delimiter();\n          index = $rb_plus(index, 1);\n        };\n        return self.attributes;\n      }, TMP_AttributeList_parse_3.$$arity = -1);\n      \n      Opal.def(self, '$rekey', TMP_AttributeList_rekey_4 = function $$rekey(posattrs) {\n        var self = this;\n\n        return $$($nesting, 'AttributeList').$rekey(self.attributes, posattrs)\n      }, TMP_AttributeList_rekey_4.$$arity = 1);\n      Opal.defs(self, '$rekey', TMP_AttributeList_rekey_6 = function $$rekey(attributes, pos_attrs) {\n        var TMP_5, self = this;\n\n        \n        $send(pos_attrs, 'each_with_index', [], (TMP_5 = function(key, index){var self = TMP_5.$$s || this, pos = nil, val = nil, $writer = nil;\nif (key == null) key = nil;if (index == null) index = nil;\n        \n          if ($truthy(key)) {\n          } else {\n            return nil;\n          };\n          pos = $rb_plus(index, 1);\n          if ($truthy((val = attributes['$[]'](pos)))) {\n            \n            $writer = [key, val];\n            $send(attributes, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];\n          } else {\n            return nil\n          };}, TMP_5.$$s = self, TMP_5.$$arity = 2, TMP_5));\n        return attributes;\n      }, TMP_AttributeList_rekey_6.$$arity = 2);\n      \n      Opal.def(self, '$parse_attribute', TMP_AttributeList_parse_attribute_8 = function $$parse_attribute(index, pos_attrs) {\n        var $a, TMP_7, self = this, single_quoted_value = nil, first = nil, name = nil, value = nil, skipped = nil, c = nil, $case = nil, $writer = nil, resolved_name = nil, pos_name = nil;\n\n        if (index == null) {\n          index = 0;\n        }\n        if (pos_attrs == null) {\n          pos_attrs = [];\n        }\n        \n        single_quoted_value = false;\n        self.$skip_blank();\n        if ((first = self.scanner.$peek(1))['$=='](\"\\\"\")) {\n          \n          name = self.$parse_attribute_value(self.scanner.$get_byte());\n          value = nil;\n        } else if (first['$=='](\"'\")) {\n          \n          name = self.$parse_attribute_value(self.scanner.$get_byte());\n          value = nil;\n          single_quoted_value = true;\n        } else {\n          \n          name = self.$scan_name();\n          skipped = 0;\n          c = nil;\n          if ($truthy(self.scanner['$eos?']())) {\n            if ($truthy(name)) {\n            } else {\n              return false\n            }\n          } else {\n            \n            skipped = ($truthy($a = self.$skip_blank()) ? $a : 0);\n            c = self.scanner.$get_byte();\n          };\n          if ($truthy(($truthy($a = c['$!']()) ? $a : c['$=='](self.delimiter)))) {\n            value = nil\n          } else if ($truthy(($truthy($a = c['$!='](\"=\")) ? $a : name['$!']()))) {\n            \n            name = \"\" + (name) + ($rb_times(\" \", skipped)) + (c) + (self.$scan_to_delimiter());\n            value = nil;\n          } else {\n            \n            self.$skip_blank();\n            if ($truthy(self.scanner.$peek(1))) {\n              if ((c = self.scanner.$get_byte())['$=='](\"\\\"\")) {\n                value = self.$parse_attribute_value(c)\n              } else if (c['$=='](\"'\")) {\n                \n                value = self.$parse_attribute_value(c);\n                single_quoted_value = true;\n              } else if (c['$=='](self.delimiter)) {\n                value = nil\n              } else {\n                \n                value = \"\" + (c) + (self.$scan_to_delimiter());\n                if (value['$=='](\"None\")) {\n                  return true};\n              }};\n          };\n        };\n        if ($truthy(value)) {\n          $case = name;\n          if (\"options\"['$===']($case) || \"opts\"['$===']($case)) {\n          if ($truthy(value['$include?'](\",\"))) {\n            \n            if ($truthy(value['$include?'](\" \"))) {\n              value = value.$delete(\" \")};\n            $send(value.$split(\",\"), 'each', [], (TMP_7 = function(opt){var self = TMP_7.$$s || this, $writer = nil;\n              if (self.attributes == null) self.attributes = nil;\nif (opt == null) opt = nil;\n            if ($truthy(opt['$empty?']())) {\n                return nil\n              } else {\n                \n                $writer = [\"\" + (opt) + \"-option\", \"\"];\n                $send(self.attributes, '[]=', Opal.to_a($writer));\n                return $writer[$rb_minus($writer[\"length\"], 1)];\n              }}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7));\n          } else {\n            \n            $writer = [\"\" + ((value = value.$strip())) + \"-option\", \"\"];\n            $send(self.attributes, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];\n          };\n          \n          $writer = [\"options\", value];\n          $send(self.attributes, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;}\n          else {if ($truthy(($truthy($a = single_quoted_value) ? self.block : $a))) {\n            $case = name;\n            if (\"title\"['$===']($case) || \"reftext\"['$===']($case)) {\n            $writer = [name, value];\n            $send(self.attributes, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];}\n            else {\n            $writer = [name, self.block.$apply_subs(value)];\n            $send(self.attributes, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];}\n          } else {\n            \n            $writer = [name, value];\n            $send(self.attributes, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];\n          }}\n        } else {\n          \n          resolved_name = (function() {if ($truthy(($truthy($a = single_quoted_value) ? self.block : $a))) {\n            \n            return self.block.$apply_subs(name);\n          } else {\n            return name\n          }; return nil; })();\n          if ($truthy((pos_name = pos_attrs['$[]'](index)))) {\n            \n            $writer = [pos_name, resolved_name];\n            $send(self.attributes, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];};\n          \n          $writer = [$rb_plus(index, 1), resolved_name];\n          $send(self.attributes, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n        };\n        return true;\n      }, TMP_AttributeList_parse_attribute_8.$$arity = -1);\n      \n      Opal.def(self, '$parse_attribute_value', TMP_AttributeList_parse_attribute_value_9 = function $$parse_attribute_value(quote) {\n        var self = this, value = nil;\n\n        \n        if (self.scanner.$peek(1)['$=='](quote)) {\n          \n          self.scanner.$get_byte();\n          return \"\";};\n        if ($truthy((value = self.$scan_to_quote(quote)))) {\n          \n          self.scanner.$get_byte();\n          if ($truthy(value['$include?']($$($nesting, 'BACKSLASH')))) {\n            return value.$gsub($$($nesting, 'EscapedQuotes')['$[]'](quote), quote)\n          } else {\n            return value\n          };\n        } else {\n          return \"\" + (quote) + (self.$scan_to_delimiter())\n        };\n      }, TMP_AttributeList_parse_attribute_value_9.$$arity = 1);\n      \n      Opal.def(self, '$skip_blank', TMP_AttributeList_skip_blank_10 = function $$skip_blank() {\n        var self = this;\n\n        return self.scanner.$skip($$($nesting, 'BlankRx'))\n      }, TMP_AttributeList_skip_blank_10.$$arity = 0);\n      \n      Opal.def(self, '$skip_delimiter', TMP_AttributeList_skip_delimiter_11 = function $$skip_delimiter() {\n        var self = this;\n\n        return self.scanner.$skip(self.delimiter_skip_pattern)\n      }, TMP_AttributeList_skip_delimiter_11.$$arity = 0);\n      \n      Opal.def(self, '$scan_name', TMP_AttributeList_scan_name_12 = function $$scan_name() {\n        var self = this;\n\n        return self.scanner.$scan($$($nesting, 'NameRx'))\n      }, TMP_AttributeList_scan_name_12.$$arity = 0);\n      \n      Opal.def(self, '$scan_to_delimiter', TMP_AttributeList_scan_to_delimiter_13 = function $$scan_to_delimiter() {\n        var self = this;\n\n        return self.scanner.$scan(self.delimiter_boundary_pattern)\n      }, TMP_AttributeList_scan_to_delimiter_13.$$arity = 0);\n      return (Opal.def(self, '$scan_to_quote', TMP_AttributeList_scan_to_quote_14 = function $$scan_to_quote(quote) {\n        var self = this;\n\n        return self.scanner.$scan($$($nesting, 'BoundaryRxs')['$[]'](quote))\n      }, TMP_AttributeList_scan_to_quote_14.$$arity = 1), nil) && 'scan_to_quote';\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/block\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$default=', '$-', '$attr_accessor', '$[]', '$key?', '$==', '$===', '$dup', '$delete', '$[]=', '$lock_in_subs', '$nil_or_empty?', '$normalize_lines_from_string', '$apply_subs', '$*', '$<', '$size', '$empty?', '$rstrip', '$shift', '$pop', '$warn', '$to_s', '$class', '$object_id', '$inspect']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Block(){};\n      var self = $Block = $klass($base, $super, 'Block', $Block);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Block_initialize_1, TMP_Block_content_2, TMP_Block_source_3, TMP_Block_to_s_4, $writer = nil;\n\n      def.attributes = def.content_model = def.lines = def.subs = def.blocks = def.context = def.style = nil;\n      \n      \n      $writer = [\"simple\"];\n      $send(Opal.const_set($nesting[0], 'DEFAULT_CONTENT_MODEL', $hash2([\"audio\", \"image\", \"listing\", \"literal\", \"stem\", \"open\", \"page_break\", \"pass\", \"thematic_break\", \"video\"], {\"audio\": \"empty\", \"image\": \"empty\", \"listing\": \"verbatim\", \"literal\": \"verbatim\", \"stem\": \"raw\", \"open\": \"compound\", \"page_break\": \"empty\", \"pass\": \"raw\", \"thematic_break\": \"empty\", \"video\": \"empty\"})), 'default=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      Opal.alias(self, \"blockname\", \"context\");\n      self.$attr_accessor(\"lines\");\n      \n      Opal.def(self, '$initialize', TMP_Block_initialize_1 = function $$initialize(parent, context, opts) {\n        var $a, self = this, $iter = TMP_Block_initialize_1.$$p, $yield = $iter || nil, subs = nil, $writer = nil, raw_source = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        if ($iter) TMP_Block_initialize_1.$$p = null;\n        // Prepare super implicit arguments\n        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n          $zuper[$zuper_i] = arguments[$zuper_i];\n        }\n        \n        $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Block_initialize_1, false), $zuper, $iter);\n        self.content_model = ($truthy($a = opts['$[]'](\"content_model\")) ? $a : $$($nesting, 'DEFAULT_CONTENT_MODEL')['$[]'](context));\n        if ($truthy(opts['$key?'](\"subs\"))) {\n          if ($truthy((subs = opts['$[]'](\"subs\")))) {\n            \n            if (subs['$=='](\"default\")) {\n              self.default_subs = opts['$[]'](\"default_subs\")\n            } else if ($truthy($$$('::', 'Array')['$==='](subs))) {\n              \n              self.default_subs = subs.$dup();\n              self.attributes.$delete(\"subs\");\n            } else {\n              \n              self.default_subs = nil;\n              \n              $writer = [\"subs\", \"\" + (subs)];\n              $send(self.attributes, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n            };\n            self.$lock_in_subs();\n          } else {\n            \n            self.default_subs = [];\n            self.attributes.$delete(\"subs\");\n          }\n        } else {\n          self.default_subs = nil\n        };\n        if ($truthy((raw_source = opts['$[]'](\"source\"))['$nil_or_empty?']())) {\n          return (self.lines = [])\n        } else if ($truthy($$$('::', 'String')['$==='](raw_source))) {\n          return (self.lines = $$($nesting, 'Helpers').$normalize_lines_from_string(raw_source))\n        } else {\n          return (self.lines = raw_source.$dup())\n        };\n      }, TMP_Block_initialize_1.$$arity = -3);\n      \n      Opal.def(self, '$content', TMP_Block_content_2 = function $$content() {\n        var $a, $b, self = this, $iter = TMP_Block_content_2.$$p, $yield = $iter || nil, $case = nil, result = nil, first = nil, last = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n        if ($iter) TMP_Block_content_2.$$p = null;\n        // Prepare super implicit arguments\n        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n          $zuper[$zuper_i] = arguments[$zuper_i];\n        }\n        return (function() {$case = self.content_model;\n        if (\"compound\"['$===']($case)) {return $send(self, Opal.find_super_dispatcher(self, 'content', TMP_Block_content_2, false), $zuper, $iter)}\n        else if (\"simple\"['$===']($case)) {return self.$apply_subs($rb_times(self.lines, $$($nesting, 'LF')), self.subs)}\n        else if (\"verbatim\"['$===']($case) || \"raw\"['$===']($case)) {\n        result = self.$apply_subs(self.lines, self.subs);\n        if ($truthy($rb_lt(result.$size(), 2))) {\n          return result['$[]'](0)\n        } else {\n          \n          while ($truthy(($truthy($b = (first = result['$[]'](0))) ? first.$rstrip()['$empty?']() : $b))) {\n            result.$shift()\n          };\n          while ($truthy(($truthy($b = (last = result['$[]'](-1))) ? last.$rstrip()['$empty?']() : $b))) {\n            result.$pop()\n          };\n          return $rb_times(result, $$($nesting, 'LF'));\n        };}\n        else {\n        if (self.content_model['$=='](\"empty\")) {\n        } else {\n          self.$warn(\"\" + \"Unknown content model '\" + (self.content_model) + \"' for block: \" + (self.$to_s()))\n        };\n        return nil;}})()\n      }, TMP_Block_content_2.$$arity = 0);\n      \n      Opal.def(self, '$source', TMP_Block_source_3 = function $$source() {\n        var self = this;\n\n        return $rb_times(self.lines, $$($nesting, 'LF'))\n      }, TMP_Block_source_3.$$arity = 0);\n      return (Opal.def(self, '$to_s', TMP_Block_to_s_4 = function $$to_s() {\n        var self = this, content_summary = nil;\n\n        \n        content_summary = (function() {if (self.content_model['$=='](\"compound\")) {\n          return \"\" + \"blocks: \" + (self.blocks.$size())\n        } else {\n          return \"\" + \"lines: \" + (self.lines.$size())\n        }; return nil; })();\n        return \"\" + \"#<\" + (self.$class()) + \"@\" + (self.$object_id()) + \" {context: \" + (self.context.$inspect()) + \", content_model: \" + (self.content_model.$inspect()) + \", style: \" + (self.style.$inspect()) + \", \" + (content_summary) + \"}>\";\n      }, TMP_Block_to_s_4.$$arity = 0), nil) && 'to_s';\n    })($nesting[0], $$($nesting, 'AbstractBlock'), $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/callouts\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;\n\n  Opal.add_stubs(['$next_list', '$<<', '$current_list', '$to_i', '$generate_next_callout_id', '$+', '$<=', '$size', '$[]', '$-', '$chop', '$join', '$map', '$==', '$<', '$generate_callout_id']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Callouts(){};\n      var self = $Callouts = $klass($base, $super, 'Callouts', $Callouts);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Callouts_initialize_1, TMP_Callouts_register_2, TMP_Callouts_read_next_id_3, TMP_Callouts_callout_ids_5, TMP_Callouts_current_list_6, TMP_Callouts_next_list_7, TMP_Callouts_rewind_8, TMP_Callouts_generate_next_callout_id_9, TMP_Callouts_generate_callout_id_10;\n\n      def.co_index = def.lists = def.list_index = nil;\n      \n      \n      Opal.def(self, '$initialize', TMP_Callouts_initialize_1 = function $$initialize() {\n        var self = this;\n\n        \n        self.lists = [];\n        self.list_index = 0;\n        return self.$next_list();\n      }, TMP_Callouts_initialize_1.$$arity = 0);\n      \n      Opal.def(self, '$register', TMP_Callouts_register_2 = function $$register(li_ordinal) {\n        var self = this, id = nil;\n\n        \n        self.$current_list()['$<<']($hash2([\"ordinal\", \"id\"], {\"ordinal\": li_ordinal.$to_i(), \"id\": (id = self.$generate_next_callout_id())}));\n        self.co_index = $rb_plus(self.co_index, 1);\n        return id;\n      }, TMP_Callouts_register_2.$$arity = 1);\n      \n      Opal.def(self, '$read_next_id', TMP_Callouts_read_next_id_3 = function $$read_next_id() {\n        var self = this, id = nil, list = nil;\n\n        \n        id = nil;\n        list = self.$current_list();\n        if ($truthy($rb_le(self.co_index, list.$size()))) {\n          id = list['$[]']($rb_minus(self.co_index, 1))['$[]'](\"id\")};\n        self.co_index = $rb_plus(self.co_index, 1);\n        return id;\n      }, TMP_Callouts_read_next_id_3.$$arity = 0);\n      \n      Opal.def(self, '$callout_ids', TMP_Callouts_callout_ids_5 = function $$callout_ids(li_ordinal) {\n        var TMP_4, self = this;\n\n        return $send(self.$current_list(), 'map', [], (TMP_4 = function(element){var self = TMP_4.$$s || this;\nif (element == null) element = nil;\n        if (element['$[]'](\"ordinal\")['$=='](li_ordinal)) {\n            return \"\" + (element['$[]'](\"id\")) + \" \"\n          } else {\n            return nil\n          }}, TMP_4.$$s = self, TMP_4.$$arity = 1, TMP_4)).$join().$chop()\n      }, TMP_Callouts_callout_ids_5.$$arity = 1);\n      \n      Opal.def(self, '$current_list', TMP_Callouts_current_list_6 = function $$current_list() {\n        var self = this;\n\n        return self.lists['$[]']($rb_minus(self.list_index, 1))\n      }, TMP_Callouts_current_list_6.$$arity = 0);\n      \n      Opal.def(self, '$next_list', TMP_Callouts_next_list_7 = function $$next_list() {\n        var self = this;\n\n        \n        self.list_index = $rb_plus(self.list_index, 1);\n        if ($truthy($rb_lt(self.lists.$size(), self.list_index))) {\n          self.lists['$<<']([])};\n        self.co_index = 1;\n        return nil;\n      }, TMP_Callouts_next_list_7.$$arity = 0);\n      \n      Opal.def(self, '$rewind', TMP_Callouts_rewind_8 = function $$rewind() {\n        var self = this;\n\n        \n        self.list_index = 1;\n        self.co_index = 1;\n        return nil;\n      }, TMP_Callouts_rewind_8.$$arity = 0);\n      \n      Opal.def(self, '$generate_next_callout_id', TMP_Callouts_generate_next_callout_id_9 = function $$generate_next_callout_id() {\n        var self = this;\n\n        return self.$generate_callout_id(self.list_index, self.co_index)\n      }, TMP_Callouts_generate_next_callout_id_9.$$arity = 0);\n      return (Opal.def(self, '$generate_callout_id', TMP_Callouts_generate_callout_id_10 = function $$generate_callout_id(list_index, co_index) {\n        var self = this;\n\n        return \"\" + \"CO\" + (list_index) + \"-\" + (co_index)\n      }, TMP_Callouts_generate_callout_id_10.$$arity = 2), nil) && 'generate_callout_id';\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/converter/base\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$include', '$node_name', '$empty?', '$send', '$content']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    \n    (function($base, $parent_nesting) {\n      var $Converter, self = $Converter = $module($base, 'Converter');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      nil\n    })($nesting[0], $nesting);\n    (function($base, $super, $parent_nesting) {\n      function $Base(){};\n      var self = $Base = $klass($base, $super, 'Base', $Base);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      return self.$include($$($nesting, 'Converter'))\n    })($$($nesting, 'Converter'), null, $nesting);\n    (function($base, $super, $parent_nesting) {\n      function $BuiltIn(){};\n      var self = $BuiltIn = $klass($base, $super, 'BuiltIn', $BuiltIn);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BuiltIn_initialize_1, TMP_BuiltIn_convert_2, TMP_BuiltIn_content_3, TMP_BuiltIn_skip_4;\n\n      \n      \n      Opal.def(self, '$initialize', TMP_BuiltIn_initialize_1 = function $$initialize(backend, opts) {\n        var self = this;\n\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        return nil\n      }, TMP_BuiltIn_initialize_1.$$arity = -2);\n      \n      Opal.def(self, '$convert', TMP_BuiltIn_convert_2 = function $$convert(node, transform, opts) {\n        var $a, self = this;\n\n        if (transform == null) {\n          transform = nil;\n        }\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        \n        transform = ($truthy($a = transform) ? $a : node.$node_name());\n        if ($truthy(opts['$empty?']())) {\n          \n          return self.$send(transform, node);\n        } else {\n          \n          return self.$send(transform, node, opts);\n        };\n      }, TMP_BuiltIn_convert_2.$$arity = -2);\n      Opal.alias(self, \"handles?\", \"respond_to?\");\n      \n      Opal.def(self, '$content', TMP_BuiltIn_content_3 = function $$content(node) {\n        var self = this;\n\n        return node.$content()\n      }, TMP_BuiltIn_content_3.$$arity = 1);\n      Opal.alias(self, \"pass\", \"content\");\n      return (Opal.def(self, '$skip', TMP_BuiltIn_skip_4 = function $$skip(node) {\n        var self = this;\n\n        return nil\n      }, TMP_BuiltIn_skip_4.$$arity = 1), nil) && 'skip';\n    })($$($nesting, 'Converter'), null, $nesting);\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/converter/factory\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;\n\n  Opal.add_stubs(['$new', '$require', '$to_s', '$warn', '$register', '$default', '$resolve', '$create', '$converters', '$unregister_all', '$attr_reader', '$each', '$[]=', '$-', '$==', '$[]', '$clear', '$===', '$key?']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Converter, self = $Converter = $module($base, 'Converter');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      (function($base, $super, $parent_nesting) {\n        function $Factory(){};\n        var self = $Factory = $klass($base, $super, 'Factory', $Factory);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Factory_initialize_7, TMP_Factory_register_9, TMP_Factory_resolve_10, TMP_Factory_unregister_all_11, TMP_Factory_create_12;\n\n        def.converters = def.star_converter = nil;\n        \n        self.__default__ = nil;\n        (function(self, $parent_nesting) {\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_default_1, TMP_register_2, TMP_resolve_3, TMP_create_4, TMP_converters_5, TMP_unregister_all_6;\n\n          \n          \n          Opal.def(self, '$default', TMP_default_1 = function(initialize_singleton) {\n            var $a, $b, self = this;\n            if (self.__default__ == null) self.__default__ = nil;\n\n            if (initialize_singleton == null) {\n              initialize_singleton = true;\n            }\n            \n            if ($truthy(initialize_singleton)) {\n            } else {\n              return ($truthy($a = self.__default__) ? $a : self.$new())\n            };\n            return (self.__default__ = ($truthy($a = self.__default__) ? $a : (function() { try {\n              \n              if ($truthy((($b = $$$('::', 'ThreadSafe', 'skip_raise')) ? 'constant' : nil))) {\n              } else {\n                self.$require(\"thread_safe\".$to_s())\n              };\n              return self.$new($$$($$$('::', 'ThreadSafe'), 'Cache').$new());\n            } catch ($err) {\n              if (Opal.rescue($err, [$$$('::', 'LoadError')])) {\n                try {\n                  \n                  self.$warn(\"asciidoctor: WARNING: gem 'thread_safe' is not installed. This gem is recommended when registering custom converters.\");\n                  return self.$new();\n                } finally { Opal.pop_exception() }\n              } else { throw $err; }\n            }})()));\n          }, TMP_default_1.$$arity = -1);\n          \n          Opal.def(self, '$register', TMP_register_2 = function $$register(converter, backends) {\n            var self = this;\n\n            if (backends == null) {\n              backends = [\"*\"];\n            }\n            return self.$default().$register(converter, backends)\n          }, TMP_register_2.$$arity = -2);\n          \n          Opal.def(self, '$resolve', TMP_resolve_3 = function $$resolve(backend) {\n            var self = this;\n\n            return self.$default().$resolve(backend)\n          }, TMP_resolve_3.$$arity = 1);\n          \n          Opal.def(self, '$create', TMP_create_4 = function $$create(backend, opts) {\n            var self = this;\n\n            if (opts == null) {\n              opts = $hash2([], {});\n            }\n            return self.$default().$create(backend, opts)\n          }, TMP_create_4.$$arity = -2);\n          \n          Opal.def(self, '$converters', TMP_converters_5 = function $$converters() {\n            var self = this;\n\n            return self.$default().$converters()\n          }, TMP_converters_5.$$arity = 0);\n          return (Opal.def(self, '$unregister_all', TMP_unregister_all_6 = function $$unregister_all() {\n            var self = this;\n\n            return self.$default().$unregister_all()\n          }, TMP_unregister_all_6.$$arity = 0), nil) && 'unregister_all';\n        })(Opal.get_singleton_class(self), $nesting);\n        self.$attr_reader(\"converters\");\n        \n        Opal.def(self, '$initialize', TMP_Factory_initialize_7 = function $$initialize(converters) {\n          var $a, self = this;\n\n          if (converters == null) {\n            converters = nil;\n          }\n          \n          self.converters = ($truthy($a = converters) ? $a : $hash2([], {}));\n          return (self.star_converter = nil);\n        }, TMP_Factory_initialize_7.$$arity = -1);\n        \n        Opal.def(self, '$register', TMP_Factory_register_9 = function $$register(converter, backends) {\n          var TMP_8, self = this;\n\n          if (backends == null) {\n            backends = [\"*\"];\n          }\n          \n          $send(backends, 'each', [], (TMP_8 = function(backend){var self = TMP_8.$$s || this, $writer = nil;\n            if (self.converters == null) self.converters = nil;\nif (backend == null) backend = nil;\n          \n            \n            $writer = [backend, converter];\n            $send(self.converters, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            if (backend['$=='](\"*\")) {\n              return (self.star_converter = converter)\n            } else {\n              return nil\n            };}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8));\n          return nil;\n        }, TMP_Factory_register_9.$$arity = -2);\n        \n        Opal.def(self, '$resolve', TMP_Factory_resolve_10 = function $$resolve(backend) {\n          var $a, $b, self = this;\n\n          return ($truthy($a = self.converters) ? ($truthy($b = self.converters['$[]'](backend)) ? $b : self.star_converter) : $a)\n        }, TMP_Factory_resolve_10.$$arity = 1);\n        \n        Opal.def(self, '$unregister_all', TMP_Factory_unregister_all_11 = function $$unregister_all() {\n          var self = this;\n\n          \n          self.converters.$clear();\n          return (self.star_converter = nil);\n        }, TMP_Factory_unregister_all_11.$$arity = 0);\n        return (Opal.def(self, '$create', TMP_Factory_create_12 = function $$create(backend, opts) {\n          var $a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $k, $l, $m, $n, $o, $p, $q, $r, self = this, converter = nil, base_converter = nil, $case = nil, template_converter = nil;\n\n          if (opts == null) {\n            opts = $hash2([], {});\n          }\n          \n          if ($truthy((converter = self.$resolve(backend)))) {\n            return (function() {if ($truthy($$$('::', 'Class')['$==='](converter))) {\n              \n              return converter.$new(backend, opts);\n            } else {\n              return converter\n            }; return nil; })()};\n          base_converter = (function() {$case = backend;\n          if (\"html5\"['$===']($case)) {\n          if ($truthy((($c = $$$('::', 'Asciidoctor', 'skip_raise')) && ($b = $$$($c, 'Converter', 'skip_raise')) && ($a = $$$($b, 'Html5Converter', 'skip_raise')) ? 'constant' : nil))) {\n          } else {\n            self.$require(\"asciidoctor/converter/html5\".$to_s())\n          };\n          return $$($nesting, 'Html5Converter').$new(backend, opts);}\n          else if (\"docbook5\"['$===']($case)) {\n          if ($truthy((($f = $$$('::', 'Asciidoctor', 'skip_raise')) && ($e = $$$($f, 'Converter', 'skip_raise')) && ($d = $$$($e, 'DocBook5Converter', 'skip_raise')) ? 'constant' : nil))) {\n          } else {\n            self.$require(\"asciidoctor/converter/docbook5\".$to_s())\n          };\n          return $$($nesting, 'DocBook5Converter').$new(backend, opts);}\n          else if (\"docbook45\"['$===']($case)) {\n          if ($truthy((($i = $$$('::', 'Asciidoctor', 'skip_raise')) && ($h = $$$($i, 'Converter', 'skip_raise')) && ($g = $$$($h, 'DocBook45Converter', 'skip_raise')) ? 'constant' : nil))) {\n          } else {\n            self.$require(\"asciidoctor/converter/docbook45\".$to_s())\n          };\n          return $$($nesting, 'DocBook45Converter').$new(backend, opts);}\n          else if (\"manpage\"['$===']($case)) {\n          if ($truthy((($l = $$$('::', 'Asciidoctor', 'skip_raise')) && ($k = $$$($l, 'Converter', 'skip_raise')) && ($j = $$$($k, 'ManPageConverter', 'skip_raise')) ? 'constant' : nil))) {\n          } else {\n            self.$require(\"asciidoctor/converter/manpage\".$to_s())\n          };\n          return $$($nesting, 'ManPageConverter').$new(backend, opts);}\n          else { return nil }})();\n          if ($truthy(opts['$key?'](\"template_dirs\"))) {\n          } else {\n            return base_converter\n          };\n          if ($truthy((($o = $$$('::', 'Asciidoctor', 'skip_raise')) && ($n = $$$($o, 'Converter', 'skip_raise')) && ($m = $$$($n, 'TemplateConverter', 'skip_raise')) ? 'constant' : nil))) {\n          } else {\n            self.$require(\"asciidoctor/converter/template\".$to_s())\n          };\n          if ($truthy((($r = $$$('::', 'Asciidoctor', 'skip_raise')) && ($q = $$$($r, 'Converter', 'skip_raise')) && ($p = $$$($q, 'CompositeConverter', 'skip_raise')) ? 'constant' : nil))) {\n          } else {\n            self.$require(\"asciidoctor/converter/composite\".$to_s())\n          };\n          template_converter = $$($nesting, 'TemplateConverter').$new(backend, opts['$[]'](\"template_dirs\"), opts);\n          return $$($nesting, 'CompositeConverter').$new(backend, template_converter, base_converter);\n        }, TMP_Factory_create_12.$$arity = -2), nil) && 'create';\n      })($nesting[0], null, $nesting)\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/converter\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send, $truthy = Opal.truthy, $range = Opal.range, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$register', '$==', '$send', '$include?', '$setup_backend_info', '$raise', '$class', '$sub', '$[]', '$[]=', '$backend_info', '$-', '$extend', '$include', '$respond_to?', '$write', '$chomp', '$require']);\n  \n  (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    \n    (function($base, $parent_nesting) {\n      var $Converter, self = $Converter = $module($base, 'Converter');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Converter_initialize_11, TMP_Converter_convert_12;\n\n      \n      (function($base, $parent_nesting) {\n        var $Config, self = $Config = $module($base, 'Config');\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Config_register_for_3;\n\n        \n        Opal.def(self, '$register_for', TMP_Config_register_for_3 = function $$register_for($a_rest) {\n          var TMP_1, TMP_2, self = this, backends, metaclass = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          backends = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            backends[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          \n          $$($nesting, 'Factory').$register(self, backends);\n          metaclass = (function(self, $parent_nesting) {\n            var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n            return self\n          })(Opal.get_singleton_class(self), $nesting);\n          if (backends['$==']([\"*\"])) {\n            $send(metaclass, 'send', [\"define_method\", \"converts?\"], (TMP_1 = function(name){var self = TMP_1.$$s || this;\nif (name == null) name = nil;\n            return true}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1))\n          } else {\n            $send(metaclass, 'send', [\"define_method\", \"converts?\"], (TMP_2 = function(name){var self = TMP_2.$$s || this;\nif (name == null) name = nil;\n            return backends['$include?'](name)}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))\n          };\n          return nil;\n        }, TMP_Config_register_for_3.$$arity = -1)\n      })($nesting[0], $nesting);\n      (function($base, $parent_nesting) {\n        var $BackendInfo, self = $BackendInfo = $module($base, 'BackendInfo');\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BackendInfo_backend_info_4, TMP_BackendInfo_setup_backend_info_5, TMP_BackendInfo_filetype_6, TMP_BackendInfo_basebackend_7, TMP_BackendInfo_outfilesuffix_8, TMP_BackendInfo_htmlsyntax_9;\n\n        \n        \n        Opal.def(self, '$backend_info', TMP_BackendInfo_backend_info_4 = function $$backend_info() {\n          var $a, self = this;\n          if (self.backend_info == null) self.backend_info = nil;\n\n          return (self.backend_info = ($truthy($a = self.backend_info) ? $a : self.$setup_backend_info()))\n        }, TMP_BackendInfo_backend_info_4.$$arity = 0);\n        \n        Opal.def(self, '$setup_backend_info', TMP_BackendInfo_setup_backend_info_5 = function $$setup_backend_info() {\n          var self = this, base = nil, ext = nil, type = nil, syntax = nil;\n          if (self.backend == null) self.backend = nil;\n\n          \n          if ($truthy(self.backend)) {\n          } else {\n            self.$raise($$$('::', 'ArgumentError'), \"\" + \"Cannot determine backend for converter: \" + (self.$class()))\n          };\n          base = self.backend.$sub($$($nesting, 'TrailingDigitsRx'), \"\");\n          if ($truthy((ext = $$($nesting, 'DEFAULT_EXTENSIONS')['$[]'](base)))) {\n            type = ext['$[]']($range(1, -1, false))\n          } else {\n            \n            base = \"html\";\n            ext = \".html\";\n            type = \"html\";\n            syntax = \"html\";\n          };\n          return $hash2([\"basebackend\", \"outfilesuffix\", \"filetype\", \"htmlsyntax\"], {\"basebackend\": base, \"outfilesuffix\": ext, \"filetype\": type, \"htmlsyntax\": syntax});\n        }, TMP_BackendInfo_setup_backend_info_5.$$arity = 0);\n        \n        Opal.def(self, '$filetype', TMP_BackendInfo_filetype_6 = function $$filetype(value) {\n          var self = this, $writer = nil;\n\n          if (value == null) {\n            value = nil;\n          }\n          if ($truthy(value)) {\n            \n            $writer = [\"filetype\", value];\n            $send(self.$backend_info(), '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];\n          } else {\n            return self.$backend_info()['$[]'](\"filetype\")\n          }\n        }, TMP_BackendInfo_filetype_6.$$arity = -1);\n        \n        Opal.def(self, '$basebackend', TMP_BackendInfo_basebackend_7 = function $$basebackend(value) {\n          var self = this, $writer = nil;\n\n          if (value == null) {\n            value = nil;\n          }\n          if ($truthy(value)) {\n            \n            $writer = [\"basebackend\", value];\n            $send(self.$backend_info(), '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];\n          } else {\n            return self.$backend_info()['$[]'](\"basebackend\")\n          }\n        }, TMP_BackendInfo_basebackend_7.$$arity = -1);\n        \n        Opal.def(self, '$outfilesuffix', TMP_BackendInfo_outfilesuffix_8 = function $$outfilesuffix(value) {\n          var self = this, $writer = nil;\n\n          if (value == null) {\n            value = nil;\n          }\n          if ($truthy(value)) {\n            \n            $writer = [\"outfilesuffix\", value];\n            $send(self.$backend_info(), '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];\n          } else {\n            return self.$backend_info()['$[]'](\"outfilesuffix\")\n          }\n        }, TMP_BackendInfo_outfilesuffix_8.$$arity = -1);\n        \n        Opal.def(self, '$htmlsyntax', TMP_BackendInfo_htmlsyntax_9 = function $$htmlsyntax(value) {\n          var self = this, $writer = nil;\n\n          if (value == null) {\n            value = nil;\n          }\n          if ($truthy(value)) {\n            \n            $writer = [\"htmlsyntax\", value];\n            $send(self.$backend_info(), '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];\n          } else {\n            return self.$backend_info()['$[]'](\"htmlsyntax\")\n          }\n        }, TMP_BackendInfo_htmlsyntax_9.$$arity = -1);\n      })($nesting[0], $nesting);\n      (function(self, $parent_nesting) {\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_included_10;\n\n        return (Opal.def(self, '$included', TMP_included_10 = function $$included(converter) {\n          var self = this;\n\n          return converter.$extend($$($nesting, 'Config'))\n        }, TMP_included_10.$$arity = 1), nil) && 'included'\n      })(Opal.get_singleton_class(self), $nesting);\n      self.$include($$($nesting, 'Config'));\n      self.$include($$($nesting, 'BackendInfo'));\n      \n      Opal.def(self, '$initialize', TMP_Converter_initialize_11 = function $$initialize(backend, opts) {\n        var self = this;\n\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        \n        self.backend = backend;\n        return self.$setup_backend_info();\n      }, TMP_Converter_initialize_11.$$arity = -2);\n      \n      Opal.def(self, '$convert', TMP_Converter_convert_12 = function $$convert(node, transform, opts) {\n        var self = this;\n\n        if (transform == null) {\n          transform = nil;\n        }\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        return self.$raise($$$('::', 'NotImplementedError'))\n      }, TMP_Converter_convert_12.$$arity = -2);\n      Opal.alias(self, \"convert_with_options\", \"convert\");\n    })($nesting[0], $nesting);\n    (function($base, $parent_nesting) {\n      var $Writer, self = $Writer = $module($base, 'Writer');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Writer_write_13;\n\n      \n      Opal.def(self, '$write', TMP_Writer_write_13 = function $$write(output, target) {\n        var self = this;\n\n        \n        if ($truthy(target['$respond_to?'](\"write\"))) {\n          \n          target.$write(output.$chomp());\n          target.$write($$($nesting, 'LF'));\n        } else {\n          $$$('::', 'IO').$write(target, output)\n        };\n        return nil;\n      }, TMP_Writer_write_13.$$arity = 2)\n    })($nesting[0], $nesting);\n    (function($base, $parent_nesting) {\n      var $VoidWriter, self = $VoidWriter = $module($base, 'VoidWriter');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_VoidWriter_write_14;\n\n      \n      self.$include($$($nesting, 'Writer'));\n      \n      Opal.def(self, '$write', TMP_VoidWriter_write_14 = function $$write(output, target) {\n        var self = this;\n\n        return nil\n      }, TMP_VoidWriter_write_14.$$arity = 2);\n    })($nesting[0], $nesting);\n  })($nesting[0], $nesting);\n  self.$require(\"asciidoctor/converter/base\");\n  return self.$require(\"asciidoctor/converter/factory\");\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/document\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2, $range = Opal.range, $gvars = Opal.gvars;\n\n  Opal.add_stubs(['$new', '$attr_reader', '$nil?', '$<<', '$[]', '$[]=', '$-', '$include?', '$strip', '$squeeze', '$gsub', '$empty?', '$!', '$rpartition', '$attr_accessor', '$delete', '$base_dir', '$inject', '$catalog', '$==', '$callouts', '$dup', '$attributes', '$safe', '$compat_mode', '$sourcemap', '$converter', '$extensions', '$each', '$start_with?', '$end_with?', '$chop', '$downcase', '$===', '$value_for_name', '$to_s', '$key?', '$freeze', '$attribute_undefined', '$attribute_missing', '$name_for_value', '$expand_path', '$pwd', '$>=', '$+', '$length', '$fetch', '$abs', '$to_i', '$delete_if', '$update_doctype_attributes', '$parse', '$restore_attributes', '$update_backend_attributes', '$utc', '$at', '$Integer', '$now', '$index', '$slice', '$strftime', '$year', '$join', '$create', '$to_proc', '$activate', '$preprocessors?', '$preprocessors', '$process_method', '$tree_processors?', '$tree_processors', '$!=', '$counter', '$nil_or_empty?', '$nextval', '$value', '$save_to', '$chr', '$ord', '$source', '$source_lines', '$sectname=', '$title=', '$title', '$first_section', '$merge', '$find', '$context', '$enumerate_section', '$clear_playback_attributes', '$save_attributes', '$attribute_locked?', '$doctitle', '$rewind', '$name', '$negate', '$limit_bytesize', '$apply_attribute_value_subs', '$delete?', '$=~', '$apply_subs', '$resolve_pass_subs', '$apply_header_subs', '$create_converter', '$basebackend', '$outfilesuffix', '$filetype', '$sub', '$raise', '$backend', '$default', '$doctype', '$content_model', '$warn', '$content', '$convert', '$postprocessors?', '$postprocessors', '$write', '$respond_to?', '$chomp', '$map', '$split', '$resolve_docinfo_subs', '$&', '$normalize_system_path', '$read_asset', '$docinfo_processors?', '$compact', '$*', '$resolve_subs', '$docinfo_processors', '$class', '$object_id', '$inspect', '$size']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Document(){};\n      var self = $Document = $klass($base, $super, 'Document', $Document);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Document_initialize_7, TMP_Document_parse_13, TMP_Document_counter_14, TMP_Document_increment_and_store_counter_15, TMP_Document_nextval_16, TMP_Document_register_17, TMP_Document_footnotes$q_18, TMP_Document_footnotes_19, TMP_Document_nested$q_20, TMP_Document_embedded$q_21, TMP_Document_extensions$q_22, TMP_Document_source_23, TMP_Document_source_lines_24, TMP_Document_basebackend$q_25, TMP_Document_title_26, TMP_Document_title$eq_27, TMP_Document_doctitle_28, TMP_Document_author_29, TMP_Document_revdate_30, TMP_Document_notitle_31, TMP_Document_noheader_32, TMP_Document_nofooter_33, TMP_Document_first_section_35, TMP_Document_has_header$q_36, TMP_Document_$lt$lt_37, TMP_Document_finalize_header_38, TMP_Document_save_attributes_40, TMP_Document_restore_attributes_41, TMP_Document_clear_playback_attributes_42, TMP_Document_playback_attributes_44, TMP_Document_set_attribute_45, TMP_Document_delete_attribute_46, TMP_Document_attribute_locked$q_47, TMP_Document_apply_attribute_value_subs_48, TMP_Document_update_backend_attributes_49, TMP_Document_update_doctype_attributes_50, TMP_Document_create_converter_51, TMP_Document_convert_53, TMP_Document_write_54, TMP_Document_content_55, TMP_Document_docinfo_58, TMP_Document_resolve_docinfo_subs_59, TMP_Document_docinfo_processors$q_60, TMP_Document_to_s_61;\n\n      def.attributes = def.safe = def.reader = def.base_dir = def.parsed = def.parent_document = def.extensions = def.options = def.counters = def.catalog = def.header = def.blocks = def.attributes_modified = def.id = def.callouts = def.header_attributes = def.max_attribute_value_size = def.attribute_overrides = def.backend = def.doctype = def.converter = def.outfilesuffix = def.docinfo_processor_extensions = def.document = nil;\n      \n      Opal.const_set($nesting[0], 'Footnote', $$$('::', 'Struct').$new(\"index\", \"id\", \"text\"));\n      (function($base, $super, $parent_nesting) {\n        function $AttributeEntry(){};\n        var self = $AttributeEntry = $klass($base, $super, 'AttributeEntry', $AttributeEntry);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_AttributeEntry_initialize_1, TMP_AttributeEntry_save_to_2;\n\n        \n        self.$attr_reader(\"name\", \"value\", \"negate\");\n        \n        Opal.def(self, '$initialize', TMP_AttributeEntry_initialize_1 = function $$initialize(name, value, negate) {\n          var self = this;\n\n          if (negate == null) {\n            negate = nil;\n          }\n          \n          self.name = name;\n          self.value = value;\n          return (self.negate = (function() {if ($truthy(negate['$nil?']())) {\n            return value['$nil?']()\n          } else {\n            return negate\n          }; return nil; })());\n        }, TMP_AttributeEntry_initialize_1.$$arity = -3);\n        return (Opal.def(self, '$save_to', TMP_AttributeEntry_save_to_2 = function $$save_to(block_attributes) {\n          var $a, self = this, $writer = nil;\n\n          \n          ($truthy($a = block_attributes['$[]'](\"attribute_entries\")) ? $a : (($writer = [\"attribute_entries\", []]), $send(block_attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))['$<<'](self);\n          return self;\n        }, TMP_AttributeEntry_save_to_2.$$arity = 1), nil) && 'save_to';\n      })($nesting[0], null, $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $Title(){};\n        var self = $Title = $klass($base, $super, 'Title', $Title);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Title_initialize_3, TMP_Title_sanitized$q_4, TMP_Title_subtitle$q_5, TMP_Title_to_s_6;\n\n        def.sanitized = def.subtitle = def.combined = nil;\n        \n        self.$attr_reader(\"main\");\n        Opal.alias(self, \"title\", \"main\");\n        self.$attr_reader(\"subtitle\");\n        self.$attr_reader(\"combined\");\n        \n        Opal.def(self, '$initialize', TMP_Title_initialize_3 = function $$initialize(val, opts) {\n          var $a, $b, self = this, sep = nil, _ = nil;\n\n          if (opts == null) {\n            opts = $hash2([], {});\n          }\n          \n          if ($truthy(($truthy($a = (self.sanitized = opts['$[]'](\"sanitize\"))) ? val['$include?'](\"<\") : $a))) {\n            val = val.$gsub($$($nesting, 'XmlSanitizeRx'), \"\").$squeeze(\" \").$strip()};\n          if ($truthy(($truthy($a = (sep = ($truthy($b = opts['$[]'](\"separator\")) ? $b : \":\"))['$empty?']()) ? $a : val['$include?']((sep = \"\" + (sep) + \" \"))['$!']()))) {\n            \n            self.main = val;\n            self.subtitle = nil;\n          } else {\n            $b = val.$rpartition(sep), $a = Opal.to_ary($b), (self.main = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), (self.subtitle = ($a[2] == null ? nil : $a[2])), $b\n          };\n          return (self.combined = val);\n        }, TMP_Title_initialize_3.$$arity = -2);\n        \n        Opal.def(self, '$sanitized?', TMP_Title_sanitized$q_4 = function() {\n          var self = this;\n\n          return self.sanitized\n        }, TMP_Title_sanitized$q_4.$$arity = 0);\n        \n        Opal.def(self, '$subtitle?', TMP_Title_subtitle$q_5 = function() {\n          var self = this;\n\n          if ($truthy(self.subtitle)) {\n            return true\n          } else {\n            return false\n          }\n        }, TMP_Title_subtitle$q_5.$$arity = 0);\n        return (Opal.def(self, '$to_s', TMP_Title_to_s_6 = function $$to_s() {\n          var self = this;\n\n          return self.combined\n        }, TMP_Title_to_s_6.$$arity = 0), nil) && 'to_s';\n      })($nesting[0], null, $nesting);\n      self.$attr_reader(\"safe\");\n      self.$attr_reader(\"compat_mode\");\n      self.$attr_reader(\"backend\");\n      self.$attr_reader(\"doctype\");\n      self.$attr_accessor(\"sourcemap\");\n      self.$attr_reader(\"catalog\");\n      Opal.alias(self, \"references\", \"catalog\");\n      self.$attr_reader(\"counters\");\n      self.$attr_reader(\"callouts\");\n      self.$attr_reader(\"header\");\n      self.$attr_reader(\"base_dir\");\n      self.$attr_reader(\"options\");\n      self.$attr_reader(\"outfilesuffix\");\n      self.$attr_reader(\"parent_document\");\n      self.$attr_reader(\"reader\");\n      self.$attr_reader(\"converter\");\n      self.$attr_reader(\"extensions\");\n      \n      Opal.def(self, '$initialize', TMP_Document_initialize_7 = function $$initialize(data, options) {\n        var $a, TMP_8, TMP_9, $b, $c, TMP_10, $d, self = this, $iter = TMP_Document_initialize_7.$$p, $yield = $iter || nil, parent_doc = nil, $writer = nil, attr_overrides = nil, parent_doctype = nil, initialize_extensions = nil, safe_mode = nil, header_footer = nil, attrs = nil, safe_mode_name = nil, base_dir_val = nil, backend_val = nil, doctype_val = nil, size = nil, now = nil, localdate = nil, localyear = nil, localtime = nil, ext_registry = nil, ext_block = nil;\n\n        if (data == null) {\n          data = nil;\n        }\n        if (options == null) {\n          options = $hash2([], {});\n        }\n        if ($iter) TMP_Document_initialize_7.$$p = null;\n        \n        $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Document_initialize_7, false), [self, \"document\"], null);\n        if ($truthy((parent_doc = options.$delete(\"parent\")))) {\n          \n          self.parent_document = parent_doc;\n          ($truthy($a = options['$[]'](\"base_dir\")) ? $a : (($writer = [\"base_dir\", parent_doc.$base_dir()]), $send(options, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n          self.catalog = $send(parent_doc.$catalog(), 'inject', [$hash2([], {})], (TMP_8 = function(accum, $b){var self = TMP_8.$$s || this, $b_args, key, table;\n\n            if ($b == null) {\n              $b = nil;\n            }\n            $b = Opal.to_ary($b);\n            $b_args = Opal.slice.call($b, 0, $b.length);\n            key = $b_args.splice(0,1)[0];\n            if (key == null) {\n              key = nil;\n            }\n            table = $b_args.splice(0,1)[0];\n            if (table == null) {\n              table = nil;\n            }if (accum == null) accum = nil;\n          \n            \n            $writer = [key, (function() {if (key['$=='](\"footnotes\")) {\n              return []\n            } else {\n              return table\n            }; return nil; })()];\n            $send(accum, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            return accum;}, TMP_8.$$s = self, TMP_8.$$arity = 2, TMP_8.$$has_top_level_mlhs_arg = true, TMP_8));\n          self.callouts = parent_doc.$callouts();\n          self.attribute_overrides = (attr_overrides = parent_doc.$attributes().$dup());\n          parent_doctype = attr_overrides.$delete(\"doctype\");\n          attr_overrides.$delete(\"compat-mode\");\n          attr_overrides.$delete(\"toc\");\n          attr_overrides.$delete(\"toc-placement\");\n          attr_overrides.$delete(\"toc-position\");\n          self.safe = parent_doc.$safe();\n          if ($truthy((self.compat_mode = parent_doc.$compat_mode()))) {\n            \n            $writer = [\"compat-mode\", \"\"];\n            $send(self.attributes, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];};\n          self.sourcemap = parent_doc.$sourcemap();\n          self.converter = parent_doc.$converter();\n          initialize_extensions = false;\n          self.extensions = parent_doc.$extensions();\n        } else {\n          \n          self.parent_document = nil;\n          self.catalog = $hash2([\"ids\", \"refs\", \"footnotes\", \"links\", \"images\", \"indexterms\", \"includes\"], {\"ids\": $hash2([], {}), \"refs\": $hash2([], {}), \"footnotes\": [], \"links\": [], \"images\": [], \"indexterms\": [], \"includes\": $$$('::', 'Set').$new()});\n          self.callouts = $$($nesting, 'Callouts').$new();\n          attr_overrides = $hash2([], {});\n          $send(($truthy($a = options['$[]'](\"attributes\")) ? $a : $hash2([], {})), 'each', [], (TMP_9 = function(key, value){var self = TMP_9.$$s || this;\nif (key == null) key = nil;if (value == null) value = nil;\n          \n            if ($truthy(key['$start_with?'](\"!\"))) {\n              \n              key = key['$[]']($range(1, -1, false));\n              value = nil;\n            } else if ($truthy(key['$end_with?'](\"!\"))) {\n              \n              key = key.$chop();\n              value = nil;};\n            \n            $writer = [key.$downcase(), value];\n            $send(attr_overrides, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];;}, TMP_9.$$s = self, TMP_9.$$arity = 2, TMP_9));\n          self.attribute_overrides = attr_overrides;\n          if ($truthy((safe_mode = options['$[]'](\"safe\"))['$!']())) {\n            self.safe = $$$($$($nesting, 'SafeMode'), 'SECURE')\n          } else if ($truthy($$$('::', 'Integer')['$==='](safe_mode))) {\n            self.safe = safe_mode\n          } else {\n            \n            try {\n              self.safe = $$($nesting, 'SafeMode').$value_for_name(safe_mode.$to_s())\n            } catch ($err) {\n              if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {\n                try {\n                  self.safe = $$$($$($nesting, 'SafeMode'), 'SECURE')\n                } finally { Opal.pop_exception() }\n              } else { throw $err; }\n            };\n          };\n          self.compat_mode = attr_overrides['$key?'](\"compat-mode\");\n          self.sourcemap = options['$[]'](\"sourcemap\");\n          self.converter = nil;\n          initialize_extensions = (($b = $$$('::', 'Asciidoctor', 'skip_raise')) && ($a = $$$($b, 'Extensions', 'skip_raise')) ? 'constant' : nil);\n          self.extensions = nil;\n        };\n        self.parsed = false;\n        self.header = nil;\n        self.counters = $hash2([], {});\n        self.attributes_modified = $$$('::', 'Set').$new();\n        self.docinfo_processor_extensions = $hash2([], {});\n        header_footer = ($truthy($c = options['$[]'](\"header_footer\")) ? $c : (($writer = [\"header_footer\", false]), $send(options, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n        (self.options = options).$freeze();\n        attrs = self.attributes;\n        \n        $writer = [\"sectids\", \"\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"toc-placement\", \"auto\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        if ($truthy(header_footer)) {\n          \n          \n          $writer = [\"copycss\", \"\"];\n          $send(attrs, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          \n          $writer = [\"embedded\", nil];\n          $send(attr_overrides, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n        } else {\n          \n          \n          $writer = [\"notitle\", \"\"];\n          $send(attrs, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          \n          $writer = [\"embedded\", \"\"];\n          $send(attr_overrides, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n        };\n        \n        $writer = [\"stylesheet\", \"\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"webfonts\", \"\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"prewrap\", \"\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"attribute-undefined\", $$($nesting, 'Compliance').$attribute_undefined()];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"attribute-missing\", $$($nesting, 'Compliance').$attribute_missing()];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"iconfont-remote\", \"\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"caution-caption\", \"Caution\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"important-caption\", \"Important\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"note-caption\", \"Note\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"tip-caption\", \"Tip\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"warning-caption\", \"Warning\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"example-caption\", \"Example\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"figure-caption\", \"Figure\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"table-caption\", \"Table\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"toc-title\", \"Table of Contents\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"manname-title\", \"NAME\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"section-refsig\", \"Section\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"chapter-refsig\", \"Chapter\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"appendix-caption\", (($writer = [\"appendix-refsig\", \"Appendix\"]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"untitled-label\", \"Untitled\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"version-label\", \"Version\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"last-update-label\", \"Last updated\"];\n        $send(attrs, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"asciidoctor\", \"\"];\n        $send(attr_overrides, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"asciidoctor-version\", $$($nesting, 'VERSION')];\n        $send(attr_overrides, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"safe-mode-name\", (safe_mode_name = $$($nesting, 'SafeMode').$name_for_value(self.safe))];\n        $send(attr_overrides, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"\" + \"safe-mode-\" + (safe_mode_name), \"\"];\n        $send(attr_overrides, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"safe-mode-level\", self.safe];\n        $send(attr_overrides, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        ($truthy($c = attr_overrides['$[]'](\"max-include-depth\")) ? $c : (($writer = [\"max-include-depth\", 64]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n        ($truthy($c = attr_overrides['$[]'](\"allow-uri-read\")) ? $c : (($writer = [\"allow-uri-read\", nil]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n        \n        $writer = [\"user-home\", $$($nesting, 'USER_HOME')];\n        $send(attr_overrides, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        if ($truthy(attr_overrides['$key?'](\"numbered\"))) {\n          \n          $writer = [\"sectnums\", attr_overrides.$delete(\"numbered\")];\n          $send(attr_overrides, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];};\n        if ($truthy((base_dir_val = options['$[]'](\"base_dir\")))) {\n          self.base_dir = (($writer = [\"docdir\", $$$('::', 'File').$expand_path(base_dir_val)]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])\n        } else if ($truthy(attr_overrides['$[]'](\"docdir\"))) {\n          self.base_dir = attr_overrides['$[]'](\"docdir\")\n        } else {\n          self.base_dir = (($writer = [\"docdir\", $$$('::', 'Dir').$pwd()]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])\n        };\n        if ($truthy((backend_val = options['$[]'](\"backend\")))) {\n          \n          $writer = [\"backend\", \"\" + (backend_val)];\n          $send(attr_overrides, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];};\n        if ($truthy((doctype_val = options['$[]'](\"doctype\")))) {\n          \n          $writer = [\"doctype\", \"\" + (doctype_val)];\n          $send(attr_overrides, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];};\n        if ($truthy($rb_ge(self.safe, $$$($$($nesting, 'SafeMode'), 'SERVER')))) {\n          \n          ($truthy($c = attr_overrides['$[]'](\"copycss\")) ? $c : (($writer = [\"copycss\", nil]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n          ($truthy($c = attr_overrides['$[]'](\"source-highlighter\")) ? $c : (($writer = [\"source-highlighter\", nil]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n          ($truthy($c = attr_overrides['$[]'](\"backend\")) ? $c : (($writer = [\"backend\", $$($nesting, 'DEFAULT_BACKEND')]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n          if ($truthy(($truthy($c = parent_doc['$!']()) ? attr_overrides['$key?'](\"docfile\") : $c))) {\n            \n            $writer = [\"docfile\", attr_overrides['$[]'](\"docfile\")['$[]'](Opal.Range.$new($rb_plus(attr_overrides['$[]'](\"docdir\").$length(), 1), -1, false))];\n            $send(attr_overrides, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];};\n          \n          $writer = [\"docdir\", \"\"];\n          $send(attr_overrides, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          \n          $writer = [\"user-home\", \".\"];\n          $send(attr_overrides, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          if ($truthy($rb_ge(self.safe, $$$($$($nesting, 'SafeMode'), 'SECURE')))) {\n            \n            if ($truthy(attr_overrides['$key?'](\"max-attribute-value-size\"))) {\n            } else {\n              \n              $writer = [\"max-attribute-value-size\", 4096];\n              $send(attr_overrides, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];\n            };\n            if ($truthy(attr_overrides.$fetch(\"linkcss\", \"\")['$nil?']())) {\n            } else {\n              \n              $writer = [\"linkcss\", \"\"];\n              $send(attr_overrides, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];\n            };\n            ($truthy($c = attr_overrides['$[]'](\"icons\")) ? $c : (($writer = [\"icons\", nil]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));};};\n        self.max_attribute_value_size = (function() {if ($truthy((size = ($truthy($c = attr_overrides['$[]'](\"max-attribute-value-size\")) ? $c : (($writer = [\"max-attribute-value-size\", nil]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))))) {\n          return size.$to_i().$abs()\n        } else {\n          return nil\n        }; return nil; })();\n        $send(attr_overrides, 'delete_if', [], (TMP_10 = function(key, val){var self = TMP_10.$$s || this, $d, verdict = nil;\nif (key == null) key = nil;if (val == null) val = nil;\n        \n          verdict = false;\n          if ($truthy(val['$nil?']())) {\n            attrs.$delete(key)\n          } else {\n            \n            if ($truthy(($truthy($d = $$$('::', 'String')['$==='](val)) ? val['$end_with?'](\"@\") : $d))) {\n              \n              val = val.$chop();\n              verdict = true;};\n            \n            $writer = [key, val];\n            $send(attrs, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n          };\n          return verdict;}, TMP_10.$$s = self, TMP_10.$$arity = 2, TMP_10));\n        if ($truthy(parent_doc)) {\n          \n          self.backend = attrs['$[]'](\"backend\");\n          if ((self.doctype = (($writer = [\"doctype\", parent_doctype]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))['$==']($$($nesting, 'DEFAULT_DOCTYPE'))) {\n          } else {\n            self.$update_doctype_attributes($$($nesting, 'DEFAULT_DOCTYPE'))\n          };\n          self.reader = $$($nesting, 'Reader').$new(data, options['$[]'](\"cursor\"));\n          $$($nesting, 'Parser').$parse(self.reader, self);\n          self.$restore_attributes();\n          return (self.parsed = true);\n        } else {\n          \n          self.backend = nil;\n          if (($truthy($c = attrs['$[]'](\"backend\")) ? $c : (($writer = [\"backend\", $$($nesting, 'DEFAULT_BACKEND')]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))['$=='](\"manpage\")) {\n            self.doctype = (($writer = [\"doctype\", (($writer = [\"doctype\", \"manpage\"]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])\n          } else {\n            self.doctype = ($truthy($c = attrs['$[]'](\"doctype\")) ? $c : (($writer = [\"doctype\", $$($nesting, 'DEFAULT_DOCTYPE')]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))\n          };\n          self.$update_backend_attributes(attrs['$[]'](\"backend\"), true);\n          now = (function() {if ($truthy($$$('::', 'ENV')['$[]'](\"SOURCE_DATE_EPOCH\"))) {\n            return $$$('::', 'Time').$at(self.$Integer($$$('::', 'ENV')['$[]'](\"SOURCE_DATE_EPOCH\"))).$utc()\n          } else {\n            return $$$('::', 'Time').$now()\n          }; return nil; })();\n          if ($truthy((localdate = attrs['$[]'](\"localdate\")))) {\n            localyear = ($truthy($c = attrs['$[]'](\"localyear\")) ? $c : (($writer = [\"localyear\", (function() {if (localdate.$index(\"-\")['$=='](4)) {\n              \n              return localdate.$slice(0, 4);\n            } else {\n              return nil\n            }; return nil; })()]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))\n          } else {\n            \n            localdate = (($writer = [\"localdate\", now.$strftime(\"%Y-%m-%d\")]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]);\n            localyear = ($truthy($c = attrs['$[]'](\"localyear\")) ? $c : (($writer = [\"localyear\", now.$year().$to_s()]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n          };\n          localtime = ($truthy($c = attrs['$[]'](\"localtime\")) ? $c : (($writer = [\"localtime\", (function() { try {\n            return now.$strftime(\"%H:%M:%S %Z\")\n          } catch ($err) {\n            if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {\n              try {\n                return now.$strftime(\"%H:%M:%S %z\")\n              } finally { Opal.pop_exception() }\n            } else { throw $err; }\n          }})()]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n          ($truthy($c = attrs['$[]'](\"localdatetime\")) ? $c : (($writer = [\"localdatetime\", \"\" + (localdate) + \" \" + (localtime)]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n          ($truthy($c = attrs['$[]'](\"docdate\")) ? $c : (($writer = [\"docdate\", localdate]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n          ($truthy($c = attrs['$[]'](\"docyear\")) ? $c : (($writer = [\"docyear\", localyear]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n          ($truthy($c = attrs['$[]'](\"doctime\")) ? $c : (($writer = [\"doctime\", localtime]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n          ($truthy($c = attrs['$[]'](\"docdatetime\")) ? $c : (($writer = [\"docdatetime\", \"\" + (localdate) + \" \" + (localtime)]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n          ($truthy($c = attrs['$[]'](\"stylesdir\")) ? $c : (($writer = [\"stylesdir\", \".\"]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n          ($truthy($c = attrs['$[]'](\"iconsdir\")) ? $c : (($writer = [\"iconsdir\", $$$('::', 'File').$join(attrs.$fetch(\"imagesdir\", \"./images\"), \"icons\")]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n          if ($truthy(initialize_extensions)) {\n            \n            if ($truthy((ext_registry = options['$[]'](\"extension_registry\")))) {\n              if ($truthy(($truthy($c = $$$($$($nesting, 'Extensions'), 'Registry')['$==='](ext_registry)) ? $c : ($truthy($d = $$$('::', 'RUBY_ENGINE_JRUBY')) ? $$$($$$($$$('::', 'AsciidoctorJ'), 'Extensions'), 'ExtensionRegistry')['$==='](ext_registry) : $d)))) {\n              } else {\n                ext_registry = $$$($$($nesting, 'Extensions'), 'Registry').$new()\n              }\n            } else if ($truthy($$$('::', 'Proc')['$===']((ext_block = options['$[]'](\"extensions\"))))) {\n              ext_registry = $send($$($nesting, 'Extensions'), 'create', [], ext_block.$to_proc())\n            } else {\n              ext_registry = $$$($$($nesting, 'Extensions'), 'Registry').$new()\n            };\n            self.extensions = ext_registry.$activate(self);};\n          return (self.reader = $$($nesting, 'PreprocessorReader').$new(self, data, $$$($$($nesting, 'Reader'), 'Cursor').$new(attrs['$[]'](\"docfile\"), self.base_dir), $hash2([\"normalize\"], {\"normalize\": true})));\n        };\n      }, TMP_Document_initialize_7.$$arity = -1);\n      \n      Opal.def(self, '$parse', TMP_Document_parse_13 = function $$parse(data) {\n        var $a, TMP_11, TMP_12, self = this, doc = nil, exts = nil;\n\n        if (data == null) {\n          data = nil;\n        }\n        if ($truthy(self.parsed)) {\n          return self\n        } else {\n          \n          doc = self;\n          if ($truthy(data)) {\n            self.reader = $$($nesting, 'PreprocessorReader').$new(doc, data, $$$($$($nesting, 'Reader'), 'Cursor').$new(self.attributes['$[]'](\"docfile\"), self.base_dir), $hash2([\"normalize\"], {\"normalize\": true}))};\n          if ($truthy(($truthy($a = (exts = (function() {if ($truthy(self.parent_document)) {\n            return nil\n          } else {\n            return self.extensions\n          }; return nil; })())) ? exts['$preprocessors?']() : $a))) {\n            $send(exts.$preprocessors(), 'each', [], (TMP_11 = function(ext){var self = TMP_11.$$s || this, $b;\n              if (self.reader == null) self.reader = nil;\nif (ext == null) ext = nil;\n            return (self.reader = ($truthy($b = ext.$process_method()['$[]'](doc, self.reader)) ? $b : self.reader))}, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11))};\n          $$($nesting, 'Parser').$parse(self.reader, doc, $hash2([\"header_only\"], {\"header_only\": self.options['$[]'](\"parse_header_only\")}));\n          self.$restore_attributes();\n          if ($truthy(($truthy($a = exts) ? exts['$tree_processors?']() : $a))) {\n            $send(exts.$tree_processors(), 'each', [], (TMP_12 = function(ext){var self = TMP_12.$$s || this, $b, $c, result = nil;\nif (ext == null) ext = nil;\n            if ($truthy(($truthy($b = ($truthy($c = (result = ext.$process_method()['$[]'](doc))) ? $$($nesting, 'Document')['$==='](result) : $c)) ? result['$!='](doc) : $b))) {\n                return (doc = result)\n              } else {\n                return nil\n              }}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12))};\n          self.parsed = true;\n          return doc;\n        }\n      }, TMP_Document_parse_13.$$arity = -1);\n      \n      Opal.def(self, '$counter', TMP_Document_counter_14 = function $$counter(name, seed) {\n        var $a, self = this, attr_seed = nil, attr_val = nil, $writer = nil;\n\n        if (seed == null) {\n          seed = nil;\n        }\n        \n        if ($truthy(self.parent_document)) {\n          return self.parent_document.$counter(name, seed)};\n        if ($truthy(($truthy($a = (attr_seed = (attr_val = self.attributes['$[]'](name))['$nil_or_empty?']()['$!']())) ? self.counters['$key?'](name) : $a))) {\n          \n          $writer = [name, (($writer = [name, self.$nextval(attr_val)]), $send(self.counters, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])];\n          $send(self.attributes, '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];\n        } else if ($truthy(seed)) {\n          \n          $writer = [name, (($writer = [name, (function() {if (seed['$=='](seed.$to_i().$to_s())) {\n            return seed.$to_i()\n          } else {\n            return seed\n          }; return nil; })()]), $send(self.counters, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])];\n          $send(self.attributes, '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];\n        } else {\n          \n          $writer = [name, (($writer = [name, self.$nextval((function() {if ($truthy(attr_seed)) {\n            return attr_val\n          } else {\n            return 0\n          }; return nil; })())]), $send(self.counters, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])];\n          $send(self.attributes, '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];\n        };\n      }, TMP_Document_counter_14.$$arity = -2);\n      \n      Opal.def(self, '$increment_and_store_counter', TMP_Document_increment_and_store_counter_15 = function $$increment_and_store_counter(counter_name, block) {\n        var self = this;\n\n        return $$($nesting, 'AttributeEntry').$new(counter_name, self.$counter(counter_name)).$save_to(block.$attributes()).$value()\n      }, TMP_Document_increment_and_store_counter_15.$$arity = 2);\n      Opal.alias(self, \"counter_increment\", \"increment_and_store_counter\");\n      \n      Opal.def(self, '$nextval', TMP_Document_nextval_16 = function $$nextval(current) {\n        var self = this, intval = nil;\n\n        if ($truthy($$$('::', 'Integer')['$==='](current))) {\n          return $rb_plus(current, 1)\n        } else {\n          \n          intval = current.$to_i();\n          if ($truthy(intval.$to_s()['$!='](current.$to_s()))) {\n            return $rb_plus(current['$[]'](0).$ord(), 1).$chr()\n          } else {\n            return $rb_plus(intval, 1)\n          };\n        }\n      }, TMP_Document_nextval_16.$$arity = 1);\n      \n      Opal.def(self, '$register', TMP_Document_register_17 = function $$register(type, value) {\n        var $a, $b, self = this, $case = nil, id = nil, reftext = nil, $logical_op_recvr_tmp_1 = nil, $writer = nil, ref = nil, refs = nil;\n\n        return (function() {$case = type;\n        if (\"ids\"['$===']($case)) {\n        $b = value, $a = Opal.to_ary($b), (id = ($a[0] == null ? nil : $a[0])), (reftext = ($a[1] == null ? nil : $a[1])), $b;\n        \n        $logical_op_recvr_tmp_1 = self.catalog['$[]'](\"ids\");\n        return ($truthy($a = $logical_op_recvr_tmp_1['$[]'](id)) ? $a : (($writer = [id, ($truthy($b = reftext) ? $b : $rb_plus($rb_plus(\"[\", id), \"]\"))]), $send($logical_op_recvr_tmp_1, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));;}\n        else if (\"refs\"['$===']($case)) {\n        $b = value, $a = Opal.to_ary($b), (id = ($a[0] == null ? nil : $a[0])), (ref = ($a[1] == null ? nil : $a[1])), (reftext = ($a[2] == null ? nil : $a[2])), $b;\n        if ($truthy((refs = self.catalog['$[]'](\"refs\"))['$key?'](id))) {\n          return nil\n        } else {\n          \n          \n          $writer = [id, ($truthy($a = reftext) ? $a : $rb_plus($rb_plus(\"[\", id), \"]\"))];\n          $send(self.catalog['$[]'](\"ids\"), '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          \n          $writer = [id, ref];\n          $send(refs, '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];;\n        };}\n        else if (\"footnotes\"['$===']($case) || \"indexterms\"['$===']($case)) {return self.catalog['$[]'](type)['$<<'](value)}\n        else {if ($truthy(self.options['$[]'](\"catalog_assets\"))) {\n          return self.catalog['$[]'](type)['$<<'](value)\n        } else {\n          return nil\n        }}})()\n      }, TMP_Document_register_17.$$arity = 2);\n      \n      Opal.def(self, '$footnotes?', TMP_Document_footnotes$q_18 = function() {\n        var self = this;\n\n        if ($truthy(self.catalog['$[]'](\"footnotes\")['$empty?']())) {\n          return false\n        } else {\n          return true\n        }\n      }, TMP_Document_footnotes$q_18.$$arity = 0);\n      \n      Opal.def(self, '$footnotes', TMP_Document_footnotes_19 = function $$footnotes() {\n        var self = this;\n\n        return self.catalog['$[]'](\"footnotes\")\n      }, TMP_Document_footnotes_19.$$arity = 0);\n      \n      Opal.def(self, '$nested?', TMP_Document_nested$q_20 = function() {\n        var self = this;\n\n        if ($truthy(self.parent_document)) {\n          return true\n        } else {\n          return false\n        }\n      }, TMP_Document_nested$q_20.$$arity = 0);\n      \n      Opal.def(self, '$embedded?', TMP_Document_embedded$q_21 = function() {\n        var self = this;\n\n        return self.attributes['$key?'](\"embedded\")\n      }, TMP_Document_embedded$q_21.$$arity = 0);\n      \n      Opal.def(self, '$extensions?', TMP_Document_extensions$q_22 = function() {\n        var self = this;\n\n        if ($truthy(self.extensions)) {\n          return true\n        } else {\n          return false\n        }\n      }, TMP_Document_extensions$q_22.$$arity = 0);\n      \n      Opal.def(self, '$source', TMP_Document_source_23 = function $$source() {\n        var self = this;\n\n        if ($truthy(self.reader)) {\n          return self.reader.$source()\n        } else {\n          return nil\n        }\n      }, TMP_Document_source_23.$$arity = 0);\n      \n      Opal.def(self, '$source_lines', TMP_Document_source_lines_24 = function $$source_lines() {\n        var self = this;\n\n        if ($truthy(self.reader)) {\n          return self.reader.$source_lines()\n        } else {\n          return nil\n        }\n      }, TMP_Document_source_lines_24.$$arity = 0);\n      \n      Opal.def(self, '$basebackend?', TMP_Document_basebackend$q_25 = function(base) {\n        var self = this;\n\n        return self.attributes['$[]'](\"basebackend\")['$=='](base)\n      }, TMP_Document_basebackend$q_25.$$arity = 1);\n      \n      Opal.def(self, '$title', TMP_Document_title_26 = function $$title() {\n        var self = this;\n\n        return self.attributes['$[]'](\"title\")\n      }, TMP_Document_title_26.$$arity = 0);\n      \n      Opal.def(self, '$title=', TMP_Document_title$eq_27 = function(title) {\n        var self = this, sect = nil, $writer = nil;\n\n        \n        if ($truthy((sect = self.header))) {\n        } else {\n          \n          $writer = [\"header\"];\n          $send((sect = (self.header = $$($nesting, 'Section').$new(self, 0, false))), 'sectname=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];\n        };\n        \n        $writer = [title];\n        $send(sect, 'title=', Opal.to_a($writer));\n        return $writer[$rb_minus($writer[\"length\"], 1)];;\n      }, TMP_Document_title$eq_27.$$arity = 1);\n      \n      Opal.def(self, '$doctitle', TMP_Document_doctitle_28 = function $$doctitle(opts) {\n        var $a, self = this, val = nil, sect = nil, separator = nil;\n\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        \n        if ($truthy((val = self.attributes['$[]'](\"title\")['$nil_or_empty?']())['$!']())) {\n          val = self.$title()\n        } else if ($truthy((sect = self.$first_section()))) {\n          val = sect.$title()\n        } else if ($truthy(($truthy($a = opts['$[]'](\"use_fallback\")) ? (val = self.attributes['$[]'](\"untitled-label\")) : $a))) {\n        } else {\n          return nil\n        };\n        if ($truthy((separator = opts['$[]'](\"partition\")))) {\n          return $$($nesting, 'Title').$new(val, opts.$merge($hash2([\"separator\"], {\"separator\": (function() {if (separator['$=='](true)) {\n            return self.attributes['$[]'](\"title-separator\")\n          } else {\n            return separator\n          }; return nil; })()})))\n        } else if ($truthy(($truthy($a = opts['$[]'](\"sanitize\")) ? val['$include?'](\"<\") : $a))) {\n          return val.$gsub($$($nesting, 'XmlSanitizeRx'), \"\").$squeeze(\" \").$strip()\n        } else {\n          return val\n        };\n      }, TMP_Document_doctitle_28.$$arity = -1);\n      Opal.alias(self, \"name\", \"doctitle\");\n      \n      Opal.def(self, '$author', TMP_Document_author_29 = function $$author() {\n        var self = this;\n\n        return self.attributes['$[]'](\"author\")\n      }, TMP_Document_author_29.$$arity = 0);\n      \n      Opal.def(self, '$revdate', TMP_Document_revdate_30 = function $$revdate() {\n        var self = this;\n\n        return self.attributes['$[]'](\"revdate\")\n      }, TMP_Document_revdate_30.$$arity = 0);\n      \n      Opal.def(self, '$notitle', TMP_Document_notitle_31 = function $$notitle() {\n        var $a, self = this;\n\n        return ($truthy($a = self.attributes['$key?'](\"showtitle\")['$!']()) ? self.attributes['$key?'](\"notitle\") : $a)\n      }, TMP_Document_notitle_31.$$arity = 0);\n      \n      Opal.def(self, '$noheader', TMP_Document_noheader_32 = function $$noheader() {\n        var self = this;\n\n        return self.attributes['$key?'](\"noheader\")\n      }, TMP_Document_noheader_32.$$arity = 0);\n      \n      Opal.def(self, '$nofooter', TMP_Document_nofooter_33 = function $$nofooter() {\n        var self = this;\n\n        return self.attributes['$key?'](\"nofooter\")\n      }, TMP_Document_nofooter_33.$$arity = 0);\n      \n      Opal.def(self, '$first_section', TMP_Document_first_section_35 = function $$first_section() {\n        var $a, TMP_34, self = this;\n\n        return ($truthy($a = self.header) ? $a : $send(self.blocks, 'find', [], (TMP_34 = function(e){var self = TMP_34.$$s || this;\nif (e == null) e = nil;\n        return e.$context()['$=='](\"section\")}, TMP_34.$$s = self, TMP_34.$$arity = 1, TMP_34)))\n      }, TMP_Document_first_section_35.$$arity = 0);\n      \n      Opal.def(self, '$has_header?', TMP_Document_has_header$q_36 = function() {\n        var self = this;\n\n        if ($truthy(self.header)) {\n          return true\n        } else {\n          return false\n        }\n      }, TMP_Document_has_header$q_36.$$arity = 0);\n      Opal.alias(self, \"header?\", \"has_header?\");\n      \n      Opal.def(self, '$<<', TMP_Document_$lt$lt_37 = function(block) {\n        var self = this, $iter = TMP_Document_$lt$lt_37.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n        if ($iter) TMP_Document_$lt$lt_37.$$p = null;\n        // Prepare super implicit arguments\n        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n          $zuper[$zuper_i] = arguments[$zuper_i];\n        }\n        \n        if (block.$context()['$=='](\"section\")) {\n          self.$enumerate_section(block)};\n        return $send(self, Opal.find_super_dispatcher(self, '<<', TMP_Document_$lt$lt_37, false), $zuper, $iter);\n      }, TMP_Document_$lt$lt_37.$$arity = 1);\n      \n      Opal.def(self, '$finalize_header', TMP_Document_finalize_header_38 = function $$finalize_header(unrooted_attributes, header_valid) {\n        var self = this, $writer = nil;\n\n        if (header_valid == null) {\n          header_valid = true;\n        }\n        \n        self.$clear_playback_attributes(unrooted_attributes);\n        self.$save_attributes();\n        if ($truthy(header_valid)) {\n        } else {\n          \n          $writer = [\"invalid-header\", true];\n          $send(unrooted_attributes, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];\n        };\n        return unrooted_attributes;\n      }, TMP_Document_finalize_header_38.$$arity = -2);\n      \n      Opal.def(self, '$save_attributes', TMP_Document_save_attributes_40 = function $$save_attributes() {\n        var $a, $b, TMP_39, self = this, attrs = nil, $writer = nil, val = nil, toc_position_val = nil, toc_val = nil, toc_placement = nil, default_toc_position = nil, default_toc_class = nil, position = nil, $case = nil;\n\n        \n        if ((attrs = self.attributes)['$[]'](\"basebackend\")['$=='](\"docbook\")) {\n          \n          if ($truthy(($truthy($a = self['$attribute_locked?'](\"toc\")) ? $a : self.attributes_modified['$include?'](\"toc\")))) {\n          } else {\n            \n            $writer = [\"toc\", \"\"];\n            $send(attrs, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];\n          };\n          if ($truthy(($truthy($a = self['$attribute_locked?'](\"sectnums\")) ? $a : self.attributes_modified['$include?'](\"sectnums\")))) {\n          } else {\n            \n            $writer = [\"sectnums\", \"\"];\n            $send(attrs, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];\n          };};\n        if ($truthy(($truthy($a = attrs['$key?'](\"doctitle\")) ? $a : (val = self.$doctitle())['$!']()))) {\n        } else {\n          \n          $writer = [\"doctitle\", val];\n          $send(attrs, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];\n        };\n        if ($truthy(self.id)) {\n        } else {\n          self.id = attrs['$[]'](\"css-signature\")\n        };\n        toc_position_val = (function() {if ($truthy((toc_val = (function() {if ($truthy(attrs.$delete(\"toc2\"))) {\n          return \"left\"\n        } else {\n          return attrs['$[]'](\"toc\")\n        }; return nil; })()))) {\n          if ($truthy(($truthy($a = (toc_placement = attrs.$fetch(\"toc-placement\", \"macro\"))) ? toc_placement['$!='](\"auto\") : $a))) {\n            return toc_placement\n          } else {\n            return attrs['$[]'](\"toc-position\")\n          }\n        } else {\n          return nil\n        }; return nil; })();\n        if ($truthy(($truthy($a = toc_val) ? ($truthy($b = toc_val['$empty?']()['$!']()) ? $b : toc_position_val['$nil_or_empty?']()['$!']()) : $a))) {\n          \n          default_toc_position = \"left\";\n          default_toc_class = \"toc2\";\n          if ($truthy(toc_position_val['$nil_or_empty?']()['$!']())) {\n            position = toc_position_val\n          } else if ($truthy(toc_val['$empty?']()['$!']())) {\n            position = toc_val\n          } else {\n            position = default_toc_position\n          };\n          \n          $writer = [\"toc\", \"\"];\n          $send(attrs, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          \n          $writer = [\"toc-placement\", \"auto\"];\n          $send(attrs, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          $case = position;\n          if (\"left\"['$===']($case) || \"<\"['$===']($case) || \"&lt;\"['$===']($case)) {\n          $writer = [\"toc-position\", \"left\"];\n          $send(attrs, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];}\n          else if (\"right\"['$===']($case) || \">\"['$===']($case) || \"&gt;\"['$===']($case)) {\n          $writer = [\"toc-position\", \"right\"];\n          $send(attrs, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];}\n          else if (\"top\"['$===']($case) || \"^\"['$===']($case)) {\n          $writer = [\"toc-position\", \"top\"];\n          $send(attrs, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];}\n          else if (\"bottom\"['$===']($case) || \"v\"['$===']($case)) {\n          $writer = [\"toc-position\", \"bottom\"];\n          $send(attrs, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];}\n          else if (\"preamble\"['$===']($case) || \"macro\"['$===']($case)) {\n          \n          $writer = [\"toc-position\", \"content\"];\n          $send(attrs, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          \n          $writer = [\"toc-placement\", position];\n          $send(attrs, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          default_toc_class = nil;}\n          else {\n          attrs.$delete(\"toc-position\");\n          default_toc_class = nil;};\n          if ($truthy(default_toc_class)) {\n            ($truthy($a = attrs['$[]'](\"toc-class\")) ? $a : (($writer = [\"toc-class\", default_toc_class]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))};};\n        if ($truthy((self.compat_mode = attrs['$key?'](\"compat-mode\")))) {\n          if ($truthy(attrs['$key?'](\"language\"))) {\n            \n            $writer = [\"source-language\", attrs['$[]'](\"language\")];\n            $send(attrs, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];}};\n        self.outfilesuffix = attrs['$[]'](\"outfilesuffix\");\n        self.header_attributes = attrs.$dup();\n        if ($truthy(self.parent_document)) {\n          return nil\n        } else {\n          return $send($$($nesting, 'FLEXIBLE_ATTRIBUTES'), 'each', [], (TMP_39 = function(name){var self = TMP_39.$$s || this, $c;\n            if (self.attribute_overrides == null) self.attribute_overrides = nil;\nif (name == null) name = nil;\n          if ($truthy(($truthy($c = self.attribute_overrides['$key?'](name)) ? self.attribute_overrides['$[]'](name) : $c))) {\n              return self.attribute_overrides.$delete(name)\n            } else {\n              return nil\n            }}, TMP_39.$$s = self, TMP_39.$$arity = 1, TMP_39))\n        };\n      }, TMP_Document_save_attributes_40.$$arity = 0);\n      \n      Opal.def(self, '$restore_attributes', TMP_Document_restore_attributes_41 = function $$restore_attributes() {\n        var self = this;\n\n        \n        if ($truthy(self.parent_document)) {\n        } else {\n          self.callouts.$rewind()\n        };\n        return (self.attributes = self.header_attributes);\n      }, TMP_Document_restore_attributes_41.$$arity = 0);\n      \n      Opal.def(self, '$clear_playback_attributes', TMP_Document_clear_playback_attributes_42 = function $$clear_playback_attributes(attributes) {\n        var self = this;\n\n        return attributes.$delete(\"attribute_entries\")\n      }, TMP_Document_clear_playback_attributes_42.$$arity = 1);\n      \n      Opal.def(self, '$playback_attributes', TMP_Document_playback_attributes_44 = function $$playback_attributes(block_attributes) {\n        var TMP_43, self = this;\n\n        if ($truthy(block_attributes['$key?'](\"attribute_entries\"))) {\n          return $send(block_attributes['$[]'](\"attribute_entries\"), 'each', [], (TMP_43 = function(entry){var self = TMP_43.$$s || this, name = nil, $writer = nil;\n            if (self.attributes == null) self.attributes = nil;\nif (entry == null) entry = nil;\n          \n            name = entry.$name();\n            if ($truthy(entry.$negate())) {\n              \n              self.attributes.$delete(name);\n              if (name['$=='](\"compat-mode\")) {\n                return (self.compat_mode = false)\n              } else {\n                return nil\n              };\n            } else {\n              \n              \n              $writer = [name, entry.$value()];\n              $send(self.attributes, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n              if (name['$=='](\"compat-mode\")) {\n                return (self.compat_mode = true)\n              } else {\n                return nil\n              };\n            };}, TMP_43.$$s = self, TMP_43.$$arity = 1, TMP_43))\n        } else {\n          return nil\n        }\n      }, TMP_Document_playback_attributes_44.$$arity = 1);\n      \n      Opal.def(self, '$set_attribute', TMP_Document_set_attribute_45 = function $$set_attribute(name, value) {\n        var self = this, resolved_value = nil, $case = nil, $writer = nil;\n\n        if (value == null) {\n          value = \"\";\n        }\n        if ($truthy(self['$attribute_locked?'](name))) {\n          return false\n        } else {\n          \n          if ($truthy(self.max_attribute_value_size)) {\n            resolved_value = self.$apply_attribute_value_subs(value).$limit_bytesize(self.max_attribute_value_size)\n          } else {\n            resolved_value = self.$apply_attribute_value_subs(value)\n          };\n          $case = name;\n          if (\"backend\"['$===']($case)) {self.$update_backend_attributes(resolved_value, self.attributes_modified['$delete?'](\"htmlsyntax\"))}\n          else if (\"doctype\"['$===']($case)) {self.$update_doctype_attributes(resolved_value)}\n          else {\n          $writer = [name, resolved_value];\n          $send(self.attributes, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];};\n          self.attributes_modified['$<<'](name);\n          return resolved_value;\n        }\n      }, TMP_Document_set_attribute_45.$$arity = -2);\n      \n      Opal.def(self, '$delete_attribute', TMP_Document_delete_attribute_46 = function $$delete_attribute(name) {\n        var self = this;\n\n        if ($truthy(self['$attribute_locked?'](name))) {\n          return false\n        } else {\n          \n          self.attributes.$delete(name);\n          self.attributes_modified['$<<'](name);\n          return true;\n        }\n      }, TMP_Document_delete_attribute_46.$$arity = 1);\n      \n      Opal.def(self, '$attribute_locked?', TMP_Document_attribute_locked$q_47 = function(name) {\n        var self = this;\n\n        return self.attribute_overrides['$key?'](name)\n      }, TMP_Document_attribute_locked$q_47.$$arity = 1);\n      \n      Opal.def(self, '$apply_attribute_value_subs', TMP_Document_apply_attribute_value_subs_48 = function $$apply_attribute_value_subs(value) {\n        var $a, self = this;\n\n        if ($truthy($$($nesting, 'AttributeEntryPassMacroRx')['$=~'](value))) {\n          if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)))) {\n            \n            return self.$apply_subs((($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), self.$resolve_pass_subs((($a = $gvars['~']) === nil ? nil : $a['$[]'](1))));\n          } else {\n            return (($a = $gvars['~']) === nil ? nil : $a['$[]'](2))\n          }\n        } else {\n          return self.$apply_header_subs(value)\n        }\n      }, TMP_Document_apply_attribute_value_subs_48.$$arity = 1);\n      \n      Opal.def(self, '$update_backend_attributes', TMP_Document_update_backend_attributes_49 = function $$update_backend_attributes(new_backend, force) {\n        var $a, $b, self = this, attrs = nil, current_backend = nil, current_basebackend = nil, current_doctype = nil, $writer = nil, resolved_backend = nil, new_basebackend = nil, new_filetype = nil, new_outfilesuffix = nil, current_filetype = nil, page_width = nil;\n\n        if (force == null) {\n          force = nil;\n        }\n        if ($truthy(($truthy($a = force) ? $a : ($truthy($b = new_backend) ? new_backend['$!='](self.backend) : $b)))) {\n          \n          $a = [self.backend, (attrs = self.attributes)['$[]'](\"basebackend\"), self.doctype], (current_backend = $a[0]), (current_basebackend = $a[1]), (current_doctype = $a[2]), $a;\n          if ($truthy(new_backend['$start_with?'](\"xhtml\"))) {\n            \n            \n            $writer = [\"htmlsyntax\", \"xml\"];\n            $send(attrs, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            new_backend = new_backend['$[]']($range(1, -1, false));\n          } else if ($truthy(new_backend['$start_with?'](\"html\"))) {\n            if (attrs['$[]'](\"htmlsyntax\")['$=='](\"xml\")) {\n            } else {\n              \n              $writer = [\"htmlsyntax\", \"html\"];\n              $send(attrs, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];\n            }};\n          if ($truthy((resolved_backend = $$($nesting, 'BACKEND_ALIASES')['$[]'](new_backend)))) {\n            new_backend = resolved_backend};\n          if ($truthy(current_doctype)) {\n            \n            if ($truthy(current_backend)) {\n              \n              attrs.$delete(\"\" + \"backend-\" + (current_backend));\n              attrs.$delete(\"\" + \"backend-\" + (current_backend) + \"-doctype-\" + (current_doctype));};\n            \n            $writer = [\"\" + \"backend-\" + (new_backend) + \"-doctype-\" + (current_doctype), \"\"];\n            $send(attrs, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            \n            $writer = [\"\" + \"doctype-\" + (current_doctype), \"\"];\n            $send(attrs, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n          } else if ($truthy(current_backend)) {\n            attrs.$delete(\"\" + \"backend-\" + (current_backend))};\n          \n          $writer = [\"\" + \"backend-\" + (new_backend), \"\"];\n          $send(attrs, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          self.backend = (($writer = [\"backend\", new_backend]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]);\n          if ($truthy($$$($$($nesting, 'Converter'), 'BackendInfo')['$===']((self.converter = self.$create_converter())))) {\n            \n            new_basebackend = self.converter.$basebackend();\n            if ($truthy(self['$attribute_locked?'](\"outfilesuffix\"))) {\n            } else {\n              \n              $writer = [\"outfilesuffix\", self.converter.$outfilesuffix()];\n              $send(attrs, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];\n            };\n            new_filetype = self.converter.$filetype();\n          } else if ($truthy(self.converter)) {\n            \n            new_basebackend = new_backend.$sub($$($nesting, 'TrailingDigitsRx'), \"\");\n            if ($truthy((new_outfilesuffix = $$($nesting, 'DEFAULT_EXTENSIONS')['$[]'](new_basebackend)))) {\n              new_filetype = new_outfilesuffix['$[]']($range(1, -1, false))\n            } else {\n              $a = [\".html\", \"html\", \"html\"], (new_outfilesuffix = $a[0]), (new_basebackend = $a[1]), (new_filetype = $a[2]), $a\n            };\n            if ($truthy(self['$attribute_locked?'](\"outfilesuffix\"))) {\n            } else {\n              \n              $writer = [\"outfilesuffix\", new_outfilesuffix];\n              $send(attrs, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];\n            };\n          } else {\n            self.$raise($$$('::', 'NotImplementedError'), \"\" + \"asciidoctor: FAILED: missing converter for backend '\" + (new_backend) + \"'. Processing aborted.\")\n          };\n          if ($truthy((current_filetype = attrs['$[]'](\"filetype\")))) {\n            attrs.$delete(\"\" + \"filetype-\" + (current_filetype))};\n          \n          $writer = [\"filetype\", new_filetype];\n          $send(attrs, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          \n          $writer = [\"\" + \"filetype-\" + (new_filetype), \"\"];\n          $send(attrs, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          if ($truthy((page_width = $$($nesting, 'DEFAULT_PAGE_WIDTHS')['$[]'](new_basebackend)))) {\n            \n            $writer = [\"pagewidth\", page_width];\n            $send(attrs, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];\n          } else {\n            attrs.$delete(\"pagewidth\")\n          };\n          if ($truthy(new_basebackend['$!='](current_basebackend))) {\n            \n            if ($truthy(current_doctype)) {\n              \n              if ($truthy(current_basebackend)) {\n                \n                attrs.$delete(\"\" + \"basebackend-\" + (current_basebackend));\n                attrs.$delete(\"\" + \"basebackend-\" + (current_basebackend) + \"-doctype-\" + (current_doctype));};\n              \n              $writer = [\"\" + \"basebackend-\" + (new_basebackend) + \"-doctype-\" + (current_doctype), \"\"];\n              $send(attrs, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n            } else if ($truthy(current_basebackend)) {\n              attrs.$delete(\"\" + \"basebackend-\" + (current_basebackend))};\n            \n            $writer = [\"\" + \"basebackend-\" + (new_basebackend), \"\"];\n            $send(attrs, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            \n            $writer = [\"basebackend\", new_basebackend];\n            $send(attrs, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;};\n          return new_backend;\n        } else {\n          return nil\n        }\n      }, TMP_Document_update_backend_attributes_49.$$arity = -2);\n      \n      Opal.def(self, '$update_doctype_attributes', TMP_Document_update_doctype_attributes_50 = function $$update_doctype_attributes(new_doctype) {\n        var $a, self = this, attrs = nil, current_backend = nil, current_basebackend = nil, current_doctype = nil, $writer = nil;\n\n        if ($truthy(($truthy($a = new_doctype) ? new_doctype['$!='](self.doctype) : $a))) {\n          \n          $a = [self.backend, (attrs = self.attributes)['$[]'](\"basebackend\"), self.doctype], (current_backend = $a[0]), (current_basebackend = $a[1]), (current_doctype = $a[2]), $a;\n          if ($truthy(current_doctype)) {\n            \n            attrs.$delete(\"\" + \"doctype-\" + (current_doctype));\n            if ($truthy(current_backend)) {\n              \n              attrs.$delete(\"\" + \"backend-\" + (current_backend) + \"-doctype-\" + (current_doctype));\n              \n              $writer = [\"\" + \"backend-\" + (current_backend) + \"-doctype-\" + (new_doctype), \"\"];\n              $send(attrs, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;};\n            if ($truthy(current_basebackend)) {\n              \n              attrs.$delete(\"\" + \"basebackend-\" + (current_basebackend) + \"-doctype-\" + (current_doctype));\n              \n              $writer = [\"\" + \"basebackend-\" + (current_basebackend) + \"-doctype-\" + (new_doctype), \"\"];\n              $send(attrs, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;};\n          } else {\n            \n            if ($truthy(current_backend)) {\n              \n              $writer = [\"\" + \"backend-\" + (current_backend) + \"-doctype-\" + (new_doctype), \"\"];\n              $send(attrs, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];};\n            if ($truthy(current_basebackend)) {\n              \n              $writer = [\"\" + \"basebackend-\" + (current_basebackend) + \"-doctype-\" + (new_doctype), \"\"];\n              $send(attrs, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];};\n          };\n          \n          $writer = [\"\" + \"doctype-\" + (new_doctype), \"\"];\n          $send(attrs, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          return (self.doctype = (($writer = [\"doctype\", new_doctype]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n        } else {\n          return nil\n        }\n      }, TMP_Document_update_doctype_attributes_50.$$arity = 1);\n      \n      Opal.def(self, '$create_converter', TMP_Document_create_converter_51 = function $$create_converter() {\n        var self = this, converter_opts = nil, $writer = nil, template_dirs = nil, template_dir = nil, converter = nil, converter_factory = nil;\n\n        \n        converter_opts = $hash2([], {});\n        \n        $writer = [\"htmlsyntax\", self.attributes['$[]'](\"htmlsyntax\")];\n        $send(converter_opts, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        template_dirs = (function() {if ($truthy((template_dir = self.options['$[]'](\"template_dir\")))) {\n          \n          $writer = [\"template_dirs\", [template_dir]];\n          $send(converter_opts, '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];\n        } else if ($truthy((template_dirs = self.options['$[]'](\"template_dirs\")))) {\n          \n          $writer = [\"template_dirs\", template_dirs];\n          $send(converter_opts, '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];\n        } else {\n          return nil\n        }; return nil; })();\n        if ($truthy(template_dirs)) {\n          \n          \n          $writer = [\"template_cache\", self.options.$fetch(\"template_cache\", true)];\n          $send(converter_opts, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          \n          $writer = [\"template_engine\", self.options['$[]'](\"template_engine\")];\n          $send(converter_opts, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          \n          $writer = [\"template_engine_options\", self.options['$[]'](\"template_engine_options\")];\n          $send(converter_opts, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          \n          $writer = [\"eruby\", self.options['$[]'](\"eruby\")];\n          $send(converter_opts, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          \n          $writer = [\"safe\", self.safe];\n          $send(converter_opts, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;};\n        if ($truthy((converter = self.options['$[]'](\"converter\")))) {\n          converter_factory = $$$($$($nesting, 'Converter'), 'Factory').$new($$$('::', 'Hash')['$[]'](self.$backend(), converter))\n        } else {\n          converter_factory = $$$($$($nesting, 'Converter'), 'Factory').$default(false)\n        };\n        return converter_factory.$create(self.$backend(), converter_opts);\n      }, TMP_Document_create_converter_51.$$arity = 0);\n      \n      Opal.def(self, '$convert', TMP_Document_convert_53 = function $$convert(opts) {\n        var $a, TMP_52, self = this, $writer = nil, block = nil, output = nil, transform = nil, exts = nil;\n\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        \n        if ($truthy(self.parsed)) {\n        } else {\n          self.$parse()\n        };\n        if ($truthy(($truthy($a = $rb_ge(self.safe, $$$($$($nesting, 'SafeMode'), 'SERVER'))) ? $a : opts['$empty?']()))) {\n        } else {\n          \n          if ($truthy((($writer = [\"outfile\", opts['$[]'](\"outfile\")]), $send(self.attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))) {\n          } else {\n            self.attributes.$delete(\"outfile\")\n          };\n          if ($truthy((($writer = [\"outdir\", opts['$[]'](\"outdir\")]), $send(self.attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))) {\n          } else {\n            self.attributes.$delete(\"outdir\")\n          };\n        };\n        if (self.$doctype()['$=='](\"inline\")) {\n          if ($truthy((block = self.blocks['$[]'](0)))) {\n            if ($truthy(($truthy($a = block.$content_model()['$=='](\"compound\")) ? $a : block.$content_model()['$=='](\"empty\")))) {\n              self.$warn(\"asciidoctor: WARNING: no inline candidate; use the inline doctype to convert a single paragragh, verbatim, or raw block\")\n            } else {\n              output = block.$content()\n            }}\n        } else {\n          \n          transform = (function() {if ($truthy((function() {if ($truthy(opts['$key?'](\"header_footer\"))) {\n            return opts['$[]'](\"header_footer\")\n          } else {\n            return self.options['$[]'](\"header_footer\")\n          }; return nil; })())) {\n            return \"document\"\n          } else {\n            return \"embedded\"\n          }; return nil; })();\n          output = self.converter.$convert(self, transform);\n        };\n        if ($truthy(self.parent_document)) {\n        } else if ($truthy(($truthy($a = (exts = self.extensions)) ? exts['$postprocessors?']() : $a))) {\n          $send(exts.$postprocessors(), 'each', [], (TMP_52 = function(ext){var self = TMP_52.$$s || this;\nif (ext == null) ext = nil;\n          return (output = ext.$process_method()['$[]'](self, output))}, TMP_52.$$s = self, TMP_52.$$arity = 1, TMP_52))};\n        return output;\n      }, TMP_Document_convert_53.$$arity = -1);\n      Opal.alias(self, \"render\", \"convert\");\n      \n      Opal.def(self, '$write', TMP_Document_write_54 = function $$write(output, target) {\n        var self = this;\n\n        if ($truthy($$($nesting, 'Writer')['$==='](self.converter))) {\n          return self.converter.$write(output, target)\n        } else {\n          \n          if ($truthy(target['$respond_to?'](\"write\"))) {\n            if ($truthy(output['$nil_or_empty?']())) {\n            } else {\n              \n              target.$write(output.$chomp());\n              target.$write($$($nesting, 'LF'));\n            }\n          } else {\n            $$$('::', 'IO').$write(target, output)\n          };\n          return nil;\n        }\n      }, TMP_Document_write_54.$$arity = 2);\n      \n      Opal.def(self, '$content', TMP_Document_content_55 = function $$content() {\n        var self = this, $iter = TMP_Document_content_55.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n        if ($iter) TMP_Document_content_55.$$p = null;\n        // Prepare super implicit arguments\n        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n          $zuper[$zuper_i] = arguments[$zuper_i];\n        }\n        \n        self.attributes.$delete(\"title\");\n        return $send(self, Opal.find_super_dispatcher(self, 'content', TMP_Document_content_55, false), $zuper, $iter);\n      }, TMP_Document_content_55.$$arity = 0);\n      \n      Opal.def(self, '$docinfo', TMP_Document_docinfo_58 = function $$docinfo(location, suffix) {\n        var TMP_56, $a, TMP_57, self = this, content = nil, qualifier = nil, docinfo = nil, docinfo_file = nil, docinfo_dir = nil, docinfo_subs = nil, docinfo_path = nil, shd_content = nil, pvt_content = nil;\n\n        if (location == null) {\n          location = \"head\";\n        }\n        if (suffix == null) {\n          suffix = nil;\n        }\n        if ($truthy($rb_ge(self.$safe(), $$$($$($nesting, 'SafeMode'), 'SECURE')))) {\n          return \"\"\n        } else {\n          \n          content = [];\n          if (location['$=='](\"head\")) {\n          } else {\n            qualifier = \"\" + \"-\" + (location)\n          };\n          if ($truthy(suffix)) {\n          } else {\n            suffix = self.outfilesuffix\n          };\n          if ($truthy((docinfo = self.attributes['$[]'](\"docinfo\"))['$nil_or_empty?']())) {\n            if ($truthy(self.attributes['$key?'](\"docinfo2\"))) {\n              docinfo = [\"private\", \"shared\"]\n            } else if ($truthy(self.attributes['$key?'](\"docinfo1\"))) {\n              docinfo = [\"shared\"]\n            } else {\n              docinfo = (function() {if ($truthy(docinfo)) {\n                return [\"private\"]\n              } else {\n                return nil\n              }; return nil; })()\n            }\n          } else {\n            docinfo = $send(docinfo.$split(\",\"), 'map', [], (TMP_56 = function(it){var self = TMP_56.$$s || this;\nif (it == null) it = nil;\n            return it.$strip()}, TMP_56.$$s = self, TMP_56.$$arity = 1, TMP_56))\n          };\n          if ($truthy(docinfo)) {\n            \n            $a = [\"\" + \"docinfo\" + (qualifier) + (suffix), self.attributes['$[]'](\"docinfodir\"), self.$resolve_docinfo_subs()], (docinfo_file = $a[0]), (docinfo_dir = $a[1]), (docinfo_subs = $a[2]), $a;\n            if ($truthy(docinfo['$&']([\"shared\", \"\" + \"shared-\" + (location)])['$empty?']())) {\n            } else {\n              \n              docinfo_path = self.$normalize_system_path(docinfo_file, docinfo_dir);\n              if ($truthy((shd_content = self.$read_asset(docinfo_path, $hash2([\"normalize\"], {\"normalize\": true}))))) {\n                content['$<<'](self.$apply_subs(shd_content, docinfo_subs))};\n            };\n            if ($truthy(($truthy($a = self.attributes['$[]'](\"docname\")['$nil_or_empty?']()) ? $a : docinfo['$&']([\"private\", \"\" + \"private-\" + (location)])['$empty?']()))) {\n            } else {\n              \n              docinfo_path = self.$normalize_system_path(\"\" + (self.attributes['$[]'](\"docname\")) + \"-\" + (docinfo_file), docinfo_dir);\n              if ($truthy((pvt_content = self.$read_asset(docinfo_path, $hash2([\"normalize\"], {\"normalize\": true}))))) {\n                content['$<<'](self.$apply_subs(pvt_content, docinfo_subs))};\n            };};\n          if ($truthy(($truthy($a = self.extensions) ? self['$docinfo_processors?'](location) : $a))) {\n            content = $rb_plus(content, $send(self.docinfo_processor_extensions['$[]'](location), 'map', [], (TMP_57 = function(ext){var self = TMP_57.$$s || this;\nif (ext == null) ext = nil;\n            return ext.$process_method()['$[]'](self)}, TMP_57.$$s = self, TMP_57.$$arity = 1, TMP_57)).$compact())};\n          return $rb_times(content, $$($nesting, 'LF'));\n        }\n      }, TMP_Document_docinfo_58.$$arity = -1);\n      \n      Opal.def(self, '$resolve_docinfo_subs', TMP_Document_resolve_docinfo_subs_59 = function $$resolve_docinfo_subs() {\n        var self = this;\n\n        if ($truthy(self.attributes['$key?'](\"docinfosubs\"))) {\n          \n          return self.$resolve_subs(self.attributes['$[]'](\"docinfosubs\"), \"block\", nil, \"docinfo\");\n        } else {\n          return [\"attributes\"]\n        }\n      }, TMP_Document_resolve_docinfo_subs_59.$$arity = 0);\n      \n      Opal.def(self, '$docinfo_processors?', TMP_Document_docinfo_processors$q_60 = function(location) {\n        var $a, self = this, $writer = nil;\n\n        if (location == null) {\n          location = \"head\";\n        }\n        if ($truthy(self.docinfo_processor_extensions['$key?'](location))) {\n          return self.docinfo_processor_extensions['$[]'](location)['$!='](false)\n        } else if ($truthy(($truthy($a = self.extensions) ? self.document.$extensions()['$docinfo_processors?'](location) : $a))) {\n          return (($writer = [location, self.document.$extensions().$docinfo_processors(location)]), $send(self.docinfo_processor_extensions, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])['$!']()['$!']()\n        } else {\n          \n          $writer = [location, false];\n          $send(self.docinfo_processor_extensions, '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];\n        }\n      }, TMP_Document_docinfo_processors$q_60.$$arity = -1);\n      return (Opal.def(self, '$to_s', TMP_Document_to_s_61 = function $$to_s() {\n        var self = this;\n\n        return \"\" + \"#<\" + (self.$class()) + \"@\" + (self.$object_id()) + \" {doctype: \" + (self.$doctype().$inspect()) + \", doctitle: \" + ((function() {if ($truthy(self.header['$!='](nil))) {\n          return self.header.$title()\n        } else {\n          return nil\n        }; return nil; })().$inspect()) + \", blocks: \" + (self.blocks.$size()) + \"}>\"\n      }, TMP_Document_to_s_61.$$arity = 0), nil) && 'to_s';\n    })($nesting[0], $$($nesting, 'AbstractBlock'), $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/inline\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$attr_reader', '$attr_accessor', '$[]', '$nil_or_empty?', '$update_attributes', '$convert', '$converter', '$attr', '$==', '$apply_reftext_subs', '$reftext']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Inline(){};\n      var self = $Inline = $klass($base, $super, 'Inline', $Inline);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Inline_initialize_1, TMP_Inline_block$q_2, TMP_Inline_inline$q_3, TMP_Inline_convert_4, TMP_Inline_alt_5, TMP_Inline_reftext$q_6, TMP_Inline_reftext_7, TMP_Inline_xreftext_8;\n\n      def.text = def.type = nil;\n      \n      self.$attr_reader(\"text\");\n      self.$attr_reader(\"type\");\n      self.$attr_accessor(\"target\");\n      \n      Opal.def(self, '$initialize', TMP_Inline_initialize_1 = function $$initialize(parent, context, text, opts) {\n        var self = this, $iter = TMP_Inline_initialize_1.$$p, $yield = $iter || nil, more_attributes = nil;\n\n        if (text == null) {\n          text = nil;\n        }\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        if ($iter) TMP_Inline_initialize_1.$$p = null;\n        \n        $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Inline_initialize_1, false), [parent, context], null);\n        self.node_name = \"\" + \"inline_\" + (context);\n        self.text = text;\n        self.id = opts['$[]'](\"id\");\n        self.type = opts['$[]'](\"type\");\n        self.target = opts['$[]'](\"target\");\n        if ($truthy((more_attributes = opts['$[]'](\"attributes\"))['$nil_or_empty?']())) {\n          return nil\n        } else {\n          return self.$update_attributes(more_attributes)\n        };\n      }, TMP_Inline_initialize_1.$$arity = -3);\n      \n      Opal.def(self, '$block?', TMP_Inline_block$q_2 = function() {\n        var self = this;\n\n        return false\n      }, TMP_Inline_block$q_2.$$arity = 0);\n      \n      Opal.def(self, '$inline?', TMP_Inline_inline$q_3 = function() {\n        var self = this;\n\n        return true\n      }, TMP_Inline_inline$q_3.$$arity = 0);\n      \n      Opal.def(self, '$convert', TMP_Inline_convert_4 = function $$convert() {\n        var self = this;\n\n        return self.$converter().$convert(self)\n      }, TMP_Inline_convert_4.$$arity = 0);\n      Opal.alias(self, \"render\", \"convert\");\n      \n      Opal.def(self, '$alt', TMP_Inline_alt_5 = function $$alt() {\n        var self = this;\n\n        return self.$attr(\"alt\")\n      }, TMP_Inline_alt_5.$$arity = 0);\n      \n      Opal.def(self, '$reftext?', TMP_Inline_reftext$q_6 = function() {\n        var $a, $b, self = this;\n\n        return ($truthy($a = self.text) ? ($truthy($b = self.type['$=='](\"ref\")) ? $b : self.type['$=='](\"bibref\")) : $a)\n      }, TMP_Inline_reftext$q_6.$$arity = 0);\n      \n      Opal.def(self, '$reftext', TMP_Inline_reftext_7 = function $$reftext() {\n        var self = this, val = nil;\n\n        if ($truthy((val = self.text))) {\n          \n          return self.$apply_reftext_subs(val);\n        } else {\n          return nil\n        }\n      }, TMP_Inline_reftext_7.$$arity = 0);\n      return (Opal.def(self, '$xreftext', TMP_Inline_xreftext_8 = function $$xreftext(xrefstyle) {\n        var self = this;\n\n        if (xrefstyle == null) {\n          xrefstyle = nil;\n        }\n        return self.$reftext()\n      }, TMP_Inline_xreftext_8.$$arity = -1), nil) && 'xreftext';\n    })($nesting[0], $$($nesting, 'AbstractNode'), $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/list\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$==', '$next_list', '$callouts', '$class', '$object_id', '$inspect', '$size', '$items', '$attr_accessor', '$level', '$dup', '$!', '$nil_or_empty?', '$apply_subs', '$empty?', '$===', '$[]', '$outline?', '$simple?', '$context', '$option?', '$shift', '$blocks', '$unshift', '$lines', '$source', '$parent']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    \n    (function($base, $super, $parent_nesting) {\n      function $List(){};\n      var self = $List = $klass($base, $super, 'List', $List);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_List_initialize_1, TMP_List_outline$q_2, TMP_List_convert_3, TMP_List_to_s_4;\n\n      def.context = def.document = def.style = nil;\n      \n      Opal.alias(self, \"items\", \"blocks\");\n      Opal.alias(self, \"content\", \"blocks\");\n      Opal.alias(self, \"items?\", \"blocks?\");\n      \n      Opal.def(self, '$initialize', TMP_List_initialize_1 = function $$initialize(parent, context) {\n        var self = this, $iter = TMP_List_initialize_1.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n        if ($iter) TMP_List_initialize_1.$$p = null;\n        // Prepare super implicit arguments\n        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n          $zuper[$zuper_i] = arguments[$zuper_i];\n        }\n        return $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_List_initialize_1, false), $zuper, $iter)\n      }, TMP_List_initialize_1.$$arity = 2);\n      \n      Opal.def(self, '$outline?', TMP_List_outline$q_2 = function() {\n        var $a, self = this;\n\n        return ($truthy($a = self.context['$=='](\"ulist\")) ? $a : self.context['$=='](\"olist\"))\n      }, TMP_List_outline$q_2.$$arity = 0);\n      \n      Opal.def(self, '$convert', TMP_List_convert_3 = function $$convert() {\n        var self = this, $iter = TMP_List_convert_3.$$p, $yield = $iter || nil, result = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n        if ($iter) TMP_List_convert_3.$$p = null;\n        // Prepare super implicit arguments\n        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n          $zuper[$zuper_i] = arguments[$zuper_i];\n        }\n        if (self.context['$=='](\"colist\")) {\n          \n          result = $send(self, Opal.find_super_dispatcher(self, 'convert', TMP_List_convert_3, false), $zuper, $iter);\n          self.document.$callouts().$next_list();\n          return result;\n        } else {\n          return $send(self, Opal.find_super_dispatcher(self, 'convert', TMP_List_convert_3, false), $zuper, $iter)\n        }\n      }, TMP_List_convert_3.$$arity = 0);\n      Opal.alias(self, \"render\", \"convert\");\n      return (Opal.def(self, '$to_s', TMP_List_to_s_4 = function $$to_s() {\n        var self = this;\n\n        return \"\" + \"#<\" + (self.$class()) + \"@\" + (self.$object_id()) + \" {context: \" + (self.context.$inspect()) + \", style: \" + (self.style.$inspect()) + \", items: \" + (self.$items().$size()) + \"}>\"\n      }, TMP_List_to_s_4.$$arity = 0), nil) && 'to_s';\n    })($nesting[0], $$($nesting, 'AbstractBlock'), $nesting);\n    (function($base, $super, $parent_nesting) {\n      function $ListItem(){};\n      var self = $ListItem = $klass($base, $super, 'ListItem', $ListItem);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ListItem_initialize_5, TMP_ListItem_text$q_6, TMP_ListItem_text_7, TMP_ListItem_text$eq_8, TMP_ListItem_simple$q_9, TMP_ListItem_compound$q_10, TMP_ListItem_fold_first_11, TMP_ListItem_to_s_12;\n\n      def.text = def.subs = def.blocks = nil;\n      \n      Opal.alias(self, \"list\", \"parent\");\n      self.$attr_accessor(\"marker\");\n      \n      Opal.def(self, '$initialize', TMP_ListItem_initialize_5 = function $$initialize(parent, text) {\n        var self = this, $iter = TMP_ListItem_initialize_5.$$p, $yield = $iter || nil;\n\n        if (text == null) {\n          text = nil;\n        }\n        if ($iter) TMP_ListItem_initialize_5.$$p = null;\n        \n        $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_ListItem_initialize_5, false), [parent, \"list_item\"], null);\n        self.text = text;\n        self.level = parent.$level();\n        return (self.subs = $$($nesting, 'NORMAL_SUBS').$dup());\n      }, TMP_ListItem_initialize_5.$$arity = -2);\n      \n      Opal.def(self, '$text?', TMP_ListItem_text$q_6 = function() {\n        var self = this;\n\n        return self.text['$nil_or_empty?']()['$!']()\n      }, TMP_ListItem_text$q_6.$$arity = 0);\n      \n      Opal.def(self, '$text', TMP_ListItem_text_7 = function $$text() {\n        var self = this;\n\n        return self.$apply_subs(self.text, self.subs)\n      }, TMP_ListItem_text_7.$$arity = 0);\n      \n      Opal.def(self, '$text=', TMP_ListItem_text$eq_8 = function(val) {\n        var self = this;\n\n        return (self.text = val)\n      }, TMP_ListItem_text$eq_8.$$arity = 1);\n      \n      Opal.def(self, '$simple?', TMP_ListItem_simple$q_9 = function() {\n        var $a, $b, $c, self = this, blk = nil;\n\n        return ($truthy($a = self.blocks['$empty?']()) ? $a : ($truthy($b = (($c = self.blocks.$size()['$=='](1)) ? $$($nesting, 'List')['$===']((blk = self.blocks['$[]'](0))) : self.blocks.$size()['$=='](1))) ? blk['$outline?']() : $b))\n      }, TMP_ListItem_simple$q_9.$$arity = 0);\n      \n      Opal.def(self, '$compound?', TMP_ListItem_compound$q_10 = function() {\n        var self = this;\n\n        return self['$simple?']()['$!']()\n      }, TMP_ListItem_compound$q_10.$$arity = 0);\n      \n      Opal.def(self, '$fold_first', TMP_ListItem_fold_first_11 = function $$fold_first(continuation_connects_first_block, content_adjacent) {\n        var $a, $b, $c, $d, $e, self = this, first_block = nil, block = nil;\n\n        if (continuation_connects_first_block == null) {\n          continuation_connects_first_block = false;\n        }\n        if (content_adjacent == null) {\n          content_adjacent = false;\n        }\n        \n        if ($truthy(($truthy($a = ($truthy($b = (first_block = self.blocks['$[]'](0))) ? $$($nesting, 'Block')['$==='](first_block) : $b)) ? ($truthy($b = (($c = first_block.$context()['$=='](\"paragraph\")) ? continuation_connects_first_block['$!']() : first_block.$context()['$=='](\"paragraph\"))) ? $b : ($truthy($c = ($truthy($d = ($truthy($e = content_adjacent) ? $e : continuation_connects_first_block['$!']())) ? first_block.$context()['$=='](\"literal\") : $d)) ? first_block['$option?'](\"listparagraph\") : $c)) : $a))) {\n          \n          block = self.$blocks().$shift();\n          if ($truthy(self.text['$nil_or_empty?']())) {\n          } else {\n            block.$lines().$unshift(self.text)\n          };\n          self.text = block.$source();};\n        return nil;\n      }, TMP_ListItem_fold_first_11.$$arity = -1);\n      return (Opal.def(self, '$to_s', TMP_ListItem_to_s_12 = function $$to_s() {\n        var $a, self = this;\n\n        return \"\" + \"#<\" + (self.$class()) + \"@\" + (self.$object_id()) + \" {list_context: \" + (self.$parent().$context().$inspect()) + \", text: \" + (self.text.$inspect()) + \", blocks: \" + (($truthy($a = self.blocks) ? $a : []).$size()) + \"}>\"\n      }, TMP_ListItem_to_s_12.$$arity = 0), nil) && 'to_s';\n    })($nesting[0], $$($nesting, 'AbstractBlock'), $nesting);\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/parser\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2, $hash = Opal.hash, $gvars = Opal.gvars, $range = Opal.range;\n\n  Opal.add_stubs(['$new', '$lambda', '$start_with?', '$match?', '$is_delimited_block?', '$raise', '$parse_document_header', '$[]', '$has_more_lines?', '$next_section', '$<<', '$parse_block_metadata_lines', '$is_next_line_doctitle?', '$attributes', '$key?', '$finalize_header', '$nil_or_empty?', '$title=', '$-', '$sourcemap', '$cursor', '$parse_section_title', '$id=', '$attribute_locked?', '$set_attr', '$delete', '$source_location=', '$header', '$[]=', '$id', '$parse_style_attribute', '$parse_header_metadata', '$==', '$doctype', '$parse_manpage_header', '$=~', '$sub_attributes', '$downcase', '$warn', '$prev_line_info', '$skip_blank_lines', '$is_next_line_section?', '$initialize_section', '$level', '$*', '$read_lines_until', '$match', '$backend', '$context', '$empty?', '$blocks', '$has_header?', '$!', '$!=', '$attr?', '$attr', '$document', '$sectname', '$+', '$to_i', '$>', '$line_info', '$include?', '$size', '$next_block', '$blocks?', '$style', '$context=', '$style=', '$parent=', '$content_model', '$shift', '$unwrap_standalone_preamble', '$dup', '$fetch', '$parse_block_metadata_line', '$extensions', '$block_macros?', '$path', '$lineno', '$read_line', '$===', '$terminator', '$to_s', '$masq', '$to_sym', '$registered_for_block?', '$strict_verbatim_paragraphs', '$unshift_line', '$markdown_syntax', '$lstrip', '$keys', '$chr', '$length', '$end_with?', '$parse_attributes', '$attribute_missing', '$clear', '$register', '$tr', '$basename', '$assign_caption', '$registered_for_block_macro?', '$config', '$update', '$process_method', '$replace', '$peek_line', '$next_list_item', '$callout_ids', '$callouts', '$items', '$next_list', '$next_item_list', '$each', '$catalog_inline_biblio_anchor', '$instance_variable_get', '$marker', '$find', '$next_description_list', '$underline_style_section_titles', '$is_section_title?', '$atx_section_title?', '$generate_id', '$title', '$level=', '$read_paragraph_lines', '$adjust_indentation!', '$set_option', '$map!', '$split', '$pop', '$build_block', '$chop', '$catalog_inline_anchors', '$rekey', '$index', '$slice', '$strip', '$<', '$next_table', '$concat', '$title?', '$lock_in_subs', '$sub?', '$catalog_callouts', '$source', '$remove_sub', '$block_terminates_paragraph', '$to_proc', '$<=', '$nil?', '$lines', '$parse_blocks', '$resolve_list_marker', '$items?', '$parent', '$scan', '$gsub', '$reader', '$marker=', '$read_lines_for_list_item', '$skip_line_comments', '$unshift_lines', '$fold_first', '$text?', '$is_sibling_list_item?', '$delete_at', '$casecmp', '$sectname=', '$special=', '$numbered=', '$special', '$numbered', '$update_attributes', '$peek_lines', '$setext_section_title?', '$abs', '$line_length', '$process_attribute_entries', '$next_line_empty?', '$process_authors', '$apply_header_subs', '$rstrip', '$each_with_index', '$map', '$compact', '$Array', '$squeeze', '$to_a', '$process_attribute_entry', '$skip_comment_lines', '$advance', '$store_attribute', '$sanitize_attribute_name', '$set_attribute', '$save_to', '$delete_attribute', '$resolve_ordered_list_marker', '$ord', '$roman_numeral_to_int', '$parse_colspecs', '$create_columns', '$format', '$starts_with_delimiter?', '$close_open_cell', '$parse_cellspec', '$delimiter', '$match_delimiter', '$buffer_has_unclosed_quotes?', '$pre_match', '$skip_past_delimiter', '$buffer', '$buffer=', '$skip_past_escaped_delimiter', '$keep_cell_open', '$push_cellspec', '$post_match', '$close_cell', '$cell_open?', '$columns', '$assign_column_widths', '$has_header_option=', '$partition_header_footer', '$upto', '$shorthand_property_syntax', '$join', '$each_char', '$call', '$sub!', '$gsub!', '$%', '$begin']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Parser(){};\n      var self = $Parser = $klass($base, $super, 'Parser', $Parser);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Parser_1, TMP_Parser_2, TMP_Parser_3, TMP_Parser_initialize_4, TMP_Parser_parse_5, TMP_Parser_parse_document_header_6, TMP_Parser_parse_manpage_header_7, TMP_Parser_next_section_8, TMP_Parser_next_block_14, TMP_Parser_read_paragraph_lines_15, TMP_Parser_is_delimited_block$q_16, TMP_Parser_build_block_17, TMP_Parser_parse_blocks_18, TMP_Parser_next_item_list_19, TMP_Parser_catalog_callouts_21, TMP_Parser_catalog_inline_anchors_23, TMP_Parser_catalog_inline_biblio_anchor_24, TMP_Parser_next_description_list_25, TMP_Parser_next_list_item_26, TMP_Parser_read_lines_for_list_item_32, TMP_Parser_initialize_section_33, TMP_Parser_is_next_line_section$q_34, TMP_Parser_is_next_line_doctitle$q_35, TMP_Parser_is_section_title$q_36, TMP_Parser_atx_section_title$q_37, TMP_Parser_setext_section_title$q_38, TMP_Parser_parse_section_title_39, TMP_Parser_line_length_40, TMP_Parser_line_length_41, TMP_Parser_parse_header_metadata_46, TMP_Parser_process_authors_52, TMP_Parser_parse_block_metadata_lines_53, TMP_Parser_parse_block_metadata_line_54, TMP_Parser_process_attribute_entries_55, TMP_Parser_process_attribute_entry_56, TMP_Parser_store_attribute_57, TMP_Parser_resolve_list_marker_58, TMP_Parser_resolve_ordered_list_marker_60, TMP_Parser_is_sibling_list_item$q_61, TMP_Parser_next_table_62, TMP_Parser_parse_colspecs_66, TMP_Parser_parse_cellspec_67, TMP_Parser_parse_style_attribute_71, TMP_Parser_adjust_indentation$B_79, TMP_Parser_sanitize_attribute_name_80, TMP_Parser_roman_numeral_to_int_82;\n\n      \n      Opal.const_set($nesting[0], 'BlockMatchData', $$($nesting, 'Struct').$new(\"context\", \"masq\", \"tip\", \"terminator\"));\n      Opal.const_set($nesting[0], 'TabRx', /\\t/);\n      Opal.const_set($nesting[0], 'TabIndentRx', /^\\t+/);\n      Opal.const_set($nesting[0], 'StartOfBlockProc', $send(self, 'lambda', [], (TMP_Parser_1 = function(l){var self = TMP_Parser_1.$$s || this, $a, $b;\nif (l == null) l = nil;\n      return ($truthy($a = ($truthy($b = l['$start_with?'](\"[\")) ? $$($nesting, 'BlockAttributeLineRx')['$match?'](l) : $b)) ? $a : self['$is_delimited_block?'](l))}, TMP_Parser_1.$$s = self, TMP_Parser_1.$$arity = 1, TMP_Parser_1)));\n      Opal.const_set($nesting[0], 'StartOfListProc', $send(self, 'lambda', [], (TMP_Parser_2 = function(l){var self = TMP_Parser_2.$$s || this;\nif (l == null) l = nil;\n      return $$($nesting, 'AnyListRx')['$match?'](l)}, TMP_Parser_2.$$s = self, TMP_Parser_2.$$arity = 1, TMP_Parser_2)));\n      Opal.const_set($nesting[0], 'StartOfBlockOrListProc', $send(self, 'lambda', [], (TMP_Parser_3 = function(l){var self = TMP_Parser_3.$$s || this, $a, $b, $c;\nif (l == null) l = nil;\n      return ($truthy($a = ($truthy($b = self['$is_delimited_block?'](l)) ? $b : ($truthy($c = l['$start_with?'](\"[\")) ? $$($nesting, 'BlockAttributeLineRx')['$match?'](l) : $c))) ? $a : $$($nesting, 'AnyListRx')['$match?'](l))}, TMP_Parser_3.$$s = self, TMP_Parser_3.$$arity = 1, TMP_Parser_3)));\n      Opal.const_set($nesting[0], 'NoOp', nil);\n      Opal.const_set($nesting[0], 'TableCellHorzAlignments', $hash2([\"<\", \">\", \"^\"], {\"<\": \"left\", \">\": \"right\", \"^\": \"center\"}));\n      Opal.const_set($nesting[0], 'TableCellVertAlignments', $hash2([\"<\", \">\", \"^\"], {\"<\": \"top\", \">\": \"bottom\", \"^\": \"middle\"}));\n      Opal.const_set($nesting[0], 'TableCellStyles', $hash2([\"d\", \"s\", \"e\", \"m\", \"h\", \"l\", \"v\", \"a\"], {\"d\": \"none\", \"s\": \"strong\", \"e\": \"emphasis\", \"m\": \"monospaced\", \"h\": \"header\", \"l\": \"literal\", \"v\": \"verse\", \"a\": \"asciidoc\"}));\n      \n      Opal.def(self, '$initialize', TMP_Parser_initialize_4 = function $$initialize() {\n        var self = this;\n\n        return self.$raise(\"Au contraire, mon frere. No parser instances will be running around.\")\n      }, TMP_Parser_initialize_4.$$arity = 0);\n      Opal.defs(self, '$parse', TMP_Parser_parse_5 = function $$parse(reader, document, options) {\n        var $a, $b, $c, self = this, block_attributes = nil, new_section = nil;\n\n        if (options == null) {\n          options = $hash2([], {});\n        }\n        \n        block_attributes = self.$parse_document_header(reader, document);\n        if ($truthy(options['$[]'](\"header_only\"))) {\n        } else {\n          while ($truthy(reader['$has_more_lines?']())) {\n            \n            $c = self.$next_section(reader, document, block_attributes), $b = Opal.to_ary($c), (new_section = ($b[0] == null ? nil : $b[0])), (block_attributes = ($b[1] == null ? nil : $b[1])), $c;\n            if ($truthy(new_section)) {\n              document['$<<'](new_section)};\n          }\n        };\n        return document;\n      }, TMP_Parser_parse_5.$$arity = -3);\n      Opal.defs(self, '$parse_document_header', TMP_Parser_parse_document_header_6 = function $$parse_document_header(reader, document) {\n        var $a, $b, self = this, block_attributes = nil, implicit_doctitle = nil, assigned_doctitle = nil, val = nil, $writer = nil, section_title = nil, source_location = nil, _ = nil, doctitle = nil, atx = nil, separator = nil, style = nil, style_attrs = nil;\n\n        \n        block_attributes = self.$parse_block_metadata_lines(reader, document);\n        if ($truthy(($truthy($a = (implicit_doctitle = self['$is_next_line_doctitle?'](reader, block_attributes, document.$attributes()['$[]'](\"leveloffset\")))) ? block_attributes['$key?'](\"title\") : $a))) {\n          return document.$finalize_header(block_attributes, false)};\n        assigned_doctitle = nil;\n        if ($truthy((val = document.$attributes()['$[]'](\"doctitle\"))['$nil_or_empty?']())) {\n        } else {\n          \n          $writer = [(assigned_doctitle = val)];\n          $send(document, 'title=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];\n        };\n        section_title = nil;\n        if ($truthy(implicit_doctitle)) {\n          \n          if ($truthy(document.$sourcemap())) {\n            source_location = reader.$cursor()};\n          $b = self.$parse_section_title(reader, document), $a = Opal.to_ary($b), document['$id='](($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), (doctitle = ($a[2] == null ? nil : $a[2])), (_ = ($a[3] == null ? nil : $a[3])), (atx = ($a[4] == null ? nil : $a[4])), $b;\n          if ($truthy(assigned_doctitle)) {\n          } else {\n            \n            $writer = [(assigned_doctitle = doctitle)];\n            $send(document, 'title=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];\n          };\n          if ($truthy(($truthy($a = atx) ? $a : document['$attribute_locked?'](\"compat-mode\")))) {\n          } else {\n            document.$set_attr(\"compat-mode\")\n          };\n          if ($truthy((separator = block_attributes.$delete(\"separator\")))) {\n            if ($truthy(document['$attribute_locked?'](\"title-separator\"))) {\n            } else {\n              document.$set_attr(\"title-separator\", separator)\n            }};\n          if ($truthy(source_location)) {\n            \n            $writer = [source_location];\n            $send(document.$header(), 'source_location=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];};\n          \n          $writer = [\"doctitle\", (section_title = doctitle)];\n          $send(document.$attributes(), '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          if ($truthy(document.$id())) {\n            \n            block_attributes.$delete(1);\n            block_attributes.$delete(\"id\");\n          } else {\n            \n            if ($truthy((style = block_attributes.$delete(1)))) {\n              \n              style_attrs = $hash(1, style);\n              self.$parse_style_attribute(style_attrs, reader);\n              if ($truthy(style_attrs['$key?'](\"id\"))) {\n                \n                $writer = [\"id\", style_attrs['$[]'](\"id\")];\n                $send(block_attributes, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];};};\n            \n            $writer = [block_attributes.$delete(\"id\")];\n            $send(document, 'id=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n          };\n          self.$parse_header_metadata(reader, document);};\n        if ($truthy(($truthy($a = (val = document.$attributes()['$[]'](\"doctitle\"))['$nil_or_empty?']()) ? $a : val['$=='](section_title)))) {\n        } else {\n          \n          $writer = [(assigned_doctitle = val)];\n          $send(document, 'title=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];\n        };\n        if ($truthy(assigned_doctitle)) {\n          \n          $writer = [\"doctitle\", assigned_doctitle];\n          $send(document.$attributes(), '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];};\n        if (document.$doctype()['$=='](\"manpage\")) {\n          self.$parse_manpage_header(reader, document)};\n        return document.$finalize_header(block_attributes);\n      }, TMP_Parser_parse_document_header_6.$$arity = 2);\n      Opal.defs(self, '$parse_manpage_header', TMP_Parser_parse_manpage_header_7 = function $$parse_manpage_header(reader, document) {\n        var $a, self = this, $writer = nil, name_section = nil, name_section_buffer = nil, m = nil;\n\n        \n        if ($truthy($$($nesting, 'ManpageTitleVolnumRx')['$=~'](document.$attributes()['$[]'](\"doctitle\")))) {\n          \n          \n          $writer = [\"mantitle\", document.$sub_attributes((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)).$downcase())];\n          $send(document.$attributes(), '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          \n          $writer = [\"manvolnum\", (($a = $gvars['~']) === nil ? nil : $a['$[]'](2))];\n          $send(document.$attributes(), '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n        } else {\n          \n          self.$warn(\"\" + \"asciidoctor: ERROR: \" + (reader.$prev_line_info()) + \": malformed manpage title\");\n          \n          $writer = [\"mantitle\", document.$attributes()['$[]'](\"doctitle\")];\n          $send(document.$attributes(), '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          \n          $writer = [\"manvolnum\", \"1\"];\n          $send(document.$attributes(), '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n        };\n        reader.$skip_blank_lines();\n        if ($truthy(self['$is_next_line_section?'](reader, $hash2([], {})))) {\n          \n          name_section = self.$initialize_section(reader, document, $hash2([], {}));\n          if (name_section.$level()['$=='](1)) {\n            \n            name_section_buffer = $rb_times(reader.$read_lines_until($hash2([\"break_on_blank_lines\"], {\"break_on_blank_lines\": true})), \" \");\n            if ($truthy((m = $$($nesting, 'ManpageNamePurposeRx').$match(name_section_buffer)))) {\n              \n              \n              $writer = [\"manname\", document.$sub_attributes(m['$[]'](1))];\n              $send(document.$attributes(), '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n              \n              $writer = [\"manpurpose\", m['$[]'](2)];\n              $send(document.$attributes(), '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n              if (document.$backend()['$=='](\"manpage\")) {\n                \n                \n                $writer = [\"docname\", document.$attributes()['$[]'](\"manname\")];\n                $send(document.$attributes(), '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];;\n                \n                $writer = [\"outfilesuffix\", \"\" + \".\" + (document.$attributes()['$[]'](\"manvolnum\"))];\n                $send(document.$attributes(), '[]=', Opal.to_a($writer));\n                return $writer[$rb_minus($writer[\"length\"], 1)];;\n              } else {\n                return nil\n              };\n            } else {\n              return self.$warn(\"\" + \"asciidoctor: ERROR: \" + (reader.$prev_line_info()) + \": malformed name section body\")\n            };\n          } else {\n            return self.$warn(\"\" + \"asciidoctor: ERROR: \" + (reader.$prev_line_info()) + \": name section title must be at level 1\")\n          };\n        } else {\n          return self.$warn(\"\" + \"asciidoctor: ERROR: \" + (reader.$prev_line_info()) + \": name section expected\")\n        };\n      }, TMP_Parser_parse_manpage_header_7.$$arity = 2);\n      Opal.defs(self, '$next_section', TMP_Parser_next_section_8 = function $$next_section(reader, parent, attributes) {\n        var $a, $b, $c, self = this, preamble = nil, intro = nil, part = nil, has_header = nil, doctype = nil, document = nil, $writer = nil, section = nil, current_level = nil, expected_next_levels = nil, title = nil, next_level = nil, new_section = nil, block_line_info = nil, new_block = nil, first_block = nil, child_block = nil;\n\n        if (attributes == null) {\n          attributes = $hash2([], {});\n        }\n        \n        preamble = (intro = (part = false));\n        if ($truthy(($truthy($a = (($b = parent.$context()['$=='](\"document\")) ? parent.$blocks()['$empty?']() : parent.$context()['$=='](\"document\"))) ? ($truthy($b = ($truthy($c = (has_header = parent['$has_header?']())) ? $c : attributes.$delete(\"invalid-header\"))) ? $b : self['$is_next_line_section?'](reader, attributes)['$!']()) : $a))) {\n          \n          doctype = (document = parent).$doctype();\n          if ($truthy(($truthy($a = has_header) ? $a : (($b = doctype['$=='](\"book\")) ? attributes['$[]'](1)['$!='](\"abstract\") : doctype['$=='](\"book\"))))) {\n            \n            preamble = (intro = $$($nesting, 'Block').$new(parent, \"preamble\", $hash2([\"content_model\"], {\"content_model\": \"compound\"})));\n            if ($truthy((($a = doctype['$=='](\"book\")) ? parent['$attr?'](\"preface-title\") : doctype['$=='](\"book\")))) {\n              \n              $writer = [parent.$attr(\"preface-title\")];\n              $send(preamble, 'title=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];};\n            parent['$<<'](preamble);};\n          section = parent;\n          current_level = 0;\n          if ($truthy(parent.$attributes()['$key?'](\"fragment\"))) {\n            expected_next_levels = nil\n          } else if (doctype['$=='](\"book\")) {\n            expected_next_levels = [0, 1]\n          } else {\n            expected_next_levels = [1]\n          };\n        } else {\n          \n          doctype = (document = parent.$document()).$doctype();\n          section = self.$initialize_section(reader, parent, attributes);\n          attributes = (function() {if ($truthy((title = attributes['$[]'](\"title\")))) {\n            return $hash2([\"title\"], {\"title\": title})\n          } else {\n            return $hash2([], {})\n          }; return nil; })();\n          part = section.$sectname()['$=='](\"part\");\n          expected_next_levels = [$rb_plus((current_level = section.$level()), 1)];\n        };\n        reader.$skip_blank_lines();\n        while ($truthy(reader['$has_more_lines?']())) {\n          \n          self.$parse_block_metadata_lines(reader, document, attributes);\n          if ($truthy((next_level = self['$is_next_line_section?'](reader, attributes)))) {\n            \n            if ($truthy(document['$attr?'](\"leveloffset\"))) {\n              next_level = $rb_plus(next_level, document.$attr(\"leveloffset\").$to_i())};\n            if ($truthy(($truthy($b = $rb_gt(next_level, current_level)) ? $b : (($c = next_level['$=='](0)) ? section.$context()['$=='](\"document\") : next_level['$=='](0))))) {\n              \n              if ($truthy((($b = next_level['$=='](0)) ? doctype['$!='](\"book\") : next_level['$=='](0)))) {\n                self.$warn(\"\" + \"asciidoctor: ERROR: \" + (reader.$line_info()) + \": only book doctypes can contain level 0 sections\")\n              } else if ($truthy(($truthy($b = expected_next_levels) ? expected_next_levels['$include?'](next_level)['$!']() : $b))) {\n                self.$warn(\"\" + \"asciidoctor: WARNING: \" + (reader.$line_info()) + \": section title out of sequence: expected \" + ((function() {if ($truthy($rb_gt(expected_next_levels.$size(), 1))) {\n                  return \"levels\"\n                } else {\n                  return \"level\"\n                }; return nil; })()) + \" \" + ($rb_times(expected_next_levels, \" or \")) + \", got level \" + (next_level))};\n              $c = self.$next_section(reader, section, attributes), $b = Opal.to_ary($c), (new_section = ($b[0] == null ? nil : $b[0])), (attributes = ($b[1] == null ? nil : $b[1])), $c;\n              section['$<<'](new_section);\n            } else {\n              \n              if ($truthy((($b = next_level['$=='](0)) ? doctype['$!='](\"book\") : next_level['$=='](0)))) {\n                self.$warn(\"\" + \"asciidoctor: ERROR: \" + (reader.$line_info()) + \": only book doctypes can contain level 0 sections\")};\n              break;;\n            };\n          } else {\n            \n            block_line_info = reader.$line_info();\n            if ($truthy((new_block = self.$next_block(reader, ($truthy($b = intro) ? $b : section), attributes, $hash2([\"parse_metadata\"], {\"parse_metadata\": false}))))) {\n              \n              if ($truthy(part)) {\n                if ($truthy(section['$blocks?']()['$!']())) {\n                  if ($truthy(new_block.$style()['$!='](\"partintro\"))) {\n                    if (new_block.$context()['$=='](\"paragraph\")) {\n                      \n                      \n                      $writer = [\"open\"];\n                      $send(new_block, 'context=', Opal.to_a($writer));\n                      $writer[$rb_minus($writer[\"length\"], 1)];;\n                      \n                      $writer = [\"partintro\"];\n                      $send(new_block, 'style=', Opal.to_a($writer));\n                      $writer[$rb_minus($writer[\"length\"], 1)];;\n                    } else {\n                      \n                      intro = $$($nesting, 'Block').$new(section, \"open\", $hash2([\"content_model\"], {\"content_model\": \"compound\"}));\n                      \n                      $writer = [\"partintro\"];\n                      $send(intro, 'style=', Opal.to_a($writer));\n                      $writer[$rb_minus($writer[\"length\"], 1)];;\n                      \n                      $writer = [intro];\n                      $send(new_block, 'parent=', Opal.to_a($writer));\n                      $writer[$rb_minus($writer[\"length\"], 1)];;\n                      section['$<<'](intro);\n                    }}\n                } else if (section.$blocks().$size()['$=='](1)) {\n                  \n                  first_block = section.$blocks()['$[]'](0);\n                  if ($truthy(($truthy($b = intro['$!']()) ? first_block.$content_model()['$=='](\"compound\") : $b))) {\n                    self.$warn(\"\" + \"asciidoctor: ERROR: \" + (block_line_info) + \": illegal block content outside of partintro block\")\n                  } else if ($truthy(first_block.$content_model()['$!='](\"compound\"))) {\n                    \n                    intro = $$($nesting, 'Block').$new(section, \"open\", $hash2([\"content_model\"], {\"content_model\": \"compound\"}));\n                    \n                    $writer = [\"partintro\"];\n                    $send(intro, 'style=', Opal.to_a($writer));\n                    $writer[$rb_minus($writer[\"length\"], 1)];;\n                    section.$blocks().$shift();\n                    if (first_block.$style()['$=='](\"partintro\")) {\n                      \n                      \n                      $writer = [\"paragraph\"];\n                      $send(first_block, 'context=', Opal.to_a($writer));\n                      $writer[$rb_minus($writer[\"length\"], 1)];;\n                      \n                      $writer = [nil];\n                      $send(first_block, 'style=', Opal.to_a($writer));\n                      $writer[$rb_minus($writer[\"length\"], 1)];;};\n                    \n                    $writer = [intro];\n                    $send(first_block, 'parent=', Opal.to_a($writer));\n                    $writer[$rb_minus($writer[\"length\"], 1)];;\n                    intro['$<<'](first_block);\n                    \n                    $writer = [intro];\n                    $send(new_block, 'parent=', Opal.to_a($writer));\n                    $writer[$rb_minus($writer[\"length\"], 1)];;\n                    section['$<<'](intro);};}};\n              ($truthy($b = intro) ? $b : section)['$<<'](new_block);\n              attributes = $hash2([], {});};\n          };\n          if ($truthy($b = reader.$skip_blank_lines())) {\n            $b\n          } else {\n            break;\n          };\n        };\n        if ($truthy(part)) {\n          if ($truthy(($truthy($a = section['$blocks?']()) ? section.$blocks()['$[]'](-1).$context()['$=='](\"section\") : $a))) {\n          } else {\n            self.$warn(\"\" + \"asciidoctor: ERROR: \" + (reader.$line_info()) + \": invalid part, must have at least one section (e.g., chapter, appendix, etc.)\")\n          }\n        } else if ($truthy(preamble)) {\n          if ($truthy(preamble['$blocks?']())) {\n            if ($truthy(($truthy($a = ($truthy($b = $$($nesting, 'Compliance').$unwrap_standalone_preamble()) ? document.$blocks().$size()['$=='](1) : $b)) ? doctype['$!='](\"book\") : $a))) {\n              \n              document.$blocks().$shift();\n              while ($truthy((child_block = preamble.$blocks().$shift()))) {\n                \n                \n                $writer = [document];\n                $send(child_block, 'parent=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];;\n                document['$<<'](child_block);\n              };}\n          } else {\n            document.$blocks().$shift()\n          }};\n        return [(function() {if ($truthy(section['$!='](parent))) {\n          return section\n        } else {\n          return nil\n        }; return nil; })(), attributes.$dup()];\n      }, TMP_Parser_next_section_8.$$arity = -3);\n      Opal.defs(self, '$next_block', TMP_Parser_next_block_14 = function $$next_block(reader, parent, attributes, options) {try {\n\n        var $a, $b, $c, TMP_9, $d, $e, TMP_10, TMP_11, TMP_12, TMP_13, self = this, skipped = nil, text_only = nil, document = nil, extensions = nil, block_extensions = nil, block_macro_extensions = nil, source_location = nil, this_path = nil, this_lineno = nil, this_line = nil, in_list = nil, block = nil, block_context = nil, cloaked_context = nil, terminator = nil, style = nil, delimited_block = nil, $writer = nil, indented = nil, md_syntax = nil, ch0 = nil, layout_break_chars = nil, ll = nil, match = nil, blk_ctx = nil, target = nil, $case = nil, posattrs = nil, scaledwidth = nil, extension = nil, content = nil, default_attrs = nil, expected_index = nil, list_item_lineno = nil, list_item = nil, coids = nil, marker = nil, float_id = nil, float_reftext = nil, float_title = nil, float_level = nil, _ = nil, break_at_list = nil, lines = nil, admonition_name = nil, attribution = nil, citetitle = nil, language = nil, comma_idx = nil, explicit_stem_syntax = nil, default_stem_syntax = nil, block_reader = nil, content_model = nil, pos_attrs = nil, block_id = nil;\n\n        if (attributes == null) {\n          attributes = $hash2([], {});\n        }\n        if (options == null) {\n          options = $hash2([], {});\n        }\n        \n        if ($truthy((skipped = reader.$skip_blank_lines()))) {\n        } else {\n          return nil\n        };\n        if ($truthy(($truthy($a = (text_only = options['$[]'](\"text\"))) ? $rb_gt(skipped, 0) : $a))) {\n          \n          options.$delete(\"text\");\n          text_only = false;};\n        document = parent.$document();\n        if ($truthy(options.$fetch(\"parse_metadata\", true))) {\n          while ($truthy(self.$parse_block_metadata_line(reader, document, attributes, options))) {\n            \n            reader.$shift();\n            ($truthy($b = reader.$skip_blank_lines()) ? $b : Opal.ret(nil));\n          }};\n        if ($truthy((extensions = document.$extensions()))) {\n          $a = [extensions['$blocks?'](), extensions['$block_macros?']()], (block_extensions = $a[0]), (block_macro_extensions = $a[1]), $a};\n        if ($truthy(document.$sourcemap())) {\n          source_location = reader.$cursor()};\n        $a = [reader.$path(), reader.$lineno(), reader.$read_line(), $$($nesting, 'ListItem')['$==='](parent)], (this_path = $a[0]), (this_lineno = $a[1]), (this_line = $a[2]), (in_list = $a[3]), $a;\n        block = (block_context = (cloaked_context = (terminator = nil)));\n        style = (function() {if ($truthy(attributes['$[]'](1))) {\n          \n          return self.$parse_style_attribute(attributes, reader);\n        } else {\n          return nil\n        }; return nil; })();\n        if ($truthy((delimited_block = self['$is_delimited_block?'](this_line, true)))) {\n          \n          block_context = (cloaked_context = delimited_block.$context());\n          terminator = delimited_block.$terminator();\n          if ($truthy(style['$!']())) {\n            style = (($writer = [\"style\", block_context.$to_s()]), $send(attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])\n          } else if ($truthy(style['$!='](block_context.$to_s()))) {\n            if ($truthy(delimited_block.$masq()['$include?'](style))) {\n              block_context = style.$to_sym()\n            } else if ($truthy(($truthy($a = delimited_block.$masq()['$include?'](\"admonition\")) ? $$($nesting, 'ADMONITION_STYLES')['$include?'](style) : $a))) {\n              block_context = \"admonition\"\n            } else if ($truthy(($truthy($a = block_extensions) ? extensions['$registered_for_block?'](style, block_context) : $a))) {\n              block_context = style.$to_sym()\n            } else {\n              \n              self.$warn(\"\" + \"asciidoctor: WARNING: \" + (this_path) + \": line \" + (this_lineno) + \": invalid style for \" + (block_context) + \" block: \" + (style));\n              style = block_context.$to_s();\n            }};};\n        if ($truthy(delimited_block)) {\n        } else {\n          while ($truthy(true)) {\n            \n            if ($truthy(($truthy($b = ($truthy($c = style) ? $$($nesting, 'Compliance').$strict_verbatim_paragraphs() : $c)) ? $$($nesting, 'VERBATIM_STYLES')['$include?'](style) : $b))) {\n              \n              block_context = style.$to_sym();\n              reader.$unshift_line(this_line);\n              break;;};\n            if ($truthy(text_only)) {\n              indented = this_line['$start_with?'](\" \", $$($nesting, 'TAB'))\n            } else {\n              \n              md_syntax = $$($nesting, 'Compliance').$markdown_syntax();\n              if ($truthy(this_line['$start_with?'](\" \"))) {\n                \n                $b = [true, \" \"], (indented = $b[0]), (ch0 = $b[1]), $b;\n                if ($truthy(($truthy($b = ($truthy($c = md_syntax) ? $send(this_line.$lstrip(), 'start_with?', Opal.to_a($$($nesting, 'MARKDOWN_THEMATIC_BREAK_CHARS').$keys())) : $c)) ? $$($nesting, 'MarkdownThematicBreakRx')['$match?'](this_line) : $b))) {\n                  \n                  block = $$($nesting, 'Block').$new(parent, \"thematic_break\", $hash2([\"content_model\"], {\"content_model\": \"empty\"}));\n                  break;;};\n              } else if ($truthy(this_line['$start_with?']($$($nesting, 'TAB')))) {\n                $b = [true, $$($nesting, 'TAB')], (indented = $b[0]), (ch0 = $b[1]), $b\n              } else {\n                \n                $b = [false, this_line.$chr()], (indented = $b[0]), (ch0 = $b[1]), $b;\n                layout_break_chars = (function() {if ($truthy(md_syntax)) {\n                  return $$($nesting, 'HYBRID_LAYOUT_BREAK_CHARS')\n                } else {\n                  return $$($nesting, 'LAYOUT_BREAK_CHARS')\n                }; return nil; })();\n                if ($truthy(($truthy($b = layout_break_chars['$key?'](ch0)) ? (function() {if ($truthy(md_syntax)) {\n                  \n                  return $$($nesting, 'ExtLayoutBreakRx')['$match?'](this_line);\n                } else {\n                  \n                  return (($c = this_line['$==']($rb_times(ch0, (ll = this_line.$length())))) ? $rb_gt(ll, 2) : this_line['$==']($rb_times(ch0, (ll = this_line.$length()))));\n                }; return nil; })() : $b))) {\n                  \n                  block = $$($nesting, 'Block').$new(parent, layout_break_chars['$[]'](ch0), $hash2([\"content_model\"], {\"content_model\": \"empty\"}));\n                  break;;\n                } else if ($truthy(($truthy($b = this_line['$end_with?'](\"]\")) ? this_line['$include?'](\"::\") : $b))) {\n                  if ($truthy(($truthy($b = ($truthy($c = ch0['$=='](\"i\")) ? $c : this_line['$start_with?'](\"video:\", \"audio:\"))) ? (match = $$($nesting, 'BlockMediaMacroRx').$match(this_line)) : $b))) {\n                    \n                    $b = [match['$[]'](1).$to_sym(), match['$[]'](2)], (blk_ctx = $b[0]), (target = $b[1]), $b;\n                    block = $$($nesting, 'Block').$new(parent, blk_ctx, $hash2([\"content_model\"], {\"content_model\": \"empty\"}));\n                    $case = blk_ctx;\n                    if (\"video\"['$===']($case)) {posattrs = [\"poster\", \"width\", \"height\"]}\n                    else if (\"audio\"['$===']($case)) {posattrs = []}\n                    else {posattrs = [\"alt\", \"width\", \"height\"]};\n                    block.$parse_attributes(match['$[]'](3), posattrs, $hash2([\"sub_input\", \"sub_result\", \"into\"], {\"sub_input\": true, \"sub_result\": false, \"into\": attributes}));\n                    if ($truthy(attributes['$key?'](\"style\"))) {\n                      attributes.$delete(\"style\")};\n                    if ($truthy(($truthy($b = target['$include?']($$($nesting, 'ATTR_REF_HEAD'))) ? (target = block.$sub_attributes(target, $hash2([\"attribute_missing\"], {\"attribute_missing\": \"drop-line\"})))['$empty?']() : $b))) {\n                      if (document.$attributes().$fetch(\"attribute-missing\", $$($nesting, 'Compliance').$attribute_missing())['$=='](\"skip\")) {\n                        return $$($nesting, 'Block').$new(parent, \"paragraph\", $hash2([\"content_model\", \"source\"], {\"content_model\": \"simple\", \"source\": [this_line]}))\n                      } else {\n                        \n                        attributes.$clear();\n                        return nil;\n                      }};\n                    if (blk_ctx['$=='](\"image\")) {\n                      \n                      block.$document().$register(\"images\", target);\n                      ($truthy($b = attributes['$[]'](\"alt\")) ? $b : (($writer = [\"alt\", ($truthy($c = style) ? $c : (($writer = [\"default-alt\", $$($nesting, 'Helpers').$basename(target, true).$tr(\"_-\", \" \")]), $send(attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))]), $send(attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n                      if ($truthy((scaledwidth = attributes.$delete(\"scaledwidth\"))['$nil_or_empty?']())) {\n                      } else {\n                        \n                        $writer = [\"scaledwidth\", (function() {if ($truthy($$($nesting, 'TrailingDigitsRx')['$match?'](scaledwidth))) {\n                          return \"\" + (scaledwidth) + \"%\"\n                        } else {\n                          return scaledwidth\n                        }; return nil; })()];\n                        $send(attributes, '[]=', Opal.to_a($writer));\n                        $writer[$rb_minus($writer[\"length\"], 1)];\n                      };\n                      \n                      $writer = [attributes.$delete(\"title\")];\n                      $send(block, 'title=', Opal.to_a($writer));\n                      $writer[$rb_minus($writer[\"length\"], 1)];;\n                      block.$assign_caption(attributes.$delete(\"caption\"), \"figure\");};\n                    \n                    $writer = [\"target\", target];\n                    $send(attributes, '[]=', Opal.to_a($writer));\n                    $writer[$rb_minus($writer[\"length\"], 1)];;\n                    break;;\n                  } else if ($truthy(($truthy($b = (($c = ch0['$=='](\"t\")) ? this_line['$start_with?'](\"toc:\") : ch0['$=='](\"t\"))) ? (match = $$($nesting, 'BlockTocMacroRx').$match(this_line)) : $b))) {\n                    \n                    block = $$($nesting, 'Block').$new(parent, \"toc\", $hash2([\"content_model\"], {\"content_model\": \"empty\"}));\n                    block.$parse_attributes(match['$[]'](1), [], $hash2([\"sub_result\", \"into\"], {\"sub_result\": false, \"into\": attributes}));\n                    break;;\n                  } else if ($truthy(($truthy($b = ($truthy($c = block_macro_extensions) ? (match = $$($nesting, 'CustomBlockMacroRx').$match(this_line)) : $c)) ? (extension = extensions['$registered_for_block_macro?'](match['$[]'](1))) : $b))) {\n                    \n                    target = match['$[]'](2);\n                    content = match['$[]'](3);\n                    if (extension.$config()['$[]'](\"content_model\")['$=='](\"attributes\")) {\n                      if ($truthy(content['$empty?']())) {\n                      } else {\n                        document.$parse_attributes(content, ($truthy($b = extension.$config()['$[]'](\"pos_attrs\")) ? $b : []), $hash2([\"sub_input\", \"sub_result\", \"into\"], {\"sub_input\": true, \"sub_result\": false, \"into\": attributes}))\n                      }\n                    } else {\n                      \n                      $writer = [\"text\", content];\n                      $send(attributes, '[]=', Opal.to_a($writer));\n                      $writer[$rb_minus($writer[\"length\"], 1)];\n                    };\n                    if ($truthy((default_attrs = extension.$config()['$[]'](\"default_attrs\")))) {\n                      $send(attributes, 'update', [default_attrs], (TMP_9 = function(_, old_v){var self = TMP_9.$$s || this;\nif (_ == null) _ = nil;if (old_v == null) old_v = nil;\n                      return old_v}, TMP_9.$$s = self, TMP_9.$$arity = 2, TMP_9))};\n                    if ($truthy((block = extension.$process_method()['$[]'](parent, target, attributes)))) {\n                      \n                      attributes.$replace(block.$attributes());\n                      break;;\n                    } else {\n                      \n                      attributes.$clear();\n                      return nil;\n                    };}};\n              };\n            };\n            if ($truthy(($truthy($b = ($truthy($c = ($truthy($d = indented['$!']()) ? $$($nesting, 'CALLOUT_LIST_HEADS')['$include?']((ch0 = ($truthy($e = ch0) ? $e : this_line.$chr()))) : $d)) ? $$($nesting, 'CalloutListSniffRx')['$match?'](this_line) : $c)) ? (match = $$($nesting, 'CalloutListRx').$match(this_line)) : $b))) {\n              \n              block = $$($nesting, 'List').$new(parent, \"colist\");\n              \n              $writer = [\"style\", \"arabic\"];\n              $send(attributes, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n              reader.$unshift_line(this_line);\n              expected_index = 1;\n              while ($truthy(($truthy($c = match) ? $c : ($truthy($d = reader['$has_more_lines?']()) ? (match = $$($nesting, 'CalloutListRx').$match(reader.$peek_line())) : $d)))) {\n                \n                list_item_lineno = reader.$lineno();\n                if (match['$[]'](1)['$=='](expected_index.$to_s())) {\n                } else {\n                  self.$warn(\"\" + \"asciidoctor: WARNING: \" + (reader.$path()) + \": line \" + (list_item_lineno) + \": callout list item index: expected \" + (expected_index) + \" got \" + (match['$[]'](1)))\n                };\n                if ($truthy((list_item = self.$next_list_item(reader, block, match)))) {\n                  \n                  block['$<<'](list_item);\n                  if ($truthy((coids = document.$callouts().$callout_ids(block.$items().$size()))['$empty?']())) {\n                    self.$warn(\"\" + \"asciidoctor: WARNING: \" + (reader.$path()) + \": line \" + (list_item_lineno) + \": no callouts refer to list item \" + (block.$items().$size()))\n                  } else {\n                    \n                    $writer = [\"coids\", coids];\n                    $send(list_item.$attributes(), '[]=', Opal.to_a($writer));\n                    $writer[$rb_minus($writer[\"length\"], 1)];\n                  };};\n                expected_index = $rb_plus(expected_index, 1);\n                match = nil;\n              };\n              document.$callouts().$next_list();\n              break;;\n            } else if ($truthy($$($nesting, 'UnorderedListRx')['$match?'](this_line))) {\n              \n              reader.$unshift_line(this_line);\n              block = self.$next_item_list(reader, \"ulist\", parent);\n              if (($truthy($b = style) ? $b : ($truthy($c = $$($nesting, 'Section')['$==='](parent)) ? parent.$sectname() : $c))['$=='](\"bibliography\")) {\n                \n                if ($truthy(style)) {\n                } else {\n                  \n                  $writer = [\"style\", \"bibliography\"];\n                  $send(attributes, '[]=', Opal.to_a($writer));\n                  $writer[$rb_minus($writer[\"length\"], 1)];\n                };\n                $send(block.$items(), 'each', [], (TMP_10 = function(item){var self = TMP_10.$$s || this;\nif (item == null) item = nil;\n                return self.$catalog_inline_biblio_anchor(item.$instance_variable_get(\"@text\"), item, document)}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10));};\n              break;;\n            } else if ($truthy((match = $$($nesting, 'OrderedListRx').$match(this_line)))) {\n              \n              reader.$unshift_line(this_line);\n              block = self.$next_item_list(reader, \"olist\", parent);\n              if ($truthy(style)) {\n              } else {\n                \n                marker = block.$items()['$[]'](0).$marker();\n                if ($truthy(marker['$start_with?'](\".\"))) {\n                  \n                  $writer = [\"style\", ($truthy($b = $$($nesting, 'ORDERED_LIST_STYLES')['$[]']($rb_minus(marker.$length(), 1))) ? $b : \"arabic\").$to_s()];\n                  $send(attributes, '[]=', Opal.to_a($writer));\n                  $writer[$rb_minus($writer[\"length\"], 1)];\n                } else {\n                  \n                  $writer = [\"style\", ($truthy($b = $send($$($nesting, 'ORDERED_LIST_STYLES'), 'find', [], (TMP_11 = function(s){var self = TMP_11.$$s || this;\nif (s == null) s = nil;\n                  return $$($nesting, 'OrderedListMarkerRxMap')['$[]'](s)['$match?'](marker)}, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11))) ? $b : \"arabic\").$to_s()];\n                  $send(attributes, '[]=', Opal.to_a($writer));\n                  $writer[$rb_minus($writer[\"length\"], 1)];\n                };\n              };\n              break;;\n            } else if ($truthy((match = $$($nesting, 'DescriptionListRx').$match(this_line)))) {\n              \n              reader.$unshift_line(this_line);\n              block = self.$next_description_list(reader, match, parent);\n              break;;\n            } else if ($truthy(($truthy($b = ($truthy($c = style['$=='](\"float\")) ? $c : style['$=='](\"discrete\"))) ? (function() {if ($truthy($$($nesting, 'Compliance').$underline_style_section_titles())) {\n              \n              return self['$is_section_title?'](this_line, reader.$peek_line());\n            } else {\n              return ($truthy($c = indented['$!']()) ? self['$atx_section_title?'](this_line) : $c)\n            }; return nil; })() : $b))) {\n              \n              reader.$unshift_line(this_line);\n              $c = self.$parse_section_title(reader, document), $b = Opal.to_ary($c), (float_id = ($b[0] == null ? nil : $b[0])), (float_reftext = ($b[1] == null ? nil : $b[1])), (float_title = ($b[2] == null ? nil : $b[2])), (float_level = ($b[3] == null ? nil : $b[3])), (_ = ($b[4] == null ? nil : $b[4])), $c;\n              if ($truthy(float_reftext)) {\n                \n                $writer = [\"reftext\", float_reftext];\n                $send(attributes, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];};\n              block = $$($nesting, 'Block').$new(parent, \"floating_title\", $hash2([\"content_model\"], {\"content_model\": \"empty\"}));\n              \n              $writer = [float_title];\n              $send(block, 'title=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n              attributes.$delete(\"title\");\n              \n              $writer = [($truthy($b = ($truthy($c = float_id) ? $c : attributes['$[]'](\"id\"))) ? $b : (function() {if ($truthy(document.$attributes()['$key?'](\"sectids\"))) {\n                \n                return $$($nesting, 'Section').$generate_id(block.$title(), document);\n              } else {\n                return nil\n              }; return nil; })())];\n              $send(block, 'id=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n              \n              $writer = [float_level];\n              $send(block, 'level=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n              break;;\n            } else if ($truthy(($truthy($b = style) ? style['$!='](\"normal\") : $b))) {\n              if ($truthy($$($nesting, 'PARAGRAPH_STYLES')['$include?'](style))) {\n                \n                block_context = style.$to_sym();\n                cloaked_context = \"paragraph\";\n                reader.$unshift_line(this_line);\n                break;;\n              } else if ($truthy($$($nesting, 'ADMONITION_STYLES')['$include?'](style))) {\n                \n                block_context = \"admonition\";\n                cloaked_context = \"paragraph\";\n                reader.$unshift_line(this_line);\n                break;;\n              } else if ($truthy(($truthy($b = block_extensions) ? extensions['$registered_for_block?'](style, \"paragraph\") : $b))) {\n                \n                block_context = style.$to_sym();\n                cloaked_context = \"paragraph\";\n                reader.$unshift_line(this_line);\n                break;;\n              } else {\n                \n                self.$warn(\"\" + \"asciidoctor: WARNING: \" + (this_path) + \": line \" + (this_lineno) + \": invalid style for paragraph: \" + (style));\n                style = nil;\n              }};\n            break_at_list = (($b = skipped['$=='](0)) ? in_list : skipped['$=='](0));\n            reader.$unshift_line(this_line);\n            if ($truthy(($truthy($b = indented) ? style['$!']() : $b))) {\n              \n              lines = self.$read_paragraph_lines(reader, break_at_list, $hash2([\"skip_line_comments\"], {\"skip_line_comments\": text_only}));\n              self['$adjust_indentation!'](lines);\n              block = $$($nesting, 'Block').$new(parent, \"literal\", $hash2([\"content_model\", \"source\", \"attributes\"], {\"content_model\": \"verbatim\", \"source\": lines, \"attributes\": attributes}));\n              if ($truthy(in_list)) {\n                block.$set_option(\"listparagraph\")};\n            } else {\n              \n              lines = self.$read_paragraph_lines(reader, break_at_list, $hash2([\"skip_line_comments\"], {\"skip_line_comments\": true}));\n              if ($truthy(text_only)) {\n                \n                if ($truthy(($truthy($b = indented) ? style['$=='](\"normal\") : $b))) {\n                  self['$adjust_indentation!'](lines)};\n                block = $$($nesting, 'Block').$new(parent, \"paragraph\", $hash2([\"content_model\", \"source\", \"attributes\"], {\"content_model\": \"simple\", \"source\": lines, \"attributes\": attributes}));\n              } else if ($truthy(($truthy($b = ($truthy($c = $$($nesting, 'ADMONITION_STYLE_HEADS')['$include?'](ch0)) ? this_line['$include?'](\":\") : $c)) ? $$($nesting, 'AdmonitionParagraphRx')['$=~'](this_line) : $b))) {\n                \n                \n                $writer = [0, (($b = $gvars['~']) === nil ? nil : $b.$post_match())];\n                $send(lines, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];;\n                \n                $writer = [\"name\", (admonition_name = (($writer = [\"style\", (($b = $gvars['~']) === nil ? nil : $b['$[]'](1))]), $send(attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]).$downcase())];\n                $send(attributes, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];;\n                \n                $writer = [\"textlabel\", ($truthy($b = attributes.$delete(\"caption\")) ? $b : document.$attributes()['$[]'](\"\" + (admonition_name) + \"-caption\"))];\n                $send(attributes, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];;\n                block = $$($nesting, 'Block').$new(parent, \"admonition\", $hash2([\"content_model\", \"source\", \"attributes\"], {\"content_model\": \"simple\", \"source\": lines, \"attributes\": attributes}));\n              } else if ($truthy(($truthy($b = ($truthy($c = md_syntax) ? ch0['$=='](\">\") : $c)) ? this_line['$start_with?'](\"> \") : $b))) {\n                \n                $send(lines, 'map!', [], (TMP_12 = function(line){var self = TMP_12.$$s || this;\nif (line == null) line = nil;\n                if (line['$=='](\">\")) {\n                    return line['$[]']($range(1, -1, false))\n                  } else {\n                    \n                    if ($truthy(line['$start_with?'](\"> \"))) {\n                      return line['$[]']($range(2, -1, false))\n                    } else {\n                      return line\n                    };\n                  }}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12));\n                if ($truthy(lines['$[]'](-1)['$start_with?'](\"-- \"))) {\n                  \n                  $c = lines.$pop()['$[]']($range(3, -1, false)).$split(\", \", 2), $b = Opal.to_ary($c), (attribution = ($b[0] == null ? nil : $b[0])), (citetitle = ($b[1] == null ? nil : $b[1])), $c;\n                  if ($truthy(attribution)) {\n                    \n                    $writer = [\"attribution\", attribution];\n                    $send(attributes, '[]=', Opal.to_a($writer));\n                    $writer[$rb_minus($writer[\"length\"], 1)];};\n                  if ($truthy(citetitle)) {\n                    \n                    $writer = [\"citetitle\", citetitle];\n                    $send(attributes, '[]=', Opal.to_a($writer));\n                    $writer[$rb_minus($writer[\"length\"], 1)];};\n                  while ($truthy(lines['$[]'](-1)['$empty?']())) {\n                    lines.$pop()\n                  };};\n                \n                $writer = [\"style\", \"quote\"];\n                $send(attributes, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];;\n                block = self.$build_block(\"quote\", \"compound\", false, parent, $$($nesting, 'Reader').$new(lines), attributes);\n              } else if ($truthy(($truthy($b = ($truthy($c = (($d = ch0['$=='](\"\\\"\")) ? $rb_gt(lines.$size(), 1) : ch0['$=='](\"\\\"\"))) ? lines['$[]'](-1)['$start_with?'](\"-- \") : $c)) ? lines['$[]'](-2)['$end_with?'](\"\\\"\") : $b))) {\n                \n                \n                $writer = [0, this_line['$[]']($range(1, -1, false))];\n                $send(lines, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];;\n                $c = lines.$pop()['$[]']($range(3, -1, false)).$split(\", \", 2), $b = Opal.to_ary($c), (attribution = ($b[0] == null ? nil : $b[0])), (citetitle = ($b[1] == null ? nil : $b[1])), $c;\n                if ($truthy(attribution)) {\n                  \n                  $writer = [\"attribution\", attribution];\n                  $send(attributes, '[]=', Opal.to_a($writer));\n                  $writer[$rb_minus($writer[\"length\"], 1)];};\n                if ($truthy(citetitle)) {\n                  \n                  $writer = [\"citetitle\", citetitle];\n                  $send(attributes, '[]=', Opal.to_a($writer));\n                  $writer[$rb_minus($writer[\"length\"], 1)];};\n                while ($truthy(lines['$[]'](-1)['$empty?']())) {\n                  lines.$pop()\n                };\n                \n                $writer = [-1, lines['$[]'](-1).$chop()];\n                $send(lines, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];;\n                \n                $writer = [\"style\", \"quote\"];\n                $send(attributes, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];;\n                block = $$($nesting, 'Block').$new(parent, \"quote\", $hash2([\"content_model\", \"source\", \"attributes\"], {\"content_model\": \"simple\", \"source\": lines, \"attributes\": attributes}));\n              } else {\n                \n                if ($truthy(($truthy($b = indented) ? style['$=='](\"normal\") : $b))) {\n                  self['$adjust_indentation!'](lines)};\n                block = $$($nesting, 'Block').$new(parent, \"paragraph\", $hash2([\"content_model\", \"source\", \"attributes\"], {\"content_model\": \"simple\", \"source\": lines, \"attributes\": attributes}));\n              };\n              self.$catalog_inline_anchors($rb_times(lines, $$($nesting, 'LF')), block, document);\n            };\n            break;;\n          }\n        };\n        if ($truthy(block)) {\n        } else {\n          \n          if ($truthy(($truthy($a = block_context['$=='](\"abstract\")) ? $a : block_context['$=='](\"partintro\")))) {\n            block_context = \"open\"};\n          $case = block_context;\n          if (\"admonition\"['$===']($case)) {\n          \n          $writer = [\"name\", (admonition_name = style.$downcase())];\n          $send(attributes, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          \n          $writer = [\"textlabel\", ($truthy($a = attributes.$delete(\"caption\")) ? $a : document.$attributes()['$[]'](\"\" + (admonition_name) + \"-caption\"))];\n          $send(attributes, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          block = self.$build_block(block_context, \"compound\", terminator, parent, reader, attributes);}\n          else if (\"comment\"['$===']($case)) {\n          self.$build_block(block_context, \"skip\", terminator, parent, reader, attributes);\n          attributes.$clear();\n          return nil;}\n          else if (\"example\"['$===']($case)) {block = self.$build_block(block_context, \"compound\", terminator, parent, reader, attributes)}\n          else if (\"listing\"['$===']($case) || \"literal\"['$===']($case)) {block = self.$build_block(block_context, \"verbatim\", terminator, parent, reader, attributes)}\n          else if (\"source\"['$===']($case)) {\n          $$($nesting, 'AttributeList').$rekey(attributes, [nil, \"language\", \"linenums\"]);\n          if ($truthy(attributes['$key?'](\"language\"))) {\n          } else if ($truthy(document.$attributes()['$key?'](\"source-language\"))) {\n            \n            $writer = [\"language\", ($truthy($a = document.$attributes()['$[]'](\"source-language\")) ? $a : \"text\")];\n            $send(attributes, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];};\n          if ($truthy(attributes['$key?'](\"linenums\"))) {\n          } else if ($truthy(($truthy($a = attributes['$key?'](\"linenums-option\")) ? $a : document.$attributes()['$key?'](\"source-linenums-option\")))) {\n            \n            $writer = [\"linenums\", \"\"];\n            $send(attributes, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];};\n          if ($truthy(attributes['$key?'](\"indent\"))) {\n          } else if ($truthy(document.$attributes()['$key?'](\"source-indent\"))) {\n            \n            $writer = [\"indent\", document.$attributes()['$[]'](\"source-indent\")];\n            $send(attributes, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];};\n          block = self.$build_block(\"listing\", \"verbatim\", terminator, parent, reader, attributes);}\n          else if (\"fenced_code\"['$===']($case)) {\n          \n          $writer = [\"style\", \"source\"];\n          $send(attributes, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          if ((ll = this_line.$length())['$=='](3)) {\n            language = nil\n          } else if ($truthy((comma_idx = (language = this_line.$slice(3, ll)).$index(\",\")))) {\n            if ($truthy($rb_gt(comma_idx, 0))) {\n              \n              language = language.$slice(0, comma_idx).$strip();\n              if ($truthy($rb_lt(comma_idx, $rb_minus(ll, 4)))) {\n                \n                $writer = [\"linenums\", \"\"];\n                $send(attributes, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];};\n            } else {\n              \n              language = nil;\n              if ($truthy($rb_gt(ll, 4))) {\n                \n                $writer = [\"linenums\", \"\"];\n                $send(attributes, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];};\n            }\n          } else {\n            language = language.$lstrip()\n          };\n          if ($truthy(language['$nil_or_empty?']())) {\n            if ($truthy(document.$attributes()['$key?'](\"source-language\"))) {\n              \n              $writer = [\"language\", ($truthy($a = document.$attributes()['$[]'](\"source-language\")) ? $a : \"text\")];\n              $send(attributes, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];}\n          } else {\n            \n            $writer = [\"language\", language];\n            $send(attributes, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];\n          };\n          if ($truthy(attributes['$key?'](\"linenums\"))) {\n          } else if ($truthy(($truthy($a = attributes['$key?'](\"linenums-option\")) ? $a : document.$attributes()['$key?'](\"source-linenums-option\")))) {\n            \n            $writer = [\"linenums\", \"\"];\n            $send(attributes, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];};\n          if ($truthy(attributes['$key?'](\"indent\"))) {\n          } else if ($truthy(document.$attributes()['$key?'](\"source-indent\"))) {\n            \n            $writer = [\"indent\", document.$attributes()['$[]'](\"source-indent\")];\n            $send(attributes, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];};\n          terminator = terminator.$slice(0, 3);\n          block = self.$build_block(\"listing\", \"verbatim\", terminator, parent, reader, attributes);}\n          else if (\"pass\"['$===']($case)) {block = self.$build_block(block_context, \"raw\", terminator, parent, reader, attributes)}\n          else if (\"stem\"['$===']($case) || \"latexmath\"['$===']($case) || \"asciimath\"['$===']($case)) {\n          if (block_context['$=='](\"stem\")) {\n            \n            $writer = [\"style\", (function() {if ($truthy((explicit_stem_syntax = attributes['$[]'](2)))) {\n              if ($truthy(explicit_stem_syntax['$include?'](\"tex\"))) {\n                return \"latexmath\"\n              } else {\n                return \"asciimath\"\n              }\n            } else if ($truthy((default_stem_syntax = document.$attributes()['$[]'](\"stem\"))['$nil_or_empty?']())) {\n              return \"asciimath\"\n            } else {\n              return default_stem_syntax\n            }; return nil; })()];\n            $send(attributes, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];};\n          block = self.$build_block(\"stem\", \"raw\", terminator, parent, reader, attributes);}\n          else if (\"open\"['$===']($case) || \"sidebar\"['$===']($case)) {block = self.$build_block(block_context, \"compound\", terminator, parent, reader, attributes)}\n          else if (\"table\"['$===']($case)) {\n          block_reader = $$($nesting, 'Reader').$new(reader.$read_lines_until($hash2([\"terminator\", \"skip_line_comments\"], {\"terminator\": terminator, \"skip_line_comments\": true})), reader.$cursor());\n          if ($truthy(terminator['$start_with?'](\"|\", \"!\"))) {\n          } else {\n            ($truthy($a = attributes['$[]'](\"format\")) ? $a : (($writer = [\"format\", (function() {if ($truthy(terminator['$start_with?'](\",\"))) {\n              return \"csv\"\n            } else {\n              return \"dsv\"\n            }; return nil; })()]), $send(attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))\n          };\n          block = self.$next_table(block_reader, parent, attributes);}\n          else if (\"quote\"['$===']($case) || \"verse\"['$===']($case)) {\n          $$($nesting, 'AttributeList').$rekey(attributes, [nil, \"attribution\", \"citetitle\"]);\n          block = self.$build_block(block_context, (function() {if (block_context['$=='](\"verse\")) {\n            return \"verbatim\"\n          } else {\n            return \"compound\"\n          }; return nil; })(), terminator, parent, reader, attributes);}\n          else {if ($truthy(($truthy($a = block_extensions) ? (extension = extensions['$registered_for_block?'](block_context, cloaked_context)) : $a))) {\n            \n            if ($truthy((content_model = extension.$config()['$[]'](\"content_model\"))['$!='](\"skip\"))) {\n              \n              if ($truthy((pos_attrs = ($truthy($a = extension.$config()['$[]'](\"pos_attrs\")) ? $a : []))['$empty?']()['$!']())) {\n                $$($nesting, 'AttributeList').$rekey(attributes, [nil].$concat(pos_attrs))};\n              if ($truthy((default_attrs = extension.$config()['$[]'](\"default_attrs\")))) {\n                $send(default_attrs, 'each', [], (TMP_13 = function(k, v){var self = TMP_13.$$s || this, $f;\nif (k == null) k = nil;if (v == null) v = nil;\n                return ($truthy($f = attributes['$[]'](k)) ? $f : (($writer = [k, v]), $send(attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))}, TMP_13.$$s = self, TMP_13.$$arity = 2, TMP_13))};\n              \n              $writer = [\"cloaked-context\", cloaked_context];\n              $send(attributes, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;};\n            block = self.$build_block(block_context, content_model, terminator, parent, reader, attributes, $hash2([\"extension\"], {\"extension\": extension}));\n            if ($truthy(block)) {\n            } else {\n              \n              attributes.$clear();\n              return nil;\n            };\n          } else {\n            self.$raise(\"\" + \"Unsupported block type \" + (block_context) + \" at \" + (reader.$line_info()))\n          }};\n        };\n        if ($truthy(source_location)) {\n          \n          $writer = [source_location];\n          $send(block, 'source_location=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];};\n        if ($truthy(attributes['$key?'](\"title\"))) {\n          \n          $writer = [attributes.$delete(\"title\")];\n          $send(block, 'title=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];};\n        \n        $writer = [attributes['$[]'](\"style\")];\n        $send(block, 'style=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        if ($truthy((block_id = ($truthy($a = block.$id()) ? $a : (($writer = [attributes['$[]'](\"id\")]), $send(block, 'id=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))))) {\n          if ($truthy(document.$register(\"refs\", [block_id, block, ($truthy($a = attributes['$[]'](\"reftext\")) ? $a : (function() {if ($truthy(block['$title?']())) {\n            return block.$title()\n          } else {\n            return nil\n          }; return nil; })())]))) {\n          } else {\n            self.$warn(\"\" + \"asciidoctor: WARNING: \" + (this_path) + \": line \" + (this_lineno) + \": id assigned to block already in use: \" + (block_id))\n          }};\n        if ($truthy(attributes['$empty?']())) {\n        } else {\n          block.$attributes().$update(attributes)\n        };\n        block.$lock_in_subs();\n        if ($truthy(block['$sub?'](\"callouts\"))) {\n          if ($truthy(self.$catalog_callouts(block.$source(), document))) {\n          } else {\n            block.$remove_sub(\"callouts\")\n          }};\n        return block;\n        } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n      }, TMP_Parser_next_block_14.$$arity = -3);\n      Opal.defs(self, '$read_paragraph_lines', TMP_Parser_read_paragraph_lines_15 = function $$read_paragraph_lines(reader, break_at_list, opts) {\n        var self = this, $writer = nil, break_condition = nil;\n\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        \n        \n        $writer = [\"break_on_blank_lines\", true];\n        $send(opts, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"break_on_list_continuation\", true];\n        $send(opts, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        \n        $writer = [\"preserve_last_line\", true];\n        $send(opts, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        break_condition = (function() {if ($truthy(break_at_list)) {\n          \n          if ($truthy($$($nesting, 'Compliance').$block_terminates_paragraph())) {\n            return $$($nesting, 'StartOfBlockOrListProc')\n          } else {\n            return $$($nesting, 'StartOfListProc')\n          };\n        } else {\n          \n          if ($truthy($$($nesting, 'Compliance').$block_terminates_paragraph())) {\n            return $$($nesting, 'StartOfBlockProc')\n          } else {\n            return $$($nesting, 'NoOp')\n          };\n        }; return nil; })();\n        return $send(reader, 'read_lines_until', [opts], break_condition.$to_proc());\n      }, TMP_Parser_read_paragraph_lines_15.$$arity = -3);\n      Opal.defs(self, '$is_delimited_block?', TMP_Parser_is_delimited_block$q_16 = function(line, return_match_data) {\n        var $a, $b, self = this, line_len = nil, tip = nil, tl = nil, fenced_code = nil, tip_3 = nil, context = nil, masq = nil;\n\n        if (return_match_data == null) {\n          return_match_data = false;\n        }\n        \n        if ($truthy(($truthy($a = $rb_gt((line_len = line.$length()), 1)) ? $$($nesting, 'DELIMITED_BLOCK_HEADS')['$include?'](line.$slice(0, 2)) : $a))) {\n        } else {\n          return nil\n        };\n        if (line_len['$=='](2)) {\n          \n          tip = line;\n          tl = 2;\n        } else {\n          \n          if ($truthy($rb_le(line_len, 4))) {\n            \n            tip = line;\n            tl = line_len;\n          } else {\n            \n            tip = line.$slice(0, 4);\n            tl = 4;\n          };\n          fenced_code = false;\n          if ($truthy($$($nesting, 'Compliance').$markdown_syntax())) {\n            \n            tip_3 = (function() {if (tl['$=='](4)) {\n              return tip.$chop()\n            } else {\n              return tip\n            }; return nil; })();\n            if (tip_3['$=='](\"```\")) {\n              \n              if ($truthy((($a = tl['$=='](4)) ? tip['$end_with?'](\"`\") : tl['$=='](4)))) {\n                return nil};\n              tip = tip_3;\n              tl = 3;\n              fenced_code = true;};};\n          if ($truthy((($a = tl['$=='](3)) ? fenced_code['$!']() : tl['$=='](3)))) {\n            return nil};\n        };\n        if ($truthy($$($nesting, 'DELIMITED_BLOCKS')['$key?'](tip))) {\n          if ($truthy(($truthy($a = $rb_lt(tl, 4)) ? $a : tl['$=='](line_len)))) {\n            if ($truthy(return_match_data)) {\n              \n              $b = $$($nesting, 'DELIMITED_BLOCKS')['$[]'](tip), $a = Opal.to_ary($b), (context = ($a[0] == null ? nil : $a[0])), (masq = ($a[1] == null ? nil : $a[1])), $b;\n              return $$($nesting, 'BlockMatchData').$new(context, masq, tip, tip);\n            } else {\n              return true\n            }\n          } else if (((\"\" + (tip)) + ($rb_times(tip['$[]']($range(-1, -1, false)), $rb_minus(line_len, tl))))['$=='](line)) {\n            if ($truthy(return_match_data)) {\n              \n              $b = $$($nesting, 'DELIMITED_BLOCKS')['$[]'](tip), $a = Opal.to_ary($b), (context = ($a[0] == null ? nil : $a[0])), (masq = ($a[1] == null ? nil : $a[1])), $b;\n              return $$($nesting, 'BlockMatchData').$new(context, masq, tip, line);\n            } else {\n              return true\n            }\n          } else {\n            return nil\n          }\n        } else {\n          return nil\n        };\n      }, TMP_Parser_is_delimited_block$q_16.$$arity = -2);\n      Opal.defs(self, '$build_block', TMP_Parser_build_block_17 = function $$build_block(block_context, content_model, terminator, parent, reader, attributes, options) {\n        var $a, $b, self = this, skip_processing = nil, parse_as_content_model = nil, lines = nil, block_reader = nil, indent = nil, tab_size = nil, extension = nil, block = nil, $writer = nil;\n\n        if (options == null) {\n          options = $hash2([], {});\n        }\n        \n        if (content_model['$=='](\"skip\")) {\n          $a = [true, \"simple\"], (skip_processing = $a[0]), (parse_as_content_model = $a[1]), $a\n        } else if (content_model['$=='](\"raw\")) {\n          $a = [false, \"simple\"], (skip_processing = $a[0]), (parse_as_content_model = $a[1]), $a\n        } else {\n          $a = [false, content_model], (skip_processing = $a[0]), (parse_as_content_model = $a[1]), $a\n        };\n        if ($truthy(terminator['$nil?']())) {\n          \n          if (parse_as_content_model['$=='](\"verbatim\")) {\n            lines = reader.$read_lines_until($hash2([\"break_on_blank_lines\", \"break_on_list_continuation\"], {\"break_on_blank_lines\": true, \"break_on_list_continuation\": true}))\n          } else {\n            \n            if (content_model['$=='](\"compound\")) {\n              content_model = \"simple\"};\n            lines = self.$read_paragraph_lines(reader, false, $hash2([\"skip_line_comments\", \"skip_processing\"], {\"skip_line_comments\": true, \"skip_processing\": skip_processing}));\n          };\n          block_reader = nil;\n        } else if ($truthy(parse_as_content_model['$!='](\"compound\"))) {\n          \n          lines = reader.$read_lines_until($hash2([\"terminator\", \"skip_processing\"], {\"terminator\": terminator, \"skip_processing\": skip_processing}));\n          block_reader = nil;\n        } else if (terminator['$=='](false)) {\n          \n          lines = nil;\n          block_reader = reader;\n        } else {\n          \n          lines = nil;\n          block_reader = $$($nesting, 'Reader').$new(reader.$read_lines_until($hash2([\"terminator\", \"skip_processing\"], {\"terminator\": terminator, \"skip_processing\": skip_processing})), reader.$cursor());\n        };\n        if (content_model['$=='](\"verbatim\")) {\n          if ($truthy((indent = attributes['$[]'](\"indent\")))) {\n            self['$adjust_indentation!'](lines, indent, ($truthy($a = attributes['$[]'](\"tabsize\")) ? $a : parent.$document().$attributes()['$[]'](\"tabsize\")))\n          } else if ($truthy($rb_gt((tab_size = ($truthy($a = attributes['$[]'](\"tabsize\")) ? $a : parent.$document().$attributes()['$[]'](\"tabsize\")).$to_i()), 0))) {\n            self['$adjust_indentation!'](lines, nil, tab_size)}\n        } else if (content_model['$=='](\"skip\")) {\n          return nil};\n        if ($truthy((extension = options['$[]'](\"extension\")))) {\n          \n          attributes.$delete(\"style\");\n          if ($truthy((block = extension.$process_method()['$[]'](parent, ($truthy($a = block_reader) ? $a : $$($nesting, 'Reader').$new(lines)), attributes.$dup())))) {\n            \n            attributes.$replace(block.$attributes());\n            if ($truthy((($a = block.$content_model()['$=='](\"compound\")) ? (lines = block.$lines())['$nil_or_empty?']()['$!']() : block.$content_model()['$=='](\"compound\")))) {\n              \n              content_model = \"compound\";\n              block_reader = $$($nesting, 'Reader').$new(lines);};\n          } else {\n            return nil\n          };\n        } else {\n          block = $$($nesting, 'Block').$new(parent, block_context, $hash2([\"content_model\", \"source\", \"attributes\"], {\"content_model\": content_model, \"source\": lines, \"attributes\": attributes}))\n        };\n        if ($truthy(($truthy($a = ($truthy($b = attributes['$key?'](\"title\")) ? block.$context()['$!='](\"admonition\") : $b)) ? parent.$document().$attributes()['$key?'](\"\" + (block.$context()) + \"-caption\") : $a))) {\n          \n          \n          $writer = [attributes.$delete(\"title\")];\n          $send(block, 'title=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          block.$assign_caption(attributes.$delete(\"caption\"));};\n        if (content_model['$=='](\"compound\")) {\n          self.$parse_blocks(block_reader, block)};\n        return block;\n      }, TMP_Parser_build_block_17.$$arity = -7);\n      Opal.defs(self, '$parse_blocks', TMP_Parser_parse_blocks_18 = function $$parse_blocks(reader, parent) {\n        var $a, $b, $c, self = this, block = nil;\n\n        while ($truthy(($truthy($b = ($truthy($c = (block = self.$next_block(reader, parent))) ? parent['$<<'](block) : $c)) ? $b : reader['$has_more_lines?']()))) {\n          \n        }\n      }, TMP_Parser_parse_blocks_18.$$arity = 2);\n      Opal.defs(self, '$next_item_list', TMP_Parser_next_item_list_19 = function $$next_item_list(reader, list_type, parent) {\n        var $a, $b, self = this, list_block = nil, $writer = nil, match = nil, marker = nil, this_item_level = nil, ancestor = nil, list_item = nil;\n\n        \n        list_block = $$($nesting, 'List').$new(parent, list_type);\n        if (parent.$context()['$=='](list_type)) {\n          \n          $writer = [$rb_plus(parent.$level(), 1)];\n          $send(list_block, 'level=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];\n        } else {\n          \n          $writer = [1];\n          $send(list_block, 'level=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];\n        };\n        while ($truthy(($truthy($b = reader['$has_more_lines?']()) ? (match = $$($nesting, 'ListRxMap')['$[]'](list_type).$match(reader.$peek_line())) : $b))) {\n          \n          marker = self.$resolve_list_marker(list_type, match['$[]'](1));\n          if ($truthy(($truthy($b = list_block['$items?']()) ? marker['$!='](list_block.$items()['$[]'](0).$marker()) : $b))) {\n            \n            this_item_level = $rb_plus(list_block.$level(), 1);\n            ancestor = parent;\n            while (ancestor.$context()['$=='](list_type)) {\n              \n              if (marker['$=='](ancestor.$items()['$[]'](0).$marker())) {\n                \n                this_item_level = ancestor.$level();\n                break;;};\n              ancestor = ancestor.$parent();\n            };\n          } else {\n            this_item_level = list_block.$level()\n          };\n          if ($truthy(($truthy($b = list_block['$items?']()['$!']()) ? $b : this_item_level['$=='](list_block.$level())))) {\n            list_item = self.$next_list_item(reader, list_block, match)\n          } else if ($truthy($rb_lt(this_item_level, list_block.$level()))) {\n            break;\n          } else if ($truthy($rb_gt(this_item_level, list_block.$level()))) {\n            list_block.$items()['$[]'](-1)['$<<'](self.$next_block(reader, list_block))};\n          if ($truthy(list_item)) {\n            list_block['$<<'](list_item)};\n          list_item = nil;\n          if ($truthy($b = reader.$skip_blank_lines())) {\n            $b\n          } else {\n            break;\n          };\n        };\n        return list_block;\n      }, TMP_Parser_next_item_list_19.$$arity = 3);\n      Opal.defs(self, '$catalog_callouts', TMP_Parser_catalog_callouts_21 = function $$catalog_callouts(text, document) {\n        var TMP_20, self = this, found = nil;\n\n        \n        found = false;\n        if ($truthy(text['$include?'](\"<\"))) {\n          $send(text, 'scan', [$$($nesting, 'CalloutScanRx')], (TMP_20 = function(){var self = TMP_20.$$s || this, $a, $b, captured = nil, num = nil;\n\n          \n            $a = [(($b = $gvars['~']) === nil ? nil : $b['$[]'](0)), (($b = $gvars['~']) === nil ? nil : $b['$[]'](2))], (captured = $a[0]), (num = $a[1]), $a;\n            if ($truthy(captured['$start_with?'](\"\\\\\"))) {\n            } else {\n              document.$callouts().$register(num)\n            };\n            return (found = true);}, TMP_20.$$s = self, TMP_20.$$arity = 0, TMP_20))};\n        return found;\n      }, TMP_Parser_catalog_callouts_21.$$arity = 2);\n      Opal.defs(self, '$catalog_inline_anchors', TMP_Parser_catalog_inline_anchors_23 = function $$catalog_inline_anchors(text, block, document) {\n        var $a, TMP_22, self = this;\n\n        \n        if ($truthy(($truthy($a = text['$include?'](\"[[\")) ? $a : text['$include?'](\"or:\")))) {\n          $send(text, 'scan', [$$($nesting, 'InlineAnchorScanRx')], (TMP_22 = function(){var self = TMP_22.$$s || this, $b, id = nil, reftext = nil;\n\n          \n            if ($truthy((id = (($b = $gvars['~']) === nil ? nil : $b['$[]'](1))))) {\n              if ($truthy((reftext = (($b = $gvars['~']) === nil ? nil : $b['$[]'](2))))) {\n                if ($truthy(($truthy($b = reftext['$include?']($$($nesting, 'ATTR_REF_HEAD'))) ? (reftext = document.$sub_attributes(reftext))['$empty?']() : $b))) {\n                  return nil;}}\n            } else {\n              \n              id = (($b = $gvars['~']) === nil ? nil : $b['$[]'](3));\n              if ($truthy((reftext = (($b = $gvars['~']) === nil ? nil : $b['$[]'](4))))) {\n                \n                if ($truthy(reftext['$include?'](\"]\"))) {\n                  reftext = reftext.$gsub(\"\\\\]\", \"]\")};\n                if ($truthy(($truthy($b = reftext['$include?']($$($nesting, 'ATTR_REF_HEAD'))) ? (reftext = document.$sub_attributes(reftext))['$empty?']() : $b))) {\n                  return nil;};};\n            };\n            if ($truthy(document.$register(\"refs\", [id, $$($nesting, 'Inline').$new(block, \"anchor\", reftext, $hash2([\"type\", \"id\"], {\"type\": \"ref\", \"id\": id})), reftext]))) {\n              return nil\n            } else {\n              return self.$warn(\"\" + \"asciidoctor: WARNING: \" + (document.$reader().$path()) + \": id assigned to anchor already in use: \" + (id))\n            };}, TMP_22.$$s = self, TMP_22.$$arity = 0, TMP_22))};\n        return nil;\n      }, TMP_Parser_catalog_inline_anchors_23.$$arity = 3);\n      Opal.defs(self, '$catalog_inline_biblio_anchor', TMP_Parser_catalog_inline_biblio_anchor_24 = function $$catalog_inline_biblio_anchor(text, block, document) {\n        var $a, $b, self = this, id = nil, reftext = nil;\n\n        \n        if ($truthy($$($nesting, 'InlineBiblioAnchorRx')['$=~'](text))) {\n          if ($truthy(document.$register(\"refs\", [(id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1))), $$($nesting, 'Inline').$new(block, \"anchor\", (reftext = \"\" + \"[\" + (($truthy($a = (($b = $gvars['~']) === nil ? nil : $b['$[]'](2))) ? $a : id)) + \"]\"), $hash2([\"type\", \"id\"], {\"type\": \"bibref\", \"id\": id})), reftext]))) {\n          } else {\n            self.$warn(\"\" + \"asciidoctor: WARNING: \" + (document.$reader().$path()) + \": id assigned to bibliography anchor already in use: \" + (id))\n          }};\n        return nil;\n      }, TMP_Parser_catalog_inline_biblio_anchor_24.$$arity = 3);\n      Opal.defs(self, '$next_description_list', TMP_Parser_next_description_list_25 = function $$next_description_list(reader, match, parent) {\n        var $a, $b, $c, self = this, list_block = nil, previous_pair = nil, sibling_pattern = nil, term = nil, item = nil;\n\n        \n        list_block = $$($nesting, 'List').$new(parent, \"dlist\");\n        previous_pair = nil;\n        sibling_pattern = $$($nesting, 'DescriptionListSiblingRx')['$[]'](match['$[]'](2));\n        while ($truthy(($truthy($b = match) ? $b : ($truthy($c = reader['$has_more_lines?']()) ? (match = sibling_pattern.$match(reader.$peek_line())) : $c)))) {\n          \n          $c = self.$next_list_item(reader, list_block, match, sibling_pattern), $b = Opal.to_ary($c), (term = ($b[0] == null ? nil : $b[0])), (item = ($b[1] == null ? nil : $b[1])), $c;\n          if ($truthy(($truthy($b = previous_pair) ? previous_pair['$[]'](-1)['$!']() : $b))) {\n            \n            previous_pair.$pop();\n            previous_pair['$[]'](0)['$<<'](term);\n            previous_pair['$<<'](item);\n          } else {\n            list_block.$items()['$<<']((previous_pair = [[term], item]))\n          };\n          match = nil;\n        };\n        return list_block;\n      }, TMP_Parser_next_description_list_25.$$arity = 3);\n      Opal.defs(self, '$next_list_item', TMP_Parser_next_list_item_26 = function $$next_list_item(reader, list_block, match, sibling_trait) {\n        var $a, $b, $c, self = this, list_type = nil, list_term = nil, list_item = nil, has_text = nil, text = nil, checkbox = nil, checked = nil, $writer = nil, list_item_reader = nil, comment_lines = nil, subsequent_line = nil, continuation_connects_first_block = nil, content_adjacent = nil, options = nil, block = nil;\n\n        if (sibling_trait == null) {\n          sibling_trait = nil;\n        }\n        \n        if ((list_type = list_block.$context())['$=='](\"dlist\")) {\n          \n          list_term = $$($nesting, 'ListItem').$new(list_block, match['$[]'](1));\n          list_item = $$($nesting, 'ListItem').$new(list_block, match['$[]'](3));\n          has_text = match['$[]'](3)['$nil_or_empty?']()['$!']();\n        } else {\n          \n          text = match['$[]'](2);\n          checkbox = false;\n          if ($truthy((($a = list_type['$=='](\"ulist\")) ? text['$start_with?'](\"[\") : list_type['$=='](\"ulist\")))) {\n            if ($truthy(text['$start_with?'](\"[ ] \"))) {\n              \n              checkbox = true;\n              checked = false;\n              text = text['$[]']($range(3, -1, false)).$lstrip();\n            } else if ($truthy(text['$start_with?'](\"[x] \", \"[*] \"))) {\n              \n              checkbox = true;\n              checked = true;\n              text = text['$[]']($range(3, -1, false)).$lstrip();}};\n          list_item = $$($nesting, 'ListItem').$new(list_block, text);\n          if ($truthy(checkbox)) {\n            \n            \n            $writer = [\"checklist-option\", \"\"];\n            $send(list_block.$attributes(), '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            \n            $writer = [\"checkbox\", \"\"];\n            $send(list_item.$attributes(), '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            if ($truthy(checked)) {\n              \n              $writer = [\"checked\", \"\"];\n              $send(list_item.$attributes(), '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];};};\n          sibling_trait = ($truthy($a = sibling_trait) ? $a : self.$resolve_list_marker(list_type, match['$[]'](1), list_block.$items().$size(), true, reader));\n          \n          $writer = [sibling_trait];\n          $send(list_item, 'marker=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          has_text = true;\n        };\n        reader.$shift();\n        list_item_reader = $$($nesting, 'Reader').$new(self.$read_lines_for_list_item(reader, list_type, sibling_trait, has_text), reader.$cursor());\n        if ($truthy(list_item_reader['$has_more_lines?']())) {\n          \n          comment_lines = list_item_reader.$skip_line_comments();\n          if ($truthy((subsequent_line = list_item_reader.$peek_line()))) {\n            \n            if ($truthy(comment_lines['$empty?']())) {\n            } else {\n              list_item_reader.$unshift_lines(comment_lines)\n            };\n            if ($truthy((continuation_connects_first_block = subsequent_line['$empty?']()))) {\n              content_adjacent = false\n            } else {\n              \n              content_adjacent = true;\n              if (list_type['$=='](\"dlist\")) {\n              } else {\n                has_text = false\n              };\n            };\n          } else {\n            \n            continuation_connects_first_block = false;\n            content_adjacent = false;\n          };\n          options = $hash2([\"text\"], {\"text\": has_text['$!']()});\n          while ($truthy(($truthy($b = ($truthy($c = (block = self.$next_block(list_item_reader, list_item, $hash2([], {}), options))) ? list_item['$<<'](block) : $c)) ? $b : list_item_reader['$has_more_lines?']()))) {\n            \n          };\n          list_item.$fold_first(continuation_connects_first_block, content_adjacent);};\n        if (list_type['$=='](\"dlist\")) {\n          if ($truthy(($truthy($a = list_item['$text?']()) ? $a : list_item['$blocks?']()))) {\n            return [list_term, list_item]\n          } else {\n            return [list_term, nil]\n          }\n        } else {\n          return list_item\n        };\n      }, TMP_Parser_next_list_item_26.$$arity = -4);\n      Opal.defs(self, '$read_lines_for_list_item', TMP_Parser_read_lines_for_list_item_32 = function $$read_lines_for_list_item(reader, list_type, sibling_trait, has_text) {\n        var $a, $b, $c, TMP_27, TMP_28, TMP_29, TMP_30, TMP_31, self = this, buffer = nil, continuation = nil, within_nested_list = nil, detached_continuation = nil, this_line = nil, prev_line = nil, $writer = nil, match = nil, nested_list_type = nil;\n\n        if (sibling_trait == null) {\n          sibling_trait = nil;\n        }\n        if (has_text == null) {\n          has_text = true;\n        }\n        \n        buffer = [];\n        continuation = \"inactive\";\n        within_nested_list = false;\n        detached_continuation = nil;\n        while ($truthy(reader['$has_more_lines?']())) {\n          \n          this_line = reader.$read_line();\n          if ($truthy(self['$is_sibling_list_item?'](this_line, list_type, sibling_trait))) {\n            break;};\n          prev_line = (function() {if ($truthy(buffer['$empty?']())) {\n            return nil\n          } else {\n            return buffer['$[]'](-1)\n          }; return nil; })();\n          if (prev_line['$==']($$($nesting, 'LIST_CONTINUATION'))) {\n            \n            if (continuation['$=='](\"inactive\")) {\n              \n              continuation = \"active\";\n              has_text = true;\n              if ($truthy(within_nested_list)) {\n              } else {\n                \n                $writer = [-1, \"\"];\n                $send(buffer, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];\n              };};\n            if (this_line['$==']($$($nesting, 'LIST_CONTINUATION'))) {\n              \n              if ($truthy(continuation['$!='](\"frozen\"))) {\n                \n                continuation = \"frozen\";\n                buffer['$<<'](this_line);};\n              this_line = nil;\n              continue;;};};\n          if ($truthy((match = self['$is_delimited_block?'](this_line, true)))) {\n            if (continuation['$=='](\"active\")) {\n              \n              buffer['$<<'](this_line);\n              buffer.$concat(reader.$read_lines_until($hash2([\"terminator\", \"read_last_line\"], {\"terminator\": match.$terminator(), \"read_last_line\": true})));\n              continuation = \"inactive\";\n            } else {\n              break;\n            }\n          } else if ($truthy(($truthy($b = (($c = list_type['$=='](\"dlist\")) ? continuation['$!='](\"active\") : list_type['$=='](\"dlist\"))) ? $$($nesting, 'BlockAttributeLineRx')['$match?'](this_line) : $b))) {\n            break;\n          } else if ($truthy((($b = continuation['$=='](\"active\")) ? this_line['$empty?']()['$!']() : continuation['$=='](\"active\")))) {\n            if ($truthy($$($nesting, 'LiteralParagraphRx')['$match?'](this_line))) {\n              \n              reader.$unshift_line(this_line);\n              buffer.$concat($send(reader, 'read_lines_until', [$hash2([\"preserve_last_line\", \"break_on_blank_lines\", \"break_on_list_continuation\"], {\"preserve_last_line\": true, \"break_on_blank_lines\": true, \"break_on_list_continuation\": true})], (TMP_27 = function(line){var self = TMP_27.$$s || this, $d;\nif (line == null) line = nil;\n              return (($d = list_type['$=='](\"dlist\")) ? self['$is_sibling_list_item?'](line, list_type, sibling_trait) : list_type['$=='](\"dlist\"))}, TMP_27.$$s = self, TMP_27.$$arity = 1, TMP_27)));\n              continuation = \"inactive\";\n            } else if ($truthy(($truthy($b = ($truthy($c = $$($nesting, 'BlockTitleRx')['$match?'](this_line)) ? $c : $$($nesting, 'BlockAttributeLineRx')['$match?'](this_line))) ? $b : $$($nesting, 'AttributeEntryRx')['$match?'](this_line)))) {\n              buffer['$<<'](this_line)\n            } else {\n              \n              if ($truthy((nested_list_type = $send((function() {if ($truthy(within_nested_list)) {\n                return [\"dlist\"]\n              } else {\n                return $$($nesting, 'NESTABLE_LIST_CONTEXTS')\n              }; return nil; })(), 'find', [], (TMP_28 = function(ctx){var self = TMP_28.$$s || this;\nif (ctx == null) ctx = nil;\n              return $$($nesting, 'ListRxMap')['$[]'](ctx)['$match?'](this_line)}, TMP_28.$$s = self, TMP_28.$$arity = 1, TMP_28))))) {\n                \n                within_nested_list = true;\n                if ($truthy((($b = nested_list_type['$=='](\"dlist\")) ? (($c = $gvars['~']) === nil ? nil : $c['$[]'](3))['$nil_or_empty?']() : nested_list_type['$=='](\"dlist\")))) {\n                  has_text = false};};\n              buffer['$<<'](this_line);\n              continuation = \"inactive\";\n            }\n          } else if ($truthy(($truthy($b = prev_line) ? prev_line['$empty?']() : $b))) {\n            \n            if ($truthy(this_line['$empty?']())) {\n              \n              if ($truthy((this_line = ($truthy($b = reader.$skip_blank_lines()) ? reader.$read_line() : $b)))) {\n              } else {\n                break;\n              };\n              if ($truthy(self['$is_sibling_list_item?'](this_line, list_type, sibling_trait))) {\n                break;};};\n            if (this_line['$==']($$($nesting, 'LIST_CONTINUATION'))) {\n              \n              detached_continuation = buffer.$size();\n              buffer['$<<'](this_line);\n            } else if ($truthy(has_text)) {\n              if ($truthy(self['$is_sibling_list_item?'](this_line, list_type, sibling_trait))) {\n                break;\n              } else if ($truthy((nested_list_type = $send($$($nesting, 'NESTABLE_LIST_CONTEXTS'), 'find', [], (TMP_29 = function(ctx){var self = TMP_29.$$s || this;\nif (ctx == null) ctx = nil;\n              return $$($nesting, 'ListRxMap')['$[]'](ctx)['$=~'](this_line)}, TMP_29.$$s = self, TMP_29.$$arity = 1, TMP_29))))) {\n                \n                buffer['$<<'](this_line);\n                within_nested_list = true;\n                if ($truthy((($b = nested_list_type['$=='](\"dlist\")) ? (($c = $gvars['~']) === nil ? nil : $c['$[]'](3))['$nil_or_empty?']() : nested_list_type['$=='](\"dlist\")))) {\n                  has_text = false};\n              } else if ($truthy($$($nesting, 'LiteralParagraphRx')['$match?'](this_line))) {\n                \n                reader.$unshift_line(this_line);\n                buffer.$concat($send(reader, 'read_lines_until', [$hash2([\"preserve_last_line\", \"break_on_blank_lines\", \"break_on_list_continuation\"], {\"preserve_last_line\": true, \"break_on_blank_lines\": true, \"break_on_list_continuation\": true})], (TMP_30 = function(line){var self = TMP_30.$$s || this, $d;\nif (line == null) line = nil;\n                return (($d = list_type['$=='](\"dlist\")) ? self['$is_sibling_list_item?'](line, list_type, sibling_trait) : list_type['$=='](\"dlist\"))}, TMP_30.$$s = self, TMP_30.$$arity = 1, TMP_30)));\n              } else {\n                break;\n              }\n            } else {\n              \n              if ($truthy(within_nested_list)) {\n              } else {\n                buffer.$pop()\n              };\n              buffer['$<<'](this_line);\n              has_text = true;\n            };\n          } else {\n            \n            if ($truthy(this_line['$empty?']()['$!']())) {\n              has_text = true};\n            if ($truthy((nested_list_type = $send((function() {if ($truthy(within_nested_list)) {\n              return [\"dlist\"]\n            } else {\n              return $$($nesting, 'NESTABLE_LIST_CONTEXTS')\n            }; return nil; })(), 'find', [], (TMP_31 = function(ctx){var self = TMP_31.$$s || this;\nif (ctx == null) ctx = nil;\n            return $$($nesting, 'ListRxMap')['$[]'](ctx)['$=~'](this_line)}, TMP_31.$$s = self, TMP_31.$$arity = 1, TMP_31))))) {\n              \n              within_nested_list = true;\n              if ($truthy((($b = nested_list_type['$=='](\"dlist\")) ? (($c = $gvars['~']) === nil ? nil : $c['$[]'](3))['$nil_or_empty?']() : nested_list_type['$=='](\"dlist\")))) {\n                has_text = false};};\n            buffer['$<<'](this_line);\n          };\n          this_line = nil;\n        };\n        if ($truthy(this_line)) {\n          reader.$unshift_line(this_line)};\n        if ($truthy(detached_continuation)) {\n          buffer.$delete_at(detached_continuation)};\n        while ($truthy(($truthy($b = buffer['$empty?']()['$!']()) ? buffer['$[]'](-1)['$empty?']() : $b))) {\n          buffer.$pop()\n        };\n        if ($truthy(($truthy($a = buffer['$empty?']()['$!']()) ? buffer['$[]'](-1)['$==']($$($nesting, 'LIST_CONTINUATION')) : $a))) {\n          buffer.$pop()};\n        return buffer;\n      }, TMP_Parser_read_lines_for_list_item_32.$$arity = -3);\n      Opal.defs(self, '$initialize_section', TMP_Parser_initialize_section_33 = function $$initialize_section(reader, parent, attributes) {\n        var $a, $b, self = this, document = nil, source_location = nil, sect_id = nil, sect_reftext = nil, sect_title = nil, sect_level = nil, atx = nil, $writer = nil, style = nil, sect_name = nil, sect_special = nil, sect_numbered_force = nil, $case = nil, section = nil, id = nil;\n\n        if (attributes == null) {\n          attributes = $hash2([], {});\n        }\n        \n        document = parent.$document();\n        if ($truthy(document.$sourcemap())) {\n          source_location = reader.$cursor()};\n        $b = self.$parse_section_title(reader, document), $a = Opal.to_ary($b), (sect_id = ($a[0] == null ? nil : $a[0])), (sect_reftext = ($a[1] == null ? nil : $a[1])), (sect_title = ($a[2] == null ? nil : $a[2])), (sect_level = ($a[3] == null ? nil : $a[3])), (atx = ($a[4] == null ? nil : $a[4])), $b;\n        if ($truthy(sect_reftext)) {\n          \n          $writer = [\"reftext\", sect_reftext];\n          $send(attributes, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];\n        } else if ($truthy(attributes['$key?'](\"reftext\"))) {\n          sect_reftext = attributes['$[]'](\"reftext\")};\n        style = (function() {if ($truthy(attributes['$[]'](1))) {\n          \n          return self.$parse_style_attribute(attributes, reader);\n        } else {\n          return nil\n        }; return nil; })();\n        if ($truthy(style)) {\n          if ($truthy((($a = style['$=='](\"abstract\")) ? document.$doctype()['$=='](\"book\") : style['$=='](\"abstract\")))) {\n            $a = [\"chapter\", 1], (sect_name = $a[0]), (sect_level = $a[1]), $a\n          } else {\n            \n            $a = [style, true], (sect_name = $a[0]), (sect_special = $a[1]), $a;\n            if (sect_level['$=='](0)) {\n              sect_level = 1};\n            sect_numbered_force = style['$=='](\"appendix\");\n          }\n        } else {\n          $case = document.$doctype();\n          if (\"book\"['$===']($case)) {sect_name = (function() {if (sect_level['$=='](0)) {\n            return \"part\"\n          } else {\n            \n            if (sect_level['$=='](1)) {\n              return \"chapter\"\n            } else {\n              return \"section\"\n            };\n          }; return nil; })()}\n          else if (\"manpage\"['$===']($case)) {if (sect_title.$casecmp(\"synopsis\")['$=='](0)) {\n            $a = [\"synopsis\", true], (sect_name = $a[0]), (sect_special = $a[1]), $a\n          } else {\n            sect_name = \"section\"\n          }}\n          else {sect_name = \"section\"}\n        };\n        section = $$($nesting, 'Section').$new(parent, sect_level, false);\n        $a = [sect_id, sect_title, sect_name, source_location], section['$id=']($a[0]), section['$title=']($a[1]), section['$sectname=']($a[2]), section['$source_location=']($a[3]), $a;\n        if ($truthy(sect_special)) {\n          \n          \n          $writer = [true];\n          $send(section, 'special=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          if ($truthy(sect_numbered_force)) {\n            \n            $writer = [true];\n            $send(section, 'numbered=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];};\n        } else if ($truthy(($truthy($a = $rb_gt(sect_level, 0)) ? document.$attributes()['$key?'](\"sectnums\") : $a))) {\n          \n          $writer = [(function() {if ($truthy(section.$special())) {\n            \n            return (($a = parent.$context()['$=='](\"section\")) ? parent.$numbered() : parent.$context()['$=='](\"section\"));\n          } else {\n            return true\n          }; return nil; })()];\n          $send(section, 'numbered=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];};\n        if ($truthy((id = ($truthy($a = section.$id()) ? $a : (($writer = [($truthy($b = attributes['$[]'](\"id\")) ? $b : (function() {if ($truthy(document.$attributes()['$key?'](\"sectids\"))) {\n          \n          return $$($nesting, 'Section').$generate_id(section.$title(), document);\n        } else {\n          return nil\n        }; return nil; })())]), $send(section, 'id=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))))) {\n          if ($truthy(document.$register(\"refs\", [id, section, ($truthy($a = sect_reftext) ? $a : section.$title())]))) {\n          } else {\n            self.$warn(\"\" + \"asciidoctor: WARNING: \" + (reader.$path()) + \": line \" + ($rb_minus(reader.$lineno(), (function() {if ($truthy(atx)) {\n              return 1\n            } else {\n              return 2\n            }; return nil; })())) + \": id assigned to section already in use: \" + (id))\n          }};\n        section.$update_attributes(attributes);\n        reader.$skip_blank_lines();\n        return section;\n      }, TMP_Parser_initialize_section_33.$$arity = -3);\n      Opal.defs(self, '$is_next_line_section?', TMP_Parser_is_next_line_section$q_34 = function(reader, attributes) {\n        var $a, $b, self = this, style = nil;\n\n        if ($truthy(($truthy($a = ($truthy($b = (style = attributes['$[]'](1))) ? style['$start_with?'](\"discrete\", \"float\") : $b)) ? $$($nesting, 'DiscreteHeadingStyleRx')['$match?'](style) : $a))) {\n          return nil\n        } else if ($truthy(reader['$has_more_lines?']())) {\n          if ($truthy($$($nesting, 'Compliance').$underline_style_section_titles())) {\n            return $send(self, 'is_section_title?', Opal.to_a(reader.$peek_lines(2, ($truthy($a = style) ? style['$=='](\"comment\") : $a))))\n          } else {\n            return self['$atx_section_title?'](reader.$peek_line())\n          }\n        } else {\n          return nil\n        }\n      }, TMP_Parser_is_next_line_section$q_34.$$arity = 2);\n      Opal.defs(self, '$is_next_line_doctitle?', TMP_Parser_is_next_line_doctitle$q_35 = function(reader, attributes, leveloffset) {\n        var $a, self = this, sect_level = nil;\n\n        if ($truthy(leveloffset)) {\n          return ($truthy($a = (sect_level = self['$is_next_line_section?'](reader, attributes))) ? $rb_plus(sect_level, leveloffset.$to_i())['$=='](0) : $a)\n        } else {\n          return self['$is_next_line_section?'](reader, attributes)['$=='](0)\n        }\n      }, TMP_Parser_is_next_line_doctitle$q_35.$$arity = 3);\n      Opal.defs(self, '$is_section_title?', TMP_Parser_is_section_title$q_36 = function(line1, line2) {\n        var $a, self = this;\n\n        if (line2 == null) {\n          line2 = nil;\n        }\n        return ($truthy($a = self['$atx_section_title?'](line1)) ? $a : (function() {if ($truthy(line2['$nil_or_empty?']())) {\n          return nil\n        } else {\n          return self['$setext_section_title?'](line1, line2)\n        }; return nil; })())\n      }, TMP_Parser_is_section_title$q_36.$$arity = -2);\n      Opal.defs(self, '$atx_section_title?', TMP_Parser_atx_section_title$q_37 = function(line) {\n        var $a, self = this;\n\n        if ($truthy((function() {if ($truthy($$($nesting, 'Compliance').$markdown_syntax())) {\n          \n          return ($truthy($a = line['$start_with?'](\"=\", \"#\")) ? $$($nesting, 'ExtAtxSectionTitleRx')['$=~'](line) : $a);\n        } else {\n          \n          return ($truthy($a = line['$start_with?'](\"=\")) ? $$($nesting, 'AtxSectionTitleRx')['$=~'](line) : $a);\n        }; return nil; })())) {\n          return $rb_minus((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)).$length(), 1)\n        } else {\n          return nil\n        }\n      }, TMP_Parser_atx_section_title$q_37.$$arity = 1);\n      Opal.defs(self, '$setext_section_title?', TMP_Parser_setext_section_title$q_38 = function(line1, line2) {\n        var $a, $b, $c, self = this, level = nil, line2_ch1 = nil, line2_len = nil;\n\n        if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = (level = $$($nesting, 'SETEXT_SECTION_LEVELS')['$[]']((line2_ch1 = line2.$chr())))) ? $rb_times(line2_ch1, (line2_len = line2.$length()))['$=='](line2) : $c)) ? $$($nesting, 'SetextSectionTitleRx')['$match?'](line1) : $b)) ? $rb_lt($rb_minus(self.$line_length(line1), line2_len).$abs(), 2) : $a))) {\n          return level\n        } else {\n          return nil\n        }\n      }, TMP_Parser_setext_section_title$q_38.$$arity = 2);\n      Opal.defs(self, '$parse_section_title', TMP_Parser_parse_section_title_39 = function $$parse_section_title(reader, document) {\n        var $a, $b, $c, $d, $e, self = this, sect_id = nil, sect_reftext = nil, line1 = nil, sect_level = nil, sect_title = nil, atx = nil, line2 = nil, line2_ch1 = nil, line2_len = nil;\n\n        \n        sect_id = (sect_reftext = nil);\n        line1 = reader.$read_line();\n        if ($truthy((function() {if ($truthy($$($nesting, 'Compliance').$markdown_syntax())) {\n          \n          return ($truthy($a = line1['$start_with?'](\"=\", \"#\")) ? $$($nesting, 'ExtAtxSectionTitleRx')['$=~'](line1) : $a);\n        } else {\n          \n          return ($truthy($a = line1['$start_with?'](\"=\")) ? $$($nesting, 'AtxSectionTitleRx')['$=~'](line1) : $a);\n        }; return nil; })())) {\n          \n          $a = [$rb_minus((($b = $gvars['~']) === nil ? nil : $b['$[]'](1)).$length(), 1), (($b = $gvars['~']) === nil ? nil : $b['$[]'](2)), true], (sect_level = $a[0]), (sect_title = $a[1]), (atx = $a[2]), $a;\n          if ($truthy(($truthy($a = ($truthy($b = sect_title['$end_with?'](\"]]\")) ? $$($nesting, 'InlineSectionAnchorRx')['$=~'](sect_title) : $b)) ? (($b = $gvars['~']) === nil ? nil : $b['$[]'](1))['$!']() : $a))) {\n            $a = [sect_title.$slice(0, $rb_minus(sect_title.$length(), (($b = $gvars['~']) === nil ? nil : $b['$[]'](0)).$length())), (($b = $gvars['~']) === nil ? nil : $b['$[]'](2)), (($b = $gvars['~']) === nil ? nil : $b['$[]'](3))], (sect_title = $a[0]), (sect_id = $a[1]), (sect_reftext = $a[2]), $a};\n        } else if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = ($truthy($e = $$($nesting, 'Compliance').$underline_style_section_titles()) ? (line2 = reader.$peek_line(true)) : $e)) ? (sect_level = $$($nesting, 'SETEXT_SECTION_LEVELS')['$[]']((line2_ch1 = line2.$chr()))) : $d)) ? $rb_times(line2_ch1, (line2_len = line2.$length()))['$=='](line2) : $c)) ? (sect_title = ($truthy($c = $$($nesting, 'SetextSectionTitleRx')['$=~'](line1)) ? (($d = $gvars['~']) === nil ? nil : $d['$[]'](1)) : $c)) : $b)) ? $rb_lt($rb_minus(self.$line_length(line1), line2_len).$abs(), 2) : $a))) {\n          \n          atx = false;\n          if ($truthy(($truthy($a = ($truthy($b = sect_title['$end_with?'](\"]]\")) ? $$($nesting, 'InlineSectionAnchorRx')['$=~'](sect_title) : $b)) ? (($b = $gvars['~']) === nil ? nil : $b['$[]'](1))['$!']() : $a))) {\n            $a = [sect_title.$slice(0, $rb_minus(sect_title.$length(), (($b = $gvars['~']) === nil ? nil : $b['$[]'](0)).$length())), (($b = $gvars['~']) === nil ? nil : $b['$[]'](2)), (($b = $gvars['~']) === nil ? nil : $b['$[]'](3))], (sect_title = $a[0]), (sect_id = $a[1]), (sect_reftext = $a[2]), $a};\n          reader.$shift();\n        } else {\n          self.$raise(\"\" + \"Unrecognized section at \" + (reader.$prev_line_info()))\n        };\n        if ($truthy(document['$attr?'](\"leveloffset\"))) {\n          sect_level = $rb_plus(sect_level, document.$attr(\"leveloffset\").$to_i())};\n        return [sect_id, sect_reftext, sect_title, sect_level, atx];\n      }, TMP_Parser_parse_section_title_39.$$arity = 2);\n      if ($truthy($$($nesting, 'FORCE_UNICODE_LINE_LENGTH'))) {\n        Opal.defs(self, '$line_length', TMP_Parser_line_length_40 = function $$line_length(line) {\n          var self = this;\n\n          return line.$scan($$($nesting, 'UnicodeCharScanRx')).$size()\n        }, TMP_Parser_line_length_40.$$arity = 1)\n      } else {\n        Opal.defs(self, '$line_length', TMP_Parser_line_length_41 = function $$line_length(line) {\n          var self = this;\n\n          return line.$length()\n        }, TMP_Parser_line_length_41.$$arity = 1)\n      };\n      Opal.defs(self, '$parse_header_metadata', TMP_Parser_parse_header_metadata_46 = function $$parse_header_metadata(reader, document) {\n        var $a, TMP_42, TMP_43, TMP_44, self = this, metadata = nil, implicit_author = nil, implicit_authors = nil, author_metadata = nil, rev_metadata = nil, rev_line = nil, match = nil, $writer = nil, component = nil, author_line = nil, authors = nil, author_idx = nil, author_key = nil, explicit = nil, sparse = nil, author_override = nil;\n\n        if (document == null) {\n          document = nil;\n        }\n        \n        self.$process_attribute_entries(reader, document);\n        $a = [$hash2([], {}), nil, nil], (metadata = $a[0]), (implicit_author = $a[1]), (implicit_authors = $a[2]), $a;\n        if ($truthy(($truthy($a = reader['$has_more_lines?']()) ? reader['$next_line_empty?']()['$!']() : $a))) {\n          \n          if ($truthy((author_metadata = self.$process_authors(reader.$read_line()))['$empty?']())) {\n          } else {\n            \n            if ($truthy(document)) {\n              \n              $send(author_metadata, 'each', [], (TMP_42 = function(key, val){var self = TMP_42.$$s || this, $writer = nil;\nif (key == null) key = nil;if (val == null) val = nil;\n              if ($truthy(document.$attributes()['$key?'](key))) {\n                  return nil\n                } else {\n                  \n                  $writer = [key, (function() {if ($truthy($$$('::', 'String')['$==='](val))) {\n                    \n                    return document.$apply_header_subs(val);\n                  } else {\n                    return val\n                  }; return nil; })()];\n                  $send(document.$attributes(), '[]=', Opal.to_a($writer));\n                  return $writer[$rb_minus($writer[\"length\"], 1)];\n                }}, TMP_42.$$s = self, TMP_42.$$arity = 2, TMP_42));\n              implicit_author = document.$attributes()['$[]'](\"author\");\n              implicit_authors = document.$attributes()['$[]'](\"authors\");};\n            metadata = author_metadata;\n          };\n          self.$process_attribute_entries(reader, document);\n          rev_metadata = $hash2([], {});\n          if ($truthy(($truthy($a = reader['$has_more_lines?']()) ? reader['$next_line_empty?']()['$!']() : $a))) {\n            \n            rev_line = reader.$read_line();\n            if ($truthy((match = $$($nesting, 'RevisionInfoLineRx').$match(rev_line)))) {\n              \n              if ($truthy(match['$[]'](1))) {\n                \n                $writer = [\"revnumber\", match['$[]'](1).$rstrip()];\n                $send(rev_metadata, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];};\n              if ($truthy((component = match['$[]'](2).$strip())['$empty?']())) {\n              } else if ($truthy(($truthy($a = match['$[]'](1)['$!']()) ? component['$start_with?'](\"v\") : $a))) {\n                \n                $writer = [\"revnumber\", component['$[]']($range(1, -1, false))];\n                $send(rev_metadata, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];\n              } else {\n                \n                $writer = [\"revdate\", component];\n                $send(rev_metadata, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];\n              };\n              if ($truthy(match['$[]'](3))) {\n                \n                $writer = [\"revremark\", match['$[]'](3).$rstrip()];\n                $send(rev_metadata, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];};\n            } else {\n              reader.$unshift_line(rev_line)\n            };};\n          if ($truthy(rev_metadata['$empty?']())) {\n          } else {\n            \n            if ($truthy(document)) {\n              $send(rev_metadata, 'each', [], (TMP_43 = function(key, val){var self = TMP_43.$$s || this;\nif (key == null) key = nil;if (val == null) val = nil;\n              if ($truthy(document.$attributes()['$key?'](key))) {\n                  return nil\n                } else {\n                  \n                  $writer = [key, document.$apply_header_subs(val)];\n                  $send(document.$attributes(), '[]=', Opal.to_a($writer));\n                  return $writer[$rb_minus($writer[\"length\"], 1)];\n                }}, TMP_43.$$s = self, TMP_43.$$arity = 2, TMP_43))};\n            metadata.$update(rev_metadata);\n          };\n          self.$process_attribute_entries(reader, document);\n          reader.$skip_blank_lines();};\n        if ($truthy(document)) {\n          \n          if ($truthy(($truthy($a = document.$attributes()['$key?'](\"author\")) ? (author_line = document.$attributes()['$[]'](\"author\"))['$!='](implicit_author) : $a))) {\n            author_metadata = self.$process_authors(author_line, true, false)\n          } else if ($truthy(($truthy($a = document.$attributes()['$key?'](\"authors\")) ? (author_line = document.$attributes()['$[]'](\"authors\"))['$!='](implicit_authors) : $a))) {\n            author_metadata = self.$process_authors(author_line, true)\n          } else {\n            \n            $a = [[], 1, \"author_1\", false, false], (authors = $a[0]), (author_idx = $a[1]), (author_key = $a[2]), (explicit = $a[3]), (sparse = $a[4]), $a;\n            while ($truthy(document.$attributes()['$key?'](author_key))) {\n              \n              if ((author_override = document.$attributes()['$[]'](author_key))['$=='](author_metadata['$[]'](author_key))) {\n                \n                authors['$<<'](nil);\n                sparse = true;\n              } else {\n                \n                authors['$<<'](author_override);\n                explicit = true;\n              };\n              author_key = \"\" + \"author_\" + ((author_idx = $rb_plus(author_idx, 1)));\n            };\n            if ($truthy(explicit)) {\n              \n              if ($truthy(sparse)) {\n                $send(authors, 'each_with_index', [], (TMP_44 = function(author, idx){var self = TMP_44.$$s || this, TMP_45, name_idx = nil;\nif (author == null) author = nil;if (idx == null) idx = nil;\n                if ($truthy(author)) {\n                    return nil\n                  } else {\n                    \n                    $writer = [idx, $rb_times($send([author_metadata['$[]'](\"\" + \"firstname_\" + ((name_idx = $rb_plus(idx, 1)))), author_metadata['$[]'](\"\" + \"middlename_\" + (name_idx)), author_metadata['$[]'](\"\" + \"lastname_\" + (name_idx))].$compact(), 'map', [], (TMP_45 = function(it){var self = TMP_45.$$s || this;\nif (it == null) it = nil;\n                    return it.$tr(\" \", \"_\")}, TMP_45.$$s = self, TMP_45.$$arity = 1, TMP_45)), \" \")];\n                    $send(authors, '[]=', Opal.to_a($writer));\n                    return $writer[$rb_minus($writer[\"length\"], 1)];\n                  }}, TMP_44.$$s = self, TMP_44.$$arity = 2, TMP_44))};\n              author_metadata = self.$process_authors(authors, true, false);\n            } else {\n              author_metadata = $hash2([], {})\n            };\n          };\n          if ($truthy(author_metadata['$empty?']())) {\n          } else {\n            \n            document.$attributes().$update(author_metadata);\n            if ($truthy(($truthy($a = document.$attributes()['$key?'](\"email\")['$!']()) ? document.$attributes()['$key?'](\"email_1\") : $a))) {\n              \n              $writer = [\"email\", document.$attributes()['$[]'](\"email_1\")];\n              $send(document.$attributes(), '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];};\n          };};\n        return metadata;\n      }, TMP_Parser_parse_header_metadata_46.$$arity = -2);\n      Opal.defs(self, '$process_authors', TMP_Parser_process_authors_52 = function $$process_authors(author_line, names_only, multiple) {\n        var TMP_47, TMP_48, self = this, author_metadata = nil, keys = nil, author_entries = nil;\n\n        if (names_only == null) {\n          names_only = false;\n        }\n        if (multiple == null) {\n          multiple = true;\n        }\n        \n        author_metadata = $hash2([], {});\n        keys = [\"author\", \"authorinitials\", \"firstname\", \"middlename\", \"lastname\", \"email\"];\n        author_entries = (function() {if ($truthy(multiple)) {\n          return $send(author_line.$split(\";\"), 'map', [], (TMP_47 = function(it){var self = TMP_47.$$s || this;\nif (it == null) it = nil;\n          return it.$strip()}, TMP_47.$$s = self, TMP_47.$$arity = 1, TMP_47))\n        } else {\n          return self.$Array(author_line)\n        }; return nil; })();\n        $send(author_entries, 'each_with_index', [], (TMP_48 = function(author_entry, idx){var self = TMP_48.$$s || this, TMP_49, TMP_50, $a, TMP_51, key_map = nil, segments = nil, $writer = nil, match = nil, author = nil, fname = nil, mname = nil, lname = nil;\nif (author_entry == null) author_entry = nil;if (idx == null) idx = nil;\n        \n          if ($truthy(author_entry['$empty?']())) {\n            return nil;};\n          key_map = $hash2([], {});\n          if (idx['$=='](0)) {\n            $send(keys, 'each', [], (TMP_49 = function(key){var self = TMP_49.$$s || this, $writer = nil;\nif (key == null) key = nil;\n            \n              $writer = [key.$to_sym(), key];\n              $send(key_map, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_49.$$s = self, TMP_49.$$arity = 1, TMP_49))\n          } else {\n            $send(keys, 'each', [], (TMP_50 = function(key){var self = TMP_50.$$s || this, $writer = nil;\nif (key == null) key = nil;\n            \n              $writer = [key.$to_sym(), \"\" + (key) + \"_\" + ($rb_plus(idx, 1))];\n              $send(key_map, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_50.$$s = self, TMP_50.$$arity = 1, TMP_50))\n          };\n          segments = nil;\n          if ($truthy(names_only)) {\n            \n            if ($truthy(author_entry['$include?'](\"<\"))) {\n              \n              \n              $writer = [key_map['$[]'](\"author\"), author_entry.$tr(\"_\", \" \")];\n              $send(author_metadata, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n              author_entry = author_entry.$gsub($$($nesting, 'XmlSanitizeRx'), \"\");};\n            if ((segments = author_entry.$split(nil, 3)).$size()['$=='](3)) {\n              segments['$<<'](segments.$pop().$squeeze(\" \"))};\n          } else if ($truthy((match = $$($nesting, 'AuthorInfoLineRx').$match(author_entry)))) {\n            (segments = match.$to_a()).$shift()};\n          if ($truthy(segments)) {\n            \n            author = (($writer = [key_map['$[]'](\"firstname\"), (fname = segments['$[]'](0).$tr(\"_\", \" \"))]), $send(author_metadata, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]);\n            \n            $writer = [key_map['$[]'](\"authorinitials\"), fname.$chr()];\n            $send(author_metadata, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            if ($truthy(segments['$[]'](1))) {\n              if ($truthy(segments['$[]'](2))) {\n                \n                \n                $writer = [key_map['$[]'](\"middlename\"), (mname = segments['$[]'](1).$tr(\"_\", \" \"))];\n                $send(author_metadata, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];;\n                \n                $writer = [key_map['$[]'](\"lastname\"), (lname = segments['$[]'](2).$tr(\"_\", \" \"))];\n                $send(author_metadata, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];;\n                author = $rb_plus($rb_plus($rb_plus($rb_plus(fname, \" \"), mname), \" \"), lname);\n                \n                $writer = [key_map['$[]'](\"authorinitials\"), \"\" + (fname.$chr()) + (mname.$chr()) + (lname.$chr())];\n                $send(author_metadata, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];;\n              } else {\n                \n                \n                $writer = [key_map['$[]'](\"lastname\"), (lname = segments['$[]'](1).$tr(\"_\", \" \"))];\n                $send(author_metadata, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];;\n                author = $rb_plus($rb_plus(fname, \" \"), lname);\n                \n                $writer = [key_map['$[]'](\"authorinitials\"), \"\" + (fname.$chr()) + (lname.$chr())];\n                $send(author_metadata, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];;\n              }};\n            ($truthy($a = author_metadata['$[]'](key_map['$[]'](\"author\"))) ? $a : (($writer = [key_map['$[]'](\"author\"), author]), $send(author_metadata, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n            if ($truthy(($truthy($a = names_only) ? $a : segments['$[]'](3)['$!']()))) {\n            } else {\n              \n              $writer = [key_map['$[]'](\"email\"), segments['$[]'](3)];\n              $send(author_metadata, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];\n            };\n          } else {\n            \n            \n            $writer = [key_map['$[]'](\"author\"), (($writer = [key_map['$[]'](\"firstname\"), (fname = author_entry.$squeeze(\" \").$strip())]), $send(author_metadata, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])];\n            $send(author_metadata, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            \n            $writer = [key_map['$[]'](\"authorinitials\"), fname.$chr()];\n            $send(author_metadata, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n          };\n          \n          $writer = [\"authorcount\", $rb_plus(idx, 1)];\n          $send(author_metadata, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          if (idx['$=='](1)) {\n            $send(keys, 'each', [], (TMP_51 = function(key){var self = TMP_51.$$s || this;\nif (key == null) key = nil;\n            if ($truthy(author_metadata['$key?'](key))) {\n                \n                $writer = [\"\" + (key) + \"_1\", author_metadata['$[]'](key)];\n                $send(author_metadata, '[]=', Opal.to_a($writer));\n                return $writer[$rb_minus($writer[\"length\"], 1)];\n              } else {\n                return nil\n              }}, TMP_51.$$s = self, TMP_51.$$arity = 1, TMP_51))};\n          if (idx['$=='](0)) {\n            \n            $writer = [\"authors\", author_metadata['$[]'](key_map['$[]'](\"author\"))];\n            $send(author_metadata, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];\n          } else {\n            \n            $writer = [\"authors\", \"\" + (author_metadata['$[]'](\"authors\")) + \", \" + (author_metadata['$[]'](key_map['$[]'](\"author\")))];\n            $send(author_metadata, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];\n          };}, TMP_48.$$s = self, TMP_48.$$arity = 2, TMP_48));\n        return author_metadata;\n      }, TMP_Parser_process_authors_52.$$arity = -2);\n      Opal.defs(self, '$parse_block_metadata_lines', TMP_Parser_parse_block_metadata_lines_53 = function $$parse_block_metadata_lines(reader, document, attributes, options) {\n        var $a, $b, self = this;\n\n        if (attributes == null) {\n          attributes = $hash2([], {});\n        }\n        if (options == null) {\n          options = $hash2([], {});\n        }\n        \n        while ($truthy(self.$parse_block_metadata_line(reader, document, attributes, options))) {\n          \n          reader.$shift();\n          if ($truthy($b = reader.$skip_blank_lines())) {\n            $b\n          } else {\n            break;\n          };\n        };\n        return attributes;\n      }, TMP_Parser_parse_block_metadata_lines_53.$$arity = -3);\n      Opal.defs(self, '$parse_block_metadata_line', TMP_Parser_parse_block_metadata_line_54 = function $$parse_block_metadata_line(reader, document, attributes, options) {\n        var $a, $b, self = this, next_line = nil, normal = nil, $writer = nil, reftext = nil, ll = nil;\n        if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n        if (options == null) {\n          options = $hash2([], {});\n        }\n        if ($truthy(($truthy($a = (next_line = reader.$peek_line())) ? (function() {if ($truthy(options['$[]'](\"text\"))) {\n          \n          return next_line['$start_with?'](\"[\", \"/\");\n        } else {\n          \n          return (normal = next_line['$start_with?'](\"[\", \".\", \"/\", \":\"));\n        }; return nil; })() : $a))) {\n          if ($truthy(next_line['$start_with?'](\"[\"))) {\n            if ($truthy(next_line['$start_with?'](\"[[\"))) {\n              if ($truthy(($truthy($a = next_line['$end_with?'](\"]]\")) ? $$($nesting, 'BlockAnchorRx')['$=~'](next_line) : $a))) {\n                \n                \n                $writer = [\"id\", (($a = $gvars['~']) === nil ? nil : $a['$[]'](1))];\n                $send(attributes, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];;\n                if ($truthy((reftext = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2))))) {\n                  \n                  $writer = [\"reftext\", (function() {if ($truthy(reftext['$include?']($$($nesting, 'ATTR_REF_HEAD')))) {\n                    \n                    return document.$sub_attributes(reftext);\n                  } else {\n                    return reftext\n                  }; return nil; })()];\n                  $send(attributes, '[]=', Opal.to_a($writer));\n                  $writer[$rb_minus($writer[\"length\"], 1)];};\n                return true;\n              } else {\n                return nil\n              }\n            } else if ($truthy(($truthy($a = next_line['$end_with?'](\"]\")) ? $$($nesting, 'BlockAttributeListRx')['$=~'](next_line) : $a))) {\n              \n              document.$parse_attributes((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), [], $hash2([\"sub_input\", \"into\"], {\"sub_input\": true, \"into\": attributes}));\n              return true;\n            } else {\n              return nil\n            }\n          } else if ($truthy(($truthy($a = normal) ? next_line['$start_with?'](\".\") : $a))) {\n            if ($truthy($$($nesting, 'BlockTitleRx')['$=~'](next_line))) {\n              \n              \n              $writer = [\"title\", (($a = $gvars['~']) === nil ? nil : $a['$[]'](1))];\n              $send(attributes, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n              return true;\n            } else {\n              return nil\n            }\n          } else if ($truthy(($truthy($a = normal['$!']()) ? $a : next_line['$start_with?'](\"/\")))) {\n            if ($truthy(next_line['$start_with?'](\"//\"))) {\n              if (next_line['$=='](\"//\")) {\n                return true\n              } else if ($truthy(($truthy($a = normal) ? $rb_times(\"/\", (ll = next_line.$length()))['$=='](next_line) : $a))) {\n                if (ll['$=='](3)) {\n                  return nil\n                } else {\n                  \n                  reader.$read_lines_until($hash2([\"skip_first_line\", \"preserve_last_line\", \"terminator\", \"skip_processing\"], {\"skip_first_line\": true, \"preserve_last_line\": true, \"terminator\": next_line, \"skip_processing\": true}));\n                  return true;\n                }\n              } else if ($truthy(next_line['$start_with?'](\"///\"))) {\n                return nil\n              } else {\n                return true\n              }\n            } else {\n              return nil\n            }\n          } else if ($truthy(($truthy($a = ($truthy($b = normal) ? next_line['$start_with?'](\":\") : $b)) ? $$($nesting, 'AttributeEntryRx')['$=~'](next_line) : $a))) {\n            \n            self.$process_attribute_entry(reader, document, attributes, $gvars[\"~\"]);\n            return true;\n          } else {\n            return nil\n          }\n        } else {\n          return nil\n        }\n      }, TMP_Parser_parse_block_metadata_line_54.$$arity = -4);\n      Opal.defs(self, '$process_attribute_entries', TMP_Parser_process_attribute_entries_55 = function $$process_attribute_entries(reader, document, attributes) {\n        var $a, self = this;\n\n        if (attributes == null) {\n          attributes = nil;\n        }\n        \n        reader.$skip_comment_lines();\n        while ($truthy(self.$process_attribute_entry(reader, document, attributes))) {\n          \n          reader.$shift();\n          reader.$skip_comment_lines();\n        };\n      }, TMP_Parser_process_attribute_entries_55.$$arity = -3);\n      Opal.defs(self, '$process_attribute_entry', TMP_Parser_process_attribute_entry_56 = function $$process_attribute_entry(reader, document, attributes, match) {\n        var $a, $b, self = this, value = nil, con = nil, next_line = nil, keep_open = nil;\n\n        if (attributes == null) {\n          attributes = nil;\n        }\n        if (match == null) {\n          match = nil;\n        }\n        if ($truthy((match = ($truthy($a = match) ? $a : (function() {if ($truthy(reader['$has_more_lines?']())) {\n          \n          return $$($nesting, 'AttributeEntryRx').$match(reader.$peek_line());\n        } else {\n          return nil\n        }; return nil; })())))) {\n          \n          if ($truthy((value = match['$[]'](2))['$nil_or_empty?']())) {\n            value = \"\"\n          } else if ($truthy(value['$end_with?']($$($nesting, 'LINE_CONTINUATION'), $$($nesting, 'LINE_CONTINUATION_LEGACY')))) {\n            \n            $a = [value.$slice(-2, 2), value.$slice(0, $rb_minus(value.$length(), 2)).$rstrip()], (con = $a[0]), (value = $a[1]), $a;\n            while ($truthy(($truthy($b = reader.$advance()) ? (next_line = reader.$peek_line().$lstrip())['$empty?']()['$!']() : $b))) {\n              \n              if ($truthy((keep_open = next_line['$end_with?'](con)))) {\n                next_line = next_line.$slice(0, $rb_minus(next_line.$length(), 2)).$rstrip()};\n              value = \"\" + (value) + ((function() {if ($truthy(value['$end_with?']($$($nesting, 'HARD_LINE_BREAK')))) {\n                return $$($nesting, 'LF')\n              } else {\n                return \" \"\n              }; return nil; })()) + (next_line);\n              if ($truthy(keep_open)) {\n              } else {\n                break;\n              };\n            };};\n          self.$store_attribute(match['$[]'](1), value, document, attributes);\n          return true;\n        } else {\n          return nil\n        }\n      }, TMP_Parser_process_attribute_entry_56.$$arity = -3);\n      Opal.defs(self, '$store_attribute', TMP_Parser_store_attribute_57 = function $$store_attribute(name, value, doc, attrs) {\n        var $a, self = this, resolved_value = nil;\n\n        if (doc == null) {\n          doc = nil;\n        }\n        if (attrs == null) {\n          attrs = nil;\n        }\n        \n        if ($truthy(name['$end_with?'](\"!\"))) {\n          $a = [name.$chop(), nil], (name = $a[0]), (value = $a[1]), $a\n        } else if ($truthy(name['$start_with?'](\"!\"))) {\n          $a = [name.$slice(1, name.$length()), nil], (name = $a[0]), (value = $a[1]), $a};\n        name = self.$sanitize_attribute_name(name);\n        if (name['$=='](\"numbered\")) {\n          name = \"sectnums\"};\n        if ($truthy(doc)) {\n          if ($truthy(value)) {\n            \n            if (name['$=='](\"leveloffset\")) {\n              if ($truthy(value['$start_with?'](\"+\"))) {\n                value = $rb_plus(doc.$attr(\"leveloffset\", 0).$to_i(), ($truthy($a = value['$[]']($range(1, -1, false))) ? $a : 0).$to_i()).$to_s()\n              } else if ($truthy(value['$start_with?'](\"-\"))) {\n                value = $rb_minus(doc.$attr(\"leveloffset\", 0).$to_i(), ($truthy($a = value['$[]']($range(1, -1, false))) ? $a : 0).$to_i()).$to_s()}};\n            if ($truthy((resolved_value = doc.$set_attribute(name, value)))) {\n              \n              value = resolved_value;\n              if ($truthy(attrs)) {\n                $$$($$($nesting, 'Document'), 'AttributeEntry').$new(name, value).$save_to(attrs)};};\n          } else if ($truthy(($truthy($a = doc.$delete_attribute(name)) ? attrs : $a))) {\n            $$$($$($nesting, 'Document'), 'AttributeEntry').$new(name, value).$save_to(attrs)}\n        } else if ($truthy(attrs)) {\n          $$$($$($nesting, 'Document'), 'AttributeEntry').$new(name, value).$save_to(attrs)};\n        return [name, value];\n      }, TMP_Parser_store_attribute_57.$$arity = -3);\n      Opal.defs(self, '$resolve_list_marker', TMP_Parser_resolve_list_marker_58 = function $$resolve_list_marker(list_type, marker, ordinal, validate, reader) {\n        var self = this;\n\n        if (ordinal == null) {\n          ordinal = 0;\n        }\n        if (validate == null) {\n          validate = false;\n        }\n        if (reader == null) {\n          reader = nil;\n        }\n        if (list_type['$=='](\"olist\")) {\n          if ($truthy(marker['$start_with?'](\".\"))) {\n            return marker\n          } else {\n            \n            return self.$resolve_ordered_list_marker(marker, ordinal, validate, reader);\n          }\n        } else if (list_type['$=='](\"colist\")) {\n          return \"<1>\"\n        } else {\n          return marker\n        }\n      }, TMP_Parser_resolve_list_marker_58.$$arity = -3);\n      Opal.defs(self, '$resolve_ordered_list_marker', TMP_Parser_resolve_ordered_list_marker_60 = function $$resolve_ordered_list_marker(marker, ordinal, validate, reader) {\n        var TMP_59, $a, self = this, expected = nil, actual = nil, $case = nil;\n\n        if (ordinal == null) {\n          ordinal = 0;\n        }\n        if (validate == null) {\n          validate = false;\n        }\n        if (reader == null) {\n          reader = nil;\n        }\n        \n        expected = (actual = nil);\n        $case = $send($$($nesting, 'ORDERED_LIST_STYLES'), 'find', [], (TMP_59 = function(s){var self = TMP_59.$$s || this;\nif (s == null) s = nil;\n        return $$($nesting, 'OrderedListMarkerRxMap')['$[]'](s)['$match?'](marker)}, TMP_59.$$s = self, TMP_59.$$arity = 1, TMP_59));\n        if (\"arabic\"['$===']($case)) {\n        if ($truthy(validate)) {\n          \n          expected = $rb_plus(ordinal, 1);\n          actual = marker.$to_i();};\n        marker = \"1.\";}\n        else if (\"loweralpha\"['$===']($case)) {\n        if ($truthy(validate)) {\n          \n          expected = $rb_plus(\"a\"['$[]'](0).$ord(), ordinal).$chr();\n          actual = marker.$chop();};\n        marker = \"a.\";}\n        else if (\"upperalpha\"['$===']($case)) {\n        if ($truthy(validate)) {\n          \n          expected = $rb_plus(\"A\"['$[]'](0).$ord(), ordinal).$chr();\n          actual = marker.$chop();};\n        marker = \"A.\";}\n        else if (\"lowerroman\"['$===']($case)) {\n        if ($truthy(validate)) {\n          \n          expected = $rb_plus(ordinal, 1);\n          actual = self.$roman_numeral_to_int(marker.$chop());};\n        marker = \"i)\";}\n        else if (\"upperroman\"['$===']($case)) {\n        if ($truthy(validate)) {\n          \n          expected = $rb_plus(ordinal, 1);\n          actual = self.$roman_numeral_to_int(marker.$chop());};\n        marker = \"I)\";};\n        if ($truthy(($truthy($a = validate) ? expected['$!='](actual) : $a))) {\n          self.$warn(\"\" + \"asciidoctor: WARNING: \" + (reader.$line_info()) + \": list item index: expected \" + (expected) + \", got \" + (actual))};\n        return marker;\n      }, TMP_Parser_resolve_ordered_list_marker_60.$$arity = -2);\n      Opal.defs(self, '$is_sibling_list_item?', TMP_Parser_is_sibling_list_item$q_61 = function(line, list_type, sibling_trait) {\n        var self = this, matcher = nil, expected_marker = nil, m = nil;\n\n        \n        if ($truthy($$$('::', 'Regexp')['$==='](sibling_trait))) {\n          \n          matcher = sibling_trait;\n          expected_marker = false;\n        } else {\n          \n          matcher = $$($nesting, 'ListRxMap')['$[]'](list_type);\n          expected_marker = sibling_trait;\n        };\n        if ($truthy((m = matcher.$match(line)))) {\n          if ($truthy(expected_marker)) {\n            return expected_marker['$=='](self.$resolve_list_marker(list_type, m['$[]'](1)))\n          } else {\n            return true\n          }\n        } else {\n          return false\n        };\n      }, TMP_Parser_is_sibling_list_item$q_61.$$arity = 3);\n      Opal.defs(self, '$next_table', TMP_Parser_next_table_62 = function $$next_table(table_reader, parent, attributes) {\n        var $a, $b, $c, $d, self = this, table = nil, $writer = nil, colspecs = nil, explicit_colspecs = nil, skipped = nil, parser_ctx = nil, format = nil, loop_idx = nil, implicit_header_boundary = nil, implicit_header = nil, line = nil, next_cellspec = nil, m = nil, $case = nil, cell_text = nil, $logical_op_recvr_tmp_2 = nil;\n\n        \n        table = $$($nesting, 'Table').$new(parent, attributes);\n        if ($truthy(attributes['$key?'](\"title\"))) {\n          \n          \n          $writer = [attributes.$delete(\"title\")];\n          $send(table, 'title=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          table.$assign_caption(attributes.$delete(\"caption\"));};\n        if ($truthy(($truthy($a = attributes['$key?'](\"cols\")) ? (colspecs = self.$parse_colspecs(attributes['$[]'](\"cols\")))['$empty?']()['$!']() : $a))) {\n          \n          table.$create_columns(colspecs);\n          explicit_colspecs = true;};\n        skipped = ($truthy($a = table_reader.$skip_blank_lines()) ? $a : 0);\n        parser_ctx = $$$($$($nesting, 'Table'), 'ParserContext').$new(table_reader, table, attributes);\n        $a = [parser_ctx.$format(), -1, nil], (format = $a[0]), (loop_idx = $a[1]), (implicit_header_boundary = $a[2]), $a;\n        if ($truthy(($truthy($a = ($truthy($b = $rb_gt(skipped, 0)) ? $b : attributes['$key?'](\"header-option\"))) ? $a : attributes['$key?'](\"noheader-option\")))) {\n        } else {\n          implicit_header = true\n        };\n        $a = false; while ($a || $truthy((line = table_reader.$read_line()))) {$a = false;\n          \n          if ($truthy(($truthy($b = $rb_gt((loop_idx = $rb_plus(loop_idx, 1)), 0)) ? line['$empty?']() : $b))) {\n            \n            line = nil;\n            if ($truthy(implicit_header_boundary)) {\n              implicit_header_boundary = $rb_plus(implicit_header_boundary, 1)};\n          } else if (format['$=='](\"psv\")) {\n            if ($truthy(parser_ctx['$starts_with_delimiter?'](line))) {\n              \n              line = line.$slice(1, line.$length());\n              parser_ctx.$close_open_cell();\n              if ($truthy(implicit_header_boundary)) {\n                implicit_header_boundary = nil};\n            } else {\n              \n              $c = self.$parse_cellspec(line, \"start\", parser_ctx.$delimiter()), $b = Opal.to_ary($c), (next_cellspec = ($b[0] == null ? nil : $b[0])), (line = ($b[1] == null ? nil : $b[1])), $c;\n              if ($truthy(next_cellspec)) {\n                \n                parser_ctx.$close_open_cell(next_cellspec);\n                if ($truthy(implicit_header_boundary)) {\n                  implicit_header_boundary = nil};\n              } else if ($truthy(($truthy($b = implicit_header_boundary) ? implicit_header_boundary['$=='](loop_idx) : $b))) {\n                $b = [false, nil], (implicit_header = $b[0]), (implicit_header_boundary = $b[1]), $b};\n            }};\n          if ($truthy((($b = loop_idx['$=='](0)) ? implicit_header : loop_idx['$=='](0)))) {\n            if ($truthy(($truthy($b = table_reader['$has_more_lines?']()) ? table_reader.$peek_line()['$empty?']() : $b))) {\n              implicit_header_boundary = 1\n            } else {\n              implicit_header = false\n            }};\n          $b = false; while ($b || $truthy(true)) {$b = false;\n            if ($truthy(($truthy($c = line) ? (m = parser_ctx.$match_delimiter(line)) : $c))) {\n              \n              $case = format;\n              if (\"csv\"['$===']($case)) {\n              if ($truthy(parser_ctx['$buffer_has_unclosed_quotes?'](m.$pre_match()))) {\n                \n                if ($truthy((line = parser_ctx.$skip_past_delimiter(m))['$empty?']())) {\n                  break;};\n                $b = true;};\n              \n              $writer = [\"\" + (parser_ctx.$buffer()) + (m.$pre_match())];\n              $send(parser_ctx, 'buffer=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;}\n              else if (\"dsv\"['$===']($case)) {\n              if ($truthy(m.$pre_match()['$end_with?'](\"\\\\\"))) {\n                \n                if ($truthy((line = parser_ctx.$skip_past_escaped_delimiter(m))['$empty?']())) {\n                  \n                  \n                  $writer = [\"\" + (parser_ctx.$buffer()) + ($$($nesting, 'LF'))];\n                  $send(parser_ctx, 'buffer=', Opal.to_a($writer));\n                  $writer[$rb_minus($writer[\"length\"], 1)];;\n                  parser_ctx.$keep_cell_open();\n                  break;;};\n                $b = true;};\n              \n              $writer = [\"\" + (parser_ctx.$buffer()) + (m.$pre_match())];\n              $send(parser_ctx, 'buffer=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;}\n              else {\n              if ($truthy(m.$pre_match()['$end_with?'](\"\\\\\"))) {\n                \n                if ($truthy((line = parser_ctx.$skip_past_escaped_delimiter(m))['$empty?']())) {\n                  \n                  \n                  $writer = [\"\" + (parser_ctx.$buffer()) + ($$($nesting, 'LF'))];\n                  $send(parser_ctx, 'buffer=', Opal.to_a($writer));\n                  $writer[$rb_minus($writer[\"length\"], 1)];;\n                  parser_ctx.$keep_cell_open();\n                  break;;};\n                $b = true;};\n              $d = self.$parse_cellspec(m.$pre_match()), $c = Opal.to_ary($d), (next_cellspec = ($c[0] == null ? nil : $c[0])), (cell_text = ($c[1] == null ? nil : $c[1])), $d;\n              parser_ctx.$push_cellspec(next_cellspec);\n              \n              $writer = [\"\" + (parser_ctx.$buffer()) + (cell_text)];\n              $send(parser_ctx, 'buffer=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;};\n              if ($truthy((line = m.$post_match())['$empty?']())) {\n                line = nil};\n              parser_ctx.$close_cell();\n            } else {\n              \n              \n              $writer = [\"\" + (parser_ctx.$buffer()) + (line) + ($$($nesting, 'LF'))];\n              $send(parser_ctx, 'buffer=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n              $case = format;\n              if (\"csv\"['$===']($case)) {\n              \n              $writer = [\"\" + (parser_ctx.$buffer().$rstrip()) + \" \"];\n              $send(parser_ctx, 'buffer=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n              if ($truthy(parser_ctx['$buffer_has_unclosed_quotes?']())) {\n                \n                if ($truthy(($truthy($c = implicit_header_boundary) ? loop_idx['$=='](0) : $c))) {\n                  $c = [false, nil], (implicit_header = $c[0]), (implicit_header_boundary = $c[1]), $c};\n                parser_ctx.$keep_cell_open();\n              } else {\n                parser_ctx.$close_cell(true)\n              };}\n              else if (\"dsv\"['$===']($case)) {parser_ctx.$close_cell(true)}\n              else {parser_ctx.$keep_cell_open()};\n              break;;\n            }\n          };\n          if ($truthy(parser_ctx['$cell_open?']())) {\n            if ($truthy(table_reader['$has_more_lines?']())) {\n            } else {\n              parser_ctx.$close_cell(true)\n            }\n          } else {\n            if ($truthy($b = table_reader.$skip_blank_lines())) {\n              $b\n            } else {\n              break;\n            }\n          };\n        };\n        if ($truthy(($truthy($a = (($logical_op_recvr_tmp_2 = table.$attributes()), ($truthy($b = $logical_op_recvr_tmp_2['$[]'](\"colcount\")) ? $b : (($writer = [\"colcount\", table.$columns().$size()]), $send($logical_op_recvr_tmp_2, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])))['$=='](0)) ? $a : explicit_colspecs))) {\n        } else {\n          table.$assign_column_widths()\n        };\n        if ($truthy(implicit_header)) {\n          \n          \n          $writer = [true];\n          $send(table, 'has_header_option=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          \n          $writer = [\"header-option\", \"\"];\n          $send(attributes, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          \n          $writer = [\"options\", (function() {if ($truthy(attributes['$key?'](\"options\"))) {\n            return \"\" + (attributes['$[]'](\"options\")) + \",header\"\n          } else {\n            return \"header\"\n          }; return nil; })()];\n          $send(attributes, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;};\n        table.$partition_header_footer(attributes);\n        return table;\n      }, TMP_Parser_next_table_62.$$arity = 3);\n      Opal.defs(self, '$parse_colspecs', TMP_Parser_parse_colspecs_66 = function $$parse_colspecs(records) {\n        var TMP_63, TMP_64, self = this, specs = nil;\n\n        \n        if ($truthy(records['$include?'](\" \"))) {\n          records = records.$delete(\" \")};\n        if (records['$=='](records.$to_i().$to_s())) {\n          return $send($$$('::', 'Array'), 'new', [records.$to_i()], (TMP_63 = function(){var self = TMP_63.$$s || this;\n\n          return $hash2([\"width\"], {\"width\": 1})}, TMP_63.$$s = self, TMP_63.$$arity = 0, TMP_63))};\n        specs = [];\n        $send(records.$split(\",\", -1), 'each', [], (TMP_64 = function(record){var self = TMP_64.$$s || this, $a, $b, TMP_65, m = nil, spec = nil, colspec = nil, rowspec = nil, $writer = nil;\nif (record == null) record = nil;\n        if ($truthy(record['$empty?']())) {\n            return specs['$<<']($hash2([\"width\"], {\"width\": 1}))\n          } else if ($truthy((m = $$($nesting, 'ColumnSpecRx').$match(record)))) {\n            \n            spec = $hash2([], {});\n            if ($truthy(m['$[]'](2))) {\n              \n              $b = m['$[]'](2).$split(\".\"), $a = Opal.to_ary($b), (colspec = ($a[0] == null ? nil : $a[0])), (rowspec = ($a[1] == null ? nil : $a[1])), $b;\n              if ($truthy(($truthy($a = colspec['$nil_or_empty?']()['$!']()) ? $$($nesting, 'TableCellHorzAlignments')['$key?'](colspec) : $a))) {\n                \n                $writer = [\"halign\", $$($nesting, 'TableCellHorzAlignments')['$[]'](colspec)];\n                $send(spec, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];};\n              if ($truthy(($truthy($a = rowspec['$nil_or_empty?']()['$!']()) ? $$($nesting, 'TableCellVertAlignments')['$key?'](rowspec) : $a))) {\n                \n                $writer = [\"valign\", $$($nesting, 'TableCellVertAlignments')['$[]'](rowspec)];\n                $send(spec, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];};};\n            \n            $writer = [\"width\", (function() {if ($truthy(m['$[]'](3))) {\n              return m['$[]'](3).$to_i()\n            } else {\n              return 1\n            }; return nil; })()];\n            $send(spec, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            if ($truthy(($truthy($a = m['$[]'](4)) ? $$($nesting, 'TableCellStyles')['$key?'](m['$[]'](4)) : $a))) {\n              \n              $writer = [\"style\", $$($nesting, 'TableCellStyles')['$[]'](m['$[]'](4))];\n              $send(spec, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];};\n            if ($truthy(m['$[]'](1))) {\n              return $send((1), 'upto', [m['$[]'](1).$to_i()], (TMP_65 = function(){var self = TMP_65.$$s || this;\n\n              return specs['$<<'](spec.$dup())}, TMP_65.$$s = self, TMP_65.$$arity = 0, TMP_65))\n            } else {\n              return specs['$<<'](spec)\n            };\n          } else {\n            return nil\n          }}, TMP_64.$$s = self, TMP_64.$$arity = 1, TMP_64));\n        return specs;\n      }, TMP_Parser_parse_colspecs_66.$$arity = 1);\n      Opal.defs(self, '$parse_cellspec', TMP_Parser_parse_cellspec_67 = function $$parse_cellspec(line, pos, delimiter) {\n        var $a, $b, self = this, m = nil, rest = nil, spec_part = nil, spec = nil, colspec = nil, rowspec = nil, $writer = nil;\n\n        if (pos == null) {\n          pos = \"end\";\n        }\n        if (delimiter == null) {\n          delimiter = nil;\n        }\n        \n        $a = [nil, \"\"], (m = $a[0]), (rest = $a[1]), $a;\n        if (pos['$=='](\"start\")) {\n          if ($truthy(line['$include?'](delimiter))) {\n            \n            $b = line.$split(delimiter, 2), $a = Opal.to_ary($b), (spec_part = ($a[0] == null ? nil : $a[0])), (rest = ($a[1] == null ? nil : $a[1])), $b;\n            if ($truthy((m = $$($nesting, 'CellSpecStartRx').$match(spec_part)))) {\n              if ($truthy(m['$[]'](0)['$empty?']())) {\n                return [$hash2([], {}), rest]}\n            } else {\n              return [nil, line]\n            };\n          } else {\n            return [nil, line]\n          }\n        } else if ($truthy((m = $$($nesting, 'CellSpecEndRx').$match(line)))) {\n          \n          if ($truthy(m['$[]'](0).$lstrip()['$empty?']())) {\n            return [$hash2([], {}), line.$rstrip()]};\n          rest = m.$pre_match();\n        } else {\n          return [$hash2([], {}), line]\n        };\n        spec = $hash2([], {});\n        if ($truthy(m['$[]'](1))) {\n          \n          $b = m['$[]'](1).$split(\".\"), $a = Opal.to_ary($b), (colspec = ($a[0] == null ? nil : $a[0])), (rowspec = ($a[1] == null ? nil : $a[1])), $b;\n          colspec = (function() {if ($truthy(colspec['$nil_or_empty?']())) {\n            return 1\n          } else {\n            return colspec.$to_i()\n          }; return nil; })();\n          rowspec = (function() {if ($truthy(rowspec['$nil_or_empty?']())) {\n            return 1\n          } else {\n            return rowspec.$to_i()\n          }; return nil; })();\n          if (m['$[]'](2)['$=='](\"+\")) {\n            \n            if (colspec['$=='](1)) {\n            } else {\n              \n              $writer = [\"colspan\", colspec];\n              $send(spec, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];\n            };\n            if (rowspec['$=='](1)) {\n            } else {\n              \n              $writer = [\"rowspan\", rowspec];\n              $send(spec, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];\n            };\n          } else if (m['$[]'](2)['$=='](\"*\")) {\n            if (colspec['$=='](1)) {\n            } else {\n              \n              $writer = [\"repeatcol\", colspec];\n              $send(spec, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];\n            }};};\n        if ($truthy(m['$[]'](3))) {\n          \n          $b = m['$[]'](3).$split(\".\"), $a = Opal.to_ary($b), (colspec = ($a[0] == null ? nil : $a[0])), (rowspec = ($a[1] == null ? nil : $a[1])), $b;\n          if ($truthy(($truthy($a = colspec['$nil_or_empty?']()['$!']()) ? $$($nesting, 'TableCellHorzAlignments')['$key?'](colspec) : $a))) {\n            \n            $writer = [\"halign\", $$($nesting, 'TableCellHorzAlignments')['$[]'](colspec)];\n            $send(spec, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];};\n          if ($truthy(($truthy($a = rowspec['$nil_or_empty?']()['$!']()) ? $$($nesting, 'TableCellVertAlignments')['$key?'](rowspec) : $a))) {\n            \n            $writer = [\"valign\", $$($nesting, 'TableCellVertAlignments')['$[]'](rowspec)];\n            $send(spec, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];};};\n        if ($truthy(($truthy($a = m['$[]'](4)) ? $$($nesting, 'TableCellStyles')['$key?'](m['$[]'](4)) : $a))) {\n          \n          $writer = [\"style\", $$($nesting, 'TableCellStyles')['$[]'](m['$[]'](4))];\n          $send(spec, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];};\n        return [spec, rest];\n      }, TMP_Parser_parse_cellspec_67.$$arity = -2);\n      Opal.defs(self, '$parse_style_attribute', TMP_Parser_parse_style_attribute_71 = function $$parse_style_attribute(attributes, reader) {\n        var $a, $b, TMP_68, TMP_69, TMP_70, self = this, raw_style = nil, type = nil, collector = nil, parsed = nil, save_current = nil, $writer = nil, parsed_style = nil, options = nil, existing_opts = nil;\n\n        if (reader == null) {\n          reader = nil;\n        }\n        if ($truthy(($truthy($a = ($truthy($b = (raw_style = attributes['$[]'](1))) ? raw_style['$include?'](\" \")['$!']() : $b)) ? $$($nesting, 'Compliance').$shorthand_property_syntax() : $a))) {\n          \n          $a = [\"style\", [], $hash2([], {})], (type = $a[0]), (collector = $a[1]), (parsed = $a[2]), $a;\n          save_current = $send(self, 'lambda', [], (TMP_68 = function(){var self = TMP_68.$$s || this, $c, $case = nil, $writer = nil;\n\n          if ($truthy(collector['$empty?']())) {\n              if (type['$=='](\"style\")) {\n                return nil\n              } else {\n                return self.$warn(\"\" + \"asciidoctor: WARNING:\" + ((function() {if ($truthy(reader)) {\n                  return \"\" + \" \" + (reader.$prev_line_info()) + \":\"\n                } else {\n                  return nil\n                }; return nil; })()) + \" invalid empty \" + (type) + \" detected in style attribute\")\n              }\n            } else {\n              \n              $case = type;\n              if (\"role\"['$===']($case) || \"option\"['$===']($case)) {($truthy($c = parsed['$[]'](type)) ? $c : (($writer = [type, []]), $send(parsed, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))['$<<'](collector.$join())}\n              else if (\"id\"['$===']($case)) {\n              if ($truthy(parsed['$key?'](\"id\"))) {\n                self.$warn(\"\" + \"asciidoctor: WARNING:\" + ((function() {if ($truthy(reader)) {\n                  return \"\" + \" \" + (reader.$prev_line_info()) + \":\"\n                } else {\n                  return nil\n                }; return nil; })()) + \" multiple ids detected in style attribute\")};\n              \n              $writer = [type, collector.$join()];\n              $send(parsed, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;}\n              else {\n              $writer = [type, collector.$join()];\n              $send(parsed, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];};\n              return (collector = []);\n            }}, TMP_68.$$s = self, TMP_68.$$arity = 0, TMP_68));\n          $send(raw_style, 'each_char', [], (TMP_69 = function(c){var self = TMP_69.$$s || this, $c, $d, $case = nil;\nif (c == null) c = nil;\n          if ($truthy(($truthy($c = ($truthy($d = c['$=='](\".\")) ? $d : c['$=='](\"#\"))) ? $c : c['$=='](\"%\")))) {\n              \n              save_current.$call();\n              return (function() {$case = c;\n              if (\".\"['$===']($case)) {return (type = \"role\")}\n              else if (\"#\"['$===']($case)) {return (type = \"id\")}\n              else if (\"%\"['$===']($case)) {return (type = \"option\")}\n              else { return nil }})();\n            } else {\n              return collector['$<<'](c)\n            }}, TMP_69.$$s = self, TMP_69.$$arity = 1, TMP_69));\n          if (type['$=='](\"style\")) {\n            \n            $writer = [\"style\", raw_style];\n            $send(attributes, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];\n          } else {\n            \n            save_current.$call();\n            if ($truthy(parsed['$key?'](\"style\"))) {\n              parsed_style = (($writer = [\"style\", parsed['$[]'](\"style\")]), $send(attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])};\n            if ($truthy(parsed['$key?'](\"id\"))) {\n              \n              $writer = [\"id\", parsed['$[]'](\"id\")];\n              $send(attributes, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];};\n            if ($truthy(parsed['$key?'](\"role\"))) {\n              \n              $writer = [\"role\", $rb_times(parsed['$[]'](\"role\"), \" \")];\n              $send(attributes, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];};\n            if ($truthy(parsed['$key?'](\"option\"))) {\n              \n              $send((options = parsed['$[]'](\"option\")), 'each', [], (TMP_70 = function(option){var self = TMP_70.$$s || this;\nif (option == null) option = nil;\n              \n                $writer = [\"\" + (option) + \"-option\", \"\"];\n                $send(attributes, '[]=', Opal.to_a($writer));\n                return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_70.$$s = self, TMP_70.$$arity = 1, TMP_70));\n              if ($truthy((existing_opts = attributes['$[]'](\"options\")))) {\n                \n                $writer = [\"options\", $rb_times($rb_plus(options, existing_opts.$split(\",\")), \",\")];\n                $send(attributes, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];\n              } else {\n                \n                $writer = [\"options\", $rb_times(options, \",\")];\n                $send(attributes, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];\n              };};\n            return parsed_style;\n          };\n        } else {\n          \n          $writer = [\"style\", raw_style];\n          $send(attributes, '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];\n        }\n      }, TMP_Parser_parse_style_attribute_71.$$arity = -2);\n      Opal.defs(self, '$adjust_indentation!', TMP_Parser_adjust_indentation$B_79 = function(lines, indent, tab_size) {\n        var $a, TMP_72, TMP_75, TMP_76, TMP_77, TMP_78, self = this, full_tab_space = nil, gutter_width = nil, padding = nil;\n\n        if (indent == null) {\n          indent = 0;\n        }\n        if (tab_size == null) {\n          tab_size = 0;\n        }\n        \n        if ($truthy(lines['$empty?']())) {\n          return nil};\n        if ($truthy(($truthy($a = $rb_gt((tab_size = tab_size.$to_i()), 0)) ? lines.$join()['$include?']($$($nesting, 'TAB')) : $a))) {\n          \n          full_tab_space = $rb_times(\" \", tab_size);\n          $send(lines, 'map!', [], (TMP_72 = function(line){var self = TMP_72.$$s || this, TMP_73, TMP_74, spaces_added = nil;\nif (line == null) line = nil;\n          \n            if ($truthy(line['$empty?']())) {\n              return line;};\n            if ($truthy(line['$start_with?']($$($nesting, 'TAB')))) {\n              line = $send(line, 'sub', [$$($nesting, 'TabIndentRx')], (TMP_73 = function(){var self = TMP_73.$$s || this, $b;\n\n              return $rb_times(full_tab_space, (($b = $gvars['~']) === nil ? nil : $b['$[]'](0)).$length())}, TMP_73.$$s = self, TMP_73.$$arity = 0, TMP_73))};\n            if ($truthy(line['$include?']($$($nesting, 'TAB')))) {\n              \n              spaces_added = 0;\n              return line = $send(line, 'gsub', [$$($nesting, 'TabRx')], (TMP_74 = function(){var self = TMP_74.$$s || this, offset = nil, spaces = nil;\n                if ($gvars[\"~\"] == null) $gvars[\"~\"] = nil;\n\n              if ((offset = $rb_plus($gvars[\"~\"].$begin(0), spaces_added))['$%'](tab_size)['$=='](0)) {\n                  \n                  spaces_added = $rb_plus(spaces_added, $rb_minus(tab_size, 1));\n                  return full_tab_space;\n                } else {\n                  \n                  if ((spaces = $rb_minus(tab_size, offset['$%'](tab_size)))['$=='](1)) {\n                  } else {\n                    spaces_added = $rb_plus(spaces_added, $rb_minus(spaces, 1))\n                  };\n                  return $rb_times(\" \", spaces);\n                }}, TMP_74.$$s = self, TMP_74.$$arity = 0, TMP_74));\n            } else {\n              return line\n            };}, TMP_72.$$s = self, TMP_72.$$arity = 1, TMP_72));};\n        if ($truthy(($truthy($a = indent) ? $rb_gt((indent = indent.$to_i()), -1) : $a))) {\n        } else {\n          return nil\n        };\n        gutter_width = nil;\n        (function(){var $brk = Opal.new_brk(); try {return $send(lines, 'each', [], (TMP_75 = function(line){var self = TMP_75.$$s || this, $b, line_indent = nil;\nif (line == null) line = nil;\n        \n          if ($truthy(line['$empty?']())) {\n            return nil;};\n          if ((line_indent = $rb_minus(line.$length(), line.$lstrip().$length()))['$=='](0)) {\n            \n            gutter_width = nil;\n            \n            Opal.brk(nil, $brk);\n          } else if ($truthy(($truthy($b = gutter_width) ? $rb_gt(line_indent, gutter_width) : $b))) {\n            return nil\n          } else {\n            return (gutter_width = line_indent)\n          };}, TMP_75.$$s = self, TMP_75.$$brk = $brk, TMP_75.$$arity = 1, TMP_75))\n        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();\n        if (indent['$=='](0)) {\n          if ($truthy(gutter_width)) {\n            $send(lines, 'map!', [], (TMP_76 = function(line){var self = TMP_76.$$s || this;\nif (line == null) line = nil;\n            if ($truthy(line['$empty?']())) {\n                return line\n              } else {\n                return line['$[]'](Opal.Range.$new(gutter_width, -1, false))\n              }}, TMP_76.$$s = self, TMP_76.$$arity = 1, TMP_76))}\n        } else {\n          \n          padding = $rb_times(\" \", indent);\n          if ($truthy(gutter_width)) {\n            $send(lines, 'map!', [], (TMP_77 = function(line){var self = TMP_77.$$s || this;\nif (line == null) line = nil;\n            if ($truthy(line['$empty?']())) {\n                return line\n              } else {\n                return $rb_plus(padding, line['$[]'](Opal.Range.$new(gutter_width, -1, false)))\n              }}, TMP_77.$$s = self, TMP_77.$$arity = 1, TMP_77))\n          } else {\n            $send(lines, 'map!', [], (TMP_78 = function(line){var self = TMP_78.$$s || this;\nif (line == null) line = nil;\n            if ($truthy(line['$empty?']())) {\n                return line\n              } else {\n                return $rb_plus(padding, line)\n              }}, TMP_78.$$s = self, TMP_78.$$arity = 1, TMP_78))\n          };\n        };\n        return nil;\n      }, TMP_Parser_adjust_indentation$B_79.$$arity = -2);\n      Opal.defs(self, '$sanitize_attribute_name', TMP_Parser_sanitize_attribute_name_80 = function $$sanitize_attribute_name(name) {\n        var self = this;\n\n        return name.$gsub($$($nesting, 'InvalidAttributeNameCharsRx'), \"\").$downcase()\n      }, TMP_Parser_sanitize_attribute_name_80.$$arity = 1);\n      return (Opal.defs(self, '$roman_numeral_to_int', TMP_Parser_roman_numeral_to_int_82 = function $$roman_numeral_to_int(value) {\n        var TMP_81, self = this, digits = nil, result = nil;\n\n        \n        value = value.$downcase();\n        digits = $hash2([\"i\", \"v\", \"x\"], {\"i\": 1, \"v\": 5, \"x\": 10});\n        result = 0;\n        $send(Opal.Range.$new(0, $rb_minus(value.$length(), 1), false), 'each', [], (TMP_81 = function(i){var self = TMP_81.$$s || this, $a, digit = nil;\nif (i == null) i = nil;\n        \n          digit = digits['$[]'](value['$[]'](Opal.Range.$new(i, i, false)));\n          if ($truthy(($truthy($a = $rb_lt($rb_plus(i, 1), value.$length())) ? $rb_gt(digits['$[]'](value['$[]'](Opal.Range.$new($rb_plus(i, 1), $rb_plus(i, 1), false))), digit) : $a))) {\n            return (result = $rb_minus(result, digit))\n          } else {\n            return (result = $rb_plus(result, digit))\n          };}, TMP_81.$$s = self, TMP_81.$$arity = 1, TMP_81));\n        return result;\n      }, TMP_Parser_roman_numeral_to_int_82.$$arity = 1), nil) && 'roman_numeral_to_int';\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/path_resolver\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $range = Opal.range, $send = Opal.send;\n\n  Opal.add_stubs(['$attr_accessor', '$root?', '$expand_path', '$pwd', '$start_with?', '$==', '$match?', '$absolute_path?', '$+', '$length', '$nil_or_empty?', '$include?', '$tr', '$partition_path', '$join_path', '$[]', '$posixify', '$web_root?', '$unc?', '$slice', '$index', '$split', '$shift', '$delete', '$[]=', '$-', '$*', '$raise', '$empty?', '$system_path', '$!=', '$!', '$dup', '$each', '$>', '$size', '$pop', '$fetch', '$warn', '$<<', '$end_with?', '$uri_prefix', '$gsub']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $PathResolver(){};\n      var self = $PathResolver = $klass($base, $super, 'PathResolver', $PathResolver);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_PathResolver_initialize_1, TMP_PathResolver_absolute_path$q_2, $a, TMP_PathResolver_root$q_3, TMP_PathResolver_unc$q_4, TMP_PathResolver_web_root$q_5, TMP_PathResolver_descends_from$q_6, TMP_PathResolver_posixify_7, TMP_PathResolver_expand_path_8, TMP_PathResolver_partition_path_9, TMP_PathResolver_join_path_10, TMP_PathResolver_system_path_12, TMP_PathResolver_web_path_14, TMP_PathResolver_relative_path_15;\n\n      def.file_separator = def._partition_path_web = def._partition_path_sys = def.working_dir = nil;\n      \n      Opal.const_set($nesting[0], 'DOT', \".\");\n      Opal.const_set($nesting[0], 'DOT_DOT', \"..\");\n      Opal.const_set($nesting[0], 'DOT_SLASH', \"./\");\n      Opal.const_set($nesting[0], 'SLASH', \"/\");\n      Opal.const_set($nesting[0], 'BACKSLASH', \"\\\\\");\n      Opal.const_set($nesting[0], 'DOUBLE_SLASH', \"//\");\n      Opal.const_set($nesting[0], 'WindowsRootRx', /^[a-zA-Z]:(?:\\\\|\\/)/);\n      self.$attr_accessor(\"file_separator\");\n      self.$attr_accessor(\"working_dir\");\n      \n      Opal.def(self, '$initialize', TMP_PathResolver_initialize_1 = function $$initialize(file_separator, working_dir) {\n        var $a, self = this;\n\n        if (file_separator == null) {\n          file_separator = nil;\n        }\n        if (working_dir == null) {\n          working_dir = nil;\n        }\n        \n        self.file_separator = (function() {if ($truthy(file_separator)) {\n          return file_separator\n        } else {\n          \n          return ($truthy($a = $$$($$$('::', 'File'), 'ALT_SEPARATOR')) ? $a : $$$($$$('::', 'File'), 'SEPARATOR'));\n        }; return nil; })();\n        if ($truthy(working_dir)) {\n          self.working_dir = (function() {if ($truthy(self['$root?'](working_dir))) {\n            return working_dir\n          } else {\n            \n            return $$$('::', 'File').$expand_path(working_dir);\n          }; return nil; })()\n        } else {\n          self.working_dir = $$$('::', 'File').$expand_path($$$('::', 'Dir').$pwd())\n        };\n        return $a = [$hash2([], {}), $hash2([], {})], (self._partition_path_sys = $a[0]), (self._partition_path_web = $a[1]), $a;\n      }, TMP_PathResolver_initialize_1.$$arity = -1);\n      \n      Opal.def(self, '$absolute_path?', TMP_PathResolver_absolute_path$q_2 = function(path) {\n        var $a, $b, self = this;\n\n        return ($truthy($a = path['$start_with?']($$($nesting, 'SLASH'))) ? $a : (($b = self.file_separator['$==']($$($nesting, 'BACKSLASH'))) ? $$($nesting, 'WindowsRootRx')['$match?'](path) : self.file_separator['$==']($$($nesting, 'BACKSLASH'))))\n      }, TMP_PathResolver_absolute_path$q_2.$$arity = 1);\n      if ($truthy((($a = $$($nesting, 'RUBY_ENGINE')['$=='](\"opal\")) ? $$$('::', 'JAVASCRIPT_IO_MODULE')['$=='](\"xmlhttprequest\") : $$($nesting, 'RUBY_ENGINE')['$=='](\"opal\")))) {\n        \n        Opal.def(self, '$root?', TMP_PathResolver_root$q_3 = function(path) {\n          var $a, self = this;\n\n          return ($truthy($a = self['$absolute_path?'](path)) ? $a : path['$start_with?'](\"file://\", \"http://\", \"https://\"))\n        }, TMP_PathResolver_root$q_3.$$arity = 1)\n      } else {\n        Opal.alias(self, \"root?\", \"absolute_path?\")\n      };\n      \n      Opal.def(self, '$unc?', TMP_PathResolver_unc$q_4 = function(path) {\n        var self = this;\n\n        return path['$start_with?']($$($nesting, 'DOUBLE_SLASH'))\n      }, TMP_PathResolver_unc$q_4.$$arity = 1);\n      \n      Opal.def(self, '$web_root?', TMP_PathResolver_web_root$q_5 = function(path) {\n        var self = this;\n\n        return path['$start_with?']($$($nesting, 'SLASH'))\n      }, TMP_PathResolver_web_root$q_5.$$arity = 1);\n      \n      Opal.def(self, '$descends_from?', TMP_PathResolver_descends_from$q_6 = function(path, base) {\n        var self = this;\n\n        if (base['$=='](path)) {\n          return 0\n        } else {\n          \n          if ($truthy(path['$start_with?']($rb_plus(base, \"/\")))) {\n            return $rb_plus(base.$length(), 1)\n          } else {\n            return false\n          };\n        }\n      }, TMP_PathResolver_descends_from$q_6.$$arity = 2);\n      \n      Opal.def(self, '$posixify', TMP_PathResolver_posixify_7 = function $$posixify(path) {\n        var self = this;\n\n        if ($truthy(path['$nil_or_empty?']())) {\n          return \"\"\n        } else if ($truthy(path['$include?']($$($nesting, 'BACKSLASH')))) {\n          return path.$tr($$($nesting, 'BACKSLASH'), $$($nesting, 'SLASH'))\n        } else {\n          return path\n        }\n      }, TMP_PathResolver_posixify_7.$$arity = 1);\n      Opal.alias(self, \"posixfy\", \"posixify\");\n      \n      Opal.def(self, '$expand_path', TMP_PathResolver_expand_path_8 = function $$expand_path(path) {\n        var $a, $b, self = this, path_segments = nil, path_root = nil, _ = nil;\n\n        \n        $b = self.$partition_path(path), $a = Opal.to_ary($b), (path_segments = ($a[0] == null ? nil : $a[0])), (path_root = ($a[1] == null ? nil : $a[1])), (_ = ($a[2] == null ? nil : $a[2])), $b;\n        return self.$join_path(path_segments, path_root);\n      }, TMP_PathResolver_expand_path_8.$$arity = 1);\n      \n      Opal.def(self, '$partition_path', TMP_PathResolver_partition_path_9 = function $$partition_path(path, web) {\n        var self = this, result = nil, cache = nil, posix_path = nil, root = nil, path_segments = nil, $writer = nil;\n\n        if (web == null) {\n          web = nil;\n        }\n        \n        if ($truthy((result = (cache = (function() {if ($truthy(web)) {\n          return self._partition_path_web\n        } else {\n          return self._partition_path_sys\n        }; return nil; })())['$[]'](path)))) {\n          return result};\n        posix_path = self.$posixify(path);\n        root = (function() {if ($truthy(web)) {\n          if ($truthy(self['$web_root?'](posix_path))) {\n            return $$($nesting, 'SLASH')\n          } else if ($truthy(posix_path['$start_with?']($$($nesting, 'DOT_SLASH')))) {\n            return $$($nesting, 'DOT_SLASH')\n          } else {\n            return nil\n          }\n        } else if ($truthy(self['$root?'](posix_path))) {\n          if ($truthy(self['$unc?'](posix_path))) {\n            return $$($nesting, 'DOUBLE_SLASH')\n          } else if ($truthy(posix_path['$start_with?']($$($nesting, 'SLASH')))) {\n            return $$($nesting, 'SLASH')\n          } else {\n            return posix_path.$slice(0, $rb_plus(posix_path.$index($$($nesting, 'SLASH')), 1))\n          }\n        } else if ($truthy(posix_path['$start_with?']($$($nesting, 'DOT_SLASH')))) {\n          return $$($nesting, 'DOT_SLASH')\n        } else {\n          return nil\n        }; return nil; })();\n        path_segments = posix_path.$split($$($nesting, 'SLASH'));\n        if (root['$==']($$($nesting, 'DOUBLE_SLASH'))) {\n          path_segments = path_segments['$[]']($range(2, -1, false))\n        } else if ($truthy(root)) {\n          path_segments.$shift()};\n        path_segments.$delete($$($nesting, 'DOT'));\n        \n        $writer = [path, [path_segments, root, posix_path]];\n        $send(cache, '[]=', Opal.to_a($writer));\n        return $writer[$rb_minus($writer[\"length\"], 1)];;\n      }, TMP_PathResolver_partition_path_9.$$arity = -2);\n      \n      Opal.def(self, '$join_path', TMP_PathResolver_join_path_10 = function $$join_path(segments, root) {\n        var self = this;\n\n        if (root == null) {\n          root = nil;\n        }\n        if ($truthy(root)) {\n          return \"\" + (root) + ($rb_times(segments, $$($nesting, 'SLASH')))\n        } else {\n          return $rb_times(segments, $$($nesting, 'SLASH'))\n        }\n      }, TMP_PathResolver_join_path_10.$$arity = -2);\n      \n      Opal.def(self, '$system_path', TMP_PathResolver_system_path_12 = function $$system_path(target, start, jail, opts) {\n        var $a, $b, TMP_11, self = this, target_segments = nil, target_root = nil, _ = nil, resolved_target = nil, jail_segments = nil, jail_root = nil, start_segments = nil, start_root = nil, resolved_segments = nil, warned = nil;\n\n        if (start == null) {\n          start = nil;\n        }\n        if (jail == null) {\n          jail = nil;\n        }\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        \n        if ($truthy(jail)) {\n          \n          if ($truthy(self['$root?'](jail))) {\n          } else {\n            self.$raise($$$('::', 'SecurityError'), \"\" + \"Jail is not an absolute path: \" + (jail))\n          };\n          jail = self.$posixify(jail);};\n        if ($truthy(target['$nil_or_empty?']())) {\n          target_segments = []\n        } else {\n          $b = self.$partition_path(target), $a = Opal.to_ary($b), (target_segments = ($a[0] == null ? nil : $a[0])), (target_root = ($a[1] == null ? nil : $a[1])), (_ = ($a[2] == null ? nil : $a[2])), $b\n        };\n        if ($truthy(target_segments['$empty?']())) {\n          if ($truthy(start['$nil_or_empty?']())) {\n            return (function() {if ($truthy(jail)) {\n              return jail\n            } else {\n              return self.working_dir\n            }; return nil; })()\n          } else if ($truthy(self['$root?'](start))) {\n            if ($truthy(jail)) {\n            } else {\n              return self.$expand_path(start)\n            }\n          } else {\n            return self.$system_path(start, jail, jail, opts)\n          }};\n        if ($truthy(($truthy($a = target_root) ? target_root['$!=']($$($nesting, 'DOT_SLASH')) : $a))) {\n          \n          resolved_target = self.$join_path(target_segments, target_root);\n          if ($truthy(($truthy($a = jail['$!']()) ? $a : resolved_target['$start_with?'](jail)))) {\n            return resolved_target};};\n        if ($truthy(start['$nil_or_empty?']())) {\n          start = (function() {if ($truthy(jail)) {\n            return jail\n          } else {\n            return self.working_dir\n          }; return nil; })()\n        } else if ($truthy(self['$root?'](start))) {\n          start = self.$posixify(start)\n        } else {\n          start = self.$system_path(start, jail, jail, opts)\n        };\n        if (jail['$=='](start)) {\n          \n          $b = self.$partition_path(jail), $a = Opal.to_ary($b), (jail_segments = ($a[0] == null ? nil : $a[0])), (jail_root = ($a[1] == null ? nil : $a[1])), (_ = ($a[2] == null ? nil : $a[2])), $b;\n          start_segments = jail_segments.$dup();\n        } else if ($truthy(jail)) {\n          \n          if ($truthy(start['$start_with?'](jail))) {\n          } else {\n            self.$raise($$$('::', 'SecurityError'), \"\" + (($truthy($a = opts['$[]'](\"target_name\")) ? $a : \"Start path\")) + \" \" + (start) + \" is outside of jail: \" + (jail) + \" (disallowed in safe mode)\")\n          };\n          $b = self.$partition_path(start), $a = Opal.to_ary($b), (start_segments = ($a[0] == null ? nil : $a[0])), (start_root = ($a[1] == null ? nil : $a[1])), (_ = ($a[2] == null ? nil : $a[2])), $b;\n          $b = self.$partition_path(jail), $a = Opal.to_ary($b), (jail_segments = ($a[0] == null ? nil : $a[0])), (jail_root = ($a[1] == null ? nil : $a[1])), (_ = ($a[2] == null ? nil : $a[2])), $b;\n        } else {\n          \n          $b = self.$partition_path(start), $a = Opal.to_ary($b), (start_segments = ($a[0] == null ? nil : $a[0])), (start_root = ($a[1] == null ? nil : $a[1])), (_ = ($a[2] == null ? nil : $a[2])), $b;\n          jail_root = start_root;\n        };\n        resolved_segments = start_segments.$dup();\n        warned = false;\n        $send(target_segments, 'each', [], (TMP_11 = function(segment){var self = TMP_11.$$s || this, $c, recover = nil;\nif (segment == null) segment = nil;\n        if (segment['$==']($$($nesting, 'DOT_DOT'))) {\n            if ($truthy(jail)) {\n              if ($truthy($rb_gt(resolved_segments.$size(), jail_segments.$size()))) {\n                return resolved_segments.$pop()\n              } else if ($truthy((recover = ($truthy($c = recover) ? $c : opts.$fetch(\"recover\", true)))['$!']())) {\n                return self.$raise($$$('::', 'SecurityError'), \"\" + (($truthy($c = opts['$[]'](\"target_name\")) ? $c : \"path\")) + \" \" + (target) + \" refers to location outside jail: \" + (jail) + \" (disallowed in safe mode)\")\n              } else if ($truthy(warned['$!']())) {\n                \n                self.$warn(\"\" + \"asciidoctor: WARNING: \" + (($truthy($c = opts['$[]'](\"target_name\")) ? $c : \"path\")) + \" has illegal reference to ancestor of jail, auto-recovering\");\n                return (warned = true);\n              } else {\n                return nil\n              }\n            } else {\n              return resolved_segments.$pop()\n            }\n          } else {\n            return resolved_segments['$<<'](segment)\n          }}, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11));\n        return self.$join_path(resolved_segments, jail_root);\n      }, TMP_PathResolver_system_path_12.$$arity = -2);\n      \n      Opal.def(self, '$web_path', TMP_PathResolver_web_path_14 = function $$web_path(target, start) {\n        var $a, $b, TMP_13, self = this, uri_prefix = nil, target_segments = nil, target_root = nil, _ = nil, resolved_segments = nil, resolved_path = nil;\n\n        if (start == null) {\n          start = nil;\n        }\n        \n        target = self.$posixify(target);\n        start = self.$posixify(start);\n        uri_prefix = nil;\n        if ($truthy(($truthy($a = start['$nil_or_empty?']()) ? $a : self['$web_root?'](target)))) {\n        } else {\n          \n          target = (function() {if ($truthy(start['$end_with?']($$($nesting, 'SLASH')))) {\n            return \"\" + (start) + (target)\n          } else {\n            return \"\" + (start) + ($$($nesting, 'SLASH')) + (target)\n          }; return nil; })();\n          if ($truthy((uri_prefix = $$($nesting, 'Helpers').$uri_prefix(target)))) {\n            target = target['$[]'](Opal.Range.$new(uri_prefix.$length(), -1, false))};\n        };\n        $b = self.$partition_path(target, true), $a = Opal.to_ary($b), (target_segments = ($a[0] == null ? nil : $a[0])), (target_root = ($a[1] == null ? nil : $a[1])), (_ = ($a[2] == null ? nil : $a[2])), $b;\n        resolved_segments = [];\n        $send(target_segments, 'each', [], (TMP_13 = function(segment){var self = TMP_13.$$s || this, $c;\nif (segment == null) segment = nil;\n        if (segment['$==']($$($nesting, 'DOT_DOT'))) {\n            if ($truthy(resolved_segments['$empty?']())) {\n              if ($truthy(($truthy($c = target_root) ? target_root['$!=']($$($nesting, 'DOT_SLASH')) : $c))) {\n                return nil\n              } else {\n                return resolved_segments['$<<'](segment)\n              }\n            } else if (resolved_segments['$[]'](-1)['$==']($$($nesting, 'DOT_DOT'))) {\n              return resolved_segments['$<<'](segment)\n            } else {\n              return resolved_segments.$pop()\n            }\n          } else {\n            return resolved_segments['$<<'](segment)\n          }}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13));\n        if ($truthy((resolved_path = self.$join_path(resolved_segments, target_root))['$include?'](\" \"))) {\n          resolved_path = resolved_path.$gsub(\" \", \"%20\")};\n        if ($truthy(uri_prefix)) {\n          return \"\" + (uri_prefix) + (resolved_path)\n        } else {\n          return resolved_path\n        };\n      }, TMP_PathResolver_web_path_14.$$arity = -2);\n      return (Opal.def(self, '$relative_path', TMP_PathResolver_relative_path_15 = function $$relative_path(filename, base_directory) {\n        var $a, self = this;\n\n        if ($truthy(($truthy($a = self['$root?'](filename)) ? filename['$start_with?'](base_directory) : $a))) {\n          return filename.$slice($rb_plus(base_directory.$length(), 1), filename.$length())\n        } else {\n          return filename\n        }\n      }, TMP_PathResolver_relative_path_15.$$arity = 2), nil) && 'relative_path';\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/reader\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $range = Opal.range, $send = Opal.send, $gvars = Opal.gvars, $hash = Opal.hash;\n\n  Opal.add_stubs(['$attr_accessor', '$path', '$lineno', '$attr_reader', '$!', '$===', '$split', '$file', '$dir', '$dirname', '$==', '$basename', '$prepare_lines', '$dup', '$[]', '$normalize_lines_from_string', '$normalize_lines_array', '$+', '$empty?', '$nil_or_empty?', '$peek_line', '$>', '$process_line', '$times', '$shift', '$read_line', '$<<', '$-', '$unshift_all', '$has_more_lines?', '$*', '$read_lines', '$unshift', '$start_with?', '$length', '$push', '$read_lines_until', '$size', '$clear', '$[]=', '$new', '$line_info', '$to_i', '$fetch', '$attributes', '$<', '$catalog', '$key?', '$skip_front_matter!', '$pop', '$adjust_indentation!', '$attr', '$end_with?', '$include?', '$=~', '$preprocess_conditional_directive', '$preprocess_include_directive', '$strip', '$pop_include', '$downcase', '$warn', '$none?', '$any?', '$all?', '$resolve_expr_val', '$send', '$to_sym', '$replace_next_line', '$rstrip', '$sub_attributes', '$attribute_missing', '$include_processors?', '$find', '$handles?', '$instance', '$process_method', '$parse', '$>=', '$safe', '$resolve_include_path', '$each', '$map', '$/', '$concat', '$to_a', '$uniq', '$sort', '$slice', '$open', '$each_line', '$infinite?', '$push_include', '$delete', '$value?', '$rindex', '$force_encoding', '$chomp', '$delete_at', '$nil?', '$keys', '$read', '$uriish?', '$require_library', '$normalize_system_path', '$file?', '$relative_path', '$base_dir', '$extname', '$rootname', '$<=', '$!=', '$to_f', '$extensions?', '$extensions', '$include_processors', '$class', '$object_id', '$inspect', '$to_s']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    \n    (function($base, $super, $parent_nesting) {\n      function $Reader(){};\n      var self = $Reader = $klass($base, $super, 'Reader', $Reader);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Reader_initialize_3, TMP_Reader_prepare_lines_4, TMP_Reader_process_line_5, TMP_Reader_has_more_lines$q_6, TMP_Reader_empty$q_7, TMP_Reader_next_line_empty$q_8, TMP_Reader_peek_line_9, TMP_Reader_peek_lines_11, TMP_Reader_read_line_12, TMP_Reader_read_lines_13, TMP_Reader_read_14, TMP_Reader_advance_15, TMP_Reader_unshift_line_16, TMP_Reader_unshift_lines_17, TMP_Reader_replace_next_line_18, TMP_Reader_skip_blank_lines_19, TMP_Reader_skip_comment_lines_20, TMP_Reader_skip_line_comments_21, TMP_Reader_terminate_22, TMP_Reader_read_lines_until_23, TMP_Reader_shift_24, TMP_Reader_unshift_25, TMP_Reader_unshift_all_26, TMP_Reader_cursor_27, TMP_Reader_line_info_28, TMP_Reader_prev_line_info_29, TMP_Reader_lines_30, TMP_Reader_string_31, TMP_Reader_source_32, TMP_Reader_to_s_33;\n\n      def.file = def.dir = def.lines = def.process_lines = def.look_ahead = def.unescape_next_line = def.lineno = def.path = def.source_lines = nil;\n      \n      (function($base, $super, $parent_nesting) {\n        function $Cursor(){};\n        var self = $Cursor = $klass($base, $super, 'Cursor', $Cursor);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Cursor_initialize_1, TMP_Cursor_line_info_2;\n\n        \n        self.$attr_accessor(\"file\");\n        self.$attr_accessor(\"dir\");\n        self.$attr_accessor(\"path\");\n        self.$attr_accessor(\"lineno\");\n        \n        Opal.def(self, '$initialize', TMP_Cursor_initialize_1 = function $$initialize(file, dir, path, lineno) {\n          var self = this;\n\n          if (dir == null) {\n            dir = nil;\n          }\n          if (path == null) {\n            path = nil;\n          }\n          if (lineno == null) {\n            lineno = nil;\n          }\n          \n          self.file = file;\n          self.dir = dir;\n          self.path = path;\n          return (self.lineno = lineno);\n        }, TMP_Cursor_initialize_1.$$arity = -2);\n        \n        Opal.def(self, '$line_info', TMP_Cursor_line_info_2 = function $$line_info() {\n          var self = this;\n\n          return \"\" + (self.$path()) + \": line \" + (self.$lineno())\n        }, TMP_Cursor_line_info_2.$$arity = 0);\n        return Opal.alias(self, \"to_s\", \"line_info\");\n      })($nesting[0], null, $nesting);\n      self.$attr_reader(\"file\");\n      self.$attr_reader(\"dir\");\n      self.$attr_reader(\"path\");\n      self.$attr_reader(\"lineno\");\n      self.$attr_reader(\"source_lines\");\n      self.$attr_accessor(\"process_lines\");\n      \n      Opal.def(self, '$initialize', TMP_Reader_initialize_3 = function $$initialize(data, cursor, opts) {\n        var $a, $b, self = this;\n\n        if (data == null) {\n          data = nil;\n        }\n        if (cursor == null) {\n          cursor = nil;\n        }\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        \n        if ($truthy(cursor['$!']())) {\n          \n          self.file = (self.dir = nil);\n          self.path = \"<stdin>\";\n          self.lineno = 1;\n        } else if ($truthy($$$('::', 'String')['$==='](cursor))) {\n          \n          self.file = cursor;\n          $b = $$$('::', 'File').$split(self.file), $a = Opal.to_ary($b), (self.dir = ($a[0] == null ? nil : $a[0])), (self.path = ($a[1] == null ? nil : $a[1])), $b;\n          self.lineno = 1;\n        } else {\n          \n          self.file = cursor.$file();\n          self.dir = cursor.$dir();\n          self.path = ($truthy($a = cursor.$path()) ? $a : \"<stdin>\");\n          if ($truthy(self.file)) {\n            \n            if ($truthy(self.dir)) {\n            } else {\n              \n              self.dir = $$$('::', 'File').$dirname(self.file);\n              if (self.dir['$=='](\".\")) {\n                self.dir = nil};\n            };\n            if ($truthy(cursor.$path())) {\n            } else {\n              self.path = $$$('::', 'File').$basename(self.file)\n            };};\n          self.lineno = ($truthy($a = cursor.$lineno()) ? $a : 1);\n        };\n        self.lines = (function() {if ($truthy(data)) {\n          \n          return self.$prepare_lines(data, opts);\n        } else {\n          return []\n        }; return nil; })();\n        self.source_lines = self.lines.$dup();\n        self.look_ahead = 0;\n        self.process_lines = true;\n        return (self.unescape_next_line = false);\n      }, TMP_Reader_initialize_3.$$arity = -1);\n      \n      Opal.def(self, '$prepare_lines', TMP_Reader_prepare_lines_4 = function $$prepare_lines(data, opts) {\n        var self = this;\n\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        if ($truthy($$$('::', 'String')['$==='](data))) {\n          if ($truthy(opts['$[]'](\"normalize\"))) {\n            return $$($nesting, 'Helpers').$normalize_lines_from_string(data)\n          } else {\n            return data.$split($$($nesting, 'LF'), -1)\n          }\n        } else if ($truthy(opts['$[]'](\"normalize\"))) {\n          return $$($nesting, 'Helpers').$normalize_lines_array(data)\n        } else {\n          return data.$dup()\n        }\n      }, TMP_Reader_prepare_lines_4.$$arity = -2);\n      \n      Opal.def(self, '$process_line', TMP_Reader_process_line_5 = function $$process_line(line) {\n        var self = this;\n\n        \n        if ($truthy(self.process_lines)) {\n          self.look_ahead = $rb_plus(self.look_ahead, 1)};\n        return line;\n      }, TMP_Reader_process_line_5.$$arity = 1);\n      \n      Opal.def(self, '$has_more_lines?', TMP_Reader_has_more_lines$q_6 = function() {\n        var self = this;\n\n        if ($truthy(self.lines['$empty?']())) {\n          \n          self.look_ahead = 0;\n          return false;\n        } else {\n          return true\n        }\n      }, TMP_Reader_has_more_lines$q_6.$$arity = 0);\n      \n      Opal.def(self, '$empty?', TMP_Reader_empty$q_7 = function() {\n        var self = this;\n\n        if ($truthy(self.lines['$empty?']())) {\n          \n          self.look_ahead = 0;\n          return true;\n        } else {\n          return false\n        }\n      }, TMP_Reader_empty$q_7.$$arity = 0);\n      Opal.alias(self, \"eof?\", \"empty?\");\n      \n      Opal.def(self, '$next_line_empty?', TMP_Reader_next_line_empty$q_8 = function() {\n        var self = this;\n\n        return self.$peek_line()['$nil_or_empty?']()\n      }, TMP_Reader_next_line_empty$q_8.$$arity = 0);\n      \n      Opal.def(self, '$peek_line', TMP_Reader_peek_line_9 = function $$peek_line(direct) {\n        var $a, self = this, line = nil;\n\n        if (direct == null) {\n          direct = false;\n        }\n        if ($truthy(($truthy($a = direct) ? $a : $rb_gt(self.look_ahead, 0)))) {\n          if ($truthy(self.unescape_next_line)) {\n            return self.lines['$[]'](0)['$[]']($range(1, -1, false))\n          } else {\n            return self.lines['$[]'](0)\n          }\n        } else if ($truthy(self.lines['$empty?']())) {\n          \n          self.look_ahead = 0;\n          return nil;\n        } else if ($truthy((line = self.$process_line(self.lines['$[]'](0))))) {\n          return line\n        } else {\n          return self.$peek_line()\n        }\n      }, TMP_Reader_peek_line_9.$$arity = -1);\n      \n      Opal.def(self, '$peek_lines', TMP_Reader_peek_lines_11 = function $$peek_lines(num, direct) {\n        var TMP_10, self = this, old_look_ahead = nil, result = nil;\n\n        if (direct == null) {\n          direct = false;\n        }\n        \n        old_look_ahead = self.look_ahead;\n        result = [];\n        (function(){var $brk = Opal.new_brk(); try {return $send(num, 'times', [], (TMP_10 = function(){var self = TMP_10.$$s || this, line = nil;\n          if (self.lineno == null) self.lineno = nil;\n\n        if ($truthy((line = (function() {if ($truthy(direct)) {\n            return self.$shift()\n          } else {\n            return self.$read_line()\n          }; return nil; })()))) {\n            return result['$<<'](line)\n          } else {\n            \n            if ($truthy(direct)) {\n              self.lineno = $rb_minus(self.lineno, 1)};\n            \n            Opal.brk(nil, $brk);\n          }}, TMP_10.$$s = self, TMP_10.$$brk = $brk, TMP_10.$$arity = 0, TMP_10))\n        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();\n        if ($truthy(result['$empty?']())) {\n        } else {\n          \n          self.$unshift_all(result);\n          if ($truthy(direct)) {\n            self.look_ahead = old_look_ahead};\n        };\n        return result;\n      }, TMP_Reader_peek_lines_11.$$arity = -2);\n      \n      Opal.def(self, '$read_line', TMP_Reader_read_line_12 = function $$read_line() {\n        var $a, self = this;\n\n        if ($truthy(($truthy($a = $rb_gt(self.look_ahead, 0)) ? $a : self['$has_more_lines?']()))) {\n          return self.$shift()\n        } else {\n          return nil\n        }\n      }, TMP_Reader_read_line_12.$$arity = 0);\n      \n      Opal.def(self, '$read_lines', TMP_Reader_read_lines_13 = function $$read_lines() {\n        var $a, self = this, lines = nil;\n\n        \n        lines = [];\n        while ($truthy(self['$has_more_lines?']())) {\n          lines['$<<'](self.$shift())\n        };\n        return lines;\n      }, TMP_Reader_read_lines_13.$$arity = 0);\n      Opal.alias(self, \"readlines\", \"read_lines\");\n      \n      Opal.def(self, '$read', TMP_Reader_read_14 = function $$read() {\n        var self = this;\n\n        return $rb_times(self.$read_lines(), $$($nesting, 'LF'))\n      }, TMP_Reader_read_14.$$arity = 0);\n      \n      Opal.def(self, '$advance', TMP_Reader_advance_15 = function $$advance() {\n        var self = this;\n\n        if ($truthy(self.$shift())) {\n          return true\n        } else {\n          return false\n        }\n      }, TMP_Reader_advance_15.$$arity = 0);\n      \n      Opal.def(self, '$unshift_line', TMP_Reader_unshift_line_16 = function $$unshift_line(line_to_restore) {\n        var self = this;\n\n        \n        self.$unshift(line_to_restore);\n        return nil;\n      }, TMP_Reader_unshift_line_16.$$arity = 1);\n      Opal.alias(self, \"restore_line\", \"unshift_line\");\n      \n      Opal.def(self, '$unshift_lines', TMP_Reader_unshift_lines_17 = function $$unshift_lines(lines_to_restore) {\n        var self = this;\n\n        \n        self.$unshift_all(lines_to_restore);\n        return nil;\n      }, TMP_Reader_unshift_lines_17.$$arity = 1);\n      Opal.alias(self, \"restore_lines\", \"unshift_lines\");\n      \n      Opal.def(self, '$replace_next_line', TMP_Reader_replace_next_line_18 = function $$replace_next_line(replacement) {\n        var self = this;\n\n        \n        self.$shift();\n        self.$unshift(replacement);\n        return true;\n      }, TMP_Reader_replace_next_line_18.$$arity = 1);\n      Opal.alias(self, \"replace_line\", \"replace_next_line\");\n      \n      Opal.def(self, '$skip_blank_lines', TMP_Reader_skip_blank_lines_19 = function $$skip_blank_lines() {\n        var $a, self = this, num_skipped = nil, next_line = nil;\n\n        \n        if ($truthy(self['$empty?']())) {\n          return nil};\n        num_skipped = 0;\n        while ($truthy((next_line = self.$peek_line()))) {\n          if ($truthy(next_line['$empty?']())) {\n            \n            self.$shift();\n            num_skipped = $rb_plus(num_skipped, 1);\n          } else {\n            return num_skipped\n          }\n        };\n      }, TMP_Reader_skip_blank_lines_19.$$arity = 0);\n      \n      Opal.def(self, '$skip_comment_lines', TMP_Reader_skip_comment_lines_20 = function $$skip_comment_lines() {\n        var $a, $b, self = this, comment_lines = nil, next_line = nil, ll = nil;\n\n        \n        if ($truthy(self['$empty?']())) {\n          return []};\n        comment_lines = [];\n        while ($truthy(($truthy($b = (next_line = self.$peek_line())) ? next_line['$empty?']()['$!']() : $b))) {\n          if ($truthy(next_line['$start_with?'](\"//\"))) {\n            if ($truthy(next_line['$start_with?'](\"///\"))) {\n              if ($truthy(($truthy($b = $rb_gt((ll = next_line.$length()), 3)) ? next_line['$==']($rb_times(\"/\", ll)) : $b))) {\n                \n                comment_lines['$<<'](self.$shift());\n                $send(comment_lines, 'push', Opal.to_a(self.$read_lines_until($hash2([\"terminator\", \"read_last_line\", \"skip_processing\"], {\"terminator\": next_line, \"read_last_line\": true, \"skip_processing\": true}))));\n              } else {\n                break;\n              }\n            } else {\n              comment_lines['$<<'](self.$shift())\n            }\n          } else {\n            break;\n          }\n        };\n        return comment_lines;\n      }, TMP_Reader_skip_comment_lines_20.$$arity = 0);\n      \n      Opal.def(self, '$skip_line_comments', TMP_Reader_skip_line_comments_21 = function $$skip_line_comments() {\n        var $a, $b, self = this, comment_lines = nil, next_line = nil;\n\n        \n        if ($truthy(self['$empty?']())) {\n          return []};\n        comment_lines = [];\n        while ($truthy(($truthy($b = (next_line = self.$peek_line())) ? next_line['$empty?']()['$!']() : $b))) {\n          if ($truthy(next_line['$start_with?'](\"//\"))) {\n            comment_lines['$<<'](self.$shift())\n          } else {\n            break;\n          }\n        };\n        return comment_lines;\n      }, TMP_Reader_skip_line_comments_21.$$arity = 0);\n      \n      Opal.def(self, '$terminate', TMP_Reader_terminate_22 = function $$terminate() {\n        var self = this;\n\n        \n        self.lineno = $rb_plus(self.lineno, self.lines.$size());\n        self.lines.$clear();\n        self.look_ahead = 0;\n        return nil;\n      }, TMP_Reader_terminate_22.$$arity = 0);\n      \n      Opal.def(self, '$read_lines_until', TMP_Reader_read_lines_until_23 = function $$read_lines_until(options) {\n        var $a, $b, $c, $d, self = this, $iter = TMP_Reader_read_lines_until_23.$$p, $yield = $iter || nil, result = nil, restore_process_lines = nil, terminator = nil, break_on_blank_lines = nil, break_on_list_continuation = nil, skip_comments = nil, line_read = nil, line_restored = nil, complete = nil, line = nil, $writer = nil;\n\n        if (options == null) {\n          options = $hash2([], {});\n        }\n        if ($iter) TMP_Reader_read_lines_until_23.$$p = null;\n        \n        result = [];\n        if ($truthy(options['$[]'](\"skip_first_line\"))) {\n          self.$shift()};\n        if ($truthy(($truthy($a = self.process_lines) ? options['$[]'](\"skip_processing\") : $a))) {\n          \n          self.process_lines = false;\n          restore_process_lines = true;\n        } else {\n          restore_process_lines = false\n        };\n        if ($truthy((terminator = options['$[]'](\"terminator\")))) {\n          \n          break_on_blank_lines = false;\n          break_on_list_continuation = false;\n        } else {\n          \n          break_on_blank_lines = options['$[]'](\"break_on_blank_lines\");\n          break_on_list_continuation = options['$[]'](\"break_on_list_continuation\");\n        };\n        skip_comments = options['$[]'](\"skip_line_comments\");\n        line_read = false;\n        line_restored = false;\n        complete = false;\n        while ($truthy(($truthy($b = complete['$!']()) ? (line = self.$read_line()) : $b))) {\n          \n          complete = (function() {while ($truthy(true)) {\n            \n            if ($truthy(($truthy($c = terminator) ? line['$=='](terminator) : $c))) {\n              return true};\n            if ($truthy(($truthy($c = break_on_blank_lines) ? line['$empty?']() : $c))) {\n              return true};\n            if ($truthy(($truthy($c = ($truthy($d = break_on_list_continuation) ? line_read : $d)) ? line['$==']($$($nesting, 'LIST_CONTINUATION')) : $c))) {\n              \n              \n              $writer = [\"preserve_last_line\", true];\n              $send(options, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;\n              return true;};\n            if ($truthy((($c = ($yield !== nil)) ? Opal.yield1($yield, line) : ($yield !== nil)))) {\n              return true};\n            return false;\n          }; return nil; })();\n          if ($truthy(complete)) {\n            \n            if ($truthy(options['$[]'](\"read_last_line\"))) {\n              \n              result['$<<'](line);\n              line_read = true;};\n            if ($truthy(options['$[]'](\"preserve_last_line\"))) {\n              \n              self.$unshift(line);\n              line_restored = true;};\n          } else if ($truthy(($truthy($b = ($truthy($c = skip_comments) ? line['$start_with?'](\"//\") : $c)) ? line['$start_with?'](\"///\")['$!']() : $b))) {\n          } else {\n            \n            result['$<<'](line);\n            line_read = true;\n          };\n        };\n        if ($truthy(restore_process_lines)) {\n          \n          self.process_lines = true;\n          if ($truthy(($truthy($a = line_restored) ? terminator['$!']() : $a))) {\n            self.look_ahead = $rb_minus(self.look_ahead, 1)};};\n        return result;\n      }, TMP_Reader_read_lines_until_23.$$arity = -1);\n      \n      Opal.def(self, '$shift', TMP_Reader_shift_24 = function $$shift() {\n        var self = this;\n\n        \n        self.lineno = $rb_plus(self.lineno, 1);\n        if (self.look_ahead['$=='](0)) {\n        } else {\n          self.look_ahead = $rb_minus(self.look_ahead, 1)\n        };\n        return self.lines.$shift();\n      }, TMP_Reader_shift_24.$$arity = 0);\n      \n      Opal.def(self, '$unshift', TMP_Reader_unshift_25 = function $$unshift(line) {\n        var self = this;\n\n        \n        self.lineno = $rb_minus(self.lineno, 1);\n        self.look_ahead = $rb_plus(self.look_ahead, 1);\n        return self.lines.$unshift(line);\n      }, TMP_Reader_unshift_25.$$arity = 1);\n      \n      Opal.def(self, '$unshift_all', TMP_Reader_unshift_all_26 = function $$unshift_all(lines) {\n        var self = this;\n\n        \n        self.lineno = $rb_minus(self.lineno, lines.$size());\n        self.look_ahead = $rb_plus(self.look_ahead, lines.$size());\n        return $send(self.lines, 'unshift', Opal.to_a(lines));\n      }, TMP_Reader_unshift_all_26.$$arity = 1);\n      \n      Opal.def(self, '$cursor', TMP_Reader_cursor_27 = function $$cursor() {\n        var self = this;\n\n        return $$($nesting, 'Cursor').$new(self.file, self.dir, self.path, self.lineno)\n      }, TMP_Reader_cursor_27.$$arity = 0);\n      \n      Opal.def(self, '$line_info', TMP_Reader_line_info_28 = function $$line_info() {\n        var self = this;\n\n        return \"\" + (self.path) + \": line \" + (self.lineno)\n      }, TMP_Reader_line_info_28.$$arity = 0);\n      Opal.alias(self, \"next_line_info\", \"line_info\");\n      \n      Opal.def(self, '$prev_line_info', TMP_Reader_prev_line_info_29 = function $$prev_line_info() {\n        var self = this;\n\n        return \"\" + (self.path) + \": line \" + ($rb_minus(self.lineno, 1))\n      }, TMP_Reader_prev_line_info_29.$$arity = 0);\n      \n      Opal.def(self, '$lines', TMP_Reader_lines_30 = function $$lines() {\n        var self = this;\n\n        return self.lines.$dup()\n      }, TMP_Reader_lines_30.$$arity = 0);\n      \n      Opal.def(self, '$string', TMP_Reader_string_31 = function $$string() {\n        var self = this;\n\n        return $rb_times(self.lines, $$($nesting, 'LF'))\n      }, TMP_Reader_string_31.$$arity = 0);\n      \n      Opal.def(self, '$source', TMP_Reader_source_32 = function $$source() {\n        var self = this;\n\n        return $rb_times(self.source_lines, $$($nesting, 'LF'))\n      }, TMP_Reader_source_32.$$arity = 0);\n      return (Opal.def(self, '$to_s', TMP_Reader_to_s_33 = function $$to_s() {\n        var self = this;\n\n        return self.$line_info()\n      }, TMP_Reader_to_s_33.$$arity = 0), nil) && 'to_s';\n    })($nesting[0], null, $nesting);\n    (function($base, $super, $parent_nesting) {\n      function $PreprocessorReader(){};\n      var self = $PreprocessorReader = $klass($base, $super, 'PreprocessorReader', $PreprocessorReader);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_PreprocessorReader_initialize_34, TMP_PreprocessorReader_prepare_lines_35, TMP_PreprocessorReader_process_line_36, TMP_PreprocessorReader_has_more_lines$q_37, TMP_PreprocessorReader_empty$q_38, TMP_PreprocessorReader_peek_line_39, TMP_PreprocessorReader_preprocess_conditional_directive_44, TMP_PreprocessorReader_preprocess_include_directive_55, TMP_PreprocessorReader_resolve_include_path_56, TMP_PreprocessorReader_push_include_57, TMP_PreprocessorReader_pop_include_58, TMP_PreprocessorReader_include_depth_59, TMP_PreprocessorReader_exceeded_max_depth$q_60, TMP_PreprocessorReader_shift_61, TMP_PreprocessorReader_skip_front_matter$B_62, TMP_PreprocessorReader_resolve_expr_val_63, TMP_PreprocessorReader_include_processors$q_64, TMP_PreprocessorReader_to_s_66;\n\n      def.document = def.lineno = def.process_lines = def.look_ahead = def.skipping = def.include_stack = def.conditional_stack = def.path = def.include_processor_extensions = def.maxdepth = def.dir = def.path_resolver = def.lines = def.file = def.includes = def.unescape_next_line = nil;\n      \n      self.$attr_reader(\"include_stack\");\n      self.$attr_reader(\"includes\");\n      \n      Opal.def(self, '$initialize', TMP_PreprocessorReader_initialize_34 = function $$initialize(document, data, cursor, opts) {\n        var self = this, $iter = TMP_PreprocessorReader_initialize_34.$$p, $yield = $iter || nil, include_depth_default = nil;\n\n        if (data == null) {\n          data = nil;\n        }\n        if (cursor == null) {\n          cursor = nil;\n        }\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        if ($iter) TMP_PreprocessorReader_initialize_34.$$p = null;\n        \n        self.document = document;\n        $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_PreprocessorReader_initialize_34, false), [data, cursor, opts], null);\n        include_depth_default = document.$attributes().$fetch(\"max-include-depth\", 64).$to_i();\n        if ($truthy($rb_lt(include_depth_default, 0))) {\n          include_depth_default = 0};\n        self.maxdepth = $hash2([\"abs\", \"rel\"], {\"abs\": include_depth_default, \"rel\": include_depth_default});\n        self.include_stack = [];\n        self.includes = document.$catalog()['$[]'](\"includes\");\n        self.skipping = false;\n        self.conditional_stack = [];\n        return (self.include_processor_extensions = nil);\n      }, TMP_PreprocessorReader_initialize_34.$$arity = -2);\n      \n      Opal.def(self, '$prepare_lines', TMP_PreprocessorReader_prepare_lines_35 = function $$prepare_lines(data, opts) {\n        var $a, $b, self = this, $iter = TMP_PreprocessorReader_prepare_lines_35.$$p, $yield = $iter || nil, result = nil, front_matter = nil, $writer = nil, first = nil, last = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        if ($iter) TMP_PreprocessorReader_prepare_lines_35.$$p = null;\n        // Prepare super implicit arguments\n        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n          $zuper[$zuper_i] = arguments[$zuper_i];\n        }\n        \n        result = $send(self, Opal.find_super_dispatcher(self, 'prepare_lines', TMP_PreprocessorReader_prepare_lines_35, false), $zuper, $iter);\n        if ($truthy(($truthy($a = self.document) ? self.document.$attributes()['$key?'](\"skip-front-matter\") : $a))) {\n          if ($truthy((front_matter = self['$skip_front_matter!'](result)))) {\n            \n            $writer = [\"front-matter\", $rb_times(front_matter, $$($nesting, 'LF'))];\n            $send(self.document.$attributes(), '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];}};\n        if ($truthy(opts.$fetch(\"condense\", true))) {\n          \n          while ($truthy(($truthy($b = (first = result['$[]'](0))) ? first['$empty?']() : $b))) {\n            ($truthy($b = result.$shift()) ? (self.lineno = $rb_plus(self.lineno, 1)) : $b)\n          };\n          while ($truthy(($truthy($b = (last = result['$[]'](-1))) ? last['$empty?']() : $b))) {\n            result.$pop()\n          };};\n        if ($truthy(opts['$[]'](\"indent\"))) {\n          $$($nesting, 'Parser')['$adjust_indentation!'](result, opts['$[]'](\"indent\"), self.document.$attr(\"tabsize\"))};\n        return result;\n      }, TMP_PreprocessorReader_prepare_lines_35.$$arity = -2);\n      \n      Opal.def(self, '$process_line', TMP_PreprocessorReader_process_line_36 = function $$process_line(line) {\n        var $a, $b, self = this;\n\n        \n        if ($truthy(self.process_lines)) {\n        } else {\n          return line\n        };\n        if ($truthy(line['$empty?']())) {\n          \n          self.look_ahead = $rb_plus(self.look_ahead, 1);\n          return line;};\n        if ($truthy(($truthy($a = ($truthy($b = line['$end_with?'](\"]\")) ? line['$start_with?'](\"[\")['$!']() : $b)) ? line['$include?'](\"::\") : $a))) {\n          if ($truthy(($truthy($a = line['$include?'](\"if\")) ? $$($nesting, 'ConditionalDirectiveRx')['$=~'](line) : $a))) {\n            if ((($a = $gvars['~']) === nil ? nil : $a['$[]'](1))['$=='](\"\\\\\")) {\n              \n              self.unescape_next_line = true;\n              self.look_ahead = $rb_plus(self.look_ahead, 1);\n              return line['$[]']($range(1, -1, false));\n            } else if ($truthy(self.$preprocess_conditional_directive((($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](3)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](4)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](5))))) {\n              \n              self.$shift();\n              return nil;\n            } else {\n              \n              self.look_ahead = $rb_plus(self.look_ahead, 1);\n              return line;\n            }\n          } else if ($truthy(self.skipping)) {\n            \n            self.$shift();\n            return nil;\n          } else if ($truthy(($truthy($a = line['$start_with?'](\"inc\", \"\\\\inc\")) ? $$($nesting, 'IncludeDirectiveRx')['$=~'](line) : $a))) {\n            if ((($a = $gvars['~']) === nil ? nil : $a['$[]'](1))['$=='](\"\\\\\")) {\n              \n              self.unescape_next_line = true;\n              self.look_ahead = $rb_plus(self.look_ahead, 1);\n              return line['$[]']($range(1, -1, false));\n            } else if ($truthy(self.$preprocess_include_directive((($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](3)).$strip()))) {\n              return nil\n            } else {\n              \n              self.look_ahead = $rb_plus(self.look_ahead, 1);\n              return line;\n            }\n          } else {\n            \n            self.look_ahead = $rb_plus(self.look_ahead, 1);\n            return line;\n          }\n        } else if ($truthy(self.skipping)) {\n          \n          self.$shift();\n          return nil;\n        } else {\n          \n          self.look_ahead = $rb_plus(self.look_ahead, 1);\n          return line;\n        };\n      }, TMP_PreprocessorReader_process_line_36.$$arity = 1);\n      \n      Opal.def(self, '$has_more_lines?', TMP_PreprocessorReader_has_more_lines$q_37 = function() {\n        var self = this;\n\n        if ($truthy(self.$peek_line())) {\n          return true\n        } else {\n          return false\n        }\n      }, TMP_PreprocessorReader_has_more_lines$q_37.$$arity = 0);\n      \n      Opal.def(self, '$empty?', TMP_PreprocessorReader_empty$q_38 = function() {\n        var self = this;\n\n        if ($truthy(self.$peek_line())) {\n          return false\n        } else {\n          return true\n        }\n      }, TMP_PreprocessorReader_empty$q_38.$$arity = 0);\n      Opal.alias(self, \"eof?\", \"empty?\");\n      \n      Opal.def(self, '$peek_line', TMP_PreprocessorReader_peek_line_39 = function $$peek_line(direct) {\n        var self = this, $iter = TMP_PreprocessorReader_peek_line_39.$$p, $yield = $iter || nil, line = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n        if (direct == null) {\n          direct = false;\n        }\n        if ($iter) TMP_PreprocessorReader_peek_line_39.$$p = null;\n        // Prepare super implicit arguments\n        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n          $zuper[$zuper_i] = arguments[$zuper_i];\n        }\n        if ($truthy((line = $send(self, Opal.find_super_dispatcher(self, 'peek_line', TMP_PreprocessorReader_peek_line_39, false), $zuper, $iter)))) {\n          return line\n        } else if ($truthy(self.include_stack['$empty?']())) {\n          return nil\n        } else {\n          \n          self.$pop_include();\n          return self.$peek_line(direct);\n        }\n      }, TMP_PreprocessorReader_peek_line_39.$$arity = -1);\n      \n      Opal.def(self, '$preprocess_conditional_directive', TMP_PreprocessorReader_preprocess_conditional_directive_44 = function $$preprocess_conditional_directive(keyword, target, delimiter, text) {\n        var $a, $b, $c, TMP_40, TMP_41, TMP_42, TMP_43, self = this, no_target = nil, pair = nil, skip = nil, $case = nil, lhs = nil, op = nil, rhs = nil;\n\n        \n        if ($truthy((no_target = target['$empty?']()))) {\n        } else {\n          target = target.$downcase()\n        };\n        if ($truthy(($truthy($a = ($truthy($b = no_target) ? ($truthy($c = keyword['$=='](\"ifdef\")) ? $c : keyword['$=='](\"ifndef\")) : $b)) ? $a : ($truthy($b = text) ? keyword['$=='](\"endif\") : $b)))) {\n          return false};\n        if (keyword['$=='](\"endif\")) {\n          \n          if ($truthy(self.conditional_stack['$empty?']())) {\n            self.$warn(\"\" + \"asciidoctor: ERROR: \" + (self.$line_info()) + \": unmatched macro: endif::\" + (target) + \"[]\")\n          } else if ($truthy(($truthy($a = no_target) ? $a : target['$==']((pair = self.conditional_stack['$[]'](-1))['$[]'](\"target\"))))) {\n            \n            self.conditional_stack.$pop();\n            self.skipping = (function() {if ($truthy(self.conditional_stack['$empty?']())) {\n              return false\n            } else {\n              return self.conditional_stack['$[]'](-1)['$[]'](\"skipping\")\n            }; return nil; })();\n          } else {\n            self.$warn(\"\" + \"asciidoctor: ERROR: \" + (self.$line_info()) + \": mismatched macro: endif::\" + (target) + \"[], expected endif::\" + (pair['$[]'](\"target\")) + \"[]\")\n          };\n          return true;};\n        if ($truthy(self.skipping)) {\n          skip = false\n        } else {\n          $case = keyword;\n          if (\"ifdef\"['$===']($case)) {$case = delimiter;\n          if (\",\"['$===']($case)) {skip = $send(target.$split(\",\", -1), 'none?', [], (TMP_40 = function(name){var self = TMP_40.$$s || this;\n            if (self.document == null) self.document = nil;\nif (name == null) name = nil;\n          return self.document.$attributes()['$key?'](name)}, TMP_40.$$s = self, TMP_40.$$arity = 1, TMP_40))}\n          else if (\"+\"['$===']($case)) {skip = $send(target.$split(\"+\", -1), 'any?', [], (TMP_41 = function(name){var self = TMP_41.$$s || this;\n            if (self.document == null) self.document = nil;\nif (name == null) name = nil;\n          return self.document.$attributes()['$key?'](name)['$!']()}, TMP_41.$$s = self, TMP_41.$$arity = 1, TMP_41))}\n          else {skip = self.document.$attributes()['$key?'](target)['$!']()}}\n          else if (\"ifndef\"['$===']($case)) {$case = delimiter;\n          if (\",\"['$===']($case)) {skip = $send(target.$split(\",\", -1), 'any?', [], (TMP_42 = function(name){var self = TMP_42.$$s || this;\n            if (self.document == null) self.document = nil;\nif (name == null) name = nil;\n          return self.document.$attributes()['$key?'](name)}, TMP_42.$$s = self, TMP_42.$$arity = 1, TMP_42))}\n          else if (\"+\"['$===']($case)) {skip = $send(target.$split(\"+\", -1), 'all?', [], (TMP_43 = function(name){var self = TMP_43.$$s || this;\n            if (self.document == null) self.document = nil;\nif (name == null) name = nil;\n          return self.document.$attributes()['$key?'](name)}, TMP_43.$$s = self, TMP_43.$$arity = 1, TMP_43))}\n          else {skip = self.document.$attributes()['$key?'](target)}}\n          else if (\"ifeval\"['$===']($case)) {\n          if ($truthy(($truthy($a = no_target) ? $$($nesting, 'EvalExpressionRx')['$=~'](text.$strip()) : $a))) {\n          } else {\n            return false\n          };\n          $a = [(($b = $gvars['~']) === nil ? nil : $b['$[]'](1)), (($b = $gvars['~']) === nil ? nil : $b['$[]'](2)), (($b = $gvars['~']) === nil ? nil : $b['$[]'](3))], (lhs = $a[0]), (op = $a[1]), (rhs = $a[2]), $a;\n          lhs = self.$resolve_expr_val(lhs);\n          rhs = self.$resolve_expr_val(rhs);\n          if (op['$=='](\"!=\")) {\n            skip = lhs.$send(\"==\", rhs)\n          } else {\n            skip = lhs.$send(op.$to_sym(), rhs)['$!']()\n          };}\n        };\n        if ($truthy(($truthy($a = keyword['$=='](\"ifeval\")) ? $a : text['$!']()))) {\n          \n          if ($truthy(skip)) {\n            self.skipping = true};\n          self.conditional_stack['$<<']($hash2([\"target\", \"skip\", \"skipping\"], {\"target\": target, \"skip\": skip, \"skipping\": self.skipping}));\n        } else if ($truthy(($truthy($a = self.skipping) ? $a : skip))) {\n        } else {\n          \n          self.$replace_next_line(text.$rstrip());\n          self.$unshift(\"\");\n          if ($truthy(text['$start_with?'](\"include::\"))) {\n            self.look_ahead = $rb_minus(self.look_ahead, 1)};\n        };\n        return true;\n      }, TMP_PreprocessorReader_preprocess_conditional_directive_44.$$arity = 4);\n      \n      Opal.def(self, '$preprocess_include_directive', TMP_PreprocessorReader_preprocess_include_directive_55 = function $$preprocess_include_directive(target, attrlist) {\n        var $a, TMP_45, $b, TMP_46, TMP_48, TMP_49, TMP_51, TMP_54, self = this, expanded_target = nil, ext = nil, abs_maxdepth = nil, parsed_attributes = nil, inc_path = nil, target_type = nil, relpath = nil, inc_linenos = nil, inc_tags = nil, tag = nil, inc_lines = nil, inc_offset = nil, inc_lineno = nil, tag_stack = nil, tags_used = nil, active_tag = nil, select = nil, base_select = nil, wildcard = nil, ext_idx = nil, circ_cmt = nil, cmt_suffix_len = nil, tag_suffix = nil, missing_tags = nil, inc_content = nil;\n\n        if ($truthy(($truthy($a = (expanded_target = target)['$include?']($$($nesting, 'ATTR_REF_HEAD'))) ? (expanded_target = self.document.$sub_attributes(target, $hash2([\"attribute_missing\"], {\"attribute_missing\": \"drop-line\"})))['$empty?']() : $a))) {\n          \n          self.$shift();\n          if (self.document.$attributes().$fetch(\"attribute-missing\", $$($nesting, 'Compliance').$attribute_missing())['$=='](\"skip\")) {\n            self.$unshift(\"\" + \"Unresolved directive in \" + (self.path) + \" - include::\" + (target) + \"[\" + (attrlist) + \"]\")};\n          return true;\n        } else if ($truthy(($truthy($a = self['$include_processors?']()) ? (ext = $send(self.include_processor_extensions, 'find', [], (TMP_45 = function(candidate){var self = TMP_45.$$s || this;\nif (candidate == null) candidate = nil;\n        return candidate.$instance()['$handles?'](expanded_target)}, TMP_45.$$s = self, TMP_45.$$arity = 1, TMP_45))) : $a))) {\n          \n          self.$shift();\n          ext.$process_method()['$[]'](self.document, self, expanded_target, $$($nesting, 'AttributeList').$new(attrlist).$parse());\n          return true;\n        } else if ($truthy($rb_ge(self.document.$safe(), $$$($$($nesting, 'SafeMode'), 'SECURE')))) {\n          return self.$replace_next_line(\"\" + \"link:\" + (expanded_target) + \"[]\")\n        } else if ($truthy($rb_gt((abs_maxdepth = self.maxdepth['$[]'](\"abs\")), 0))) {\n          \n          if ($truthy($rb_ge(self.include_stack.$size(), abs_maxdepth))) {\n            \n            self.$warn(\"\" + \"asciidoctor: ERROR: \" + (self.$line_info()) + \": maximum include depth of \" + (self.maxdepth['$[]'](\"rel\")) + \" exceeded\");\n            return nil;};\n          parsed_attributes = (function() {if ($truthy(attrlist['$empty?']())) {\n            return $hash2([], {})\n          } else {\n            return $$($nesting, 'AttributeList').$new(attrlist).$parse()\n          }; return nil; })();\n          $b = self.$resolve_include_path(expanded_target, attrlist, parsed_attributes), $a = Opal.to_ary($b), (inc_path = ($a[0] == null ? nil : $a[0])), (target_type = ($a[1] == null ? nil : $a[1])), (relpath = ($a[2] == null ? nil : $a[2])), $b;\n          if ($truthy(target_type)) {\n          } else {\n            return inc_path\n          };\n          inc_linenos = (inc_tags = nil);\n          if ($truthy(parsed_attributes['$empty?']())) {\n          } else if ($truthy(parsed_attributes['$key?'](\"lines\"))) {\n            \n            inc_linenos = [];\n            $send(parsed_attributes['$[]'](\"lines\").$split($$($nesting, 'DataDelimiterRx')), 'each', [], (TMP_46 = function(linedef){var self = TMP_46.$$s || this, $c, $d, TMP_47, from = nil, to = nil;\nif (linedef == null) linedef = nil;\n            if ($truthy(linedef['$include?'](\"..\"))) {\n                \n                $d = $send(linedef.$split(\"..\", 2), 'map', [], (TMP_47 = function(it){var self = TMP_47.$$s || this;\nif (it == null) it = nil;\n                return it.$to_i()}, TMP_47.$$s = self, TMP_47.$$arity = 1, TMP_47)), $c = Opal.to_ary($d), (from = ($c[0] == null ? nil : $c[0])), (to = ($c[1] == null ? nil : $c[1])), $d;\n                if (to['$=='](-1)) {\n                  \n                  inc_linenos['$<<'](from);\n                  return inc_linenos['$<<']($rb_divide(1, 0));\n                } else {\n                  return inc_linenos.$concat($$$('::', 'Range').$new(from, to).$to_a())\n                };\n              } else {\n                return inc_linenos['$<<'](linedef.$to_i())\n              }}, TMP_46.$$s = self, TMP_46.$$arity = 1, TMP_46));\n            inc_linenos = (function() {if ($truthy(inc_linenos['$empty?']())) {\n              return nil\n            } else {\n              return inc_linenos.$sort().$uniq()\n            }; return nil; })();\n          } else if ($truthy(parsed_attributes['$key?'](\"tag\"))) {\n            if ($truthy((tag = parsed_attributes['$[]'](\"tag\"))['$empty?']())) {\n            } else if ($truthy(tag['$start_with?'](\"!\"))) {\n              if (tag['$=='](\"!\")) {\n              } else {\n                inc_tags = $hash(tag.$slice(1, tag.$length()), false)\n              }\n            } else {\n              inc_tags = $hash(tag, true)\n            }\n          } else if ($truthy(parsed_attributes['$key?'](\"tags\"))) {\n            \n            inc_tags = $hash2([], {});\n            $send(parsed_attributes['$[]'](\"tags\").$split($$($nesting, 'DataDelimiterRx')), 'each', [], (TMP_48 = function(tagdef){var self = TMP_48.$$s || this, $writer = nil;\nif (tagdef == null) tagdef = nil;\n            if ($truthy(tagdef['$empty?']())) {\n                return nil\n              } else if ($truthy(tagdef['$start_with?'](\"!\"))) {\n                if (tagdef['$=='](\"!\")) {\n                  return nil\n                } else {\n                  \n                  $writer = [tagdef.$slice(1, tagdef.$length()), false];\n                  $send(inc_tags, '[]=', Opal.to_a($writer));\n                  return $writer[$rb_minus($writer[\"length\"], 1)];\n                }\n              } else {\n                \n                $writer = [tagdef, true];\n                $send(inc_tags, '[]=', Opal.to_a($writer));\n                return $writer[$rb_minus($writer[\"length\"], 1)];\n              }}, TMP_48.$$s = self, TMP_48.$$arity = 1, TMP_48));\n            if ($truthy(inc_tags['$empty?']())) {\n              inc_tags = nil};};\n          if ($truthy(inc_linenos)) {\n            \n            $a = [[], nil, 0], (inc_lines = $a[0]), (inc_offset = $a[1]), (inc_lineno = $a[2]), $a;\n            \n            try {\n              (function(){var $brk = Opal.new_brk(); try {return $send(self, 'open', [inc_path, \"r\"], (TMP_49 = function(f){var self = TMP_49.$$s || this, TMP_50;\nif (f == null) f = nil;\n              return (function(){var $brk = Opal.new_brk(); try {return $send(f, 'each_line', [], (TMP_50 = function(l){var self = TMP_50.$$s || this, $c, select = nil;\nif (l == null) l = nil;\n                \n                  inc_lineno = $rb_plus(inc_lineno, 1);\n                  select = inc_linenos['$[]'](0);\n                  if ($truthy(($truthy($c = $$$('::', 'Float')['$==='](select)) ? select['$infinite?']() : $c))) {\n                    \n                    inc_offset = ($truthy($c = inc_offset) ? $c : inc_lineno);\n                    return inc_lines['$<<'](l);\n                  } else {\n                    \n                    if (inc_lineno['$=='](select)) {\n                      \n                      inc_offset = ($truthy($c = inc_offset) ? $c : inc_lineno);\n                      inc_lines['$<<'](l);\n                      inc_linenos.$shift();};\n                    if ($truthy(inc_linenos['$empty?']())) {\n                      \n                      Opal.brk(nil, $brk)\n                    } else {\n                      return nil\n                    };\n                  };}, TMP_50.$$s = self, TMP_50.$$brk = $brk, TMP_50.$$arity = 1, TMP_50))\n                } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})()}, TMP_49.$$s = self, TMP_49.$$brk = $brk, TMP_49.$$arity = 1, TMP_49))\n              } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})()\n            } catch ($err) {\n              if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {\n                try {\n                  \n                  self.$warn(\"\" + \"asciidoctor: WARNING: \" + (self.$line_info()) + \": include \" + (target_type) + \" not readable: \" + (inc_path));\n                  return self.$replace_next_line(\"\" + \"Unresolved directive in \" + (self.path) + \" - include::\" + (expanded_target) + \"[\" + (attrlist) + \"]\");\n                } finally { Opal.pop_exception() }\n              } else { throw $err; }\n            };;\n            self.$shift();\n            if ($truthy(inc_offset)) {\n              self.$push_include(inc_lines, inc_path, relpath, inc_offset, parsed_attributes)};\n          } else if ($truthy(inc_tags)) {\n            \n            $a = [[], nil, 0, [], $$$('::', 'Set').$new(), nil], (inc_lines = $a[0]), (inc_offset = $a[1]), (inc_lineno = $a[2]), (tag_stack = $a[3]), (tags_used = $a[4]), (active_tag = $a[5]), $a;\n            if ($truthy(inc_tags['$key?'](\"**\"))) {\n              if ($truthy(inc_tags['$key?'](\"*\"))) {\n                \n                select = (base_select = inc_tags.$delete(\"**\"));\n                wildcard = inc_tags.$delete(\"*\");\n              } else {\n                select = (base_select = (wildcard = inc_tags.$delete(\"**\")))\n              }\n            } else {\n              \n              select = (base_select = inc_tags['$value?'](true)['$!']());\n              wildcard = inc_tags.$delete(\"*\");\n            };\n            if ($truthy(($truthy($a = (ext_idx = inc_path.$rindex(\".\"))) ? (circ_cmt = $$($nesting, 'CIRCUMFIX_COMMENTS')['$[]'](inc_path.$slice(ext_idx, inc_path.$length()))) : $a))) {\n              cmt_suffix_len = $rb_minus((tag_suffix = \"\" + \"[] \" + (circ_cmt['$[]'](\"suffix\"))).$length(), 2)};\n            \n            try {\n              $send(self, 'open', [inc_path, \"r\"], (TMP_51 = function(f){var self = TMP_51.$$s || this, TMP_52;\nif (f == null) f = nil;\n              return $send(f, 'each_line', [], (TMP_52 = function(l){var self = TMP_52.$$s || this, $c, $d, $e, $f, TMP_53, tl = nil, this_tag = nil, idx = nil;\nif (l == null) l = nil;\n                \n                  inc_lineno = $rb_plus(inc_lineno, 1);\n                  if ($truthy($$($nesting, 'FORCE_ENCODING'))) {\n                    l.$force_encoding($$$($$$('::', 'Encoding'), 'UTF_8'))};\n                  if ($truthy(($truthy($c = ($truthy($d = (tl = l.$chomp())['$end_with?'](\"[]\")) ? $d : ($truthy($e = ($truthy($f = tag_suffix) ? tl['$end_with?'](tag_suffix) : $f)) ? (tl = tl.$slice(0, $rb_minus(tl.$length(), cmt_suffix_len))) : $e))) ? $$($nesting, 'TagDirectiveRx')['$=~'](tl) : $c))) {\n                    if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](1)))) {\n                      if ((this_tag = (($c = $gvars['~']) === nil ? nil : $c['$[]'](2)))['$=='](active_tag)) {\n                        \n                        tag_stack.$pop();\n                        return $d = (function() {if ($truthy(tag_stack['$empty?']())) {\n                          return [nil, base_select]\n                        } else {\n                          return tag_stack['$[]'](-1)\n                        }; return nil; })(), $c = Opal.to_ary($d), (active_tag = ($c[0] == null ? nil : $c[0])), (select = ($c[1] == null ? nil : $c[1])), $d;\n                      } else if ($truthy(inc_tags['$key?'](this_tag))) {\n                        if ($truthy((idx = $send(tag_stack, 'rindex', [], (TMP_53 = function(key, _){var self = TMP_53.$$s || this;\nif (key == null) key = nil;if (_ == null) _ = nil;\n                        return key['$=='](this_tag)}, TMP_53.$$s = self, TMP_53.$$arity = 2, TMP_53))))) {\n                          \n                          if (idx['$=='](0)) {\n                            tag_stack.$shift()\n                          } else {\n                            \n                            tag_stack.$delete_at(idx);\n                          };\n                          return self.$warn(\"\" + \"asciidoctor: WARNING: \" + (expanded_target) + \": line \" + (inc_lineno) + \": mismatched end tag in include: expected \" + (active_tag) + \", found \" + (this_tag));\n                        } else {\n                          return self.$warn(\"\" + \"asciidoctor: WARNING: \" + (expanded_target) + \": line \" + (inc_lineno) + \": unexpected end tag in include: \" + (this_tag))\n                        }\n                      } else {\n                        return nil\n                      }\n                    } else if ($truthy(inc_tags['$key?']((this_tag = (($c = $gvars['~']) === nil ? nil : $c['$[]'](2)))))) {\n                      \n                      tags_used['$<<'](this_tag);\n                      return tag_stack['$<<']([(active_tag = this_tag), (select = inc_tags['$[]'](this_tag))]);\n                    } else if ($truthy(wildcard['$nil?']()['$!']())) {\n                      \n                      select = (function() {if ($truthy(($truthy($c = active_tag) ? select['$!']() : $c))) {\n                        return false\n                      } else {\n                        return wildcard\n                      }; return nil; })();\n                      return tag_stack['$<<']([(active_tag = this_tag), select]);\n                    } else {\n                      return nil\n                    }\n                  } else if ($truthy(select)) {\n                    \n                    inc_offset = ($truthy($c = inc_offset) ? $c : inc_lineno);\n                    return inc_lines['$<<'](l);\n                  } else {\n                    return nil\n                  };}, TMP_52.$$s = self, TMP_52.$$arity = 1, TMP_52))}, TMP_51.$$s = self, TMP_51.$$arity = 1, TMP_51))\n            } catch ($err) {\n              if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {\n                try {\n                  \n                  self.$warn(\"\" + \"asciidoctor: WARNING: \" + (self.$line_info()) + \": include \" + (target_type) + \" not readable: \" + (inc_path));\n                  return self.$replace_next_line(\"\" + \"Unresolved directive in \" + (self.path) + \" - include::\" + (expanded_target) + \"[\" + (attrlist) + \"]\");\n                } finally { Opal.pop_exception() }\n              } else { throw $err; }\n            };;\n            if ($truthy((missing_tags = $rb_minus(inc_tags.$keys().$to_a(), tags_used.$to_a()))['$empty?']())) {\n            } else {\n              self.$warn(\"\" + \"asciidoctor: WARNING: \" + (self.$line_info()) + \": tag\" + ((function() {if ($truthy($rb_gt(missing_tags.$size(), 1))) {\n                return \"s\"\n              } else {\n                return nil\n              }; return nil; })()) + \" '\" + ($rb_times(missing_tags, \",\")) + \"' not found in include \" + (target_type) + \": \" + (inc_path))\n            };\n            self.$shift();\n            if ($truthy(inc_offset)) {\n              self.$push_include(inc_lines, inc_path, relpath, inc_offset, parsed_attributes)};\n          } else {\n            \n            try {\n              \n              inc_content = (function() {if (target_type['$=='](\"file\")) {\n                \n                return $$$('::', 'IO').$read(inc_path);\n              } else {\n                return $send(self, 'open', [inc_path, \"r\"], (TMP_54 = function(f){var self = TMP_54.$$s || this;\nif (f == null) f = nil;\n                return f.$read()}, TMP_54.$$s = self, TMP_54.$$arity = 1, TMP_54))\n              }; return nil; })();\n              self.$shift();\n              self.$push_include(inc_content, inc_path, relpath, 1, parsed_attributes);\n            } catch ($err) {\n              if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {\n                try {\n                  \n                  self.$warn(\"\" + \"asciidoctor: WARNING: \" + (self.$line_info()) + \": include \" + (target_type) + \" not readable: \" + (inc_path));\n                  return self.$replace_next_line(\"\" + \"Unresolved directive in \" + (self.path) + \" - include::\" + (expanded_target) + \"[\" + (attrlist) + \"]\");\n                } finally { Opal.pop_exception() }\n              } else { throw $err; }\n            };\n          };\n          return true;\n        } else {\n          return false\n        }\n      }, TMP_PreprocessorReader_preprocess_include_directive_55.$$arity = 2);\n      \n      Opal.def(self, '$resolve_include_path', TMP_PreprocessorReader_resolve_include_path_56 = function $$resolve_include_path(target, attrlist, attributes) {\n        var $a, $b, $c, self = this, inc_path = nil, relpath = nil;\n\n        if ($truthy($$($nesting, 'Helpers')['$uriish?'](target))) {\n          \n          if ($truthy(self.document.$attributes()['$key?'](\"allow-uri-read\"))) {\n          } else {\n            return self.$replace_next_line(\"\" + \"link:\" + (target) + \"[\" + (attrlist) + \"]\")\n          };\n          if ($truthy(self.document.$attributes()['$key?'](\"cache-uri\"))) {\n            if ($truthy((($b = $$$('::', 'OpenURI', 'skip_raise')) && ($a = $$$($b, 'Cache', 'skip_raise')) ? 'constant' : nil))) {\n            } else {\n              $$($nesting, 'Helpers').$require_library(\"open-uri/cached\", \"open-uri-cached\")\n            }\n          } else if ($truthy($$$('::', 'RUBY_ENGINE_OPAL')['$!']())) {\n            $$$('::', 'OpenURI')};\n          return [target, \"uri\", target];\n        } else {\n          \n          inc_path = self.document.$normalize_system_path(target, self.dir, nil, $hash2([\"target_name\"], {\"target_name\": \"include file\"}));\n          if ($truthy($$$('::', 'File')['$file?'](inc_path))) {\n          } else {\n            \n            self.$warn(\"\" + \"asciidoctor: WARNING: \" + (self.$line_info()) + \": include file not found: \" + (inc_path));\n            return self.$replace_next_line(\"\" + \"Unresolved directive in \" + (self.path) + \" - include::\" + (target) + \"[\" + (attrlist) + \"]\");\n          };\n          relpath = (self.path_resolver = ($truthy($c = self.path_resolver) ? $c : $$($nesting, 'PathResolver').$new())).$relative_path(inc_path, self.document.$base_dir());\n          return [inc_path, \"file\", relpath];\n        }\n      }, TMP_PreprocessorReader_resolve_include_path_56.$$arity = 3);\n      \n      Opal.def(self, '$push_include', TMP_PreprocessorReader_push_include_57 = function $$push_include(data, file, path, lineno, attributes) {\n        var self = this, depth = nil, old_leveloffset = nil;\n\n        if (file == null) {\n          file = nil;\n        }\n        if (path == null) {\n          path = nil;\n        }\n        if (lineno == null) {\n          lineno = 1;\n        }\n        if (attributes == null) {\n          attributes = $hash2([], {});\n        }\n        \n        self.include_stack['$<<']([self.lines, self.file, self.dir, self.path, self.lineno, self.maxdepth, self.process_lines]);\n        if ($truthy(file)) {\n          \n          self.file = file;\n          self.dir = $$($nesting, 'File').$dirname(file);\n          self.process_lines = $$($nesting, 'ASCIIDOC_EXTENSIONS')['$[]']($$$('::', 'File').$extname(file));\n        } else {\n          \n          self.file = nil;\n          self.dir = \".\";\n          self.process_lines = true;\n        };\n        if ($truthy(path)) {\n          self.includes['$<<']($$($nesting, 'Helpers').$rootname((self.path = path)))\n        } else {\n          self.path = \"<stdin>\"\n        };\n        self.lineno = lineno;\n        if ($truthy(attributes['$key?'](\"depth\"))) {\n          \n          depth = attributes['$[]'](\"depth\").$to_i();\n          if ($truthy($rb_le(depth, 0))) {\n            depth = 1};\n          self.maxdepth = $hash2([\"abs\", \"rel\"], {\"abs\": $rb_plus($rb_minus(self.include_stack.$size(), 1), depth), \"rel\": depth});};\n        if ($truthy((self.lines = self.$prepare_lines(data, $hash2([\"normalize\", \"condense\", \"indent\"], {\"normalize\": true, \"condense\": false, \"indent\": attributes['$[]'](\"indent\")})))['$empty?']())) {\n          self.$pop_include()\n        } else {\n          \n          if ($truthy(attributes['$key?'](\"leveloffset\"))) {\n            \n            self.lines.$unshift(\"\");\n            self.lines.$unshift(\"\" + \":leveloffset: \" + (attributes['$[]'](\"leveloffset\")));\n            self.lines['$<<'](\"\");\n            if ($truthy((old_leveloffset = self.document.$attr(\"leveloffset\")))) {\n              self.lines['$<<'](\"\" + \":leveloffset: \" + (old_leveloffset))\n            } else {\n              self.lines['$<<'](\":leveloffset!:\")\n            };\n            self.lineno = $rb_minus(self.lineno, 2);};\n          self.look_ahead = 0;\n        };\n        return self;\n      }, TMP_PreprocessorReader_push_include_57.$$arity = -2);\n      \n      Opal.def(self, '$pop_include', TMP_PreprocessorReader_pop_include_58 = function $$pop_include() {\n        var $a, $b, self = this;\n\n        if ($truthy($rb_gt(self.include_stack.$size(), 0))) {\n          \n          $b = self.include_stack.$pop(), $a = Opal.to_ary($b), (self.lines = ($a[0] == null ? nil : $a[0])), (self.file = ($a[1] == null ? nil : $a[1])), (self.dir = ($a[2] == null ? nil : $a[2])), (self.path = ($a[3] == null ? nil : $a[3])), (self.lineno = ($a[4] == null ? nil : $a[4])), (self.maxdepth = ($a[5] == null ? nil : $a[5])), (self.process_lines = ($a[6] == null ? nil : $a[6])), $b;\n          self.look_ahead = 0;\n          return nil;\n        } else {\n          return nil\n        }\n      }, TMP_PreprocessorReader_pop_include_58.$$arity = 0);\n      \n      Opal.def(self, '$include_depth', TMP_PreprocessorReader_include_depth_59 = function $$include_depth() {\n        var self = this;\n\n        return self.include_stack.$size()\n      }, TMP_PreprocessorReader_include_depth_59.$$arity = 0);\n      \n      Opal.def(self, '$exceeded_max_depth?', TMP_PreprocessorReader_exceeded_max_depth$q_60 = function() {\n        var $a, self = this, abs_maxdepth = nil;\n\n        if ($truthy(($truthy($a = $rb_gt((abs_maxdepth = self.maxdepth['$[]'](\"abs\")), 0)) ? $rb_ge(self.include_stack.$size(), abs_maxdepth) : $a))) {\n          return self.maxdepth['$[]'](\"rel\")\n        } else {\n          return false\n        }\n      }, TMP_PreprocessorReader_exceeded_max_depth$q_60.$$arity = 0);\n      \n      Opal.def(self, '$shift', TMP_PreprocessorReader_shift_61 = function $$shift() {\n        var self = this, $iter = TMP_PreprocessorReader_shift_61.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n        if ($iter) TMP_PreprocessorReader_shift_61.$$p = null;\n        // Prepare super implicit arguments\n        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n          $zuper[$zuper_i] = arguments[$zuper_i];\n        }\n        if ($truthy(self.unescape_next_line)) {\n          \n          self.unescape_next_line = false;\n          return $send(self, Opal.find_super_dispatcher(self, 'shift', TMP_PreprocessorReader_shift_61, false), $zuper, $iter)['$[]']($range(1, -1, false));\n        } else {\n          return $send(self, Opal.find_super_dispatcher(self, 'shift', TMP_PreprocessorReader_shift_61, false), $zuper, $iter)\n        }\n      }, TMP_PreprocessorReader_shift_61.$$arity = 0);\n      \n      Opal.def(self, '$skip_front_matter!', TMP_PreprocessorReader_skip_front_matter$B_62 = function(data, increment_linenos) {\n        var $a, $b, self = this, front_matter = nil, original_data = nil;\n\n        if (increment_linenos == null) {\n          increment_linenos = true;\n        }\n        \n        front_matter = nil;\n        if (data['$[]'](0)['$=='](\"---\")) {\n          \n          original_data = data.$dup();\n          front_matter = [];\n          data.$shift();\n          if ($truthy(increment_linenos)) {\n            self.lineno = $rb_plus(self.lineno, 1)};\n          while ($truthy(($truthy($b = data['$empty?']()['$!']()) ? data['$[]'](0)['$!='](\"---\") : $b))) {\n            \n            front_matter['$<<'](data.$shift());\n            if ($truthy(increment_linenos)) {\n              self.lineno = $rb_plus(self.lineno, 1)};\n          };\n          if ($truthy(data['$empty?']())) {\n            \n            $send(data, 'unshift', Opal.to_a(original_data));\n            if ($truthy(increment_linenos)) {\n              self.lineno = 0};\n            front_matter = nil;\n          } else {\n            \n            data.$shift();\n            if ($truthy(increment_linenos)) {\n              self.lineno = $rb_plus(self.lineno, 1)};\n          };};\n        return front_matter;\n      }, TMP_PreprocessorReader_skip_front_matter$B_62.$$arity = -2);\n      \n      Opal.def(self, '$resolve_expr_val', TMP_PreprocessorReader_resolve_expr_val_63 = function $$resolve_expr_val(val) {\n        var $a, $b, self = this, quoted = nil;\n\n        \n        if ($truthy(($truthy($a = ($truthy($b = val['$start_with?'](\"\\\"\")) ? val['$end_with?'](\"\\\"\") : $b)) ? $a : ($truthy($b = val['$start_with?'](\"'\")) ? val['$end_with?'](\"'\") : $b)))) {\n          \n          quoted = true;\n          val = val['$[]']($range(1, -1, true));\n        } else {\n          quoted = false\n        };\n        if ($truthy(val['$include?']($$($nesting, 'ATTR_REF_HEAD')))) {\n          val = self.document.$sub_attributes(val, $hash2([\"attribute_missing\"], {\"attribute_missing\": \"drop\"}))};\n        if ($truthy(quoted)) {\n          return val\n        } else if ($truthy(val['$empty?']())) {\n          return nil\n        } else if (val['$=='](\"true\")) {\n          return true\n        } else if (val['$=='](\"false\")) {\n          return false\n        } else if ($truthy(val.$rstrip()['$empty?']())) {\n          return \" \"\n        } else if ($truthy(val['$include?'](\".\"))) {\n          return val.$to_f()\n        } else {\n          return val.$to_i()\n        };\n      }, TMP_PreprocessorReader_resolve_expr_val_63.$$arity = 1);\n      \n      Opal.def(self, '$include_processors?', TMP_PreprocessorReader_include_processors$q_64 = function() {\n        var $a, self = this;\n\n        if ($truthy(self.include_processor_extensions['$nil?']())) {\n          if ($truthy(($truthy($a = self.document['$extensions?']()) ? self.document.$extensions()['$include_processors?']() : $a))) {\n            return (self.include_processor_extensions = self.document.$extensions().$include_processors())['$!']()['$!']()\n          } else {\n            return (self.include_processor_extensions = false)\n          }\n        } else {\n          return self.include_processor_extensions['$!='](false)\n        }\n      }, TMP_PreprocessorReader_include_processors$q_64.$$arity = 0);\n      return (Opal.def(self, '$to_s', TMP_PreprocessorReader_to_s_66 = function $$to_s() {\n        var TMP_65, self = this;\n\n        return \"\" + \"#<\" + (self.$class()) + \"@\" + (self.$object_id()) + \" {path: \" + (self.path.$inspect()) + \", line #: \" + (self.lineno) + \", include depth: \" + (self.include_stack.$size()) + \", include stack: [\" + ($rb_times($send(self.include_stack, 'map', [], (TMP_65 = function(inc){var self = TMP_65.$$s || this;\nif (inc == null) inc = nil;\n        return inc.$to_s()}, TMP_65.$$s = self, TMP_65.$$arity = 1, TMP_65)), \", \")) + \"]}>\"\n      }, TMP_PreprocessorReader_to_s_66.$$arity = 0), nil) && 'to_s';\n    })($nesting[0], $$($nesting, 'Reader'), $nesting);\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/section\"] = function(Opal) {\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$attr_accessor', '$attr_reader', '$+', '$level', '$>', '$==', '$context', '$special', '$generate_id', '$title', '$sectnum', '$reftext', '$!', '$empty?', '$===', '$sprintf', '$sub_quotes', '$compat_mode', '$[]', '$attributes', '$enumerate_section', '$class', '$object_id', '$inspect', '$size', '$gsub', '$downcase', '$tr_s', '$end_with?', '$chop', '$start_with?', '$slice', '$length', '$key?', '$catalog', '$unique_id_start_index']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Section(){};\n      var self = $Section = $klass($base, $super, 'Section', $Section);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Section_initialize_1, TMP_Section_generate_id_2, TMP_Section_sectnum_3, TMP_Section_xreftext_4, TMP_Section_$lt$lt_5, TMP_Section_to_s_6, TMP_Section_generate_id_7;\n\n      def.level = def.document = def.parent = def.number = def.numbered = def.sectname = def.title = def.blocks = nil;\n      \n      self.$attr_accessor(\"index\");\n      self.$attr_accessor(\"sectname\");\n      self.$attr_accessor(\"special\");\n      self.$attr_accessor(\"numbered\");\n      self.$attr_reader(\"caption\");\n      \n      Opal.def(self, '$initialize', TMP_Section_initialize_1 = function $$initialize(parent, level, numbered, opts) {\n        var $a, $b, self = this, $iter = TMP_Section_initialize_1.$$p, $yield = $iter || nil;\n\n        if (parent == null) {\n          parent = nil;\n        }\n        if (level == null) {\n          level = nil;\n        }\n        if (numbered == null) {\n          numbered = true;\n        }\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        if ($iter) TMP_Section_initialize_1.$$p = null;\n        \n        $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Section_initialize_1, false), [parent, \"section\", opts], null);\n        self.level = (function() {if ($truthy(level)) {\n          return level\n        } else {\n          \n          if ($truthy(parent)) {\n            \n            return $rb_plus(parent.$level(), 1);\n          } else {\n            return 1\n          };\n        }; return nil; })();\n        self.numbered = ($truthy($a = numbered) ? $rb_gt(self.level, 0) : $a);\n        self.special = ($truthy($a = ($truthy($b = parent) ? parent.$context()['$=='](\"section\") : $b)) ? parent.$special() : $a);\n        self.index = 0;\n        return (self.number = 1);\n      }, TMP_Section_initialize_1.$$arity = -1);\n      Opal.alias(self, \"name\", \"title\");\n      \n      Opal.def(self, '$generate_id', TMP_Section_generate_id_2 = function $$generate_id() {\n        var self = this;\n\n        return $$($nesting, 'Section').$generate_id(self.$title(), self.document)\n      }, TMP_Section_generate_id_2.$$arity = 0);\n      \n      Opal.def(self, '$sectnum', TMP_Section_sectnum_3 = function $$sectnum(delimiter, append) {\n        var $a, $b, $c, self = this;\n\n        if (delimiter == null) {\n          delimiter = \".\";\n        }\n        if (append == null) {\n          append = nil;\n        }\n        \n        append = ($truthy($a = append) ? $a : (function() {if (append['$=='](false)) {\n          return \"\"\n        } else {\n          return delimiter\n        }; return nil; })());\n        if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = self.level) ? $rb_gt(self.level, 1) : $c)) ? self.parent : $b)) ? self.parent.$context()['$=='](\"section\") : $a))) {\n          return \"\" + (self.parent.$sectnum(delimiter)) + (self.number) + (append)\n        } else {\n          return \"\" + (self.number) + (append)\n        };\n      }, TMP_Section_sectnum_3.$$arity = -1);\n      \n      Opal.def(self, '$xreftext', TMP_Section_xreftext_4 = function $$xreftext(xrefstyle) {\n        var $a, self = this, val = nil, $case = nil, type = nil, quoted_title = nil, signifier = nil;\n\n        if (xrefstyle == null) {\n          xrefstyle = nil;\n        }\n        if ($truthy(($truthy($a = (val = self.$reftext())) ? val['$empty?']()['$!']() : $a))) {\n          return val\n        } else if ($truthy(xrefstyle)) {\n          if ($truthy(self.numbered)) {\n            return (function() {$case = xrefstyle;\n            if (\"full\"['$===']($case)) {\n            if ($truthy(($truthy($a = (type = self.sectname)['$=='](\"chapter\")) ? $a : type['$=='](\"appendix\")))) {\n              quoted_title = self.$sprintf(self.$sub_quotes(\"_%s_\"), self.$title())\n            } else {\n              quoted_title = self.$sprintf(self.$sub_quotes((function() {if ($truthy(self.document.$compat_mode())) {\n                return \"``%s''\"\n              } else {\n                return \"\\\"`%s`\\\"\"\n              }; return nil; })()), self.$title())\n            };\n            if ($truthy((signifier = self.document.$attributes()['$[]'](\"\" + (type) + \"-refsig\")))) {\n              return \"\" + (signifier) + \" \" + (self.$sectnum(\".\", \",\")) + \" \" + (quoted_title)\n            } else {\n              return \"\" + (self.$sectnum(\".\", \",\")) + \" \" + (quoted_title)\n            };}\n            else if (\"short\"['$===']($case)) {if ($truthy((signifier = self.document.$attributes()['$[]'](\"\" + (self.sectname) + \"-refsig\")))) {\n              return \"\" + (signifier) + \" \" + (self.$sectnum(\".\", \"\"))\n            } else {\n              return self.$sectnum(\".\", \"\")\n            }}\n            else {if ($truthy(($truthy($a = (type = self.sectname)['$=='](\"chapter\")) ? $a : type['$=='](\"appendix\")))) {\n              \n              return self.$sprintf(self.$sub_quotes(\"_%s_\"), self.$title());\n            } else {\n              return self.$title()\n            }}})()\n          } else if ($truthy(($truthy($a = (type = self.sectname)['$=='](\"chapter\")) ? $a : type['$=='](\"appendix\")))) {\n            \n            return self.$sprintf(self.$sub_quotes(\"_%s_\"), self.$title());\n          } else {\n            return self.$title()\n          }\n        } else {\n          return self.$title()\n        }\n      }, TMP_Section_xreftext_4.$$arity = -1);\n      \n      Opal.def(self, '$<<', TMP_Section_$lt$lt_5 = function(block) {\n        var self = this, $iter = TMP_Section_$lt$lt_5.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n        if ($iter) TMP_Section_$lt$lt_5.$$p = null;\n        // Prepare super implicit arguments\n        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n          $zuper[$zuper_i] = arguments[$zuper_i];\n        }\n        \n        if (block.$context()['$=='](\"section\")) {\n          self.$enumerate_section(block)};\n        return $send(self, Opal.find_super_dispatcher(self, '<<', TMP_Section_$lt$lt_5, false), $zuper, $iter);\n      }, TMP_Section_$lt$lt_5.$$arity = 1);\n      \n      Opal.def(self, '$to_s', TMP_Section_to_s_6 = function $$to_s() {\n        var self = this, $iter = TMP_Section_to_s_6.$$p, $yield = $iter || nil, formal_title = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n        if ($iter) TMP_Section_to_s_6.$$p = null;\n        // Prepare super implicit arguments\n        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n          $zuper[$zuper_i] = arguments[$zuper_i];\n        }\n        if ($truthy(self.title)) {\n          \n          formal_title = (function() {if ($truthy(self.numbered)) {\n            return \"\" + (self.$sectnum()) + \" \" + (self.title)\n          } else {\n            return self.title\n          }; return nil; })();\n          return \"\" + \"#<\" + (self.$class()) + \"@\" + (self.$object_id()) + \" {level: \" + (self.level) + \", title: \" + (formal_title.$inspect()) + \", blocks: \" + (self.blocks.$size()) + \"}>\";\n        } else {\n          return $send(self, Opal.find_super_dispatcher(self, 'to_s', TMP_Section_to_s_6, false), $zuper, $iter)\n        }\n      }, TMP_Section_to_s_6.$$arity = 0);\n      return (Opal.defs(self, '$generate_id', TMP_Section_generate_id_7 = function $$generate_id(title, document) {\n        var $a, self = this, attrs = nil, sep = nil, pre = nil, gen_id = nil, ids = nil, cnt = nil, candidate_id = nil;\n\n        \n        attrs = document.$attributes();\n        sep = ($truthy($a = attrs['$[]'](\"idseparator\")) ? $a : \"_\");\n        pre = ($truthy($a = attrs['$[]'](\"idprefix\")) ? $a : \"_\");\n        gen_id = \"\" + (pre) + (title.$downcase().$gsub($$($nesting, 'InvalidSectionIdCharsRx'), sep));\n        if ($truthy(sep['$empty?']())) {\n        } else {\n          \n          gen_id = gen_id.$tr_s(sep, sep);\n          if ($truthy(gen_id['$end_with?'](sep))) {\n            gen_id = gen_id.$chop()};\n          if ($truthy(pre['$empty?']())) {\n            while ($truthy(gen_id['$start_with?'](sep))) {\n              gen_id = gen_id.$slice(1, gen_id.$length())\n            }};\n        };\n        if ($truthy(document.$catalog()['$[]'](\"ids\")['$key?'](gen_id))) {\n          \n          $a = [document.$catalog()['$[]'](\"ids\"), $$($nesting, 'Compliance').$unique_id_start_index()], (ids = $a[0]), (cnt = $a[1]), $a;\n          while ($truthy(ids['$key?']((candidate_id = \"\" + (gen_id) + (sep) + (cnt))))) {\n            cnt = $rb_plus(cnt, 1)\n          };\n          return candidate_id;\n        } else {\n          return gen_id\n        };\n      }, TMP_Section_generate_id_7.$$arity = 2), nil) && 'generate_id';\n    })($nesting[0], $$($nesting, 'AbstractBlock'), $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/stylesheets\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;\n\n  Opal.add_stubs(['$join', '$new', '$chomp', '$read', '$primary_stylesheet_data', '$write', '$primary_stylesheet_name', '$coderay_stylesheet_data', '$coderay_stylesheet_name', '$load_pygments', '$[]', '$sub', '$css', '$[]=', '$-', '$pygments_stylesheet_data', '$pygments_stylesheet_name', '$!', '$nil?', '$require_library']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Stylesheets(){};\n      var self = $Stylesheets = $klass($base, $super, 'Stylesheets', $Stylesheets);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Stylesheets_instance_1, TMP_Stylesheets_primary_stylesheet_name_2, TMP_Stylesheets_primary_stylesheet_data_3, TMP_Stylesheets_embed_primary_stylesheet_4, TMP_Stylesheets_write_primary_stylesheet_5, TMP_Stylesheets_coderay_stylesheet_name_6, TMP_Stylesheets_coderay_stylesheet_data_7, TMP_Stylesheets_embed_coderay_stylesheet_8, TMP_Stylesheets_write_coderay_stylesheet_9, TMP_Stylesheets_pygments_stylesheet_name_10, TMP_Stylesheets_pygments_stylesheet_data_11, TMP_Stylesheets_embed_pygments_stylesheet_12, TMP_Stylesheets_write_pygments_stylesheet_13, TMP_Stylesheets_load_pygments_14;\n\n      def.primary_stylesheet_data = def.coderay_stylesheet_data = def.pygments_stylesheet_data = nil;\n      \n      Opal.const_set($nesting[0], 'DEFAULT_STYLESHEET_NAME', \"asciidoctor.css\");\n      Opal.const_set($nesting[0], 'DEFAULT_PYGMENTS_STYLE', \"default\");\n      Opal.const_set($nesting[0], 'STYLESHEETS_DATA_PATH', $$$('::', 'File').$join($$($nesting, 'DATA_PATH'), \"stylesheets\"));\n      self.__instance__ = self.$new();\n      Opal.defs(self, '$instance', TMP_Stylesheets_instance_1 = function $$instance() {\n        var self = this;\n        if (self.__instance__ == null) self.__instance__ = nil;\n\n        return self.__instance__\n      }, TMP_Stylesheets_instance_1.$$arity = 0);\n      \n      Opal.def(self, '$primary_stylesheet_name', TMP_Stylesheets_primary_stylesheet_name_2 = function $$primary_stylesheet_name() {\n        var self = this;\n\n        return $$($nesting, 'DEFAULT_STYLESHEET_NAME')\n      }, TMP_Stylesheets_primary_stylesheet_name_2.$$arity = 0);\n      \n      Opal.def(self, '$primary_stylesheet_data', TMP_Stylesheets_primary_stylesheet_data_3 = function $$primary_stylesheet_data() {\n\nvar File = Opal.const_get_relative([], \"File\");\nvar stylesheetsPath;\nif (Opal.const_get_relative([], \"JAVASCRIPT_PLATFORM\")[\"$==\"](\"node\")) {\n  if (File.$basename(__dirname) === \"node\" && File.$basename(File.$dirname(__dirname)) === \"dist\") {\n    stylesheetsPath = File.$join(File.$dirname(__dirname), \"css\");\n  } else {\n    stylesheetsPath = File.$join(__dirname, \"css\");\n  }\n} else if (Opal.const_get_relative([], \"JAVASCRIPT_ENGINE\")[\"$==\"](\"nashorn\")) {\n  if (File.$basename(__DIR__) === \"nashorn\" && File.$basename(File.$dirname(__DIR__)) === \"dist\") {\n    stylesheetsPath = File.$join(File.$dirname(__DIR__), \"css\");\n  } else {\n    stylesheetsPath = File.$join(__DIR__, \"css\");\n  }\n} else {\n  stylesheetsPath = \"css\";\n}\nreturn ((($a = self.primary_stylesheet_data) !== false && $a !== nil && $a != null) ? $a : self.primary_stylesheet_data = Opal.const_get_relative([], \"IO\").$read(File.$join(stylesheetsPath, \"asciidoctor.css\")).$chomp());\n  \n      }, TMP_Stylesheets_primary_stylesheet_data_3.$$arity = 0);\n      \n      Opal.def(self, '$embed_primary_stylesheet', TMP_Stylesheets_embed_primary_stylesheet_4 = function $$embed_primary_stylesheet() {\n        var self = this;\n\n        return \"\" + \"<style>\\n\" + (self.$primary_stylesheet_data()) + \"\\n\" + \"</style>\"\n      }, TMP_Stylesheets_embed_primary_stylesheet_4.$$arity = 0);\n      \n      Opal.def(self, '$write_primary_stylesheet', TMP_Stylesheets_write_primary_stylesheet_5 = function $$write_primary_stylesheet(target_dir) {\n        var self = this;\n\n        if (target_dir == null) {\n          target_dir = \".\";\n        }\n        return $$$('::', 'IO').$write($$$('::', 'File').$join(target_dir, self.$primary_stylesheet_name()), self.$primary_stylesheet_data())\n      }, TMP_Stylesheets_write_primary_stylesheet_5.$$arity = -1);\n      \n      Opal.def(self, '$coderay_stylesheet_name', TMP_Stylesheets_coderay_stylesheet_name_6 = function $$coderay_stylesheet_name() {\n        var self = this;\n\n        return \"coderay-asciidoctor.css\"\n      }, TMP_Stylesheets_coderay_stylesheet_name_6.$$arity = 0);\n      \n      Opal.def(self, '$coderay_stylesheet_data', TMP_Stylesheets_coderay_stylesheet_data_7 = function $$coderay_stylesheet_data() {\n        var $a, self = this;\n\n        return (self.coderay_stylesheet_data = ($truthy($a = self.coderay_stylesheet_data) ? $a : $$$('::', 'IO').$read($$$('::', 'File').$join($$($nesting, 'STYLESHEETS_DATA_PATH'), \"coderay-asciidoctor.css\")).$chomp()))\n      }, TMP_Stylesheets_coderay_stylesheet_data_7.$$arity = 0);\n      \n      Opal.def(self, '$embed_coderay_stylesheet', TMP_Stylesheets_embed_coderay_stylesheet_8 = function $$embed_coderay_stylesheet() {\n        var self = this;\n\n        return \"\" + \"<style>\\n\" + (self.$coderay_stylesheet_data()) + \"\\n\" + \"</style>\"\n      }, TMP_Stylesheets_embed_coderay_stylesheet_8.$$arity = 0);\n      \n      Opal.def(self, '$write_coderay_stylesheet', TMP_Stylesheets_write_coderay_stylesheet_9 = function $$write_coderay_stylesheet(target_dir) {\n        var self = this;\n\n        if (target_dir == null) {\n          target_dir = \".\";\n        }\n        return $$$('::', 'IO').$write($$$('::', 'File').$join(target_dir, self.$coderay_stylesheet_name()), self.$coderay_stylesheet_data())\n      }, TMP_Stylesheets_write_coderay_stylesheet_9.$$arity = -1);\n      \n      Opal.def(self, '$pygments_stylesheet_name', TMP_Stylesheets_pygments_stylesheet_name_10 = function $$pygments_stylesheet_name(style) {\n        var $a, self = this;\n\n        if (style == null) {\n          style = nil;\n        }\n        return \"\" + \"pygments-\" + (($truthy($a = style) ? $a : $$($nesting, 'DEFAULT_PYGMENTS_STYLE'))) + \".css\"\n      }, TMP_Stylesheets_pygments_stylesheet_name_10.$$arity = -1);\n      \n      Opal.def(self, '$pygments_stylesheet_data', TMP_Stylesheets_pygments_stylesheet_data_11 = function $$pygments_stylesheet_data(style) {\n        var $a, $b, self = this, $writer = nil;\n\n        if (style == null) {\n          style = nil;\n        }\n        if ($truthy(self.$load_pygments())) {\n          return ($truthy($a = (self.pygments_stylesheet_data = ($truthy($b = self.pygments_stylesheet_data) ? $b : $hash2([], {})))['$[]'](($truthy($b = style) ? $b : $$($nesting, 'DEFAULT_PYGMENTS_STYLE')))) ? $a : (($writer = [($truthy($b = style) ? $b : $$($nesting, 'DEFAULT_PYGMENTS_STYLE')), $$$('::', 'Pygments').$css(\".listingblock .pygments\", $hash2([\"classprefix\", \"style\"], {\"classprefix\": \"tok-\", \"style\": ($truthy($b = style) ? $b : $$($nesting, 'DEFAULT_PYGMENTS_STYLE'))})).$sub(\".listingblock .pygments  {\", \".listingblock .pygments, .listingblock .pygments code {\")]), $send((self.pygments_stylesheet_data = ($truthy($b = self.pygments_stylesheet_data) ? $b : $hash2([], {}))), '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))\n        } else {\n          return \"/* Pygments styles disabled. Pygments is not available. */\"\n        }\n      }, TMP_Stylesheets_pygments_stylesheet_data_11.$$arity = -1);\n      \n      Opal.def(self, '$embed_pygments_stylesheet', TMP_Stylesheets_embed_pygments_stylesheet_12 = function $$embed_pygments_stylesheet(style) {\n        var self = this;\n\n        if (style == null) {\n          style = nil;\n        }\n        return \"\" + \"<style>\\n\" + (self.$pygments_stylesheet_data(style)) + \"\\n\" + \"</style>\"\n      }, TMP_Stylesheets_embed_pygments_stylesheet_12.$$arity = -1);\n      \n      Opal.def(self, '$write_pygments_stylesheet', TMP_Stylesheets_write_pygments_stylesheet_13 = function $$write_pygments_stylesheet(target_dir, style) {\n        var self = this;\n\n        if (target_dir == null) {\n          target_dir = \".\";\n        }\n        if (style == null) {\n          style = nil;\n        }\n        return $$$('::', 'IO').$write($$$('::', 'File').$join(target_dir, self.$pygments_stylesheet_name(style)), self.$pygments_stylesheet_data(style))\n      }, TMP_Stylesheets_write_pygments_stylesheet_13.$$arity = -1);\n      return (Opal.def(self, '$load_pygments', TMP_Stylesheets_load_pygments_14 = function $$load_pygments() {\n        var $a, self = this;\n\n        if ($truthy((($a = $$$('::', 'Pygments', 'skip_raise')) ? 'constant' : nil))) {\n          return true\n        } else {\n          return $$($nesting, 'Helpers').$require_library(\"pygments\", \"pygments.rb\", \"ignore\")['$nil?']()['$!']()\n        }\n      }, TMP_Stylesheets_load_pygments_14.$$arity = 0), nil) && 'load_pygments';\n    })($nesting[0], null, $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/table\"] = function(Opal) {\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_divide(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2, $range = Opal.range;\n\n  Opal.add_stubs(['$attr_accessor', '$attr_reader', '$new', '$key?', '$[]', '$>', '$to_i', '$<', '$==', '$[]=', '$-', '$attributes', '$round', '$*', '$/', '$to_f', '$empty?', '$body', '$each', '$+', '$<<', '$size', '$assign_column_widths', '$**', '$assign_width', '$shift', '$style=', '$head=', '$pop', '$foot=', '$update_attributes', '$parent', '$header_row?', '$table', '$delete', '$!', '$rstrip', '$start_with?', '$slice', '$length', '$strip', '$split', '$include?', '$readlines', '$unshift', '$nil?', '$apply_subs', '$convert', '$map', '$text', '$to_s', '$to_set', '$cursor', '$nested?', '$document', '$warn', '$prev_line_info', '$nil_or_empty?', '$escape', '$columns', '$match', '$pre_match', '$post_match', '$chop', '$buffer', '$end_with?', '$gsub', '$push_cellspec', '$cell_open?', '$close_cell', '$advance', '$take_cellspec', '$line_info', '$squeeze', '$upto', '$times', '$rowspan', '$activate_rowspan', '$colspan', '$end_of_row?', '$!=', '$close_row', '$rows', '$effective_column_visits']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    \n    (function($base, $super, $parent_nesting) {\n      function $Table(){};\n      var self = $Table = $klass($base, $super, 'Table', $Table);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Table_initialize_3, TMP_Table_header_row$q_4, TMP_Table_create_columns_6, TMP_Table_assign_column_widths_9, TMP_Table_partition_header_footer_11;\n\n      def.attributes = def.document = def.has_header_option = def.rows = def.columns = nil;\n      \n      (function($base, $super, $parent_nesting) {\n        function $Rows(){};\n        var self = $Rows = $klass($base, $super, 'Rows', $Rows);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Rows_initialize_1, TMP_Rows_by_section_2;\n\n        def.head = def.foot = def.body = nil;\n        \n        self.$attr_accessor(\"head\", \"foot\", \"body\");\n        \n        Opal.def(self, '$initialize', TMP_Rows_initialize_1 = function $$initialize(head, foot, body) {\n          var self = this;\n\n          if (head == null) {\n            head = [];\n          }\n          if (foot == null) {\n            foot = [];\n          }\n          if (body == null) {\n            body = [];\n          }\n          \n          self.head = head;\n          self.foot = foot;\n          return (self.body = body);\n        }, TMP_Rows_initialize_1.$$arity = -1);\n        Opal.alias(self, \"[]\", \"send\");\n        return (Opal.def(self, '$by_section', TMP_Rows_by_section_2 = function $$by_section() {\n          var self = this;\n\n          return [[\"head\", self.head], [\"foot\", self.foot], [\"body\", self.body]]\n        }, TMP_Rows_by_section_2.$$arity = 0), nil) && 'by_section';\n      })($nesting[0], null, $nesting);\n      self.$attr_accessor(\"columns\");\n      self.$attr_accessor(\"rows\");\n      self.$attr_accessor(\"has_header_option\");\n      self.$attr_reader(\"caption\");\n      \n      Opal.def(self, '$initialize', TMP_Table_initialize_3 = function $$initialize(parent, attributes) {\n        var $a, $b, self = this, $iter = TMP_Table_initialize_3.$$p, $yield = $iter || nil, pcwidth = nil, pcwidth_intval = nil, $writer = nil;\n\n        if ($iter) TMP_Table_initialize_3.$$p = null;\n        \n        $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Table_initialize_3, false), [parent, \"table\"], null);\n        self.rows = $$($nesting, 'Rows').$new();\n        self.columns = [];\n        self.has_header_option = attributes['$key?'](\"header-option\");\n        if ($truthy((pcwidth = attributes['$[]'](\"width\")))) {\n          if ($truthy(($truthy($a = $rb_gt((pcwidth_intval = pcwidth.$to_i()), 100)) ? $a : $rb_lt(pcwidth_intval, 1)))) {\n            if ($truthy((($a = pcwidth_intval['$=='](0)) ? ($truthy($b = pcwidth['$=='](\"0\")) ? $b : pcwidth['$=='](\"0%\")) : pcwidth_intval['$=='](0)))) {\n            } else {\n              pcwidth_intval = 100\n            }}\n        } else {\n          pcwidth_intval = 100\n        };\n        \n        $writer = [\"tablepcwidth\", pcwidth_intval];\n        $send(self.attributes, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        if ($truthy(self.document.$attributes()['$key?'](\"pagewidth\"))) {\n          ($truthy($a = self.attributes['$[]'](\"tableabswidth\")) ? $a : (($writer = [\"tableabswidth\", $rb_times($rb_divide(self.attributes['$[]'](\"tablepcwidth\").$to_f(), 100), self.document.$attributes()['$[]'](\"pagewidth\")).$round()]), $send(self.attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))};\n        if ($truthy(attributes['$key?'](\"rotate-option\"))) {\n          \n          $writer = [\"orientation\", \"landscape\"];\n          $send(attributes, '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];\n        } else {\n          return nil\n        };\n      }, TMP_Table_initialize_3.$$arity = 2);\n      \n      Opal.def(self, '$header_row?', TMP_Table_header_row$q_4 = function() {\n        var $a, self = this;\n\n        return ($truthy($a = self.has_header_option) ? self.rows.$body()['$empty?']() : $a)\n      }, TMP_Table_header_row$q_4.$$arity = 0);\n      \n      Opal.def(self, '$create_columns', TMP_Table_create_columns_6 = function $$create_columns(colspecs) {\n        var TMP_5, self = this, cols = nil, width_base = nil, $writer = nil;\n\n        \n        cols = [];\n        width_base = 0;\n        $send(colspecs, 'each', [], (TMP_5 = function(colspec){var self = TMP_5.$$s || this;\nif (colspec == null) colspec = nil;\n        \n          width_base = $rb_plus(width_base, colspec['$[]'](\"width\"));\n          return cols['$<<']($$($nesting, 'Column').$new(self, cols.$size(), colspec));}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));\n        if ($truthy((self.columns = cols)['$empty?']())) {\n        } else {\n          \n          \n          $writer = [\"colcount\", cols.$size()];\n          $send(self.attributes, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          self.$assign_column_widths((function() {if (width_base['$=='](0)) {\n            return nil\n          } else {\n            return width_base\n          }; return nil; })());\n        };\n        return nil;\n      }, TMP_Table_create_columns_6.$$arity = 1);\n      \n      Opal.def(self, '$assign_column_widths', TMP_Table_assign_column_widths_9 = function $$assign_column_widths(width_base) {\n        var TMP_7, TMP_8, self = this, pf = nil, total_width = nil, col_pcwidth = nil;\n\n        if (width_base == null) {\n          width_base = nil;\n        }\n        \n        pf = (10)['$**'](4);\n        total_width = (col_pcwidth = 0);\n        if ($truthy(width_base)) {\n          $send(self.columns, 'each', [], (TMP_7 = function(col){var self = TMP_7.$$s || this;\nif (col == null) col = nil;\n          return (total_width = $rb_plus(total_width, (col_pcwidth = col.$assign_width(nil, width_base, pf))))}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7))\n        } else {\n          \n          col_pcwidth = $rb_divide($rb_divide($rb_times(100, pf), self.columns.$size()).$to_i(), pf);\n          if (col_pcwidth.$to_i()['$=='](col_pcwidth)) {\n            col_pcwidth = col_pcwidth.$to_i()};\n          $send(self.columns, 'each', [], (TMP_8 = function(col){var self = TMP_8.$$s || this;\nif (col == null) col = nil;\n          return (total_width = $rb_plus(total_width, col.$assign_width(col_pcwidth)))}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8));\n        };\n        if (total_width['$=='](100)) {\n        } else {\n          self.columns['$[]'](-1).$assign_width($rb_divide($rb_times($rb_plus($rb_minus(100, total_width), col_pcwidth), pf).$round(), pf))\n        };\n        return nil;\n      }, TMP_Table_assign_column_widths_9.$$arity = -1);\n      return (Opal.def(self, '$partition_header_footer', TMP_Table_partition_header_footer_11 = function $$partition_header_footer(attrs) {\n        var $a, TMP_10, self = this, $writer = nil, num_body_rows = nil, head = nil;\n\n        \n        \n        $writer = [\"rowcount\", self.rows.$body().$size()];\n        $send(self.attributes, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        num_body_rows = self.rows.$body().$size();\n        if ($truthy(($truthy($a = $rb_gt(num_body_rows, 0)) ? self.has_header_option : $a))) {\n          \n          head = self.rows.$body().$shift();\n          num_body_rows = $rb_minus(num_body_rows, 1);\n          $send(head, 'each', [], (TMP_10 = function(c){var self = TMP_10.$$s || this;\nif (c == null) c = nil;\n          \n            $writer = [nil];\n            $send(c, 'style=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10));\n          \n          $writer = [[head]];\n          $send(self.rows, 'head=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;};\n        if ($truthy(($truthy($a = $rb_gt(num_body_rows, 0)) ? attrs['$key?'](\"footer-option\") : $a))) {\n          \n          $writer = [[self.rows.$body().$pop()]];\n          $send(self.rows, 'foot=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];};\n        return nil;\n      }, TMP_Table_partition_header_footer_11.$$arity = 1), nil) && 'partition_header_footer';\n    })($nesting[0], $$($nesting, 'AbstractBlock'), $nesting);\n    (function($base, $super, $parent_nesting) {\n      function $Column(){};\n      var self = $Column = $klass($base, $super, 'Column', $Column);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Column_initialize_12, TMP_Column_assign_width_13;\n\n      def.attributes = nil;\n      \n      self.$attr_accessor(\"style\");\n      \n      Opal.def(self, '$initialize', TMP_Column_initialize_12 = function $$initialize(table, index, attributes) {\n        var $a, self = this, $iter = TMP_Column_initialize_12.$$p, $yield = $iter || nil, $writer = nil;\n\n        if (attributes == null) {\n          attributes = $hash2([], {});\n        }\n        if ($iter) TMP_Column_initialize_12.$$p = null;\n        \n        $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Column_initialize_12, false), [table, \"column\"], null);\n        self.style = attributes['$[]'](\"style\");\n        \n        $writer = [\"colnumber\", $rb_plus(index, 1)];\n        $send(attributes, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        ($truthy($a = attributes['$[]'](\"width\")) ? $a : (($writer = [\"width\", 1]), $send(attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n        ($truthy($a = attributes['$[]'](\"halign\")) ? $a : (($writer = [\"halign\", \"left\"]), $send(attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n        ($truthy($a = attributes['$[]'](\"valign\")) ? $a : (($writer = [\"valign\", \"top\"]), $send(attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n        return self.$update_attributes(attributes);\n      }, TMP_Column_initialize_12.$$arity = -3);\n      Opal.alias(self, \"table\", \"parent\");\n      return (Opal.def(self, '$assign_width', TMP_Column_assign_width_13 = function $$assign_width(col_pcwidth, width_base, pf) {\n        var self = this, $writer = nil;\n\n        if (width_base == null) {\n          width_base = nil;\n        }\n        if (pf == null) {\n          pf = 10000;\n        }\n        \n        if ($truthy(width_base)) {\n          \n          col_pcwidth = $rb_divide($rb_times($rb_times($rb_divide(self.attributes['$[]'](\"width\").$to_f(), width_base), 100), pf).$to_i(), pf);\n          if (col_pcwidth.$to_i()['$=='](col_pcwidth)) {\n            col_pcwidth = col_pcwidth.$to_i()};};\n        \n        $writer = [\"colpcwidth\", col_pcwidth];\n        $send(self.attributes, '[]=', Opal.to_a($writer));\n        $writer[$rb_minus($writer[\"length\"], 1)];;\n        if ($truthy(self.$parent().$attributes()['$key?'](\"tableabswidth\"))) {\n          \n          $writer = [\"colabswidth\", $rb_times($rb_divide(col_pcwidth, 100), self.$parent().$attributes()['$[]'](\"tableabswidth\")).$round()];\n          $send(self.attributes, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];};\n        return col_pcwidth;\n      }, TMP_Column_assign_width_13.$$arity = -2), nil) && 'assign_width';\n    })($$($nesting, 'Table'), $$($nesting, 'AbstractNode'), $nesting);\n    (function($base, $super, $parent_nesting) {\n      function $Cell(){};\n      var self = $Cell = $klass($base, $super, 'Cell', $Cell);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Cell_initialize_14, TMP_Cell_text_15, TMP_Cell_text$eq_16, TMP_Cell_content_18, TMP_Cell_to_s_19;\n\n      def.document = def.text = def.style = def.inner_document = def.colspan = def.rowspan = def.attributes = nil;\n      \n      self.$attr_accessor(\"style\");\n      self.$attr_accessor(\"colspan\");\n      self.$attr_accessor(\"rowspan\");\n      Opal.alias(self, \"column\", \"parent\");\n      self.$attr_reader(\"inner_document\");\n      \n      Opal.def(self, '$initialize', TMP_Cell_initialize_14 = function $$initialize(column, cell_text, attributes, opts) {\n        var $a, self = this, $iter = TMP_Cell_initialize_14.$$p, $yield = $iter || nil, cell_style = nil, in_header_row = nil, parent_doctitle = nil, inner_document_lines = nil, unprocessed_line1 = nil, preprocessed_lines = nil, $writer = nil;\n\n        if (attributes == null) {\n          attributes = $hash2([], {});\n        }\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        if ($iter) TMP_Cell_initialize_14.$$p = null;\n        \n        $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_Cell_initialize_14, false), [column, \"cell\"], null);\n        if ($truthy(column)) {\n          \n          cell_style = (function() {if ($truthy((in_header_row = column.$table()['$header_row?']()))) {\n            return nil\n          } else {\n            return column.$attributes()['$[]'](\"style\")\n          }; return nil; })();\n          self.$update_attributes(column.$attributes());\n        } else {\n          in_header_row = (cell_style = nil)\n        };\n        if ($truthy(attributes)) {\n          \n          self.colspan = attributes.$delete(\"colspan\");\n          self.rowspan = attributes.$delete(\"rowspan\");\n          if ($truthy(($truthy($a = in_header_row) ? $a : attributes['$key?'](\"style\")['$!']()))) {\n          } else {\n            cell_style = attributes['$[]'](\"style\")\n          };\n          if ($truthy(opts['$[]'](\"strip_text\"))) {\n            if ($truthy(($truthy($a = cell_style['$=='](\"literal\")) ? $a : cell_style['$=='](\"verse\")))) {\n              \n              cell_text = cell_text.$rstrip();\n              while ($truthy(cell_text['$start_with?']($$($nesting, 'LF')))) {\n                cell_text = cell_text.$slice(1, $rb_minus(cell_text.$length(), 1))\n              };\n            } else {\n              cell_text = cell_text.$strip()\n            }};\n          self.$update_attributes(attributes);\n        } else {\n          \n          self.colspan = nil;\n          self.rowspan = nil;\n        };\n        if (cell_style['$=='](\"asciidoc\")) {\n          \n          parent_doctitle = self.document.$attributes().$delete(\"doctitle\");\n          inner_document_lines = cell_text.$split($$($nesting, 'LF'), -1);\n          if ($truthy(inner_document_lines['$empty?']())) {\n          } else if ($truthy((unprocessed_line1 = inner_document_lines['$[]'](0))['$include?'](\"::\"))) {\n            \n            preprocessed_lines = $$($nesting, 'PreprocessorReader').$new(self.document, [unprocessed_line1]).$readlines();\n            if ($truthy((($a = unprocessed_line1['$=='](preprocessed_lines['$[]'](0))) ? $rb_lt(preprocessed_lines.$size(), 2) : unprocessed_line1['$=='](preprocessed_lines['$[]'](0))))) {\n            } else {\n              \n              inner_document_lines.$shift();\n              if ($truthy(preprocessed_lines['$empty?']())) {\n              } else {\n                $send(inner_document_lines, 'unshift', Opal.to_a(preprocessed_lines))\n              };\n            };};\n          self.inner_document = $$($nesting, 'Document').$new(inner_document_lines, $hash2([\"header_footer\", \"parent\", \"cursor\"], {\"header_footer\": false, \"parent\": self.document, \"cursor\": opts['$[]'](\"cursor\")}));\n          if ($truthy(parent_doctitle['$nil?']())) {\n          } else {\n            \n            $writer = [\"doctitle\", parent_doctitle];\n            $send(self.document.$attributes(), '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];\n          };};\n        self.text = cell_text;\n        return (self.style = cell_style);\n      }, TMP_Cell_initialize_14.$$arity = -3);\n      \n      Opal.def(self, '$text', TMP_Cell_text_15 = function $$text() {\n        var self = this;\n\n        return self.$apply_subs(self.text, (function() {if (self.style['$=='](\"literal\")) {\n          return $$($nesting, 'BASIC_SUBS')\n        } else {\n          return $$($nesting, 'NORMAL_SUBS')\n        }; return nil; })())\n      }, TMP_Cell_text_15.$$arity = 0);\n      \n      Opal.def(self, '$text=', TMP_Cell_text$eq_16 = function(val) {\n        var self = this;\n\n        return (self.text = val)\n      }, TMP_Cell_text$eq_16.$$arity = 1);\n      \n      Opal.def(self, '$content', TMP_Cell_content_18 = function $$content() {\n        var TMP_17, self = this;\n\n        if (self.style['$=='](\"asciidoc\")) {\n          return self.inner_document.$convert()\n        } else {\n          return $send(self.$text().$split($$($nesting, 'BlankLineRx')), 'map', [], (TMP_17 = function(p){var self = TMP_17.$$s || this, $a;\n            if (self.style == null) self.style = nil;\nif (p == null) p = nil;\n          if ($truthy(($truthy($a = self.style['$!']()) ? $a : self.style['$=='](\"header\")))) {\n              return p\n            } else {\n              return $$($nesting, 'Inline').$new(self.$parent(), \"quoted\", p, $hash2([\"type\"], {\"type\": self.style})).$convert()\n            }}, TMP_17.$$s = self, TMP_17.$$arity = 1, TMP_17))\n        }\n      }, TMP_Cell_content_18.$$arity = 0);\n      return (Opal.def(self, '$to_s', TMP_Cell_to_s_19 = function $$to_s() {\n        var $a, self = this, $iter = TMP_Cell_to_s_19.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n        if ($iter) TMP_Cell_to_s_19.$$p = null;\n        // Prepare super implicit arguments\n        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n          $zuper[$zuper_i] = arguments[$zuper_i];\n        }\n        return \"\" + ($send(self, Opal.find_super_dispatcher(self, 'to_s', TMP_Cell_to_s_19, false), $zuper, $iter).$to_s()) + \" - [text: \" + (self.text) + \", colspan: \" + (($truthy($a = self.colspan) ? $a : 1)) + \", rowspan: \" + (($truthy($a = self.rowspan) ? $a : 1)) + \", attributes: \" + (self.attributes) + \"]\"\n      }, TMP_Cell_to_s_19.$$arity = 0), nil) && 'to_s';\n    })($$($nesting, 'Table'), $$($nesting, 'AbstractNode'), $nesting);\n    (function($base, $super, $parent_nesting) {\n      function $ParserContext(){};\n      var self = $ParserContext = $klass($base, $super, 'ParserContext', $ParserContext);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ParserContext_initialize_20, TMP_ParserContext_starts_with_delimiter$q_21, TMP_ParserContext_match_delimiter_22, TMP_ParserContext_skip_past_delimiter_23, TMP_ParserContext_skip_past_escaped_delimiter_24, TMP_ParserContext_buffer_has_unclosed_quotes$q_25, TMP_ParserContext_take_cellspec_26, TMP_ParserContext_push_cellspec_27, TMP_ParserContext_keep_cell_open_28, TMP_ParserContext_mark_cell_closed_29, TMP_ParserContext_cell_open$q_30, TMP_ParserContext_cell_closed$q_31, TMP_ParserContext_close_open_cell_32, TMP_ParserContext_close_cell_35, TMP_ParserContext_close_row_36, TMP_ParserContext_activate_rowspan_38, TMP_ParserContext_end_of_row$q_39, TMP_ParserContext_effective_column_visits_40, TMP_ParserContext_advance_41;\n\n      def.delimiter = def.delimiter_re = def.buffer = def.cellspecs = def.cell_open = def.format = def.last_cursor = def.table = def.current_row = def.colcount = def.column_visits = def.active_rowspans = def.linenum = nil;\n      \n      Opal.const_set($nesting[0], 'FORMATS', [\"psv\", \"csv\", \"dsv\", \"tsv\"].$to_set());\n      Opal.const_set($nesting[0], 'DELIMITERS', $hash2([\"psv\", \"csv\", \"dsv\", \"tsv\", \"!sv\"], {\"psv\": [\"|\", /\\|/], \"csv\": [\",\", /,/], \"dsv\": [\":\", /:/], \"tsv\": [\"\\t\", /\\t/], \"!sv\": [\"!\", /!/]}));\n      self.$attr_accessor(\"table\");\n      self.$attr_accessor(\"format\");\n      self.$attr_reader(\"colcount\");\n      self.$attr_accessor(\"buffer\");\n      self.$attr_reader(\"delimiter\");\n      self.$attr_reader(\"delimiter_re\");\n      \n      Opal.def(self, '$initialize', TMP_ParserContext_initialize_20 = function $$initialize(reader, table, attributes) {\n        var $a, $b, self = this, xsv = nil, sep = nil;\n\n        if (attributes == null) {\n          attributes = $hash2([], {});\n        }\n        \n        self.reader = reader;\n        self.table = table;\n        self.last_cursor = reader.$cursor();\n        if ($truthy(attributes['$key?'](\"format\"))) {\n          if ($truthy($$($nesting, 'FORMATS')['$include?']((xsv = attributes['$[]'](\"format\"))))) {\n            if (xsv['$=='](\"tsv\")) {\n              self.format = \"csv\"\n            } else if ($truthy((($a = (self.format = xsv)['$=='](\"psv\")) ? table.$document()['$nested?']() : (self.format = xsv)['$=='](\"psv\")))) {\n              xsv = \"!sv\"}\n          } else {\n            \n            self.$warn(\"\" + \"asciidoctor: ERROR: \" + (reader.$prev_line_info()) + \": illegal table format: \" + (xsv));\n            $a = [\"psv\", (function() {if ($truthy(table.$document()['$nested?']())) {\n              return \"!sv\"\n            } else {\n              return \"psv\"\n            }; return nil; })()], (self.format = $a[0]), (xsv = $a[1]), $a;\n          }\n        } else {\n          $a = [\"psv\", (function() {if ($truthy(table.$document()['$nested?']())) {\n            return \"!sv\"\n          } else {\n            return \"psv\"\n          }; return nil; })()], (self.format = $a[0]), (xsv = $a[1]), $a\n        };\n        if ($truthy(attributes['$key?'](\"separator\"))) {\n          if ($truthy((sep = attributes['$[]'](\"separator\"))['$nil_or_empty?']())) {\n            $b = $$($nesting, 'DELIMITERS')['$[]'](xsv), $a = Opal.to_ary($b), (self.delimiter = ($a[0] == null ? nil : $a[0])), (self.delimiter_re = ($a[1] == null ? nil : $a[1])), $b\n          } else if (sep['$=='](\"\\\\t\")) {\n            $b = $$($nesting, 'DELIMITERS')['$[]'](\"tsv\"), $a = Opal.to_ary($b), (self.delimiter = ($a[0] == null ? nil : $a[0])), (self.delimiter_re = ($a[1] == null ? nil : $a[1])), $b\n          } else {\n            $a = [sep, new RegExp($$$('::', 'Regexp').$escape(sep))], (self.delimiter = $a[0]), (self.delimiter_re = $a[1]), $a\n          }\n        } else {\n          $b = $$($nesting, 'DELIMITERS')['$[]'](xsv), $a = Opal.to_ary($b), (self.delimiter = ($a[0] == null ? nil : $a[0])), (self.delimiter_re = ($a[1] == null ? nil : $a[1])), $b\n        };\n        self.colcount = (function() {if ($truthy(table.$columns()['$empty?']())) {\n          return -1\n        } else {\n          return table.$columns().$size()\n        }; return nil; })();\n        self.buffer = \"\";\n        self.cellspecs = [];\n        self.cell_open = false;\n        self.active_rowspans = [0];\n        self.column_visits = 0;\n        self.current_row = [];\n        return (self.linenum = -1);\n      }, TMP_ParserContext_initialize_20.$$arity = -3);\n      \n      Opal.def(self, '$starts_with_delimiter?', TMP_ParserContext_starts_with_delimiter$q_21 = function(line) {\n        var self = this;\n\n        return line['$start_with?'](self.delimiter)\n      }, TMP_ParserContext_starts_with_delimiter$q_21.$$arity = 1);\n      \n      Opal.def(self, '$match_delimiter', TMP_ParserContext_match_delimiter_22 = function $$match_delimiter(line) {\n        var self = this;\n\n        return self.delimiter_re.$match(line)\n      }, TMP_ParserContext_match_delimiter_22.$$arity = 1);\n      \n      Opal.def(self, '$skip_past_delimiter', TMP_ParserContext_skip_past_delimiter_23 = function $$skip_past_delimiter(match) {\n        var self = this;\n\n        \n        self.buffer = \"\" + (self.buffer) + (match.$pre_match()) + (self.delimiter);\n        return match.$post_match();\n      }, TMP_ParserContext_skip_past_delimiter_23.$$arity = 1);\n      \n      Opal.def(self, '$skip_past_escaped_delimiter', TMP_ParserContext_skip_past_escaped_delimiter_24 = function $$skip_past_escaped_delimiter(match) {\n        var self = this;\n\n        \n        self.buffer = \"\" + (self.buffer) + (match.$pre_match().$chop()) + (self.delimiter);\n        return match.$post_match();\n      }, TMP_ParserContext_skip_past_escaped_delimiter_24.$$arity = 1);\n      \n      Opal.def(self, '$buffer_has_unclosed_quotes?', TMP_ParserContext_buffer_has_unclosed_quotes$q_25 = function(append) {\n        var $a, $b, self = this, record = nil, trailing_quote = nil;\n\n        if (append == null) {\n          append = nil;\n        }\n        if ($truthy((record = (function() {if ($truthy(append)) {\n          return $rb_plus(self.$buffer(), append).$strip()\n        } else {\n          return self.$buffer().$strip()\n        }; return nil; })())['$start_with?'](\"\\\"\"))) {\n          if ($truthy(($truthy($a = ($truthy($b = (trailing_quote = record['$end_with?'](\"\\\"\"))) ? record['$end_with?'](\"\\\"\\\"\") : $b)) ? $a : record['$start_with?'](\"\\\"\\\"\")))) {\n            return ($truthy($a = (record = record.$gsub(\"\\\"\\\"\", \"\"))['$start_with?'](\"\\\"\")) ? record['$end_with?'](\"\\\"\")['$!']() : $a)\n          } else {\n            return trailing_quote['$!']()\n          }\n        } else {\n          return false\n        }\n      }, TMP_ParserContext_buffer_has_unclosed_quotes$q_25.$$arity = -1);\n      \n      Opal.def(self, '$take_cellspec', TMP_ParserContext_take_cellspec_26 = function $$take_cellspec() {\n        var self = this;\n\n        return self.cellspecs.$shift()\n      }, TMP_ParserContext_take_cellspec_26.$$arity = 0);\n      \n      Opal.def(self, '$push_cellspec', TMP_ParserContext_push_cellspec_27 = function $$push_cellspec(cellspec) {\n        var $a, self = this;\n\n        if (cellspec == null) {\n          cellspec = $hash2([], {});\n        }\n        \n        self.cellspecs['$<<'](($truthy($a = cellspec) ? $a : $hash2([], {})));\n        return nil;\n      }, TMP_ParserContext_push_cellspec_27.$$arity = -1);\n      \n      Opal.def(self, '$keep_cell_open', TMP_ParserContext_keep_cell_open_28 = function $$keep_cell_open() {\n        var self = this;\n\n        \n        self.cell_open = true;\n        return nil;\n      }, TMP_ParserContext_keep_cell_open_28.$$arity = 0);\n      \n      Opal.def(self, '$mark_cell_closed', TMP_ParserContext_mark_cell_closed_29 = function $$mark_cell_closed() {\n        var self = this;\n\n        \n        self.cell_open = false;\n        return nil;\n      }, TMP_ParserContext_mark_cell_closed_29.$$arity = 0);\n      \n      Opal.def(self, '$cell_open?', TMP_ParserContext_cell_open$q_30 = function() {\n        var self = this;\n\n        return self.cell_open\n      }, TMP_ParserContext_cell_open$q_30.$$arity = 0);\n      \n      Opal.def(self, '$cell_closed?', TMP_ParserContext_cell_closed$q_31 = function() {\n        var self = this;\n\n        return self.cell_open['$!']()\n      }, TMP_ParserContext_cell_closed$q_31.$$arity = 0);\n      \n      Opal.def(self, '$close_open_cell', TMP_ParserContext_close_open_cell_32 = function $$close_open_cell(next_cellspec) {\n        var self = this;\n\n        if (next_cellspec == null) {\n          next_cellspec = $hash2([], {});\n        }\n        \n        self.$push_cellspec(next_cellspec);\n        if ($truthy(self['$cell_open?']())) {\n          self.$close_cell(true)};\n        self.$advance();\n        return nil;\n      }, TMP_ParserContext_close_open_cell_32.$$arity = -1);\n      \n      Opal.def(self, '$close_cell', TMP_ParserContext_close_cell_35 = function $$close_cell(eol) {try {\n\n        var $a, TMP_33, self = this, strip_text = nil, cell_text = nil, cellspec = nil, repeat = nil;\n\n        if (eol == null) {\n          eol = false;\n        }\n        \n        if (self.format['$=='](\"psv\")) {\n          \n          strip_text = true;\n          cell_text = self.buffer;\n          self.buffer = \"\";\n          if ($truthy((cellspec = self.$take_cellspec()))) {\n            repeat = ($truthy($a = cellspec.$delete(\"repeatcol\")) ? $a : 1)\n          } else {\n            \n            self.$warn(\"\" + \"asciidoctor: ERROR: \" + (self.last_cursor.$line_info()) + \": table missing leading separator, recovering automatically\");\n            cellspec = $hash2([], {});\n            repeat = 1;\n          };\n        } else {\n          \n          strip_text = false;\n          cell_text = self.buffer.$strip();\n          self.buffer = \"\";\n          cellspec = nil;\n          repeat = 1;\n          if (self.format['$=='](\"csv\")) {\n            if ($truthy(($truthy($a = cell_text['$empty?']()['$!']()) ? cell_text['$include?'](\"\\\"\") : $a))) {\n              \n              if ($truthy(($truthy($a = cell_text['$start_with?'](\"\\\"\")) ? cell_text['$end_with?'](\"\\\"\") : $a))) {\n                cell_text = cell_text['$[]']($range(1, -1, true)).$strip()};\n              cell_text = cell_text.$squeeze(\"\\\"\");}};\n        };\n        $send((1), 'upto', [repeat], (TMP_33 = function(i){var self = TMP_33.$$s || this, $b, $c, TMP_34, $d, column = nil, extra_cols = nil, offset = nil, cell = nil;\n          if (self.colcount == null) self.colcount = nil;\n          if (self.table == null) self.table = nil;\n          if (self.current_row == null) self.current_row = nil;\n          if (self.last_cursor == null) self.last_cursor = nil;\n          if (self.reader == null) self.reader = nil;\n          if (self.column_visits == null) self.column_visits = nil;\n          if (self.linenum == null) self.linenum = nil;\nif (i == null) i = nil;\n        \n          if (self.colcount['$=='](-1)) {\n            \n            self.table.$columns()['$<<']((column = $$$($$($nesting, 'Table'), 'Column').$new(self.table, $rb_minus($rb_plus(self.table.$columns().$size(), i), 1))));\n            if ($truthy(($truthy($b = ($truthy($c = cellspec) ? cellspec['$key?'](\"colspan\") : $c)) ? $rb_gt((extra_cols = $rb_minus(cellspec['$[]'](\"colspan\").$to_i(), 1)), 0) : $b))) {\n              \n              offset = self.table.$columns().$size();\n              $send(extra_cols, 'times', [], (TMP_34 = function(j){var self = TMP_34.$$s || this;\n                if (self.table == null) self.table = nil;\nif (j == null) j = nil;\n              return self.table.$columns()['$<<']($$$($$($nesting, 'Table'), 'Column').$new(self.table, $rb_plus(offset, j)))}, TMP_34.$$s = self, TMP_34.$$arity = 1, TMP_34));};\n          } else if ($truthy((column = self.table.$columns()['$[]'](self.current_row.$size())))) {\n          } else {\n            \n            self.$warn(\"\" + \"asciidoctor: ERROR: \" + (self.last_cursor.$line_info()) + \": dropping cell because it exceeds specified number of columns\");\n            Opal.ret(nil);\n          };\n          cell = $$$($$($nesting, 'Table'), 'Cell').$new(column, cell_text, cellspec, $hash2([\"cursor\", \"strip_text\"], {\"cursor\": self.last_cursor, \"strip_text\": strip_text}));\n          self.last_cursor = self.reader.$cursor();\n          if ($truthy(($truthy($b = cell.$rowspan()['$!']()) ? $b : cell.$rowspan()['$=='](1)))) {\n          } else {\n            self.$activate_rowspan(cell.$rowspan(), ($truthy($b = cell.$colspan()) ? $b : 1))\n          };\n          self.column_visits = $rb_plus(self.column_visits, ($truthy($b = cell.$colspan()) ? $b : 1));\n          self.current_row['$<<'](cell);\n          if ($truthy(($truthy($b = self['$end_of_row?']()) ? ($truthy($c = ($truthy($d = self.colcount['$!='](-1)) ? $d : $rb_gt(self.linenum, 0))) ? $c : ($truthy($d = eol) ? i['$=='](repeat) : $d)) : $b))) {\n            return self.$close_row()\n          } else {\n            return nil\n          };}, TMP_33.$$s = self, TMP_33.$$arity = 1, TMP_33));\n        self.cell_open = false;\n        return nil;\n        } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n      }, TMP_ParserContext_close_cell_35.$$arity = -1);\n      \n      Opal.def(self, '$close_row', TMP_ParserContext_close_row_36 = function $$close_row() {\n        var $a, self = this, $writer = nil;\n\n        \n        self.table.$rows().$body()['$<<'](self.current_row);\n        if (self.colcount['$=='](-1)) {\n          self.colcount = self.column_visits};\n        self.column_visits = 0;\n        self.current_row = [];\n        self.active_rowspans.$shift();\n        ($truthy($a = self.active_rowspans['$[]'](0)) ? $a : (($writer = [0, 0]), $send(self.active_rowspans, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n        return nil;\n      }, TMP_ParserContext_close_row_36.$$arity = 0);\n      \n      Opal.def(self, '$activate_rowspan', TMP_ParserContext_activate_rowspan_38 = function $$activate_rowspan(rowspan, colspan) {\n        var TMP_37, self = this;\n\n        \n        $send((1).$upto($rb_minus(rowspan, 1)), 'each', [], (TMP_37 = function(i){var self = TMP_37.$$s || this, $a, $writer = nil;\n          if (self.active_rowspans == null) self.active_rowspans = nil;\nif (i == null) i = nil;\n        \n          $writer = [i, $rb_plus(($truthy($a = self.active_rowspans['$[]'](i)) ? $a : 0), colspan)];\n          $send(self.active_rowspans, '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_37.$$s = self, TMP_37.$$arity = 1, TMP_37));\n        return nil;\n      }, TMP_ParserContext_activate_rowspan_38.$$arity = 2);\n      \n      Opal.def(self, '$end_of_row?', TMP_ParserContext_end_of_row$q_39 = function() {\n        var $a, self = this;\n\n        return ($truthy($a = self.colcount['$=='](-1)) ? $a : self.$effective_column_visits()['$=='](self.colcount))\n      }, TMP_ParserContext_end_of_row$q_39.$$arity = 0);\n      \n      Opal.def(self, '$effective_column_visits', TMP_ParserContext_effective_column_visits_40 = function $$effective_column_visits() {\n        var self = this;\n\n        return $rb_plus(self.column_visits, self.active_rowspans['$[]'](0))\n      }, TMP_ParserContext_effective_column_visits_40.$$arity = 0);\n      return (Opal.def(self, '$advance', TMP_ParserContext_advance_41 = function $$advance() {\n        var self = this;\n\n        return (self.linenum = $rb_plus(self.linenum, 1))\n      }, TMP_ParserContext_advance_41.$$arity = 0), nil) && 'advance';\n    })($$($nesting, 'Table'), null, $nesting);\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/converter/composite\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;\n\n  Opal.add_stubs(['$attr_reader', '$each', '$compact', '$flatten', '$respond_to?', '$composed', '$node_name', '$convert', '$converter_for', '$[]', '$find_converter', '$[]=', '$-', '$handles?', '$raise']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $CompositeConverter(){};\n      var self = $CompositeConverter = $klass($base, $super, 'CompositeConverter', $CompositeConverter);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_CompositeConverter_initialize_2, TMP_CompositeConverter_convert_3, TMP_CompositeConverter_converter_for_4, TMP_CompositeConverter_find_converter_6;\n\n      def.converter_map = def.converters = nil;\n      \n      self.$attr_reader(\"converters\");\n      \n      Opal.def(self, '$initialize', TMP_CompositeConverter_initialize_2 = function $$initialize(backend, $a_rest) {\n        var TMP_1, self = this, converters;\n\n        var $args_len = arguments.length, $rest_len = $args_len - 1;\n        if ($rest_len < 0) { $rest_len = 0; }\n        converters = new Array($rest_len);\n        for (var $arg_idx = 1; $arg_idx < $args_len; $arg_idx++) {\n          converters[$arg_idx - 1] = arguments[$arg_idx];\n        }\n        \n        self.backend = backend;\n        $send((self.converters = converters.$flatten().$compact()), 'each', [], (TMP_1 = function(converter){var self = TMP_1.$$s || this;\nif (converter == null) converter = nil;\n        if ($truthy(converter['$respond_to?'](\"composed\"))) {\n            return converter.$composed(self)\n          } else {\n            return nil\n          }}, TMP_1.$$s = self, TMP_1.$$arity = 1, TMP_1));\n        return (self.converter_map = $hash2([], {}));\n      }, TMP_CompositeConverter_initialize_2.$$arity = -2);\n      \n      Opal.def(self, '$convert', TMP_CompositeConverter_convert_3 = function $$convert(node, transform, opts) {\n        var $a, self = this;\n\n        if (transform == null) {\n          transform = nil;\n        }\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        \n        transform = ($truthy($a = transform) ? $a : node.$node_name());\n        return self.$converter_for(transform).$convert(node, transform, opts);\n      }, TMP_CompositeConverter_convert_3.$$arity = -2);\n      Opal.alias(self, \"convert_with_options\", \"convert\");\n      \n      Opal.def(self, '$converter_for', TMP_CompositeConverter_converter_for_4 = function $$converter_for(transform) {\n        var $a, self = this, $writer = nil;\n\n        return ($truthy($a = self.converter_map['$[]'](transform)) ? $a : (($writer = [transform, self.$find_converter(transform)]), $send(self.converter_map, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))\n      }, TMP_CompositeConverter_converter_for_4.$$arity = 1);\n      return (Opal.def(self, '$find_converter', TMP_CompositeConverter_find_converter_6 = function $$find_converter(transform) {try {\n\n        var TMP_5, self = this;\n\n        \n        $send(self.converters, 'each', [], (TMP_5 = function(candidate){var self = TMP_5.$$s || this;\nif (candidate == null) candidate = nil;\n        if ($truthy(candidate['$handles?'](transform))) {\n            Opal.ret(candidate)\n          } else {\n            return nil\n          }}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));\n        return self.$raise(\"\" + \"Could not find a converter to handle transform: \" + (transform));\n        } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }\n      }, TMP_CompositeConverter_find_converter_6.$$arity = 1), nil) && 'find_converter';\n    })($$($nesting, 'Converter'), $$$($$($nesting, 'Converter'), 'Base'), $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/converter/html5\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_le(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy, $range = Opal.range;\n\n  Opal.add_stubs(['$default=', '$-', '$==', '$[]', '$instance', '$empty?', '$attr', '$>=', '$safe', '$attr?', '$<<', '$include?', '$gsub', '$extname', '$doctitle', '$normalize_web_path', '$embed_primary_stylesheet', '$read_asset', '$normalize_system_path', '$===', '$coderay_stylesheet_name', '$embed_coderay_stylesheet', '$pygments_stylesheet_name', '$embed_pygments_stylesheet', '$docinfo', '$id', '$sections?', '$doctype', '$*', '$noheader', '$outline', '$has_header?', '$notitle', '$title', '$header', '$sub_macros', '$>', '$to_i', '$each', '$downcase', '$concat', '$content', '$footnotes?', '$!', '$footnotes', '$index', '$text', '$nofooter', '$inspect', '$!=', '$document', '$sections', '$level', '$caption', '$captioned_title', '$numbered', '$<=', '$sectnum', '$<', '$+', '$role', '$title?', '$icon_uri', '$compact', '$media_uri', '$option?', '$append_boolean_attribute', '$style', '$items', '$blocks?', '$text?', '$chomp', '$read_svg_contents', '$alt', '$image_uri', '$encode_quotes', '$to_sym', '$start_with?', '$end_with?', '$list_marker_keyword', '$parent', '$warn', '$context', '$times', '$size', '$columns', '$by_section', '$rows', '$colspan', '$rowspan', '$role?', '$unshift', '$shift', '$split', '$nil_or_empty?', '$type', '$attributes', '$catalog', '$xreftext', '$target', '$join', '$map', '$chop', '$read_contents', '$sub', '$match', '$length']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $Html5Converter(){};\n      var self = $Html5Converter = $klass($base, $super, 'Html5Converter', $Html5Converter);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Html5Converter_initialize_1, TMP_Html5Converter_document_4, TMP_Html5Converter_embedded_6, TMP_Html5Converter_outline_8, TMP_Html5Converter_section_9, TMP_Html5Converter_admonition_10, TMP_Html5Converter_audio_11, TMP_Html5Converter_colist_14, TMP_Html5Converter_dlist_21, TMP_Html5Converter_example_22, TMP_Html5Converter_floating_title_23, TMP_Html5Converter_image_24, TMP_Html5Converter_listing_25, TMP_Html5Converter_literal_26, TMP_Html5Converter_stem_27, TMP_Html5Converter_olist_29, TMP_Html5Converter_open_30, TMP_Html5Converter_page_break_31, TMP_Html5Converter_paragraph_32, TMP_Html5Converter_preamble_33, TMP_Html5Converter_quote_34, TMP_Html5Converter_thematic_break_35, TMP_Html5Converter_sidebar_36, TMP_Html5Converter_table_42, TMP_Html5Converter_toc_43, TMP_Html5Converter_ulist_45, TMP_Html5Converter_verse_46, TMP_Html5Converter_video_47, TMP_Html5Converter_inline_anchor_48, TMP_Html5Converter_inline_break_49, TMP_Html5Converter_inline_button_50, TMP_Html5Converter_inline_callout_51, TMP_Html5Converter_inline_footnote_52, TMP_Html5Converter_inline_image_55, TMP_Html5Converter_inline_indexterm_56, TMP_Html5Converter_inline_kbd_57, TMP_Html5Converter_inline_menu_58, TMP_Html5Converter_inline_quoted_59, TMP_Html5Converter_append_boolean_attribute_60, TMP_Html5Converter_encode_quotes_61, TMP_Html5Converter_read_svg_contents_63, $writer = nil;\n\n      def.xml_mode = def.void_element_slash = def.stylesheets = def.xrefstyle = nil;\n      \n      \n      $writer = [[\"\", \"\", false]];\n      $send(Opal.const_set($nesting[0], 'QUOTE_TAGS', $hash2([\"monospaced\", \"emphasis\", \"strong\", \"double\", \"single\", \"mark\", \"superscript\", \"subscript\", \"asciimath\", \"latexmath\"], {\"monospaced\": [\"<code>\", \"</code>\", true], \"emphasis\": [\"<em>\", \"</em>\", true], \"strong\": [\"<strong>\", \"</strong>\", true], \"double\": [\"&#8220;\", \"&#8221;\", false], \"single\": [\"&#8216;\", \"&#8217;\", false], \"mark\": [\"<mark>\", \"</mark>\", true], \"superscript\": [\"<sup>\", \"</sup>\", true], \"subscript\": [\"<sub>\", \"</sub>\", true], \"asciimath\": [\"\\\\$\", \"\\\\$\", false], \"latexmath\": [\"\\\\(\", \"\\\\)\", false]})), 'default=', Opal.to_a($writer));\n      $writer[$rb_minus($writer[\"length\"], 1)];;\n      Opal.const_set($nesting[0], 'SvgPreambleRx', /^.*?(?=<svg\\b)/m);\n      Opal.const_set($nesting[0], 'SvgStartTagRx', /^<svg[^>]*>/);\n      Opal.const_set($nesting[0], 'DimensionAttributeRx', /\\s(?:width|height|style)=([\"'])[^\\n]*?\\1/);\n      \n      Opal.def(self, '$initialize', TMP_Html5Converter_initialize_1 = function $$initialize(backend, opts) {\n        var self = this;\n\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        \n        self.xml_mode = opts['$[]'](\"htmlsyntax\")['$=='](\"xml\");\n        self.void_element_slash = (function() {if ($truthy(self.xml_mode)) {\n          return \"/\"\n        } else {\n          return nil\n        }; return nil; })();\n        return (self.stylesheets = $$($nesting, 'Stylesheets').$instance());\n      }, TMP_Html5Converter_initialize_1.$$arity = -2);\n      \n      Opal.def(self, '$document', TMP_Html5Converter_document_4 = function $$document(node) {\n        var $a, $b, $c, TMP_2, TMP_3, self = this, slash = nil, br = nil, asset_uri_scheme = nil, cdn_base = nil, linkcss = nil, result = nil, lang_attribute = nil, authors = nil, icon_href = nil, icon_type = nil, icon_ext = nil, webfonts = nil, iconfont_stylesheet = nil, $case = nil, highlighter = nil, pygments_style = nil, docinfo_content = nil, body_attrs = nil, sectioned = nil, details = nil, authorcount = nil, highlightjs_path = nil, prettify_path = nil, eqnums_val = nil, eqnums_opt = nil;\n\n        \n        slash = self.void_element_slash;\n        br = \"\" + \"<br\" + (slash) + \">\";\n        if ($truthy((asset_uri_scheme = node.$attr(\"asset-uri-scheme\", \"https\"))['$empty?']())) {\n        } else {\n          asset_uri_scheme = \"\" + (asset_uri_scheme) + \":\"\n        };\n        cdn_base = \"\" + (asset_uri_scheme) + \"//cdnjs.cloudflare.com/ajax/libs\";\n        linkcss = ($truthy($a = $rb_ge(node.$safe(), $$$($$($nesting, 'SafeMode'), 'SECURE'))) ? $a : node['$attr?'](\"linkcss\"));\n        result = [\"<!DOCTYPE html>\"];\n        lang_attribute = (function() {if ($truthy(node['$attr?'](\"nolang\"))) {\n          return nil\n        } else {\n          return \"\" + \" lang=\\\"\" + (node.$attr(\"lang\", \"en\")) + \"\\\"\"\n        }; return nil; })();\n        result['$<<'](\"\" + \"<html\" + ((function() {if ($truthy(self.xml_mode)) {\n          return \" xmlns=\\\"http://www.w3.org/1999/xhtml\\\"\"\n        } else {\n          return nil\n        }; return nil; })()) + (lang_attribute) + \">\");\n        result['$<<'](\"\" + \"<head>\\n\" + \"<meta charset=\\\"\" + (node.$attr(\"encoding\", \"UTF-8\")) + \"\\\"\" + (slash) + \">\\n\" + \"<!--[if IE]><meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"\" + (slash) + \"><![endif]-->\\n\" + \"<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"\" + (slash) + \">\\n\" + \"<meta name=\\\"generator\\\" content=\\\"Asciidoctor \" + (node.$attr(\"asciidoctor-version\")) + \"\\\"\" + (slash) + \">\");\n        if ($truthy(node['$attr?'](\"app-name\"))) {\n          result['$<<'](\"\" + \"<meta name=\\\"application-name\\\" content=\\\"\" + (node.$attr(\"app-name\")) + \"\\\"\" + (slash) + \">\")};\n        if ($truthy(node['$attr?'](\"description\"))) {\n          result['$<<'](\"\" + \"<meta name=\\\"description\\\" content=\\\"\" + (node.$attr(\"description\")) + \"\\\"\" + (slash) + \">\")};\n        if ($truthy(node['$attr?'](\"keywords\"))) {\n          result['$<<'](\"\" + \"<meta name=\\\"keywords\\\" content=\\\"\" + (node.$attr(\"keywords\")) + \"\\\"\" + (slash) + \">\")};\n        if ($truthy(node['$attr?'](\"authors\"))) {\n          result['$<<'](\"\" + \"<meta name=\\\"author\\\" content=\\\"\" + ((function() {if ($truthy((authors = node.$attr(\"authors\"))['$include?'](\"<\"))) {\n            \n            return authors.$gsub($$($nesting, 'XmlSanitizeRx'), \"\");\n          } else {\n            return authors\n          }; return nil; })()) + \"\\\"\" + (slash) + \">\")};\n        if ($truthy(node['$attr?'](\"copyright\"))) {\n          result['$<<'](\"\" + \"<meta name=\\\"copyright\\\" content=\\\"\" + (node.$attr(\"copyright\")) + \"\\\"\" + (slash) + \">\")};\n        if ($truthy(node['$attr?'](\"favicon\"))) {\n          \n          if ($truthy((icon_href = node.$attr(\"favicon\"))['$empty?']())) {\n            $a = [\"favicon.ico\", \"image/x-icon\"], (icon_href = $a[0]), (icon_type = $a[1]), $a\n          } else {\n            icon_type = (function() {if ((icon_ext = $$$('::', 'File').$extname(icon_href))['$=='](\".ico\")) {\n              return \"image/x-icon\"\n            } else {\n              return \"\" + \"image/\" + (icon_ext['$[]']($range(1, -1, false)))\n            }; return nil; })()\n          };\n          result['$<<'](\"\" + \"<link rel=\\\"shortcut icon\\\" type=\\\"\" + (icon_type) + \"\\\" href=\\\"\" + (icon_href) + \"\\\">\");};\n        result['$<<'](\"\" + \"<title>\" + (node.$doctitle($hash2([\"sanitize\", \"use_fallback\"], {\"sanitize\": true, \"use_fallback\": true}))) + \"</title>\");\n        if ($truthy($$($nesting, 'DEFAULT_STYLESHEET_KEYS')['$include?'](node.$attr(\"stylesheet\")))) {\n          \n          if ($truthy((webfonts = node.$attr(\"webfonts\")))) {\n            result['$<<'](\"\" + \"<link rel=\\\"stylesheet\\\" href=\\\"\" + (asset_uri_scheme) + \"//fonts.googleapis.com/css?family=\" + ((function() {if ($truthy(webfonts['$empty?']())) {\n              return \"Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700\"\n            } else {\n              return webfonts\n            }; return nil; })()) + \"\\\"\" + (slash) + \">\")};\n          if ($truthy(linkcss)) {\n            result['$<<'](\"\" + \"<link rel=\\\"stylesheet\\\" href=\\\"\" + (node.$normalize_web_path($$($nesting, 'DEFAULT_STYLESHEET_NAME'), node.$attr(\"stylesdir\", \"\"), false)) + \"\\\"\" + (slash) + \">\")\n          } else {\n            result['$<<'](self.stylesheets.$embed_primary_stylesheet())\n          };\n        } else if ($truthy(node['$attr?'](\"stylesheet\"))) {\n          if ($truthy(linkcss)) {\n            result['$<<'](\"\" + \"<link rel=\\\"stylesheet\\\" href=\\\"\" + (node.$normalize_web_path(node.$attr(\"stylesheet\"), node.$attr(\"stylesdir\", \"\"))) + \"\\\"\" + (slash) + \">\")\n          } else {\n            result['$<<'](\"\" + \"<style>\\n\" + (node.$read_asset(node.$normalize_system_path(node.$attr(\"stylesheet\"), node.$attr(\"stylesdir\", \"\")), $hash2([\"warn_on_failure\", \"label\"], {\"warn_on_failure\": true, \"label\": \"stylesheet\"}))) + \"\\n\" + \"</style>\")\n          }};\n        if ($truthy(node['$attr?'](\"icons\", \"font\"))) {\n          if ($truthy(node['$attr?'](\"iconfont-remote\"))) {\n            result['$<<'](\"\" + \"<link rel=\\\"stylesheet\\\" href=\\\"\" + (node.$attr(\"iconfont-cdn\", \"\" + (cdn_base) + \"/font-awesome/4.6.3/css/font-awesome.min.css\")) + \"\\\"\" + (slash) + \">\")\n          } else {\n            \n            iconfont_stylesheet = \"\" + (node.$attr(\"iconfont-name\", \"font-awesome\")) + \".css\";\n            result['$<<'](\"\" + \"<link rel=\\\"stylesheet\\\" href=\\\"\" + (node.$normalize_web_path(iconfont_stylesheet, node.$attr(\"stylesdir\", \"\"), false)) + \"\\\"\" + (slash) + \">\");\n          }};\n        $case = (highlighter = node.$attr(\"source-highlighter\"));\n        if (\"coderay\"['$===']($case)) {if (node.$attr(\"coderay-css\", \"class\")['$=='](\"class\")) {\n          if ($truthy(linkcss)) {\n            result['$<<'](\"\" + \"<link rel=\\\"stylesheet\\\" href=\\\"\" + (node.$normalize_web_path(self.stylesheets.$coderay_stylesheet_name(), node.$attr(\"stylesdir\", \"\"), false)) + \"\\\"\" + (slash) + \">\")\n          } else {\n            result['$<<'](self.stylesheets.$embed_coderay_stylesheet())\n          }}}\n        else if (\"pygments\"['$===']($case)) {if (node.$attr(\"pygments-css\", \"class\")['$=='](\"class\")) {\n          \n          pygments_style = node.$attr(\"pygments-style\");\n          if ($truthy(linkcss)) {\n            result['$<<'](\"\" + \"<link rel=\\\"stylesheet\\\" href=\\\"\" + (node.$normalize_web_path(self.stylesheets.$pygments_stylesheet_name(pygments_style), node.$attr(\"stylesdir\", \"\"), false)) + \"\\\"\" + (slash) + \">\")\n          } else {\n            result['$<<'](self.stylesheets.$embed_pygments_stylesheet(pygments_style))\n          };}};\n        if ($truthy((docinfo_content = node.$docinfo())['$empty?']())) {\n        } else {\n          result['$<<'](docinfo_content)\n        };\n        result['$<<'](\"</head>\");\n        body_attrs = [];\n        if ($truthy(node.$id())) {\n          body_attrs['$<<'](\"\" + \"id=\\\"\" + (node.$id()) + \"\\\"\")};\n        if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = (sectioned = node['$sections?']())) ? node['$attr?'](\"toc-class\") : $c)) ? node['$attr?'](\"toc\") : $b)) ? node['$attr?'](\"toc-placement\", \"auto\") : $a))) {\n          body_attrs['$<<'](\"\" + \"class=\\\"\" + (node.$doctype()) + \" \" + (node.$attr(\"toc-class\")) + \" toc-\" + (node.$attr(\"toc-position\", \"header\")) + \"\\\"\")\n        } else {\n          body_attrs['$<<'](\"\" + \"class=\\\"\" + (node.$doctype()) + \"\\\"\")\n        };\n        if ($truthy(node['$attr?'](\"max-width\"))) {\n          body_attrs['$<<'](\"\" + \"style=\\\"max-width: \" + (node.$attr(\"max-width\")) + \";\\\"\")};\n        result['$<<'](\"\" + \"<body \" + ($rb_times(body_attrs, \" \")) + \">\");\n        if ($truthy(node.$noheader())) {\n        } else {\n          \n          result['$<<'](\"<div id=\\\"header\\\">\");\n          if (node.$doctype()['$=='](\"manpage\")) {\n            \n            result['$<<'](\"\" + \"<h1>\" + (node.$doctitle()) + \" Manual Page</h1>\");\n            if ($truthy(($truthy($a = ($truthy($b = sectioned) ? node['$attr?'](\"toc\") : $b)) ? node['$attr?'](\"toc-placement\", \"auto\") : $a))) {\n              result['$<<'](\"\" + \"<div id=\\\"toc\\\" class=\\\"\" + (node.$attr(\"toc-class\", \"toc\")) + \"\\\">\\n\" + \"<div id=\\\"toctitle\\\">\" + (node.$attr(\"toc-title\")) + \"</div>\\n\" + (self.$outline(node)) + \"\\n\" + \"</div>\")};\n            result['$<<'](\"\" + \"<h2>\" + (node.$attr(\"manname-title\")) + \"</h2>\\n\" + \"<div class=\\\"sectionbody\\\">\\n\" + \"<p>\" + (node.$attr(\"manname\")) + \" - \" + (node.$attr(\"manpurpose\")) + \"</p>\\n\" + \"</div>\");\n          } else {\n            \n            if ($truthy(node['$has_header?']())) {\n              \n              if ($truthy(node.$notitle())) {\n              } else {\n                result['$<<'](\"\" + \"<h1>\" + (node.$header().$title()) + \"</h1>\")\n              };\n              details = [];\n              if ($truthy(node['$attr?'](\"author\"))) {\n                \n                details['$<<'](\"\" + \"<span id=\\\"author\\\" class=\\\"author\\\">\" + (node.$attr(\"author\")) + \"</span>\" + (br));\n                if ($truthy(node['$attr?'](\"email\"))) {\n                  details['$<<'](\"\" + \"<span id=\\\"email\\\" class=\\\"email\\\">\" + (node.$sub_macros(node.$attr(\"email\"))) + \"</span>\" + (br))};\n                if ($truthy($rb_gt((authorcount = node.$attr(\"authorcount\").$to_i()), 1))) {\n                  $send(Opal.Range.$new(2, authorcount, false), 'each', [], (TMP_2 = function(idx){var self = TMP_2.$$s || this;\nif (idx == null) idx = nil;\n                  \n                    details['$<<'](\"\" + \"<span id=\\\"author\" + (idx) + \"\\\" class=\\\"author\\\">\" + (node.$attr(\"\" + \"author_\" + (idx))) + \"</span>\" + (br));\n                    if ($truthy(node['$attr?'](\"\" + \"email_\" + (idx)))) {\n                      return details['$<<'](\"\" + \"<span id=\\\"email\" + (idx) + \"\\\" class=\\\"email\\\">\" + (node.$sub_macros(node.$attr(\"\" + \"email_\" + (idx)))) + \"</span>\" + (br))\n                    } else {\n                      return nil\n                    };}, TMP_2.$$s = self, TMP_2.$$arity = 1, TMP_2))};};\n              if ($truthy(node['$attr?'](\"revnumber\"))) {\n                details['$<<'](\"\" + \"<span id=\\\"revnumber\\\">\" + (($truthy($a = node.$attr(\"version-label\")) ? $a : \"\").$downcase()) + \" \" + (node.$attr(\"revnumber\")) + ((function() {if ($truthy(node['$attr?'](\"revdate\"))) {\n                  return \",\"\n                } else {\n                  return \"\"\n                }; return nil; })()) + \"</span>\")};\n              if ($truthy(node['$attr?'](\"revdate\"))) {\n                details['$<<'](\"\" + \"<span id=\\\"revdate\\\">\" + (node.$attr(\"revdate\")) + \"</span>\")};\n              if ($truthy(node['$attr?'](\"revremark\"))) {\n                details['$<<'](\"\" + (br) + \"<span id=\\\"revremark\\\">\" + (node.$attr(\"revremark\")) + \"</span>\")};\n              if ($truthy(details['$empty?']())) {\n              } else {\n                \n                result['$<<'](\"<div class=\\\"details\\\">\");\n                result.$concat(details);\n                result['$<<'](\"</div>\");\n              };};\n            if ($truthy(($truthy($a = ($truthy($b = sectioned) ? node['$attr?'](\"toc\") : $b)) ? node['$attr?'](\"toc-placement\", \"auto\") : $a))) {\n              result['$<<'](\"\" + \"<div id=\\\"toc\\\" class=\\\"\" + (node.$attr(\"toc-class\", \"toc\")) + \"\\\">\\n\" + \"<div id=\\\"toctitle\\\">\" + (node.$attr(\"toc-title\")) + \"</div>\\n\" + (self.$outline(node)) + \"\\n\" + \"</div>\")};\n          };\n          result['$<<'](\"</div>\");\n        };\n        result['$<<'](\"\" + \"<div id=\\\"content\\\">\\n\" + (node.$content()) + \"\\n\" + \"</div>\");\n        if ($truthy(($truthy($a = node['$footnotes?']()) ? node['$attr?'](\"nofootnotes\")['$!']() : $a))) {\n          \n          result['$<<'](\"\" + \"<div id=\\\"footnotes\\\">\\n\" + \"<hr\" + (slash) + \">\");\n          $send(node.$footnotes(), 'each', [], (TMP_3 = function(footnote){var self = TMP_3.$$s || this;\nif (footnote == null) footnote = nil;\n          return result['$<<'](\"\" + \"<div class=\\\"footnote\\\" id=\\\"_footnote_\" + (footnote.$index()) + \"\\\">\\n\" + \"<a href=\\\"#_footnoteref_\" + (footnote.$index()) + \"\\\">\" + (footnote.$index()) + \"</a>. \" + (footnote.$text()) + \"\\n\" + \"</div>\")}, TMP_3.$$s = self, TMP_3.$$arity = 1, TMP_3));\n          result['$<<'](\"</div>\");};\n        if ($truthy(node.$nofooter())) {\n        } else {\n          \n          result['$<<'](\"<div id=\\\"footer\\\">\");\n          result['$<<'](\"<div id=\\\"footer-text\\\">\");\n          if ($truthy(node['$attr?'](\"revnumber\"))) {\n            result['$<<'](\"\" + (node.$attr(\"version-label\")) + \" \" + (node.$attr(\"revnumber\")) + (br))};\n          if ($truthy(($truthy($a = node['$attr?'](\"last-update-label\")) ? node['$attr?'](\"reproducible\")['$!']() : $a))) {\n            result['$<<'](\"\" + (node.$attr(\"last-update-label\")) + \" \" + (node.$attr(\"docdatetime\")))};\n          result['$<<'](\"</div>\");\n          result['$<<'](\"</div>\");\n        };\n        if ($truthy((docinfo_content = node.$docinfo(\"footer\"))['$empty?']())) {\n        } else {\n          result['$<<'](docinfo_content)\n        };\n        $case = highlighter;\n        if (\"highlightjs\"['$===']($case) || \"highlight.js\"['$===']($case)) {\n        highlightjs_path = node.$attr(\"highlightjsdir\", \"\" + (cdn_base) + \"/highlight.js/9.12.0\");\n        result['$<<'](\"\" + \"<link rel=\\\"stylesheet\\\" href=\\\"\" + (highlightjs_path) + \"/styles/\" + (node.$attr(\"highlightjs-theme\", \"github\")) + \".min.css\\\"\" + (slash) + \">\");\n        result['$<<'](\"\" + \"<script src=\\\"\" + (highlightjs_path) + \"/highlight.min.js\\\"></script>\\n\" + \"<script>hljs.initHighlighting()</script>\");}\n        else if (\"prettify\"['$===']($case)) {\n        prettify_path = node.$attr(\"prettifydir\", \"\" + (cdn_base) + \"/prettify/r298\");\n        result['$<<'](\"\" + \"<link rel=\\\"stylesheet\\\" href=\\\"\" + (prettify_path) + \"/\" + (node.$attr(\"prettify-theme\", \"prettify\")) + \".min.css\\\"\" + (slash) + \">\");\n        result['$<<'](\"\" + \"<script src=\\\"\" + (prettify_path) + \"/prettify.min.js\\\"></script>\\n\" + \"<script>prettyPrint()</script>\");};\n        if ($truthy(node['$attr?'](\"stem\"))) {\n          \n          eqnums_val = node.$attr(\"eqnums\", \"none\");\n          if ($truthy(eqnums_val['$empty?']())) {\n            eqnums_val = \"AMS\"};\n          eqnums_opt = \"\" + \" equationNumbers: { autoNumber: \\\"\" + (eqnums_val) + \"\\\" } \";\n          result['$<<'](\"\" + \"<script type=\\\"text/x-mathjax-config\\\">\\n\" + \"MathJax.Hub.Config({\\n\" + \"  messageStyle: \\\"none\\\",\\n\" + \"  tex2jax: {\\n\" + \"    inlineMath: [\" + ($$($nesting, 'INLINE_MATH_DELIMITERS')['$[]'](\"latexmath\").$inspect()) + \"],\\n\" + \"    displayMath: [\" + ($$($nesting, 'BLOCK_MATH_DELIMITERS')['$[]'](\"latexmath\").$inspect()) + \"],\\n\" + \"    ignoreClass: \\\"nostem|nolatexmath\\\"\\n\" + \"  },\\n\" + \"  asciimath2jax: {\\n\" + \"    delimiters: [\" + ($$($nesting, 'BLOCK_MATH_DELIMITERS')['$[]'](\"asciimath\").$inspect()) + \"],\\n\" + \"    ignoreClass: \\\"nostem|noasciimath\\\"\\n\" + \"  },\\n\" + \"  TeX: {\" + (eqnums_opt) + \"}\\n\" + \"});\\n\" + \"</script>\\n\" + \"<script src=\\\"\" + (cdn_base) + \"/mathjax/2.6.0/MathJax.js?config=TeX-MML-AM_HTMLorMML\\\"></script>\");};\n        result['$<<'](\"</body>\");\n        result['$<<'](\"</html>\");\n        return $rb_times(result, $$($nesting, 'LF'));\n      }, TMP_Html5Converter_document_4.$$arity = 1);\n      \n      Opal.def(self, '$embedded', TMP_Html5Converter_embedded_6 = function $$embedded(node) {\n        var $a, $b, $c, TMP_5, self = this, result = nil, id_attr = nil, toc_p = nil;\n\n        \n        result = [];\n        if (node.$doctype()['$=='](\"manpage\")) {\n          \n          if ($truthy(node.$notitle())) {\n          } else {\n            \n            id_attr = (function() {if ($truthy(node.$id())) {\n              return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n            } else {\n              return nil\n            }; return nil; })();\n            result['$<<'](\"\" + \"<h1\" + (id_attr) + \">\" + (node.$doctitle()) + \" Manual Page</h1>\");\n          };\n          result['$<<'](\"\" + \"<h2>\" + (node.$attr(\"manname-title\")) + \"</h2>\\n\" + \"<div class=\\\"sectionbody\\\">\\n\" + \"<p>\" + (node.$attr(\"manname\")) + \" - \" + (node.$attr(\"manpurpose\")) + \"</p>\\n\" + \"</div>\");\n        } else if ($truthy(($truthy($a = node['$has_header?']()) ? node.$notitle()['$!']() : $a))) {\n          \n          id_attr = (function() {if ($truthy(node.$id())) {\n            return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n          } else {\n            return nil\n          }; return nil; })();\n          result['$<<'](\"\" + \"<h1\" + (id_attr) + \">\" + (node.$header().$title()) + \"</h1>\");};\n        if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = node['$sections?']()) ? node['$attr?'](\"toc\") : $c)) ? (toc_p = node.$attr(\"toc-placement\"))['$!='](\"macro\") : $b)) ? toc_p['$!='](\"preamble\") : $a))) {\n          result['$<<'](\"\" + \"<div id=\\\"toc\\\" class=\\\"toc\\\">\\n\" + \"<div id=\\\"toctitle\\\">\" + (node.$attr(\"toc-title\")) + \"</div>\\n\" + (self.$outline(node)) + \"\\n\" + \"</div>\")};\n        result['$<<'](node.$content());\n        if ($truthy(($truthy($a = node['$footnotes?']()) ? node['$attr?'](\"nofootnotes\")['$!']() : $a))) {\n          \n          result['$<<'](\"\" + \"<div id=\\\"footnotes\\\">\\n\" + \"<hr\" + (self.void_element_slash) + \">\");\n          $send(node.$footnotes(), 'each', [], (TMP_5 = function(footnote){var self = TMP_5.$$s || this;\nif (footnote == null) footnote = nil;\n          return result['$<<'](\"\" + \"<div class=\\\"footnote\\\" id=\\\"_footnote_\" + (footnote.$index()) + \"\\\">\\n\" + \"<a href=\\\"#_footnoteref_\" + (footnote.$index()) + \"\\\">\" + (footnote.$index()) + \"</a>. \" + (footnote.$text()) + \"\\n\" + \"</div>\")}, TMP_5.$$s = self, TMP_5.$$arity = 1, TMP_5));\n          result['$<<'](\"</div>\");};\n        return $rb_times(result, $$($nesting, 'LF'));\n      }, TMP_Html5Converter_embedded_6.$$arity = 1);\n      \n      Opal.def(self, '$outline', TMP_Html5Converter_outline_8 = function $$outline(node, opts) {\n        var $a, TMP_7, self = this, sectnumlevels = nil, toclevels = nil, sections = nil, result = nil;\n\n        if (opts == null) {\n          opts = $hash2([], {});\n        }\n        \n        if ($truthy(node['$sections?']())) {\n        } else {\n          return nil\n        };\n        sectnumlevels = ($truthy($a = opts['$[]'](\"sectnumlevels\")) ? $a : node.$document().$attr(\"sectnumlevels\", 3).$to_i());\n        toclevels = ($truthy($a = opts['$[]'](\"toclevels\")) ? $a : node.$document().$attr(\"toclevels\", 2).$to_i());\n        sections = node.$sections();\n        result = [\"\" + \"<ul class=\\\"sectlevel\" + (sections['$[]'](0).$level()) + \"\\\">\"];\n        $send(sections, 'each', [], (TMP_7 = function(section){var self = TMP_7.$$s || this, $b, slevel = nil, stitle = nil, child_toc_level = nil;\nif (section == null) section = nil;\n        \n          slevel = section.$level();\n          if ($truthy(section.$caption())) {\n            stitle = section.$captioned_title()\n          } else if ($truthy(($truthy($b = section.$numbered()) ? $rb_le(slevel, sectnumlevels) : $b))) {\n            stitle = \"\" + (section.$sectnum()) + \" \" + (section.$title())\n          } else {\n            stitle = section.$title()\n          };\n          if ($truthy(($truthy($b = $rb_lt(slevel, toclevels)) ? (child_toc_level = self.$outline(section, $hash2([\"toclevels\", \"secnumlevels\"], {\"toclevels\": toclevels, \"secnumlevels\": sectnumlevels}))) : $b))) {\n            \n            result['$<<'](\"\" + \"<li><a href=\\\"#\" + (section.$id()) + \"\\\">\" + (stitle) + \"</a>\");\n            result['$<<'](child_toc_level);\n            return result['$<<'](\"</li>\");\n          } else {\n            return result['$<<'](\"\" + \"<li><a href=\\\"#\" + (section.$id()) + \"\\\">\" + (stitle) + \"</a></li>\")\n          };}, TMP_7.$$s = self, TMP_7.$$arity = 1, TMP_7));\n        result['$<<'](\"</ul>\");\n        return $rb_times(result, $$($nesting, 'LF'));\n      }, TMP_Html5Converter_outline_8.$$arity = -2);\n      \n      Opal.def(self, '$section', TMP_Html5Converter_section_9 = function $$section(node) {\n        var $a, $b, self = this, slevel = nil, htag = nil, id_attr = nil, anchor = nil, link_start = nil, link_end = nil, id = nil, doc = nil, class_attr = nil, role = nil, sectnum = nil;\n\n        \n        slevel = node.$level();\n        htag = \"\" + \"h\" + ($rb_plus(slevel, 1));\n        id_attr = (anchor = (link_start = (link_end = nil)));\n        if ($truthy(node.$id())) {\n          \n          id_attr = \"\" + \" id=\\\"\" + ((id = node.$id())) + \"\\\"\";\n          if ($truthy((doc = node.$document())['$attr?'](\"sectanchors\"))) {\n            anchor = \"\" + \"<a class=\\\"anchor\\\" href=\\\"#\" + (id) + \"\\\"></a>\"};\n          if ($truthy(doc['$attr?'](\"sectlinks\"))) {\n            \n            link_start = \"\" + \"<a class=\\\"link\\\" href=\\\"#\" + (id) + \"\\\">\";\n            link_end = \"</a>\";};};\n        if (slevel['$=='](0)) {\n          return \"\" + \"<h1\" + (id_attr) + \" class=\\\"sect0\\\">\" + (anchor) + (link_start) + (node.$title()) + (link_end) + \"</h1>\\n\" + (node.$content())\n        } else {\n          \n          class_attr = (function() {if ($truthy((role = node.$role()))) {\n            return \"\" + \" class=\\\"sect\" + (slevel) + \" \" + (role) + \"\\\"\"\n          } else {\n            return \"\" + \" class=\\\"sect\" + (slevel) + \"\\\"\"\n          }; return nil; })();\n          sectnum = (function() {if ($truthy(($truthy($a = ($truthy($b = node.$numbered()) ? node.$caption()['$!']() : $b)) ? $rb_le(slevel, node.$document().$attr(\"sectnumlevels\", 3).$to_i()) : $a))) {\n            return \"\" + (node.$sectnum()) + \" \"\n          } else {\n            return nil\n          }; return nil; })();\n          return \"\" + \"<div\" + (class_attr) + \">\\n\" + \"<\" + (htag) + (id_attr) + \">\" + (anchor) + (link_start) + (sectnum) + (node.$captioned_title()) + (link_end) + \"</\" + (htag) + \">\\n\" + ((function() {if (slevel['$=='](1)) {\n            return \"\" + \"<div class=\\\"sectionbody\\\">\\n\" + (node.$content()) + \"\\n</div>\"\n          } else {\n            return node.$content()\n          }; return nil; })()) + \"\\n\" + \"</div>\";\n        };\n      }, TMP_Html5Converter_section_9.$$arity = 1);\n      \n      Opal.def(self, '$admonition', TMP_Html5Converter_admonition_10 = function $$admonition(node) {\n        var $a, self = this, id_attr = nil, name = nil, title_element = nil, label = nil, role = nil;\n\n        \n        id_attr = (function() {if ($truthy(node.$id())) {\n          return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        name = node.$attr(\"name\");\n        title_element = (function() {if ($truthy(node['$title?']())) {\n          return \"\" + \"<div class=\\\"title\\\">\" + (node.$title()) + \"</div>\\n\"\n        } else {\n          return nil\n        }; return nil; })();\n        if ($truthy(node.$document()['$attr?'](\"icons\"))) {\n          if ($truthy(($truthy($a = node.$document()['$attr?'](\"icons\", \"font\")) ? node['$attr?'](\"icon\")['$!']() : $a))) {\n            label = \"\" + \"<i class=\\\"fa icon-\" + (name) + \"\\\" title=\\\"\" + (node.$attr(\"textlabel\")) + \"\\\"></i>\"\n          } else {\n            label = \"\" + \"<img src=\\\"\" + (node.$icon_uri(name)) + \"\\\" alt=\\\"\" + (node.$attr(\"textlabel\")) + \"\\\"\" + (self.void_element_slash) + \">\"\n          }\n        } else {\n          label = \"\" + \"<div class=\\\"title\\\">\" + (node.$attr(\"textlabel\")) + \"</div>\"\n        };\n        return \"\" + \"<div\" + (id_attr) + \" class=\\\"admonitionblock \" + (name) + (($truthy($a = (role = node.$role())) ? \"\" + \" \" + (role) : $a)) + \"\\\">\\n\" + \"<table>\\n\" + \"<tr>\\n\" + \"<td class=\\\"icon\\\">\\n\" + (label) + \"\\n\" + \"</td>\\n\" + \"<td class=\\\"content\\\">\\n\" + (title_element) + (node.$content()) + \"\\n\" + \"</td>\\n\" + \"</tr>\\n\" + \"</table>\\n\" + \"</div>\";\n      }, TMP_Html5Converter_admonition_10.$$arity = 1);\n      \n      Opal.def(self, '$audio', TMP_Html5Converter_audio_11 = function $$audio(node) {\n        var $a, self = this, xml = nil, id_attribute = nil, classes = nil, class_attribute = nil, title_element = nil, start_t = nil, end_t = nil, time_anchor = nil;\n\n        \n        xml = self.xml_mode;\n        id_attribute = (function() {if ($truthy(node.$id())) {\n          return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        classes = [\"audioblock\", node.$role()].$compact();\n        class_attribute = \"\" + \" class=\\\"\" + ($rb_times(classes, \" \")) + \"\\\"\";\n        title_element = (function() {if ($truthy(node['$title?']())) {\n          return \"\" + \"<div class=\\\"title\\\">\" + (node.$title()) + \"</div>\\n\"\n        } else {\n          return nil\n        }; return nil; })();\n        start_t = node.$attr(\"start\", nil, false);\n        end_t = node.$attr(\"end\", nil, false);\n        time_anchor = (function() {if ($truthy(($truthy($a = start_t) ? $a : end_t))) {\n          return \"\" + \"#t=\" + (start_t) + ((function() {if ($truthy(end_t)) {\n            return \",\"\n          } else {\n            return nil\n          }; return nil; })()) + (end_t)\n        } else {\n          return nil\n        }; return nil; })();\n        return \"\" + \"<div\" + (id_attribute) + (class_attribute) + \">\\n\" + (title_element) + \"<div class=\\\"content\\\">\\n\" + \"<audio src=\\\"\" + (node.$media_uri(node.$attr(\"target\"))) + (time_anchor) + \"\\\"\" + ((function() {if ($truthy(node['$option?'](\"autoplay\"))) {\n          \n          return self.$append_boolean_attribute(\"autoplay\", xml);\n        } else {\n          return nil\n        }; return nil; })()) + ((function() {if ($truthy(node['$option?'](\"nocontrols\"))) {\n          return nil\n        } else {\n          \n          return self.$append_boolean_attribute(\"controls\", xml);\n        }; return nil; })()) + ((function() {if ($truthy(node['$option?'](\"loop\"))) {\n          \n          return self.$append_boolean_attribute(\"loop\", xml);\n        } else {\n          return nil\n        }; return nil; })()) + \">\\n\" + \"Your browser does not support the audio tag.\\n\" + \"</audio>\\n\" + \"</div>\\n\" + \"</div>\";\n      }, TMP_Html5Converter_audio_11.$$arity = 1);\n      \n      Opal.def(self, '$colist', TMP_Html5Converter_colist_14 = function $$colist(node) {\n        var $a, TMP_12, TMP_13, self = this, result = nil, id_attribute = nil, classes = nil, class_attribute = nil, font_icons = nil, num = nil;\n\n        \n        result = [];\n        id_attribute = (function() {if ($truthy(node.$id())) {\n          return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        classes = [\"colist\", node.$style(), node.$role()].$compact();\n        class_attribute = \"\" + \" class=\\\"\" + ($rb_times(classes, \" \")) + \"\\\"\";\n        result['$<<'](\"\" + \"<div\" + (id_attribute) + (class_attribute) + \">\");\n        if ($truthy(node['$title?']())) {\n          result['$<<'](\"\" + \"<div class=\\\"title\\\">\" + (node.$title()) + \"</div>\")};\n        if ($truthy(node.$document()['$attr?'](\"icons\"))) {\n          \n          result['$<<'](\"<table>\");\n          $a = [node.$document()['$attr?'](\"icons\", \"font\"), 0], (font_icons = $a[0]), (num = $a[1]), $a;\n          $send(node.$items(), 'each', [], (TMP_12 = function(item){var self = TMP_12.$$s || this, num_label = nil;\n            if (self.void_element_slash == null) self.void_element_slash = nil;\nif (item == null) item = nil;\n          \n            num = $rb_plus(num, 1);\n            if ($truthy(font_icons)) {\n              num_label = \"\" + \"<i class=\\\"conum\\\" data-value=\\\"\" + (num) + \"\\\"></i><b>\" + (num) + \"</b>\"\n            } else {\n              num_label = \"\" + \"<img src=\\\"\" + (node.$icon_uri(\"\" + \"callouts/\" + (num))) + \"\\\" alt=\\\"\" + (num) + \"\\\"\" + (self.void_element_slash) + \">\"\n            };\n            return result['$<<'](\"\" + \"<tr>\\n\" + \"<td>\" + (num_label) + \"</td>\\n\" + \"<td>\" + (item.$text()) + ((function() {if ($truthy(item['$blocks?']())) {\n              return $rb_plus($$($nesting, 'LF'), item.$content())\n            } else {\n              return \"\"\n            }; return nil; })()) + \"</td>\\n\" + \"</tr>\");}, TMP_12.$$s = self, TMP_12.$$arity = 1, TMP_12));\n          result['$<<'](\"</table>\");\n        } else {\n          \n          result['$<<'](\"<ol>\");\n          $send(node.$items(), 'each', [], (TMP_13 = function(item){var self = TMP_13.$$s || this;\nif (item == null) item = nil;\n          return result['$<<'](\"\" + \"<li>\\n\" + \"<p>\" + (item.$text()) + \"</p>\" + ((function() {if ($truthy(item['$blocks?']())) {\n              return $rb_plus($$($nesting, 'LF'), item.$content())\n            } else {\n              return \"\"\n            }; return nil; })()) + \"\\n\" + \"</li>\")}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13));\n          result['$<<'](\"</ol>\");\n        };\n        result['$<<'](\"</div>\");\n        return $rb_times(result, $$($nesting, 'LF'));\n      }, TMP_Html5Converter_colist_14.$$arity = 1);\n      \n      Opal.def(self, '$dlist', TMP_Html5Converter_dlist_21 = function $$dlist(node) {\n        var TMP_15, $a, TMP_17, TMP_19, self = this, result = nil, id_attribute = nil, classes = nil, $case = nil, class_attribute = nil, slash = nil, col_style_attribute = nil, dt_style_attribute = nil;\n\n        \n        result = [];\n        id_attribute = (function() {if ($truthy(node.$id())) {\n          return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        classes = (function() {$case = node.$style();\n        if (\"qanda\"['$===']($case)) {return [\"qlist\", \"qanda\", node.$role()]}\n        else if (\"horizontal\"['$===']($case)) {return [\"hdlist\", node.$role()]}\n        else {return [\"dlist\", node.$style(), node.$role()]}})().$compact();\n        class_attribute = \"\" + \" class=\\\"\" + ($rb_times(classes, \" \")) + \"\\\"\";\n        result['$<<'](\"\" + \"<div\" + (id_attribute) + (class_attribute) + \">\");\n        if ($truthy(node['$title?']())) {\n          result['$<<'](\"\" + \"<div class=\\\"title\\\">\" + (node.$title()) + \"</div>\")};\n        $case = node.$style();\n        if (\"qanda\"['$===']($case)) {\n        result['$<<'](\"<ol>\");\n        $send(node.$items(), 'each', [], (TMP_15 = function(terms, dd){var self = TMP_15.$$s || this, TMP_16;\nif (terms == null) terms = nil;if (dd == null) dd = nil;\n        \n          result['$<<'](\"<li>\");\n          $send([].concat(Opal.to_a(terms)), 'each', [], (TMP_16 = function(dt){var self = TMP_16.$$s || this;\nif (dt == null) dt = nil;\n          return result['$<<'](\"\" + \"<p><em>\" + (dt.$text()) + \"</em></p>\")}, TMP_16.$$s = self, TMP_16.$$arity = 1, TMP_16));\n          if ($truthy(dd)) {\n            \n            if ($truthy(dd['$text?']())) {\n              result['$<<'](\"\" + \"<p>\" + (dd.$text()) + \"</p>\")};\n            if ($truthy(dd['$blocks?']())) {\n              result['$<<'](dd.$content())};};\n          return result['$<<'](\"</li>\");}, TMP_15.$$s = self, TMP_15.$$arity = 2, TMP_15));\n        result['$<<'](\"</ol>\");}\n        else if (\"horizontal\"['$===']($case)) {\n        slash = self.void_element_slash;\n        result['$<<'](\"<table>\");\n        if ($truthy(($truthy($a = node['$attr?'](\"labelwidth\")) ? $a : node['$attr?'](\"itemwidth\")))) {\n          \n          result['$<<'](\"<colgroup>\");\n          col_style_attribute = (function() {if ($truthy(node['$attr?'](\"labelwidth\"))) {\n            return \"\" + \" style=\\\"width: \" + (node.$attr(\"labelwidth\").$chomp(\"%\")) + \"%;\\\"\"\n          } else {\n            return nil\n          }; return nil; })();\n          result['$<<'](\"\" + \"<col\" + (col_style_attribute) + (slash) + \">\");\n          col_style_attribute = (function() {if ($truthy(node['$attr?'](\"itemwidth\"))) {\n            return \"\" + \" style=\\\"width: \" + (node.$attr(\"itemwidth\").$chomp(\"%\")) + \"%;\\\"\"\n          } else {\n            return nil\n          }; return nil; })();\n          result['$<<'](\"\" + \"<col\" + (col_style_attribute) + (slash) + \">\");\n          result['$<<'](\"</colgroup>\");};\n        $send(node.$items(), 'each', [], (TMP_17 = function(terms, dd){var self = TMP_17.$$s || this, TMP_18, terms_array = nil, last_term = nil;\nif (terms == null) terms = nil;if (dd == null) dd = nil;\n        \n          result['$<<'](\"<tr>\");\n          result['$<<'](\"\" + \"<td class=\\\"hdlist1\" + ((function() {if ($truthy(node['$option?'](\"strong\"))) {\n            return \" strong\"\n          } else {\n            return nil\n          }; return nil; })()) + \"\\\">\");\n          terms_array = [].concat(Opal.to_a(terms));\n          last_term = terms_array['$[]'](-1);\n          $send(terms_array, 'each', [], (TMP_18 = function(dt){var self = TMP_18.$$s || this;\nif (dt == null) dt = nil;\n          \n            result['$<<'](dt.$text());\n            if ($truthy(dt['$!='](last_term))) {\n              return result['$<<'](\"\" + \"<br\" + (slash) + \">\")\n            } else {\n              return nil\n            };}, TMP_18.$$s = self, TMP_18.$$arity = 1, TMP_18));\n          result['$<<'](\"</td>\");\n          result['$<<'](\"<td class=\\\"hdlist2\\\">\");\n          if ($truthy(dd)) {\n            \n            if ($truthy(dd['$text?']())) {\n              result['$<<'](\"\" + \"<p>\" + (dd.$text()) + \"</p>\")};\n            if ($truthy(dd['$blocks?']())) {\n              result['$<<'](dd.$content())};};\n          result['$<<'](\"</td>\");\n          return result['$<<'](\"</tr>\");}, TMP_17.$$s = self, TMP_17.$$arity = 2, TMP_17));\n        result['$<<'](\"</table>\");}\n        else {\n        result['$<<'](\"<dl>\");\n        dt_style_attribute = (function() {if ($truthy(node.$style())) {\n          return nil\n        } else {\n          return \" class=\\\"hdlist1\\\"\"\n        }; return nil; })();\n        $send(node.$items(), 'each', [], (TMP_19 = function(terms, dd){var self = TMP_19.$$s || this, TMP_20;\nif (terms == null) terms = nil;if (dd == null) dd = nil;\n        \n          $send([].concat(Opal.to_a(terms)), 'each', [], (TMP_20 = function(dt){var self = TMP_20.$$s || this;\nif (dt == null) dt = nil;\n          return result['$<<'](\"\" + \"<dt\" + (dt_style_attribute) + \">\" + (dt.$text()) + \"</dt>\")}, TMP_20.$$s = self, TMP_20.$$arity = 1, TMP_20));\n          if ($truthy(dd)) {\n            \n            result['$<<'](\"<dd>\");\n            if ($truthy(dd['$text?']())) {\n              result['$<<'](\"\" + \"<p>\" + (dd.$text()) + \"</p>\")};\n            if ($truthy(dd['$blocks?']())) {\n              result['$<<'](dd.$content())};\n            return result['$<<'](\"</dd>\");\n          } else {\n            return nil\n          };}, TMP_19.$$s = self, TMP_19.$$arity = 2, TMP_19));\n        result['$<<'](\"</dl>\");};\n        result['$<<'](\"</div>\");\n        return $rb_times(result, $$($nesting, 'LF'));\n      }, TMP_Html5Converter_dlist_21.$$arity = 1);\n      \n      Opal.def(self, '$example', TMP_Html5Converter_example_22 = function $$example(node) {\n        var $a, self = this, id_attribute = nil, title_element = nil, role = nil;\n\n        \n        id_attribute = (function() {if ($truthy(node.$id())) {\n          return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        title_element = (function() {if ($truthy(node['$title?']())) {\n          return \"\" + \"<div class=\\\"title\\\">\" + (node.$captioned_title()) + \"</div>\\n\"\n        } else {\n          return nil\n        }; return nil; })();\n        return \"\" + \"<div\" + (id_attribute) + \" class=\\\"exampleblock\" + (($truthy($a = (role = node.$role())) ? \"\" + \" \" + (role) : $a)) + \"\\\">\\n\" + (title_element) + \"<div class=\\\"content\\\">\\n\" + (node.$content()) + \"\\n\" + \"</div>\\n\" + \"</div>\";\n      }, TMP_Html5Converter_example_22.$$arity = 1);\n      \n      Opal.def(self, '$floating_title', TMP_Html5Converter_floating_title_23 = function $$floating_title(node) {\n        var self = this, tag_name = nil, id_attribute = nil, classes = nil;\n\n        \n        tag_name = \"\" + \"h\" + ($rb_plus(node.$level(), 1));\n        id_attribute = (function() {if ($truthy(node.$id())) {\n          return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        classes = [node.$style(), node.$role()].$compact();\n        return \"\" + \"<\" + (tag_name) + (id_attribute) + \" class=\\\"\" + ($rb_times(classes, \" \")) + \"\\\">\" + (node.$title()) + \"</\" + (tag_name) + \">\";\n      }, TMP_Html5Converter_floating_title_23.$$arity = 1);\n      \n      Opal.def(self, '$image', TMP_Html5Converter_image_24 = function $$image(node) {\n        var $a, $b, $c, self = this, target = nil, width_attr = nil, height_attr = nil, svg = nil, obj = nil, img = nil, fallback = nil, window_attr = nil, window = nil, id_attr = nil, classes = nil, class_attr = nil, styles = nil, style_attr = nil, title_el = nil;\n\n        \n        target = node.$attr(\"target\");\n        width_attr = (function() {if ($truthy(node['$attr?'](\"width\"))) {\n          return \"\" + \" width=\\\"\" + (node.$attr(\"width\")) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        height_attr = (function() {if ($truthy(node['$attr?'](\"height\"))) {\n          return \"\" + \" height=\\\"\" + (node.$attr(\"height\")) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = node['$attr?'](\"format\", \"svg\", false)) ? $c : target['$include?'](\".svg\"))) ? $rb_lt(node.$document().$safe(), $$$($$($nesting, 'SafeMode'), 'SECURE')) : $b)) ? ($truthy($b = (svg = node['$option?'](\"inline\"))) ? $b : (obj = node['$option?'](\"interactive\"))) : $a))) {\n          if ($truthy(svg)) {\n            img = ($truthy($a = self.$read_svg_contents(node, target)) ? $a : \"\" + \"<span class=\\\"alt\\\">\" + (node.$alt()) + \"</span>\")\n          } else if ($truthy(obj)) {\n            \n            fallback = (function() {if ($truthy(node['$attr?'](\"fallback\"))) {\n              return \"\" + \"<img src=\\\"\" + (node.$image_uri(node.$attr(\"fallback\"))) + \"\\\" alt=\\\"\" + (self.$encode_quotes(node.$alt())) + \"\\\"\" + (width_attr) + (height_attr) + (self.void_element_slash) + \">\"\n            } else {\n              return \"\" + \"<span class=\\\"alt\\\">\" + (node.$alt()) + \"</span>\"\n            }; return nil; })();\n            img = \"\" + \"<object type=\\\"image/svg+xml\\\" data=\\\"\" + (node.$image_uri(target)) + \"\\\"\" + (width_attr) + (height_attr) + \">\" + (fallback) + \"</object>\";}};\n        img = ($truthy($a = img) ? $a : \"\" + \"<img src=\\\"\" + (node.$image_uri(target)) + \"\\\" alt=\\\"\" + (self.$encode_quotes(node.$alt())) + \"\\\"\" + (width_attr) + (height_attr) + (self.void_element_slash) + \">\");\n        if ($truthy(node['$attr?'](\"link\"))) {\n          \n          if ($truthy(node['$attr?'](\"window\"))) {\n            window_attr = \"\" + \" target=\\\"\" + ((window = node.$attr(\"window\"))) + \"\\\"\" + ((function() {if ($truthy(($truthy($a = window['$=='](\"_blank\")) ? $a : node['$option?'](\"noopener\")))) {\n              return \" rel=\\\"noopener\\\"\"\n            } else {\n              return \"\"\n            }; return nil; })())};\n          img = \"\" + \"<a class=\\\"image\\\" href=\\\"\" + (node.$attr(\"link\")) + \"\\\"\" + (window_attr) + \">\" + (img) + \"</a>\";};\n        id_attr = (function() {if ($truthy(node.$id())) {\n          return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        classes = [\"imageblock\", node.$role()].$compact();\n        class_attr = \"\" + \" class=\\\"\" + ($rb_times(classes, \" \")) + \"\\\"\";\n        styles = [];\n        if ($truthy(node['$attr?'](\"align\"))) {\n          styles['$<<'](\"\" + \"text-align: \" + (node.$attr(\"align\")))};\n        if ($truthy(node['$attr?'](\"float\"))) {\n          styles['$<<'](\"\" + \"float: \" + (node.$attr(\"float\")))};\n        style_attr = (function() {if ($truthy(styles['$empty?']())) {\n          return nil\n        } else {\n          return \"\" + \" style=\\\"\" + ($rb_times(styles, \";\")) + \"\\\"\"\n        }; return nil; })();\n        title_el = (function() {if ($truthy(node['$title?']())) {\n          return \"\" + \"\\n<div class=\\\"title\\\">\" + (node.$captioned_title()) + \"</div>\"\n        } else {\n          return nil\n        }; return nil; })();\n        return \"\" + \"<div\" + (id_attr) + (class_attr) + (style_attr) + \">\\n\" + \"<div class=\\\"content\\\">\\n\" + (img) + \"\\n\" + \"</div>\" + (title_el) + \"\\n\" + \"</div>\";\n      }, TMP_Html5Converter_image_24.$$arity = 1);\n      \n      Opal.def(self, '$listing', TMP_Html5Converter_listing_25 = function $$listing(node) {\n        var $a, self = this, nowrap = nil, language = nil, code_attrs = nil, $case = nil, pre_class = nil, pre_start = nil, pre_end = nil, id_attribute = nil, title_element = nil, role = nil;\n\n        \n        nowrap = ($truthy($a = node.$document()['$attr?'](\"prewrap\")['$!']()) ? $a : node['$option?'](\"nowrap\"));\n        if (node.$style()['$=='](\"source\")) {\n          \n          if ($truthy((language = node.$attr(\"language\", nil, false)))) {\n            code_attrs = \"\" + \" data-lang=\\\"\" + (language) + \"\\\"\"\n          } else {\n            code_attrs = nil\n          };\n          $case = node.$document().$attr(\"source-highlighter\");\n          if (\"coderay\"['$===']($case)) {pre_class = \"\" + \" class=\\\"CodeRay highlight\" + ((function() {if ($truthy(nowrap)) {\n            return \" nowrap\"\n          } else {\n            return nil\n          }; return nil; })()) + \"\\\"\"}\n          else if (\"pygments\"['$===']($case)) {pre_class = \"\" + \" class=\\\"pygments highlight\" + ((function() {if ($truthy(nowrap)) {\n            return \" nowrap\"\n          } else {\n            return nil\n          }; return nil; })()) + \"\\\"\"}\n          else if (\"highlightjs\"['$===']($case) || \"highlight.js\"['$===']($case)) {\n          pre_class = \"\" + \" class=\\\"highlightjs highlight\" + ((function() {if ($truthy(nowrap)) {\n            return \" nowrap\"\n          } else {\n            return nil\n          }; return nil; })()) + \"\\\"\";\n          if ($truthy(language)) {\n            code_attrs = \"\" + \" class=\\\"language-\" + (language) + \" hljs\\\"\" + (code_attrs)};}\n          else if (\"prettify\"['$===']($case)) {\n          pre_class = \"\" + \" class=\\\"prettyprint highlight\" + ((function() {if ($truthy(nowrap)) {\n            return \" nowrap\"\n          } else {\n            return nil\n          }; return nil; })()) + ((function() {if ($truthy(node['$attr?'](\"linenums\", nil, false))) {\n            return \" linenums\"\n          } else {\n            return nil\n          }; return nil; })()) + \"\\\"\";\n          if ($truthy(language)) {\n            code_attrs = \"\" + \" class=\\\"language-\" + (language) + \"\\\"\" + (code_attrs)};}\n          else if (\"html-pipeline\"['$===']($case)) {\n          pre_class = (function() {if ($truthy(language)) {\n            return \"\" + \" lang=\\\"\" + (language) + \"\\\"\"\n          } else {\n            return nil\n          }; return nil; })();\n          code_attrs = nil;}\n          else {\n          pre_class = \"\" + \" class=\\\"highlight\" + ((function() {if ($truthy(nowrap)) {\n            return \" nowrap\"\n          } else {\n            return nil\n          }; return nil; })()) + \"\\\"\";\n          if ($truthy(language)) {\n            code_attrs = \"\" + \" class=\\\"language-\" + (language) + \"\\\"\" + (code_attrs)};};\n          pre_start = \"\" + \"<pre\" + (pre_class) + \"><code\" + (code_attrs) + \">\";\n          pre_end = \"</code></pre>\";\n        } else {\n          \n          pre_start = \"\" + \"<pre\" + ((function() {if ($truthy(nowrap)) {\n            return \" class=\\\"nowrap\\\"\"\n          } else {\n            return nil\n          }; return nil; })()) + \">\";\n          pre_end = \"</pre>\";\n        };\n        id_attribute = (function() {if ($truthy(node.$id())) {\n          return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        title_element = (function() {if ($truthy(node['$title?']())) {\n          return \"\" + \"<div class=\\\"title\\\">\" + (node.$captioned_title()) + \"</div>\\n\"\n        } else {\n          return nil\n        }; return nil; })();\n        return \"\" + \"<div\" + (id_attribute) + \" class=\\\"listingblock\" + (($truthy($a = (role = node.$role())) ? \"\" + \" \" + (role) : $a)) + \"\\\">\\n\" + (title_element) + \"<div class=\\\"content\\\">\\n\" + (pre_start) + (node.$content()) + (pre_end) + \"\\n\" + \"</div>\\n\" + \"</div>\";\n      }, TMP_Html5Converter_listing_25.$$arity = 1);\n      \n      Opal.def(self, '$literal', TMP_Html5Converter_literal_26 = function $$literal(node) {\n        var $a, self = this, id_attribute = nil, title_element = nil, nowrap = nil, role = nil;\n\n        \n        id_attribute = (function() {if ($truthy(node.$id())) {\n          return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        title_element = (function() {if ($truthy(node['$title?']())) {\n          return \"\" + \"<div class=\\\"title\\\">\" + (node.$title()) + \"</div>\\n\"\n        } else {\n          return nil\n        }; return nil; })();\n        nowrap = ($truthy($a = node.$document()['$attr?'](\"prewrap\")['$!']()) ? $a : node['$option?'](\"nowrap\"));\n        return \"\" + \"<div\" + (id_attribute) + \" class=\\\"literalblock\" + (($truthy($a = (role = node.$role())) ? \"\" + \" \" + (role) : $a)) + \"\\\">\\n\" + (title_element) + \"<div class=\\\"content\\\">\\n\" + \"<pre\" + ((function() {if ($truthy(nowrap)) {\n          return \" class=\\\"nowrap\\\"\"\n        } else {\n          return nil\n        }; return nil; })()) + \">\" + (node.$content()) + \"</pre>\\n\" + \"</div>\\n\" + \"</div>\";\n      }, TMP_Html5Converter_literal_26.$$arity = 1);\n      \n      Opal.def(self, '$stem', TMP_Html5Converter_stem_27 = function $$stem(node) {\n        var $a, $b, self = this, id_attribute = nil, title_element = nil, open = nil, close = nil, equation = nil, role = nil;\n\n        \n        id_attribute = (function() {if ($truthy(node.$id())) {\n          return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        title_element = (function() {if ($truthy(node['$title?']())) {\n          return \"\" + \"<div class=\\\"title\\\">\" + (node.$title()) + \"</div>\\n\"\n        } else {\n          return nil\n        }; return nil; })();\n        $b = $$($nesting, 'BLOCK_MATH_DELIMITERS')['$[]'](node.$style().$to_sym()), $a = Opal.to_ary($b), (open = ($a[0] == null ? nil : $a[0])), (close = ($a[1] == null ? nil : $a[1])), $b;\n        if ($truthy(($truthy($a = (equation = node.$content())['$start_with?'](open)) ? equation['$end_with?'](close) : $a))) {\n        } else {\n          equation = \"\" + (open) + (equation) + (close)\n        };\n        return \"\" + \"<div\" + (id_attribute) + \" class=\\\"stemblock\" + (($truthy($a = (role = node.$role())) ? \"\" + \" \" + (role) : $a)) + \"\\\">\\n\" + (title_element) + \"<div class=\\\"content\\\">\\n\" + (equation) + \"\\n\" + \"</div>\\n\" + \"</div>\";\n      }, TMP_Html5Converter_stem_27.$$arity = 1);\n      \n      Opal.def(self, '$olist', TMP_Html5Converter_olist_29 = function $$olist(node) {\n        var TMP_28, self = this, result = nil, id_attribute = nil, classes = nil, class_attribute = nil, type_attribute = nil, keyword = nil, start_attribute = nil, reversed_attribute = nil;\n\n        \n        result = [];\n        id_attribute = (function() {if ($truthy(node.$id())) {\n          return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        classes = [\"olist\", node.$style(), node.$role()].$compact();\n        class_attribute = \"\" + \" class=\\\"\" + ($rb_times(classes, \" \")) + \"\\\"\";\n        result['$<<'](\"\" + \"<div\" + (id_attribute) + (class_attribute) + \">\");\n        if ($truthy(node['$title?']())) {\n          result['$<<'](\"\" + \"<div class=\\\"title\\\">\" + (node.$title()) + \"</div>\")};\n        type_attribute = (function() {if ($truthy((keyword = node.$list_marker_keyword()))) {\n          return \"\" + \" type=\\\"\" + (keyword) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        start_attribute = (function() {if ($truthy(node['$attr?'](\"start\"))) {\n          return \"\" + \" start=\\\"\" + (node.$attr(\"start\")) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        reversed_attribute = (function() {if ($truthy(node['$option?'](\"reversed\"))) {\n          \n          return self.$append_boolean_attribute(\"reversed\", self.xml_mode);\n        } else {\n          return nil\n        }; return nil; })();\n        result['$<<'](\"\" + \"<ol class=\\\"\" + (node.$style()) + \"\\\"\" + (type_attribute) + (start_attribute) + (reversed_attribute) + \">\");\n        $send(node.$items(), 'each', [], (TMP_28 = function(item){var self = TMP_28.$$s || this;\nif (item == null) item = nil;\n        \n          result['$<<'](\"<li>\");\n          result['$<<'](\"\" + \"<p>\" + (item.$text()) + \"</p>\");\n          if ($truthy(item['$blocks?']())) {\n            result['$<<'](item.$content())};\n          return result['$<<'](\"</li>\");}, TMP_28.$$s = self, TMP_28.$$arity = 1, TMP_28));\n        result['$<<'](\"</ol>\");\n        result['$<<'](\"</div>\");\n        return $rb_times(result, $$($nesting, 'LF'));\n      }, TMP_Html5Converter_olist_29.$$arity = 1);\n      \n      Opal.def(self, '$open', TMP_Html5Converter_open_30 = function $$open(node) {\n        var $a, $b, $c, self = this, style = nil, id_attr = nil, title_el = nil, role = nil;\n\n        if ((style = node.$style())['$=='](\"abstract\")) {\n          if ($truthy((($a = node.$parent()['$=='](node.$document())) ? node.$document().$doctype()['$=='](\"book\") : node.$parent()['$=='](node.$document())))) {\n            \n            self.$warn(\"asciidoctor: WARNING: abstract block cannot be used in a document without a title when doctype is book. Excluding block content.\");\n            return \"\";\n          } else {\n            \n            id_attr = (function() {if ($truthy(node.$id())) {\n              return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n            } else {\n              return nil\n            }; return nil; })();\n            title_el = (function() {if ($truthy(node['$title?']())) {\n              return \"\" + \"<div class=\\\"title\\\">\" + (node.$title()) + \"</div>\\n\"\n            } else {\n              return nil\n            }; return nil; })();\n            return \"\" + \"<div\" + (id_attr) + \" class=\\\"quoteblock abstract\" + (($truthy($a = (role = node.$role())) ? \"\" + \" \" + (role) : $a)) + \"\\\">\\n\" + (title_el) + \"<blockquote>\\n\" + (node.$content()) + \"\\n\" + \"</blockquote>\\n\" + \"</div>\";\n          }\n        } else if ($truthy((($a = style['$=='](\"partintro\")) ? ($truthy($b = ($truthy($c = $rb_gt(node.$level(), 0)) ? $c : node.$parent().$context()['$!='](\"section\"))) ? $b : node.$document().$doctype()['$!='](\"book\")) : style['$=='](\"partintro\")))) {\n          \n          self.$warn(\"asciidoctor: ERROR: partintro block can only be used when doctype is book and it's a child of a book part. Excluding block content.\");\n          return \"\";\n        } else {\n          \n          id_attr = (function() {if ($truthy(node.$id())) {\n            return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n          } else {\n            return nil\n          }; return nil; })();\n          title_el = (function() {if ($truthy(node['$title?']())) {\n            return \"\" + \"<div class=\\\"title\\\">\" + (node.$title()) + \"</div>\\n\"\n          } else {\n            return nil\n          }; return nil; })();\n          return \"\" + \"<div\" + (id_attr) + \" class=\\\"openblock\" + ((function() {if ($truthy(($truthy($a = style) ? style['$!='](\"open\") : $a))) {\n            return \"\" + \" \" + (style)\n          } else {\n            return \"\"\n          }; return nil; })()) + (($truthy($a = (role = node.$role())) ? \"\" + \" \" + (role) : $a)) + \"\\\">\\n\" + (title_el) + \"<div class=\\\"content\\\">\\n\" + (node.$content()) + \"\\n\" + \"</div>\\n\" + \"</div>\";\n        }\n      }, TMP_Html5Converter_open_30.$$arity = 1);\n      \n      Opal.def(self, '$page_break', TMP_Html5Converter_page_break_31 = function $$page_break(node) {\n        var self = this;\n\n        return \"<div style=\\\"page-break-after: always;\\\"></div>\"\n      }, TMP_Html5Converter_page_break_31.$$arity = 1);\n      \n      Opal.def(self, '$paragraph', TMP_Html5Converter_paragraph_32 = function $$paragraph(node) {\n        var self = this, class_attribute = nil, attributes = nil;\n\n        \n        class_attribute = (function() {if ($truthy(node.$role())) {\n          return \"\" + \"class=\\\"paragraph \" + (node.$role()) + \"\\\"\"\n        } else {\n          return \"class=\\\"paragraph\\\"\"\n        }; return nil; })();\n        attributes = (function() {if ($truthy(node.$id())) {\n          return \"\" + \"id=\\\"\" + (node.$id()) + \"\\\" \" + (class_attribute)\n        } else {\n          return class_attribute\n        }; return nil; })();\n        if ($truthy(node['$title?']())) {\n          return \"\" + \"<div \" + (attributes) + \">\\n\" + \"<div class=\\\"title\\\">\" + (node.$title()) + \"</div>\\n\" + \"<p>\" + (node.$content()) + \"</p>\\n\" + \"</div>\"\n        } else {\n          return \"\" + \"<div \" + (attributes) + \">\\n\" + \"<p>\" + (node.$content()) + \"</p>\\n\" + \"</div>\"\n        };\n      }, TMP_Html5Converter_paragraph_32.$$arity = 1);\n      \n      Opal.def(self, '$preamble', TMP_Html5Converter_preamble_33 = function $$preamble(node) {\n        var $a, $b, self = this, doc = nil, toc = nil;\n\n        \n        if ($truthy(($truthy($a = ($truthy($b = (doc = node.$document())['$attr?'](\"toc-placement\", \"preamble\")) ? doc['$sections?']() : $b)) ? doc['$attr?'](\"toc\") : $a))) {\n          toc = \"\" + \"\\n\" + \"<div id=\\\"toc\\\" class=\\\"\" + (doc.$attr(\"toc-class\", \"toc\")) + \"\\\">\\n\" + \"<div id=\\\"toctitle\\\">\" + (doc.$attr(\"toc-title\")) + \"</div>\\n\" + (self.$outline(doc)) + \"\\n\" + \"</div>\"\n        } else {\n          toc = nil\n        };\n        return \"\" + \"<div id=\\\"preamble\\\">\\n\" + \"<div class=\\\"sectionbody\\\">\\n\" + (node.$content()) + \"\\n\" + \"</div>\" + (toc) + \"\\n\" + \"</div>\";\n      }, TMP_Html5Converter_preamble_33.$$arity = 1);\n      \n      Opal.def(self, '$quote', TMP_Html5Converter_quote_34 = function $$quote(node) {\n        var $a, self = this, id_attribute = nil, classes = nil, class_attribute = nil, title_element = nil, attribution = nil, citetitle = nil, cite_element = nil, attribution_text = nil, attribution_element = nil;\n\n        \n        id_attribute = (function() {if ($truthy(node.$id())) {\n          return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        classes = [\"quoteblock\", node.$role()].$compact();\n        class_attribute = \"\" + \" class=\\\"\" + ($rb_times(classes, \" \")) + \"\\\"\";\n        title_element = (function() {if ($truthy(node['$title?']())) {\n          return \"\" + \"\\n<div class=\\\"title\\\">\" + (node.$title()) + \"</div>\"\n        } else {\n          return nil\n        }; return nil; })();\n        attribution = (function() {if ($truthy(node['$attr?'](\"attribution\"))) {\n          \n          return node.$attr(\"attribution\");\n        } else {\n          return nil\n        }; return nil; })();\n        citetitle = (function() {if ($truthy(node['$attr?'](\"citetitle\"))) {\n          \n          return node.$attr(\"citetitle\");\n        } else {\n          return nil\n        }; return nil; })();\n        if ($truthy(($truthy($a = attribution) ? $a : citetitle))) {\n          \n          cite_element = (function() {if ($truthy(citetitle)) {\n            return \"\" + \"<cite>\" + (citetitle) + \"</cite>\"\n          } else {\n            return nil\n          }; return nil; })();\n          attribution_text = (function() {if ($truthy(attribution)) {\n            return \"\" + \"&#8212; \" + (attribution) + ((function() {if ($truthy(citetitle)) {\n              return \"\" + \"<br\" + (self.void_element_slash) + \">\\n\"\n            } else {\n              return nil\n            }; return nil; })())\n          } else {\n            return nil\n          }; return nil; })();\n          attribution_element = \"\" + \"\\n<div class=\\\"attribution\\\">\\n\" + (attribution_text) + (cite_element) + \"\\n</div>\";\n        } else {\n          attribution_element = nil\n        };\n        return \"\" + \"<div\" + (id_attribute) + (class_attribute) + \">\" + (title_element) + \"\\n\" + \"<blockquote>\\n\" + (node.$content()) + \"\\n\" + \"</blockquote>\" + (attribution_element) + \"\\n\" + \"</div>\";\n      }, TMP_Html5Converter_quote_34.$$arity = 1);\n      \n      Opal.def(self, '$thematic_break', TMP_Html5Converter_thematic_break_35 = function $$thematic_break(node) {\n        var self = this;\n\n        return \"\" + \"<hr\" + (self.void_element_slash) + \">\"\n      }, TMP_Html5Converter_thematic_break_35.$$arity = 1);\n      \n      Opal.def(self, '$sidebar', TMP_Html5Converter_sidebar_36 = function $$sidebar(node) {\n        var $a, self = this, id_attribute = nil, title_element = nil, role = nil;\n\n        \n        id_attribute = (function() {if ($truthy(node.$id())) {\n          return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        title_element = (function() {if ($truthy(node['$title?']())) {\n          return \"\" + \"<div class=\\\"title\\\">\" + (node.$title()) + \"</div>\\n\"\n        } else {\n          return nil\n        }; return nil; })();\n        return \"\" + \"<div\" + (id_attribute) + \" class=\\\"sidebarblock\" + (($truthy($a = (role = node.$role())) ? \"\" + \" \" + (role) : $a)) + \"\\\">\\n\" + \"<div class=\\\"content\\\">\\n\" + (title_element) + (node.$content()) + \"\\n\" + \"</div>\\n\" + \"</div>\";\n      }, TMP_Html5Converter_sidebar_36.$$arity = 1);\n      \n      Opal.def(self, '$table', TMP_Html5Converter_table_42 = function $$table(node) {\n        var $a, TMP_37, TMP_38, TMP_39, self = this, result = nil, id_attribute = nil, classes = nil, styles = nil, role = nil, class_attribute = nil, style_attribute = nil, slash = nil, tag = nil;\n\n        \n        result = [];\n        id_attribute = (function() {if ($truthy(node.$id())) {\n          return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        classes = [\"tableblock\", \"\" + \"frame-\" + (node.$attr(\"frame\", \"all\")), \"\" + \"grid-\" + (node.$attr(\"grid\", \"all\"))];\n        styles = [];\n        if ($truthy(($truthy($a = node['$option?'](\"autowidth\")) ? node['$attr?'](\"width\", nil, false)['$!']() : $a))) {\n        } else if ($truthy(node['$attr?'](\"tablepcwidth\", 100))) {\n          classes['$<<'](\"spread\")\n        } else {\n          styles['$<<'](\"\" + \"width: \" + (node.$attr(\"tablepcwidth\")) + \"%;\")\n        };\n        if ($truthy((role = node.$role()))) {\n          classes['$<<'](role)};\n        class_attribute = \"\" + \" class=\\\"\" + ($rb_times(classes, \" \")) + \"\\\"\";\n        if ($truthy(node['$attr?'](\"float\"))) {\n          styles['$<<'](\"\" + \"float: \" + (node.$attr(\"float\")) + \";\")};\n        style_attribute = (function() {if ($truthy(styles['$empty?']())) {\n          return nil\n        } else {\n          return \"\" + \" style=\\\"\" + ($rb_times(styles, \" \")) + \"\\\"\"\n        }; return nil; })();\n        result['$<<'](\"\" + \"<table\" + (id_attribute) + (class_attribute) + (style_attribute) + \">\");\n        if ($truthy(node['$title?']())) {\n          result['$<<'](\"\" + \"<caption class=\\\"title\\\">\" + (node.$captioned_title()) + \"</caption>\")};\n        if ($truthy($rb_gt(node.$attr(\"rowcount\"), 0))) {\n          \n          slash = self.void_element_slash;\n          result['$<<'](\"<colgroup>\");\n          if ($truthy(node['$option?'](\"autowidth\"))) {\n            \n            tag = \"\" + \"<col\" + (slash) + \">\";\n            $send(node.$columns().$size(), 'times', [], (TMP_37 = function(){var self = TMP_37.$$s || this;\n\n            return result['$<<'](tag)}, TMP_37.$$s = self, TMP_37.$$arity = 0, TMP_37));\n          } else {\n            $send(node.$columns(), 'each', [], (TMP_38 = function(col){var self = TMP_38.$$s || this;\nif (col == null) col = nil;\n            return result['$<<'](\"\" + \"<col style=\\\"width: \" + (col.$attr(\"colpcwidth\")) + \"%;\\\"\" + (slash) + \">\")}, TMP_38.$$s = self, TMP_38.$$arity = 1, TMP_38))\n          };\n          result['$<<'](\"</colgroup>\");\n          $send(node.$rows().$by_section(), 'each', [], (TMP_39 = function(tsec, rows){var self = TMP_39.$$s || this, TMP_40;\nif (tsec == null) tsec = nil;if (rows == null) rows = nil;\n          \n            if ($truthy(rows['$empty?']())) {\n              return nil;};\n            result['$<<'](\"\" + \"<t\" + (tsec) + \">\");\n            $send(rows, 'each', [], (TMP_40 = function(row){var self = TMP_40.$$s || this, TMP_41;\nif (row == null) row = nil;\n            \n              result['$<<'](\"<tr>\");\n              $send(row, 'each', [], (TMP_41 = function(cell){var self = TMP_41.$$s || this, $b, cell_content = nil, $case = nil, cell_tag_name = nil, cell_class_attribute = nil, cell_colspan_attribute = nil, cell_rowspan_attribute = nil, cell_style_attribute = nil;\nif (cell == null) cell = nil;\n              \n                if (tsec['$=='](\"head\")) {\n                  cell_content = cell.$text()\n                } else {\n                  $case = cell.$style();\n                  if (\"asciidoc\"['$===']($case)) {cell_content = \"\" + \"<div>\" + (cell.$content()) + \"</div>\"}\n                  else if (\"verse\"['$===']($case)) {cell_content = \"\" + \"<div class=\\\"verse\\\">\" + (cell.$text()) + \"</div>\"}\n                  else if (\"literal\"['$===']($case)) {cell_content = \"\" + \"<div class=\\\"literal\\\"><pre>\" + (cell.$text()) + \"</pre></div>\"}\n                  else {cell_content = (function() {if ($truthy((cell_content = cell.$content())['$empty?']())) {\n                    return \"\"\n                  } else {\n                    return \"\" + \"<p class=\\\"tableblock\\\">\" + ($rb_times(cell_content, \"\" + \"</p>\\n\" + \"<p class=\\\"tableblock\\\">\")) + \"</p>\"\n                  }; return nil; })()}\n                };\n                cell_tag_name = (function() {if ($truthy(($truthy($b = tsec['$=='](\"head\")) ? $b : cell.$style()['$=='](\"header\")))) {\n                  return \"th\"\n                } else {\n                  return \"td\"\n                }; return nil; })();\n                cell_class_attribute = \"\" + \" class=\\\"tableblock halign-\" + (cell.$attr(\"halign\")) + \" valign-\" + (cell.$attr(\"valign\")) + \"\\\"\";\n                cell_colspan_attribute = (function() {if ($truthy(cell.$colspan())) {\n                  return \"\" + \" colspan=\\\"\" + (cell.$colspan()) + \"\\\"\"\n                } else {\n                  return nil\n                }; return nil; })();\n                cell_rowspan_attribute = (function() {if ($truthy(cell.$rowspan())) {\n                  return \"\" + \" rowspan=\\\"\" + (cell.$rowspan()) + \"\\\"\"\n                } else {\n                  return nil\n                }; return nil; })();\n                cell_style_attribute = (function() {if ($truthy(node.$document()['$attr?'](\"cellbgcolor\"))) {\n                  return \"\" + \" style=\\\"background-color: \" + (node.$document().$attr(\"cellbgcolor\")) + \";\\\"\"\n                } else {\n                  return nil\n                }; return nil; })();\n                return result['$<<'](\"\" + \"<\" + (cell_tag_name) + (cell_class_attribute) + (cell_colspan_attribute) + (cell_rowspan_attribute) + (cell_style_attribute) + \">\" + (cell_content) + \"</\" + (cell_tag_name) + \">\");}, TMP_41.$$s = self, TMP_41.$$arity = 1, TMP_41));\n              return result['$<<'](\"</tr>\");}, TMP_40.$$s = self, TMP_40.$$arity = 1, TMP_40));\n            return result['$<<'](\"\" + \"</t\" + (tsec) + \">\");}, TMP_39.$$s = self, TMP_39.$$arity = 2, TMP_39));};\n        result['$<<'](\"</table>\");\n        return $rb_times(result, $$($nesting, 'LF'));\n      }, TMP_Html5Converter_table_42.$$arity = 1);\n      \n      Opal.def(self, '$toc', TMP_Html5Converter_toc_43 = function $$toc(node) {\n        var $a, $b, self = this, doc = nil, id_attr = nil, title_id_attr = nil, title = nil, levels = nil, role = nil;\n\n        \n        if ($truthy(($truthy($a = ($truthy($b = (doc = node.$document())['$attr?'](\"toc-placement\", \"macro\")) ? doc['$sections?']() : $b)) ? doc['$attr?'](\"toc\") : $a))) {\n        } else {\n          return \"<!-- toc disabled -->\"\n        };\n        if ($truthy(node.$id())) {\n          \n          id_attr = \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\";\n          title_id_attr = \"\" + \" id=\\\"\" + (node.$id()) + \"title\\\"\";\n        } else {\n          \n          id_attr = \" id=\\\"toc\\\"\";\n          title_id_attr = \" id=\\\"toctitle\\\"\";\n        };\n        title = (function() {if ($truthy(node['$title?']())) {\n          return node.$title()\n        } else {\n          \n          return doc.$attr(\"toc-title\");\n        }; return nil; })();\n        levels = (function() {if ($truthy(node['$attr?'](\"levels\"))) {\n          return node.$attr(\"levels\").$to_i()\n        } else {\n          return nil\n        }; return nil; })();\n        role = (function() {if ($truthy(node['$role?']())) {\n          return node.$role()\n        } else {\n          \n          return doc.$attr(\"toc-class\", \"toc\");\n        }; return nil; })();\n        return \"\" + \"<div\" + (id_attr) + \" class=\\\"\" + (role) + \"\\\">\\n\" + \"<div\" + (title_id_attr) + \" class=\\\"title\\\">\" + (title) + \"</div>\\n\" + (self.$outline(doc, $hash2([\"toclevels\"], {\"toclevels\": levels}))) + \"\\n\" + \"</div>\";\n      }, TMP_Html5Converter_toc_43.$$arity = 1);\n      \n      Opal.def(self, '$ulist', TMP_Html5Converter_ulist_45 = function $$ulist(node) {\n        var TMP_44, self = this, result = nil, id_attribute = nil, div_classes = nil, marker_checked = nil, marker_unchecked = nil, checklist = nil, ul_class_attribute = nil;\n\n        \n        result = [];\n        id_attribute = (function() {if ($truthy(node.$id())) {\n          return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        div_classes = [\"ulist\", node.$style(), node.$role()].$compact();\n        marker_checked = nil;\n        marker_unchecked = nil;\n        if ($truthy((checklist = node['$option?'](\"checklist\")))) {\n          \n          div_classes.$unshift(div_classes.$shift(), \"checklist\");\n          ul_class_attribute = \" class=\\\"checklist\\\"\";\n          if ($truthy(node['$option?'](\"interactive\"))) {\n            if ($truthy(self.xml_mode)) {\n              \n              marker_checked = \"<input type=\\\"checkbox\\\" data-item-complete=\\\"1\\\" checked=\\\"checked\\\"/> \";\n              marker_unchecked = \"<input type=\\\"checkbox\\\" data-item-complete=\\\"0\\\"/> \";\n            } else {\n              \n              marker_checked = \"<input type=\\\"checkbox\\\" data-item-complete=\\\"1\\\" checked> \";\n              marker_unchecked = \"<input type=\\\"checkbox\\\" data-item-complete=\\\"0\\\"> \";\n            }\n          } else if ($truthy(node.$document()['$attr?'](\"icons\", \"font\"))) {\n            \n            marker_checked = \"<i class=\\\"fa fa-check-square-o\\\"></i> \";\n            marker_unchecked = \"<i class=\\\"fa fa-square-o\\\"></i> \";\n          } else {\n            \n            marker_checked = \"&#10003; \";\n            marker_unchecked = \"&#10063; \";\n          };\n        } else {\n          ul_class_attribute = (function() {if ($truthy(node.$style())) {\n            return \"\" + \" class=\\\"\" + (node.$style()) + \"\\\"\"\n          } else {\n            return nil\n          }; return nil; })()\n        };\n        result['$<<'](\"\" + \"<div\" + (id_attribute) + \" class=\\\"\" + ($rb_times(div_classes, \" \")) + \"\\\">\");\n        if ($truthy(node['$title?']())) {\n          result['$<<'](\"\" + \"<div class=\\\"title\\\">\" + (node.$title()) + \"</div>\")};\n        result['$<<'](\"\" + \"<ul\" + (ul_class_attribute) + \">\");\n        $send(node.$items(), 'each', [], (TMP_44 = function(item){var self = TMP_44.$$s || this, $a;\nif (item == null) item = nil;\n        \n          result['$<<'](\"<li>\");\n          if ($truthy(($truthy($a = checklist) ? item['$attr?'](\"checkbox\") : $a))) {\n            result['$<<'](\"\" + \"<p>\" + ((function() {if ($truthy(item['$attr?'](\"checked\"))) {\n              return marker_checked\n            } else {\n              return marker_unchecked\n            }; return nil; })()) + (item.$text()) + \"</p>\")\n          } else {\n            result['$<<'](\"\" + \"<p>\" + (item.$text()) + \"</p>\")\n          };\n          if ($truthy(item['$blocks?']())) {\n            result['$<<'](item.$content())};\n          return result['$<<'](\"</li>\");}, TMP_44.$$s = self, TMP_44.$$arity = 1, TMP_44));\n        result['$<<'](\"</ul>\");\n        result['$<<'](\"</div>\");\n        return $rb_times(result, $$($nesting, 'LF'));\n      }, TMP_Html5Converter_ulist_45.$$arity = 1);\n      \n      Opal.def(self, '$verse', TMP_Html5Converter_verse_46 = function $$verse(node) {\n        var $a, self = this, id_attribute = nil, classes = nil, class_attribute = nil, title_element = nil, attribution = nil, citetitle = nil, cite_element = nil, attribution_text = nil, attribution_element = nil;\n\n        \n        id_attribute = (function() {if ($truthy(node.$id())) {\n          return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        classes = [\"verseblock\", node.$role()].$compact();\n        class_attribute = \"\" + \" class=\\\"\" + ($rb_times(classes, \" \")) + \"\\\"\";\n        title_element = (function() {if ($truthy(node['$title?']())) {\n          return \"\" + \"\\n<div class=\\\"title\\\">\" + (node.$title()) + \"</div>\"\n        } else {\n          return nil\n        }; return nil; })();\n        attribution = (function() {if ($truthy(node['$attr?'](\"attribution\"))) {\n          \n          return node.$attr(\"attribution\");\n        } else {\n          return nil\n        }; return nil; })();\n        citetitle = (function() {if ($truthy(node['$attr?'](\"citetitle\"))) {\n          \n          return node.$attr(\"citetitle\");\n        } else {\n          return nil\n        }; return nil; })();\n        if ($truthy(($truthy($a = attribution) ? $a : citetitle))) {\n          \n          cite_element = (function() {if ($truthy(citetitle)) {\n            return \"\" + \"<cite>\" + (citetitle) + \"</cite>\"\n          } else {\n            return nil\n          }; return nil; })();\n          attribution_text = (function() {if ($truthy(attribution)) {\n            return \"\" + \"&#8212; \" + (attribution) + ((function() {if ($truthy(citetitle)) {\n              return \"\" + \"<br\" + (self.void_element_slash) + \">\\n\"\n            } else {\n              return nil\n            }; return nil; })())\n          } else {\n            return nil\n          }; return nil; })();\n          attribution_element = \"\" + \"\\n<div class=\\\"attribution\\\">\\n\" + (attribution_text) + (cite_element) + \"\\n</div>\";\n        } else {\n          attribution_element = nil\n        };\n        return \"\" + \"<div\" + (id_attribute) + (class_attribute) + \">\" + (title_element) + \"\\n\" + \"<pre class=\\\"content\\\">\" + (node.$content()) + \"</pre>\" + (attribution_element) + \"\\n\" + \"</div>\";\n      }, TMP_Html5Converter_verse_46.$$arity = 1);\n      \n      Opal.def(self, '$video', TMP_Html5Converter_video_47 = function $$video(node) {\n        var $a, $b, self = this, xml = nil, id_attribute = nil, classes = nil, class_attribute = nil, title_element = nil, width_attribute = nil, height_attribute = nil, $case = nil, asset_uri_scheme = nil, start_anchor = nil, delimiter = nil, autoplay_param = nil, loop_param = nil, rel_param_val = nil, start_param = nil, end_param = nil, controls_param = nil, fs_param = nil, fs_attribute = nil, modest_param = nil, theme_param = nil, hl_param = nil, target = nil, list = nil, list_param = nil, playlist = nil, poster_attribute = nil, val = nil, preload_attribute = nil, start_t = nil, end_t = nil, time_anchor = nil;\n\n        \n        xml = self.xml_mode;\n        id_attribute = (function() {if ($truthy(node.$id())) {\n          return \"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        classes = [\"videoblock\", node.$role()].$compact();\n        class_attribute = \"\" + \" class=\\\"\" + ($rb_times(classes, \" \")) + \"\\\"\";\n        title_element = (function() {if ($truthy(node['$title?']())) {\n          return \"\" + \"\\n<div class=\\\"title\\\">\" + (node.$title()) + \"</div>\"\n        } else {\n          return nil\n        }; return nil; })();\n        width_attribute = (function() {if ($truthy(node['$attr?'](\"width\"))) {\n          return \"\" + \" width=\\\"\" + (node.$attr(\"width\")) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        height_attribute = (function() {if ($truthy(node['$attr?'](\"height\"))) {\n          return \"\" + \" height=\\\"\" + (node.$attr(\"height\")) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        return (function() {$case = node.$attr(\"poster\");\n        if (\"vimeo\"['$===']($case)) {\n        if ($truthy((asset_uri_scheme = node.$document().$attr(\"asset-uri-scheme\", \"https\"))['$empty?']())) {\n        } else {\n          asset_uri_scheme = \"\" + (asset_uri_scheme) + \":\"\n        };\n        start_anchor = (function() {if ($truthy(node['$attr?'](\"start\", nil, false))) {\n          return \"\" + \"#at=\" + (node.$attr(\"start\"))\n        } else {\n          return nil\n        }; return nil; })();\n        delimiter = \"?\";\n        autoplay_param = (function() {if ($truthy(node['$option?'](\"autoplay\"))) {\n          return \"\" + (delimiter) + \"autoplay=1\"\n        } else {\n          return nil\n        }; return nil; })();\n        if ($truthy(autoplay_param)) {\n          delimiter = \"&amp;\"};\n        loop_param = (function() {if ($truthy(node['$option?'](\"loop\"))) {\n          return \"\" + (delimiter) + \"loop=1\"\n        } else {\n          return nil\n        }; return nil; })();\n        return \"\" + \"<div\" + (id_attribute) + (class_attribute) + \">\" + (title_element) + \"\\n\" + \"<div class=\\\"content\\\">\\n\" + \"<iframe\" + (width_attribute) + (height_attribute) + \" src=\\\"\" + (asset_uri_scheme) + \"//player.vimeo.com/video/\" + (node.$attr(\"target\")) + (start_anchor) + (autoplay_param) + (loop_param) + \"\\\" frameborder=\\\"0\\\"\" + ((function() {if ($truthy(node['$option?'](\"nofullscreen\"))) {\n          return nil\n        } else {\n          \n          return self.$append_boolean_attribute(\"allowfullscreen\", xml);\n        }; return nil; })()) + \"></iframe>\\n\" + \"</div>\\n\" + \"</div>\";}\n        else if (\"youtube\"['$===']($case)) {\n        if ($truthy((asset_uri_scheme = node.$document().$attr(\"asset-uri-scheme\", \"https\"))['$empty?']())) {\n        } else {\n          asset_uri_scheme = \"\" + (asset_uri_scheme) + \":\"\n        };\n        rel_param_val = (function() {if ($truthy(node['$option?'](\"related\"))) {\n          return 1\n        } else {\n          return 0\n        }; return nil; })();\n        start_param = (function() {if ($truthy(node['$attr?'](\"start\", nil, false))) {\n          return \"\" + \"&amp;start=\" + (node.$attr(\"start\"))\n        } else {\n          return nil\n        }; return nil; })();\n        end_param = (function() {if ($truthy(node['$attr?'](\"end\", nil, false))) {\n          return \"\" + \"&amp;end=\" + (node.$attr(\"end\"))\n        } else {\n          return nil\n        }; return nil; })();\n        autoplay_param = (function() {if ($truthy(node['$option?'](\"autoplay\"))) {\n          return \"&amp;autoplay=1\"\n        } else {\n          return nil\n        }; return nil; })();\n        loop_param = (function() {if ($truthy(node['$option?'](\"loop\"))) {\n          return \"&amp;loop=1\"\n        } else {\n          return nil\n        }; return nil; })();\n        controls_param = (function() {if ($truthy(node['$option?'](\"nocontrols\"))) {\n          return \"&amp;controls=0\"\n        } else {\n          return nil\n        }; return nil; })();\n        if ($truthy(node['$option?'](\"nofullscreen\"))) {\n          \n          fs_param = \"&amp;fs=0\";\n          fs_attribute = nil;\n        } else {\n          \n          fs_param = nil;\n          fs_attribute = self.$append_boolean_attribute(\"allowfullscreen\", xml);\n        };\n        modest_param = (function() {if ($truthy(node['$option?'](\"modest\"))) {\n          return \"&amp;modestbranding=1\"\n        } else {\n          return nil\n        }; return nil; })();\n        theme_param = (function() {if ($truthy(node['$attr?'](\"theme\", nil, false))) {\n          return \"\" + \"&amp;theme=\" + (node.$attr(\"theme\"))\n        } else {\n          return nil\n        }; return nil; })();\n        hl_param = (function() {if ($truthy(node['$attr?'](\"lang\"))) {\n          return \"\" + \"&amp;hl=\" + (node.$attr(\"lang\"))\n        } else {\n          return nil\n        }; return nil; })();\n        $b = node.$attr(\"target\").$split(\"/\", 2), $a = Opal.to_ary($b), (target = ($a[0] == null ? nil : $a[0])), (list = ($a[1] == null ? nil : $a[1])), $b;\n        if ($truthy((list = ($truthy($a = list) ? $a : node.$attr(\"list\", nil, false))))) {\n          list_param = \"\" + \"&amp;list=\" + (list)\n        } else {\n          \n          $b = target.$split(\",\", 2), $a = Opal.to_ary($b), (target = ($a[0] == null ? nil : $a[0])), (playlist = ($a[1] == null ? nil : $a[1])), $b;\n          if ($truthy((playlist = ($truthy($a = playlist) ? $a : node.$attr(\"playlist\", nil, false))))) {\n            list_param = \"\" + \"&amp;playlist=\" + (playlist)\n          } else {\n            list_param = (function() {if ($truthy(loop_param)) {\n              return \"\" + \"&amp;playlist=\" + (target)\n            } else {\n              return nil\n            }; return nil; })()\n          };\n        };\n        return \"\" + \"<div\" + (id_attribute) + (class_attribute) + \">\" + (title_element) + \"\\n\" + \"<div class=\\\"content\\\">\\n\" + \"<iframe\" + (width_attribute) + (height_attribute) + \" src=\\\"\" + (asset_uri_scheme) + \"//www.youtube.com/embed/\" + (target) + \"?rel=\" + (rel_param_val) + (start_param) + (end_param) + (autoplay_param) + (loop_param) + (controls_param) + (list_param) + (fs_param) + (modest_param) + (theme_param) + (hl_param) + \"\\\" frameborder=\\\"0\\\"\" + (fs_attribute) + \"></iframe>\\n\" + \"</div>\\n\" + \"</div>\";}\n        else {\n        poster_attribute = (function() {if ($truthy((val = node.$attr(\"poster\", nil, false))['$nil_or_empty?']())) {\n          return nil\n        } else {\n          return \"\" + \" poster=\\\"\" + (node.$media_uri(val)) + \"\\\"\"\n        }; return nil; })();\n        preload_attribute = (function() {if ($truthy((val = node.$attr(\"preload\", nil, false))['$nil_or_empty?']())) {\n          return nil\n        } else {\n          return \"\" + \" preload=\\\"\" + (val) + \"\\\"\"\n        }; return nil; })();\n        start_t = node.$attr(\"start\", nil, false);\n        end_t = node.$attr(\"end\", nil, false);\n        time_anchor = (function() {if ($truthy(($truthy($a = start_t) ? $a : end_t))) {\n          return \"\" + \"#t=\" + (start_t) + ((function() {if ($truthy(end_t)) {\n            return \",\"\n          } else {\n            return nil\n          }; return nil; })()) + (end_t)\n        } else {\n          return nil\n        }; return nil; })();\n        return \"\" + \"<div\" + (id_attribute) + (class_attribute) + \">\" + (title_element) + \"\\n\" + \"<div class=\\\"content\\\">\\n\" + \"<video src=\\\"\" + (node.$media_uri(node.$attr(\"target\"))) + (time_anchor) + \"\\\"\" + (width_attribute) + (height_attribute) + (poster_attribute) + ((function() {if ($truthy(node['$option?'](\"autoplay\"))) {\n          \n          return self.$append_boolean_attribute(\"autoplay\", xml);\n        } else {\n          return nil\n        }; return nil; })()) + ((function() {if ($truthy(node['$option?'](\"nocontrols\"))) {\n          return nil\n        } else {\n          \n          return self.$append_boolean_attribute(\"controls\", xml);\n        }; return nil; })()) + ((function() {if ($truthy(node['$option?'](\"loop\"))) {\n          \n          return self.$append_boolean_attribute(\"loop\", xml);\n        } else {\n          return nil\n        }; return nil; })()) + (preload_attribute) + \">\\n\" + \"Your browser does not support the video tag.\\n\" + \"</video>\\n\" + \"</div>\\n\" + \"</div>\";}})();\n      }, TMP_Html5Converter_video_47.$$arity = 1);\n      \n      Opal.def(self, '$inline_anchor', TMP_Html5Converter_inline_anchor_48 = function $$inline_anchor(node) {\n        var $a, $b, self = this, $case = nil, text = nil, ref = nil, refid = nil, attrs = nil, role = nil, window = nil;\n\n        return (function() {$case = node.$type();\n        if (\"xref\"['$===']($case)) {\n        if ($truthy(($truthy($a = (text = node.$text())) ? $a : (text = node.$attributes()['$[]'](\"path\"))))) {\n        } else if ($truthy($$($nesting, 'AbstractNode')['$===']((ref = node.$document().$catalog()['$[]'](\"refs\")['$[]']((refid = node.$attributes()['$[]'](\"refid\"))))))) {\n          text = ($truthy($a = ref.$xreftext((self.xrefstyle = ($truthy($b = self.xrefstyle) ? $b : node.$document().$attributes()['$[]'](\"xrefstyle\"))))) ? $a : \"\" + \"[\" + (refid) + \"]\")\n        } else {\n          text = \"\" + \"[\" + (refid) + \"]\"\n        };\n        return \"\" + \"<a href=\\\"\" + (node.$target()) + \"\\\">\" + (text) + \"</a>\";}\n        else if (\"ref\"['$===']($case)) {return \"\" + \"<a id=\\\"\" + (node.$id()) + \"\\\"></a>\"}\n        else if (\"link\"['$===']($case)) {\n        attrs = (function() {if ($truthy(node.$id())) {\n          return [\"\" + \" id=\\\"\" + (node.$id()) + \"\\\"\"]\n        } else {\n          return []\n        }; return nil; })();\n        if ($truthy((role = node.$role()))) {\n          attrs['$<<'](\"\" + \" class=\\\"\" + (role) + \"\\\"\")};\n        if ($truthy(node['$attr?'](\"title\", nil, false))) {\n          attrs['$<<'](\"\" + \" title=\\\"\" + (node.$attr(\"title\")) + \"\\\"\")};\n        if ($truthy(node['$attr?'](\"window\", nil, false))) {\n          attrs['$<<'](\"\" + \" target=\\\"\" + ((window = node.$attr(\"window\"))) + \"\\\"\" + ((function() {if ($truthy(($truthy($a = window['$=='](\"_blank\")) ? $a : node['$option?'](\"noopener\")))) {\n            return \" rel=\\\"noopener\\\"\"\n          } else {\n            return \"\"\n          }; return nil; })()))};\n        return \"\" + \"<a href=\\\"\" + (node.$target()) + \"\\\"\" + (attrs.$join()) + \">\" + (node.$text()) + \"</a>\";}\n        else if (\"bibref\"['$===']($case)) {return \"\" + \"<a id=\\\"\" + (node.$id()) + \"\\\"></a>\" + (node.$text())}\n        else {return self.$warn(\"\" + \"asciidoctor: WARNING: unknown anchor type: \" + (node.$type().$inspect()))}})()\n      }, TMP_Html5Converter_inline_anchor_48.$$arity = 1);\n      \n      Opal.def(self, '$inline_break', TMP_Html5Converter_inline_break_49 = function $$inline_break(node) {\n        var self = this;\n\n        return \"\" + (node.$text()) + \"<br\" + (self.void_element_slash) + \">\"\n      }, TMP_Html5Converter_inline_break_49.$$arity = 1);\n      \n      Opal.def(self, '$inline_button', TMP_Html5Converter_inline_button_50 = function $$inline_button(node) {\n        var self = this;\n\n        return \"\" + \"<b class=\\\"button\\\">\" + (node.$text()) + \"</b>\"\n      }, TMP_Html5Converter_inline_button_50.$$arity = 1);\n      \n      Opal.def(self, '$inline_callout', TMP_Html5Converter_inline_callout_51 = function $$inline_callout(node) {\n        var self = this, src = nil;\n\n        if ($truthy(node.$document()['$attr?'](\"icons\", \"font\"))) {\n          return \"\" + \"<i class=\\\"conum\\\" data-value=\\\"\" + (node.$text()) + \"\\\"></i><b>(\" + (node.$text()) + \")</b>\"\n        } else if ($truthy(node.$document()['$attr?'](\"icons\"))) {\n          \n          src = node.$icon_uri(\"\" + \"callouts/\" + (node.$text()));\n          return \"\" + \"<img src=\\\"\" + (src) + \"\\\" alt=\\\"\" + (node.$text()) + \"\\\"\" + (self.void_element_slash) + \">\";\n        } else {\n          return \"\" + \"<b class=\\\"conum\\\">(\" + (node.$text()) + \")</b>\"\n        }\n      }, TMP_Html5Converter_inline_callout_51.$$arity = 1);\n      \n      Opal.def(self, '$inline_footnote', TMP_Html5Converter_inline_footnote_52 = function $$inline_footnote(node) {\n        var self = this, index = nil, id_attr = nil;\n\n        if ($truthy((index = node.$attr(\"index\", nil, false)))) {\n          if (node.$type()['$=='](\"xref\")) {\n            return \"\" + \"<sup class=\\\"footnoteref\\\">[<a class=\\\"footnote\\\" href=\\\"#_footnote_\" + (index) + \"\\\" title=\\\"View footnote.\\\">\" + (index) + \"</a>]</sup>\"\n          } else {\n            \n            id_attr = (function() {if ($truthy(node.$id())) {\n              return \"\" + \" id=\\\"_footnote_\" + (node.$id()) + \"\\\"\"\n            } else {\n              return nil\n            }; return nil; })();\n            return \"\" + \"<sup class=\\\"footnote\\\"\" + (id_attr) + \">[<a id=\\\"_footnoteref_\" + (index) + \"\\\" class=\\\"footnote\\\" href=\\\"#_footnote_\" + (index) + \"\\\" title=\\\"View footnote.\\\">\" + (index) + \"</a>]</sup>\";\n          }\n        } else if (node.$type()['$=='](\"xref\")) {\n          return \"\" + \"<sup class=\\\"footnoteref red\\\" title=\\\"Unresolved footnote reference.\\\">[\" + (node.$text()) + \"]</sup>\"\n        } else {\n          return nil\n        }\n      }, TMP_Html5Converter_inline_footnote_52.$$arity = 1);\n      \n      Opal.def(self, '$inline_image', TMP_Html5Converter_inline_image_55 = function $$inline_image(node) {\n        var $a, TMP_53, TMP_54, $b, $c, $d, self = this, type = nil, class_attr_val = nil, title_attr = nil, img = nil, target = nil, attrs = nil, svg = nil, obj = nil, fallback = nil, window_attr = nil, window = nil, role = nil, style_attr = nil;\n\n        \n        if ($truthy((($a = (type = node.$type())['$=='](\"icon\")) ? node.$document()['$attr?'](\"icons\", \"font\") : (type = node.$type())['$=='](\"icon\")))) {\n          \n          class_attr_val = \"\" + \"fa fa-\" + (node.$target());\n          $send($hash2([\"size\", \"rotate\", \"flip\"], {\"size\": \"fa-\", \"rotate\": \"fa-rotate-\", \"flip\": \"fa-flip-\"}), 'each', [], (TMP_53 = function(key, prefix){var self = TMP_53.$$s || this;\nif (key == null) key = nil;if (prefix == null) prefix = nil;\n          if ($truthy(node['$attr?'](key))) {\n              return (class_attr_val = \"\" + (class_attr_val) + \" \" + (prefix) + (node.$attr(key)))\n            } else {\n              return nil\n            }}, TMP_53.$$s = self, TMP_53.$$arity = 2, TMP_53));\n          title_attr = (function() {if ($truthy(node['$attr?'](\"title\"))) {\n            return \"\" + \" title=\\\"\" + (node.$attr(\"title\")) + \"\\\"\"\n          } else {\n            return nil\n          }; return nil; })();\n          img = \"\" + \"<i class=\\\"\" + (class_attr_val) + \"\\\"\" + (title_attr) + \"></i>\";\n        } else if ($truthy((($a = type['$=='](\"icon\")) ? node.$document()['$attr?'](\"icons\")['$!']() : type['$=='](\"icon\")))) {\n          img = \"\" + \"[\" + (node.$alt()) + \"]\"\n        } else {\n          \n          target = node.$target();\n          attrs = $send([\"width\", \"height\", \"title\"], 'map', [], (TMP_54 = function(name){var self = TMP_54.$$s || this;\nif (name == null) name = nil;\n          if ($truthy(node['$attr?'](name))) {\n              return \"\" + \" \" + (name) + \"=\\\"\" + (node.$attr(name)) + \"\\\"\"\n            } else {\n              return nil\n            }}, TMP_54.$$s = self, TMP_54.$$arity = 1, TMP_54)).$join();\n          if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = type['$!='](\"icon\")) ? ($truthy($d = node['$attr?'](\"format\", \"svg\", false)) ? $d : target['$include?'](\".svg\")) : $c)) ? $rb_lt(node.$document().$safe(), $$$($$($nesting, 'SafeMode'), 'SECURE')) : $b)) ? ($truthy($b = (svg = node['$option?'](\"inline\"))) ? $b : (obj = node['$option?'](\"interactive\"))) : $a))) {\n            if ($truthy(svg)) {\n              img = ($truthy($a = self.$read_svg_contents(node, target)) ? $a : \"\" + \"<span class=\\\"alt\\\">\" + (node.$alt()) + \"</span>\")\n            } else if ($truthy(obj)) {\n              \n              fallback = (function() {if ($truthy(node['$attr?'](\"fallback\"))) {\n                return \"\" + \"<img src=\\\"\" + (node.$image_uri(node.$attr(\"fallback\"))) + \"\\\" alt=\\\"\" + (self.$encode_quotes(node.$alt())) + \"\\\"\" + (attrs) + (self.void_element_slash) + \">\"\n              } else {\n                return \"\" + \"<span class=\\\"alt\\\">\" + (node.$alt()) + \"</span>\"\n              }; return nil; })();\n              img = \"\" + \"<object type=\\\"image/svg+xml\\\" data=\\\"\" + (node.$image_uri(target)) + \"\\\"\" + (attrs) + \">\" + (fallback) + \"</object>\";}};\n          img = ($truthy($a = img) ? $a : \"\" + \"<img src=\\\"\" + ((function() {if (type['$=='](\"icon\")) {\n            \n            return node.$icon_uri(target);\n          } else {\n            \n            return node.$image_uri(target);\n          }; return nil; })()) + \"\\\" alt=\\\"\" + (self.$encode_quotes(node.$alt())) + \"\\\"\" + (attrs) + (self.void_element_slash) + \">\");\n        };\n        if ($truthy(node['$attr?'](\"link\"))) {\n          \n          if ($truthy(node['$attr?'](\"window\"))) {\n            window_attr = \"\" + \" target=\\\"\" + ((window = node.$attr(\"window\"))) + \"\\\"\" + ((function() {if ($truthy(($truthy($a = window['$=='](\"_blank\")) ? $a : node['$option?'](\"noopener\")))) {\n              return \" rel=\\\"noopener\\\"\"\n            } else {\n              return \"\"\n            }; return nil; })())};\n          img = \"\" + \"<a class=\\\"image\\\" href=\\\"\" + (node.$attr(\"link\")) + \"\\\"\" + (window_attr) + \">\" + (img) + \"</a>\";};\n        class_attr_val = (function() {if ($truthy((role = node.$role()))) {\n          return \"\" + (type) + \" \" + (role)\n        } else {\n          return type\n        }; return nil; })();\n        style_attr = (function() {if ($truthy(node['$attr?'](\"float\"))) {\n          return \"\" + \" style=\\\"float: \" + (node.$attr(\"float\")) + \"\\\"\"\n        } else {\n          return nil\n        }; return nil; })();\n        return \"\" + \"<span class=\\\"\" + (class_attr_val) + \"\\\"\" + (style_attr) + \">\" + (img) + \"</span>\";\n      }, TMP_Html5Converter_inline_image_55.$$arity = 1);\n      \n      Opal.def(self, '$inline_indexterm', TMP_Html5Converter_inline_indexterm_56 = function $$inline_indexterm(node) {\n        var self = this;\n\n        if (node.$type()['$=='](\"visible\")) {\n          return node.$text()\n        } else {\n          return \"\"\n        }\n      }, TMP_Html5Converter_inline_indexterm_56.$$arity = 1);\n      \n      Opal.def(self, '$inline_kbd', TMP_Html5Converter_inline_kbd_57 = function $$inline_kbd(node) {\n        var self = this, keys = nil;\n\n        if ((keys = node.$attr(\"keys\")).$size()['$=='](1)) {\n          return \"\" + \"<kbd>\" + (keys['$[]'](0)) + \"</kbd>\"\n        } else {\n          return \"\" + \"<span class=\\\"keyseq\\\"><kbd>\" + ($rb_times(keys, \"</kbd>+<kbd>\")) + \"</kbd></span>\"\n        }\n      }, TMP_Html5Converter_inline_kbd_57.$$arity = 1);\n      \n      Opal.def(self, '$inline_menu', TMP_Html5Converter_inline_menu_58 = function $$inline_menu(node) {\n        var self = this, caret = nil, submenu_joiner = nil, menu = nil, submenus = nil, menuitem = nil;\n\n        \n        caret = (function() {if ($truthy(node.$document()['$attr?'](\"icons\", \"font\"))) {\n          return \"&#160;<i class=\\\"fa fa-angle-right caret\\\"></i> \"\n        } else {\n          return \"&#160;<b class=\\\"caret\\\">&#8250;</b> \"\n        }; return nil; })();\n        submenu_joiner = \"\" + \"</b>\" + (caret) + \"<b class=\\\"submenu\\\">\";\n        menu = node.$attr(\"menu\");\n        if ($truthy((submenus = node.$attr(\"submenus\"))['$empty?']())) {\n          if ($truthy((menuitem = node.$attr(\"menuitem\", nil, false)))) {\n            return \"\" + \"<span class=\\\"menuseq\\\"><b class=\\\"menu\\\">\" + (menu) + \"</b>\" + (caret) + \"<b class=\\\"menuitem\\\">\" + (menuitem) + \"</b></span>\"\n          } else {\n            return \"\" + \"<b class=\\\"menuref\\\">\" + (menu) + \"</b>\"\n          }\n        } else {\n          return \"\" + \"<span class=\\\"menuseq\\\"><b class=\\\"menu\\\">\" + (menu) + \"</b>\" + (caret) + \"<b class=\\\"submenu\\\">\" + ($rb_times(submenus, submenu_joiner)) + \"</b>\" + (caret) + \"<b class=\\\"menuitem\\\">\" + (node.$attr(\"menuitem\")) + \"</b></span>\"\n        };\n      }, TMP_Html5Converter_inline_menu_58.$$arity = 1);\n      \n      Opal.def(self, '$inline_quoted', TMP_Html5Converter_inline_quoted_59 = function $$inline_quoted(node) {\n        var $a, $b, self = this, open = nil, close = nil, is_tag = nil, quoted_text = nil;\n\n        \n        $b = $$($nesting, 'QUOTE_TAGS')['$[]'](node.$type()), $a = Opal.to_ary($b), (open = ($a[0] == null ? nil : $a[0])), (close = ($a[1] == null ? nil : $a[1])), (is_tag = ($a[2] == null ? nil : $a[2])), $b;\n        if ($truthy(node.$role())) {\n          if ($truthy(is_tag)) {\n            quoted_text = \"\" + (open.$chop()) + \" class=\\\"\" + (node.$role()) + \"\\\">\" + (node.$text()) + (close)\n          } else {\n            quoted_text = \"\" + \"<span class=\\\"\" + (node.$role()) + \"\\\">\" + (open) + (node.$text()) + (close) + \"</span>\"\n          }\n        } else {\n          quoted_text = \"\" + (open) + (node.$text()) + (close)\n        };\n        if ($truthy(node.$id())) {\n          return \"\" + \"<a id=\\\"\" + (node.$id()) + \"\\\"></a>\" + (quoted_text)\n        } else {\n          return quoted_text\n        };\n      }, TMP_Html5Converter_inline_quoted_59.$$arity = 1);\n      \n      Opal.def(self, '$append_boolean_attribute', TMP_Html5Converter_append_boolean_attribute_60 = function $$append_boolean_attribute(name, xml) {\n        var self = this;\n\n        if ($truthy(xml)) {\n          return \"\" + \" \" + (name) + \"=\\\"\" + (name) + \"\\\"\"\n        } else {\n          return \"\" + \" \" + (name)\n        }\n      }, TMP_Html5Converter_append_boolean_attribute_60.$$arity = 2);\n      \n      Opal.def(self, '$encode_quotes', TMP_Html5Converter_encode_quotes_61 = function $$encode_quotes(val) {\n        var self = this;\n\n        if ($truthy(val['$include?'](\"\\\"\"))) {\n          \n          return val.$gsub(\"\\\"\", \"&quot;\");\n        } else {\n          return val\n        }\n      }, TMP_Html5Converter_encode_quotes_61.$$arity = 1);\n      return (Opal.def(self, '$read_svg_contents', TMP_Html5Converter_read_svg_contents_63 = function $$read_svg_contents(node, target) {\n        var TMP_62, self = this, svg = nil, old_start_tag = nil, new_start_tag = nil;\n\n        \n        if ($truthy((svg = node.$read_contents(target, $hash2([\"start\", \"normalize\", \"label\"], {\"start\": node.$document().$attr(\"imagesdir\"), \"normalize\": true, \"label\": \"SVG\"}))))) {\n          \n          if ($truthy(svg['$start_with?'](\"<svg\"))) {\n          } else {\n            svg = svg.$sub($$($nesting, 'SvgPreambleRx'), \"\")\n          };\n          old_start_tag = (new_start_tag = nil);\n          $send([\"width\", \"height\"], 'each', [], (TMP_62 = function(dim){var self = TMP_62.$$s || this;\nif (dim == null) dim = nil;\n          if ($truthy(node['$attr?'](dim))) {\n              \n              if ($truthy(new_start_tag)) {\n              } else {\n                new_start_tag = (old_start_tag = svg.$match($$($nesting, 'SvgStartTagRx'))['$[]'](0)).$gsub($$($nesting, 'DimensionAttributeRx'), \"\")\n              };\n              return (new_start_tag = \"\" + (new_start_tag.$chop()) + \" \" + (dim) + \"=\\\"\" + (node.$attr(dim)) + \"px\\\">\");\n            } else {\n              return nil\n            }}, TMP_62.$$s = self, TMP_62.$$arity = 1, TMP_62));\n          if ($truthy(new_start_tag)) {\n            svg = \"\" + (new_start_tag) + (svg['$[]'](Opal.Range.$new(old_start_tag.$length(), -1, false)))};};\n        return svg;\n      }, TMP_Html5Converter_read_svg_contents_63.$$arity = 2), nil) && 'read_svg_contents';\n    })($$($nesting, 'Converter'), $$$($$($nesting, 'Converter'), 'BuiltIn'), $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/extensions\"] = function(Opal) {\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_plus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);\n  }\n  function $rb_gt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send, $hash = Opal.hash;\n\n  Opal.add_stubs(['$[]=', '$config', '$-', '$nil_or_empty?', '$name', '$grep', '$constants', '$include', '$const_get', '$extend', '$attr_reader', '$merge', '$class', '$update', '$raise', '$document', '$doctype', '$[]', '$+', '$level', '$delete', '$==', '$casecmp', '$new', '$title=', '$sectname=', '$special=', '$fetch', '$numbered=', '$>', '$key?', '$attributes', '$special', '$context', '$numbered', '$generate_id', '$title', '$id=', '$update_attributes', '$tr', '$basename', '$create_block', '$===', '$next_block', '$dup', '$<<', '$has_more_lines?', '$each', '$define_method', '$unshift', '$shift', '$send', '$empty?', '$size', '$call', '$option', '$flatten', '$respond_to?', '$include?', '$to_s', '$split', '$to_i', '$compact', '$inspect', '$attr_accessor', '$to_set', '$!', '$resolve_regexp', '$match?', '$method', '$register', '$values', '$groups', '$arity', '$instance_exec', '$to_proc', '$activate', '$add_document_processor', '$any?', '$select', '$add_syntax_processor', '$to_sym', '$private', '$join', '$map', '$capitalize', '$instance_variable_get', '$instance_variable_set', '$resolve_args', '$freeze', '$process_block_given?', '$source_location', '$resolve_class', '$<', '$update_config', '$push', '$as_symbol', '$name=', '$pop', '$-@', '$next_auto_id', '$generate_name', '$class_for_name', '$const_defined?']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $parent_nesting) {\n      var $Extensions, self = $Extensions = $module($base, 'Extensions');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n      \n      (function($base, $super, $parent_nesting) {\n        function $Processor(){};\n        var self = $Processor = $klass($base, $super, 'Processor', $Processor);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Processor_initialize_4, TMP_Processor_update_config_5, TMP_Processor_process_6, TMP_Processor_create_section_7, TMP_Processor_create_block_8, TMP_Processor_create_image_block_9, TMP_Processor_create_inline_10, TMP_Processor_parse_content_11, TMP_Processor_12;\n\n        def.config = nil;\n        \n        (function(self, $parent_nesting) {\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_config_1, TMP_option_2, TMP_use_dsl_3;\n\n          \n          \n          Opal.def(self, '$config', TMP_config_1 = function $$config() {\n            var $a, self = this;\n            if (self.config == null) self.config = nil;\n\n            return (self.config = ($truthy($a = self.config) ? $a : $hash2([], {})))\n          }, TMP_config_1.$$arity = 0);\n          \n          Opal.def(self, '$option', TMP_option_2 = function $$option(key, default_value) {\n            var self = this, $writer = nil;\n\n            \n            $writer = [key, default_value];\n            $send(self.$config(), '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];\n          }, TMP_option_2.$$arity = 2);\n          \n          Opal.def(self, '$use_dsl', TMP_use_dsl_3 = function $$use_dsl() {\n            var self = this;\n\n            if ($truthy(self.$name()['$nil_or_empty?']())) {\n              if ($truthy((Opal.Module.$$nesting = $nesting, self.$constants()).$grep(\"DSL\"))) {\n                return self.$include(self.$const_get(\"DSL\"))\n              } else {\n                return nil\n              }\n            } else if ($truthy((Opal.Module.$$nesting = $nesting, self.$constants()).$grep(\"DSL\"))) {\n              return self.$extend(self.$const_get(\"DSL\"))\n            } else {\n              return nil\n            }\n          }, TMP_use_dsl_3.$$arity = 0);\n          Opal.alias(self, \"extend_dsl\", \"use_dsl\");\n          return Opal.alias(self, \"include_dsl\", \"use_dsl\");\n        })(Opal.get_singleton_class(self), $nesting);\n        self.$attr_reader(\"config\");\n        \n        Opal.def(self, '$initialize', TMP_Processor_initialize_4 = function $$initialize(config) {\n          var self = this;\n\n          if (config == null) {\n            config = $hash2([], {});\n          }\n          return (self.config = self.$class().$config().$merge(config))\n        }, TMP_Processor_initialize_4.$$arity = -1);\n        \n        Opal.def(self, '$update_config', TMP_Processor_update_config_5 = function $$update_config(config) {\n          var self = this;\n\n          return self.config.$update(config)\n        }, TMP_Processor_update_config_5.$$arity = 1);\n        \n        Opal.def(self, '$process', TMP_Processor_process_6 = function $$process($a_rest) {\n          var self = this, args;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          return self.$raise($$$('::', 'NotImplementedError'), \"\" + \"Asciidoctor::Extensions::Processor subclass must implement #\" + (\"process\") + \" method\")\n        }, TMP_Processor_process_6.$$arity = -1);\n        \n        Opal.def(self, '$create_section', TMP_Processor_create_section_7 = function $$create_section(parent, title, attrs, opts) {\n          var $a, $b, self = this, doc = nil, doctype = nil, level = nil, style = nil, sectname = nil, special = nil, sect = nil, $writer = nil, id = nil;\n\n          if (opts == null) {\n            opts = $hash2([], {});\n          }\n          \n          doc = parent.$document();\n          $a = [doc.$doctype(), ($truthy($b = opts['$[]'](\"level\")) ? $b : $rb_plus(parent.$level(), 1))], (doctype = $a[0]), (level = $a[1]), $a;\n          if ($truthy((style = attrs.$delete(\"style\")))) {\n            if ($truthy((($a = style['$=='](\"abstract\")) ? doctype['$=='](\"book\") : style['$=='](\"abstract\")))) {\n              $a = [\"chapter\", 1], (sectname = $a[0]), (level = $a[1]), $a\n            } else {\n              \n              $a = [style, true], (sectname = $a[0]), (special = $a[1]), $a;\n              if (level['$=='](0)) {\n                level = 1};\n            }\n          } else if (doctype['$=='](\"book\")) {\n            sectname = (function() {if (level['$=='](0)) {\n              return \"part\"\n            } else {\n              \n              if (level['$=='](1)) {\n                return \"chapter\"\n              } else {\n                return \"section\"\n              };\n            }; return nil; })()\n          } else if ($truthy((($a = doctype['$=='](\"manpage\")) ? title.$casecmp(\"synopsis\")['$=='](0) : doctype['$=='](\"manpage\")))) {\n            $a = [\"synopsis\", true], (sectname = $a[0]), (special = $a[1]), $a\n          } else {\n            sectname = \"section\"\n          };\n          sect = $$($nesting, 'Section').$new(parent, level, false);\n          $a = [title, sectname], sect['$title=']($a[0]), sect['$sectname=']($a[1]), $a;\n          if ($truthy(special)) {\n            \n            \n            $writer = [true];\n            $send(sect, 'special=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            if ($truthy(opts.$fetch(\"numbered\", style['$=='](\"appendix\")))) {\n              \n              $writer = [true];\n              $send(sect, 'numbered=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];};\n          } else if ($truthy(opts.$fetch(\"numbered\", ($truthy($a = $rb_gt(level, 0)) ? doc.$attributes()['$key?'](\"sectnums\") : $a)))) {\n            \n            $writer = [(function() {if ($truthy(sect.$special())) {\n              \n              return (($a = parent.$context()['$=='](\"section\")) ? parent.$numbered() : parent.$context()['$=='](\"section\"));\n            } else {\n              return true\n            }; return nil; })()];\n            $send(sect, 'numbered=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];};\n          if ((id = attrs.$delete(\"id\"))['$=='](false)) {\n          } else {\n            \n            $writer = [(($writer = [\"id\", ($truthy($a = id) ? $a : (function() {if ($truthy(doc.$attributes()['$key?'](\"sectids\"))) {\n              \n              return $$($nesting, 'Section').$generate_id(sect.$title(), doc);\n            } else {\n              return nil\n            }; return nil; })())]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])];\n            $send(sect, 'id=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];\n          };\n          sect.$update_attributes(attrs);\n          return sect;\n        }, TMP_Processor_create_section_7.$$arity = -4);\n        \n        Opal.def(self, '$create_block', TMP_Processor_create_block_8 = function $$create_block(parent, context, source, attrs, opts) {\n          var self = this;\n\n          if (opts == null) {\n            opts = $hash2([], {});\n          }\n          return $$($nesting, 'Block').$new(parent, context, $hash2([\"source\", \"attributes\"], {\"source\": source, \"attributes\": attrs}).$merge(opts))\n        }, TMP_Processor_create_block_8.$$arity = -5);\n        \n        Opal.def(self, '$create_image_block', TMP_Processor_create_image_block_9 = function $$create_image_block(parent, attrs, opts) {\n          var $a, self = this, target = nil, $writer = nil;\n\n          if (opts == null) {\n            opts = $hash2([], {});\n          }\n          \n          if ($truthy((target = attrs['$[]'](\"target\")))) {\n          } else {\n            self.$raise($$$('::', 'ArgumentError'), \"Unable to create an image block, target attribute is required\")\n          };\n          ($truthy($a = attrs['$[]'](\"alt\")) ? $a : (($writer = [\"alt\", (($writer = [\"default-alt\", $$($nesting, 'Helpers').$basename(target, true).$tr(\"_-\", \" \")]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)])]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n          return self.$create_block(parent, \"image\", nil, attrs, opts);\n        }, TMP_Processor_create_image_block_9.$$arity = -3);\n        \n        Opal.def(self, '$create_inline', TMP_Processor_create_inline_10 = function $$create_inline(parent, context, text, opts) {\n          var self = this;\n\n          if (opts == null) {\n            opts = $hash2([], {});\n          }\n          return $$($nesting, 'Inline').$new(parent, context, text, opts)\n        }, TMP_Processor_create_inline_10.$$arity = -4);\n        \n        Opal.def(self, '$parse_content', TMP_Processor_parse_content_11 = function $$parse_content(parent, content, attributes) {\n          var $a, $b, $c, self = this, reader = nil, block = nil;\n\n          if (attributes == null) {\n            attributes = nil;\n          }\n          \n          reader = (function() {if ($truthy($$($nesting, 'Reader')['$==='](content))) {\n            return content\n          } else {\n            \n            return $$($nesting, 'Reader').$new(content);\n          }; return nil; })();\n          while ($truthy(($truthy($b = ($truthy($c = (block = $$($nesting, 'Parser').$next_block(reader, parent, (function() {if ($truthy(attributes)) {\n            return attributes.$dup()\n          } else {\n            return $hash2([], {})\n          }; return nil; })()))) ? parent['$<<'](block) : $c)) ? $b : reader['$has_more_lines?']()))) {\n            \n          };\n          return parent;\n        }, TMP_Processor_parse_content_11.$$arity = -3);\n        return $send([[\"create_paragraph\", \"create_block\", \"paragraph\"], [\"create_open_block\", \"create_block\", \"open\"], [\"create_example_block\", \"create_block\", \"example\"], [\"create_pass_block\", \"create_block\", \"pass\"], [\"create_listing_block\", \"create_block\", \"listing\"], [\"create_literal_block\", \"create_block\", \"literal\"], [\"create_anchor\", \"create_inline\", \"anchor\"]], 'each', [], (TMP_Processor_12 = function(method_name, delegate_method_name, context){var self = TMP_Processor_12.$$s || this, TMP_13;\nif (method_name == null) method_name = nil;if (delegate_method_name == null) delegate_method_name = nil;if (context == null) context = nil;\n        return $send(self, 'define_method', [method_name], (TMP_13 = function($a_rest){var self = TMP_13.$$s || this, args;\n\n            var $args_len = arguments.length, $rest_len = $args_len - 0;\n            if ($rest_len < 0) { $rest_len = 0; }\n            args = new Array($rest_len);\n            for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n              args[$arg_idx - 0] = arguments[$arg_idx];\n            }\n          \n            args.$unshift(args.$shift(), context);\n            return $send(self, 'send', [delegate_method_name].concat(Opal.to_a(args)));}, TMP_13.$$s = self, TMP_13.$$arity = -1, TMP_13))}, TMP_Processor_12.$$s = self, TMP_Processor_12.$$arity = 3, TMP_Processor_12));\n      })($nesting[0], null, $nesting);\n      (function($base, $parent_nesting) {\n        var $ProcessorDsl, self = $ProcessorDsl = $module($base, 'ProcessorDsl');\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ProcessorDsl_option_14, TMP_ProcessorDsl_process_15, TMP_ProcessorDsl_process_block_given$q_16;\n\n        \n        \n        Opal.def(self, '$option', TMP_ProcessorDsl_option_14 = function $$option(key, value) {\n          var self = this, $writer = nil;\n\n          \n          $writer = [key, value];\n          $send(self.$config(), '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];\n        }, TMP_ProcessorDsl_option_14.$$arity = 2);\n        \n        Opal.def(self, '$process', TMP_ProcessorDsl_process_15 = function $$process($a_rest) {\n          var $b, self = this, args, $iter = TMP_ProcessorDsl_process_15.$$p, block = $iter || nil;\n          if (self.process_block == null) self.process_block = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          if ($iter) TMP_ProcessorDsl_process_15.$$p = null;\n          if ((block !== nil)) {\n            \n            if ($truthy(args['$empty?']())) {\n            } else {\n              self.$raise($$$('::', 'ArgumentError'), \"\" + \"wrong number of arguments (given \" + (args.$size()) + \", expected 0)\")\n            };\n            return (self.process_block = block);\n          } else if ($truthy((($b = self['process_block'], $b != null && $b !== nil) ? 'instance-variable' : nil))) {\n            return $send(self.process_block, 'call', Opal.to_a(args))\n          } else {\n            return self.$raise($$$('::', 'NotImplementedError'))\n          }\n        }, TMP_ProcessorDsl_process_15.$$arity = -1);\n        \n        Opal.def(self, '$process_block_given?', TMP_ProcessorDsl_process_block_given$q_16 = function() {\n          var $a, self = this;\n\n          return (($a = self['process_block'], $a != null && $a !== nil) ? 'instance-variable' : nil)\n        }, TMP_ProcessorDsl_process_block_given$q_16.$$arity = 0);\n      })($nesting[0], $nesting);\n      (function($base, $parent_nesting) {\n        var $SyntaxDsl, self = $SyntaxDsl = $module($base, 'SyntaxDsl');\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_SyntaxDsl_named_17, TMP_SyntaxDsl_content_model_18, TMP_SyntaxDsl_positional_attrs_19, TMP_SyntaxDsl_default_attrs_20, TMP_SyntaxDsl_resolves_attributes_23;\n\n        \n        self.$include($$($nesting, 'ProcessorDsl'));\n        \n        Opal.def(self, '$named', TMP_SyntaxDsl_named_17 = function $$named(value) {\n          var self = this;\n\n          if ($truthy($$($nesting, 'Processor')['$==='](self))) {\n            return (self.name = value)\n          } else {\n            return self.$option(\"name\", value)\n          }\n        }, TMP_SyntaxDsl_named_17.$$arity = 1);\n        Opal.alias(self, \"match_name\", \"named\");\n        \n        Opal.def(self, '$content_model', TMP_SyntaxDsl_content_model_18 = function $$content_model(value) {\n          var self = this;\n\n          return self.$option(\"content_model\", value)\n        }, TMP_SyntaxDsl_content_model_18.$$arity = 1);\n        Opal.alias(self, \"parse_content_as\", \"content_model\");\n        Opal.alias(self, \"parses_content_as\", \"content_model\");\n        \n        Opal.def(self, '$positional_attrs', TMP_SyntaxDsl_positional_attrs_19 = function $$positional_attrs($a_rest) {\n          var self = this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          return self.$option(\"pos_attrs\", value.$flatten())\n        }, TMP_SyntaxDsl_positional_attrs_19.$$arity = -1);\n        Opal.alias(self, \"name_attributes\", \"positional_attrs\");\n        Opal.alias(self, \"name_positional_attributes\", \"positional_attrs\");\n        \n        Opal.def(self, '$default_attrs', TMP_SyntaxDsl_default_attrs_20 = function $$default_attrs(value) {\n          var self = this;\n\n          return self.$option(\"default_attrs\", value)\n        }, TMP_SyntaxDsl_default_attrs_20.$$arity = 1);\n        \n        Opal.def(self, '$resolves_attributes', TMP_SyntaxDsl_resolves_attributes_23 = function $$resolves_attributes($a_rest) {\n          var $b, TMP_21, TMP_22, self = this, args, $case = nil, names = nil, defaults = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          \n          if ($truthy($rb_gt(args.$size(), 1))) {\n          } else if ($truthy((args = args.$fetch(0, true))['$respond_to?'](\"to_sym\"))) {\n            args = [args]};\n          return (function() {$case = args;\n          if (true['$===']($case)) {\n          self.$option(\"pos_attrs\", []);\n          return self.$option(\"default_attrs\", $hash2([], {}));}\n          else if ($$$('::', 'Array')['$===']($case)) {\n          $b = [[], $hash2([], {})], (names = $b[0]), (defaults = $b[1]), $b;\n          $send(args, 'each', [], (TMP_21 = function(arg){var self = TMP_21.$$s || this, $a, $c, name = nil, value = nil, idx = nil, $writer = nil;\nif (arg == null) arg = nil;\n          if ($truthy((arg = arg.$to_s())['$include?'](\"=\"))) {\n              \n              $c = arg.$split(\"=\", 2), $a = Opal.to_ary($c), (name = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), $c;\n              if ($truthy(name['$include?'](\":\"))) {\n                \n                $c = name.$split(\":\", 2), $a = Opal.to_ary($c), (idx = ($a[0] == null ? nil : $a[0])), (name = ($a[1] == null ? nil : $a[1])), $c;\n                idx = (function() {if (idx['$=='](\"@\")) {\n                  return names.$size()\n                } else {\n                  return idx.$to_i()\n                }; return nil; })();\n                \n                $writer = [idx, name];\n                $send(names, '[]=', Opal.to_a($writer));\n                $writer[$rb_minus($writer[\"length\"], 1)];;};\n              \n              $writer = [name, value];\n              $send(defaults, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];;\n            } else if ($truthy(arg['$include?'](\":\"))) {\n              \n              $c = arg.$split(\":\", 2), $a = Opal.to_ary($c), (idx = ($a[0] == null ? nil : $a[0])), (name = ($a[1] == null ? nil : $a[1])), $c;\n              idx = (function() {if (idx['$=='](\"@\")) {\n                return names.$size()\n              } else {\n                return idx.$to_i()\n              }; return nil; })();\n              \n              $writer = [idx, name];\n              $send(names, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];;\n            } else {\n              return names['$<<'](arg)\n            }}, TMP_21.$$s = self, TMP_21.$$arity = 1, TMP_21));\n          self.$option(\"pos_attrs\", names.$compact());\n          return self.$option(\"default_attrs\", defaults);}\n          else if ($$$('::', 'Hash')['$===']($case)) {\n          $b = [[], $hash2([], {})], (names = $b[0]), (defaults = $b[1]), $b;\n          $send(args, 'each', [], (TMP_22 = function(key, val){var self = TMP_22.$$s || this, $a, $c, name = nil, idx = nil, $writer = nil;\nif (key == null) key = nil;if (val == null) val = nil;\n          \n            if ($truthy((name = key.$to_s())['$include?'](\":\"))) {\n              \n              $c = name.$split(\":\", 2), $a = Opal.to_ary($c), (idx = ($a[0] == null ? nil : $a[0])), (name = ($a[1] == null ? nil : $a[1])), $c;\n              idx = (function() {if (idx['$=='](\"@\")) {\n                return names.$size()\n              } else {\n                return idx.$to_i()\n              }; return nil; })();\n              \n              $writer = [idx, name];\n              $send(names, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];;};\n            if ($truthy(val)) {\n              \n              $writer = [name, val];\n              $send(defaults, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];\n            } else {\n              return nil\n            };}, TMP_22.$$s = self, TMP_22.$$arity = 2, TMP_22));\n          self.$option(\"pos_attrs\", names.$compact());\n          return self.$option(\"default_attrs\", defaults);}\n          else {return self.$raise($$$('::', 'ArgumentError'), \"\" + \"unsupported attributes specification for macro: \" + (args.$inspect()))}})();\n        }, TMP_SyntaxDsl_resolves_attributes_23.$$arity = -1);\n        Opal.alias(self, \"resolve_attributes\", \"resolves_attributes\");\n      })($nesting[0], $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $Preprocessor(){};\n        var self = $Preprocessor = $klass($base, $super, 'Preprocessor', $Preprocessor);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Preprocessor_process_24;\n\n        return (Opal.def(self, '$process', TMP_Preprocessor_process_24 = function $$process(document, reader) {\n          var self = this;\n\n          return self.$raise($$$('::', 'NotImplementedError'), \"\" + \"Asciidoctor::Extensions::Preprocessor subclass must implement #\" + (\"process\") + \" method\")\n        }, TMP_Preprocessor_process_24.$$arity = 2), nil) && 'process'\n      })($nesting[0], $$($nesting, 'Processor'), $nesting);\n      Opal.const_set($$($nesting, 'Preprocessor'), 'DSL', $$($nesting, 'ProcessorDsl'));\n      (function($base, $super, $parent_nesting) {\n        function $TreeProcessor(){};\n        var self = $TreeProcessor = $klass($base, $super, 'TreeProcessor', $TreeProcessor);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_TreeProcessor_process_25;\n\n        return (Opal.def(self, '$process', TMP_TreeProcessor_process_25 = function $$process(document) {\n          var self = this;\n\n          return self.$raise($$$('::', 'NotImplementedError'), \"\" + \"Asciidoctor::Extensions::TreeProcessor subclass must implement #\" + (\"process\") + \" method\")\n        }, TMP_TreeProcessor_process_25.$$arity = 1), nil) && 'process'\n      })($nesting[0], $$($nesting, 'Processor'), $nesting);\n      Opal.const_set($$($nesting, 'TreeProcessor'), 'DSL', $$($nesting, 'ProcessorDsl'));\n      Opal.const_set($nesting[0], 'Treeprocessor', $$($nesting, 'TreeProcessor'));\n      (function($base, $super, $parent_nesting) {\n        function $Postprocessor(){};\n        var self = $Postprocessor = $klass($base, $super, 'Postprocessor', $Postprocessor);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Postprocessor_process_26;\n\n        return (Opal.def(self, '$process', TMP_Postprocessor_process_26 = function $$process(document, output) {\n          var self = this;\n\n          return self.$raise($$$('::', 'NotImplementedError'), \"\" + \"Asciidoctor::Extensions::Postprocessor subclass must implement #\" + (\"process\") + \" method\")\n        }, TMP_Postprocessor_process_26.$$arity = 2), nil) && 'process'\n      })($nesting[0], $$($nesting, 'Processor'), $nesting);\n      Opal.const_set($$($nesting, 'Postprocessor'), 'DSL', $$($nesting, 'ProcessorDsl'));\n      (function($base, $super, $parent_nesting) {\n        function $IncludeProcessor(){};\n        var self = $IncludeProcessor = $klass($base, $super, 'IncludeProcessor', $IncludeProcessor);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_IncludeProcessor_process_27, TMP_IncludeProcessor_handles$q_28;\n\n        \n        \n        Opal.def(self, '$process', TMP_IncludeProcessor_process_27 = function $$process(document, reader, target, attributes) {\n          var self = this;\n\n          return self.$raise($$$('::', 'NotImplementedError'), \"\" + \"Asciidoctor::Extensions::IncludeProcessor subclass must implement #\" + (\"process\") + \" method\")\n        }, TMP_IncludeProcessor_process_27.$$arity = 4);\n        return (Opal.def(self, '$handles?', TMP_IncludeProcessor_handles$q_28 = function(target) {\n          var self = this;\n\n          return true\n        }, TMP_IncludeProcessor_handles$q_28.$$arity = 1), nil) && 'handles?';\n      })($nesting[0], $$($nesting, 'Processor'), $nesting);\n      (function($base, $parent_nesting) {\n        var $IncludeProcessorDsl, self = $IncludeProcessorDsl = $module($base, 'IncludeProcessorDsl');\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_IncludeProcessorDsl_handles$q_29;\n\n        \n        self.$include($$($nesting, 'ProcessorDsl'));\n        \n        Opal.def(self, '$handles?', TMP_IncludeProcessorDsl_handles$q_29 = function($a_rest) {\n          var $b, self = this, args, $iter = TMP_IncludeProcessorDsl_handles$q_29.$$p, block = $iter || nil;\n          if (self.handles_block == null) self.handles_block = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          if ($iter) TMP_IncludeProcessorDsl_handles$q_29.$$p = null;\n          if ((block !== nil)) {\n            \n            if ($truthy(args['$empty?']())) {\n            } else {\n              self.$raise($$$('::', 'ArgumentError'), \"\" + \"wrong number of arguments (given \" + (args.$size()) + \", expected 0)\")\n            };\n            return (self.handles_block = block);\n          } else if ($truthy((($b = self['handles_block'], $b != null && $b !== nil) ? 'instance-variable' : nil))) {\n            return self.handles_block.$call(args['$[]'](0))\n          } else {\n            return true\n          }\n        }, TMP_IncludeProcessorDsl_handles$q_29.$$arity = -1);\n      })($nesting[0], $nesting);\n      Opal.const_set($$($nesting, 'IncludeProcessor'), 'DSL', $$($nesting, 'IncludeProcessorDsl'));\n      (function($base, $super, $parent_nesting) {\n        function $DocinfoProcessor(){};\n        var self = $DocinfoProcessor = $klass($base, $super, 'DocinfoProcessor', $DocinfoProcessor);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_DocinfoProcessor_initialize_30, TMP_DocinfoProcessor_process_31;\n\n        def.config = nil;\n        \n        self.$attr_accessor(\"location\");\n        \n        Opal.def(self, '$initialize', TMP_DocinfoProcessor_initialize_30 = function $$initialize(config) {\n          var $a, self = this, $iter = TMP_DocinfoProcessor_initialize_30.$$p, $yield = $iter || nil, $writer = nil;\n\n          if (config == null) {\n            config = $hash2([], {});\n          }\n          if ($iter) TMP_DocinfoProcessor_initialize_30.$$p = null;\n          \n          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_DocinfoProcessor_initialize_30, false), [config], null);\n          return ($truthy($a = self.config['$[]'](\"location\")) ? $a : (($writer = [\"location\", \"head\"]), $send(self.config, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n        }, TMP_DocinfoProcessor_initialize_30.$$arity = -1);\n        return (Opal.def(self, '$process', TMP_DocinfoProcessor_process_31 = function $$process(document) {\n          var self = this;\n\n          return self.$raise($$$('::', 'NotImplementedError'), \"\" + \"Asciidoctor::Extensions::DocinfoProcessor subclass must implement #\" + (\"process\") + \" method\")\n        }, TMP_DocinfoProcessor_process_31.$$arity = 1), nil) && 'process';\n      })($nesting[0], $$($nesting, 'Processor'), $nesting);\n      (function($base, $parent_nesting) {\n        var $DocinfoProcessorDsl, self = $DocinfoProcessorDsl = $module($base, 'DocinfoProcessorDsl');\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_DocinfoProcessorDsl_at_location_32;\n\n        \n        self.$include($$($nesting, 'ProcessorDsl'));\n        \n        Opal.def(self, '$at_location', TMP_DocinfoProcessorDsl_at_location_32 = function $$at_location(value) {\n          var self = this;\n\n          return self.$option(\"location\", value)\n        }, TMP_DocinfoProcessorDsl_at_location_32.$$arity = 1);\n      })($nesting[0], $nesting);\n      Opal.const_set($$($nesting, 'DocinfoProcessor'), 'DSL', $$($nesting, 'DocinfoProcessorDsl'));\n      (function($base, $super, $parent_nesting) {\n        function $BlockProcessor(){};\n        var self = $BlockProcessor = $klass($base, $super, 'BlockProcessor', $BlockProcessor);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BlockProcessor_initialize_33, TMP_BlockProcessor_process_34;\n\n        def.config = nil;\n        \n        self.$attr_accessor(\"name\");\n        \n        Opal.def(self, '$initialize', TMP_BlockProcessor_initialize_33 = function $$initialize(name, config) {\n          var $a, self = this, $iter = TMP_BlockProcessor_initialize_33.$$p, $yield = $iter || nil, $case = nil, $writer = nil;\n\n          if (name == null) {\n            name = nil;\n          }\n          if (config == null) {\n            config = $hash2([], {});\n          }\n          if ($iter) TMP_BlockProcessor_initialize_33.$$p = null;\n          \n          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_BlockProcessor_initialize_33, false), [config], null);\n          self.name = ($truthy($a = name) ? $a : self.config['$[]'](\"name\"));\n          $case = self.config['$[]'](\"contexts\");\n          if ($$$('::', 'NilClass')['$===']($case)) {($truthy($a = self.config['$[]'](\"contexts\")) ? $a : (($writer = [\"contexts\", [\"open\", \"paragraph\"].$to_set()]), $send(self.config, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))}\n          else if ($$$('::', 'Symbol')['$===']($case)) {\n          $writer = [\"contexts\", [self.config['$[]'](\"contexts\")].$to_set()];\n          $send(self.config, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];}\n          else {\n          $writer = [\"contexts\", self.config['$[]'](\"contexts\").$to_set()];\n          $send(self.config, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];};\n          return ($truthy($a = self.config['$[]'](\"content_model\")) ? $a : (($writer = [\"content_model\", \"compound\"]), $send(self.config, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n        }, TMP_BlockProcessor_initialize_33.$$arity = -1);\n        return (Opal.def(self, '$process', TMP_BlockProcessor_process_34 = function $$process(parent, reader, attributes) {\n          var self = this;\n\n          return self.$raise($$$('::', 'NotImplementedError'), \"\" + \"Asciidoctor::Extensions::BlockProcessor subclass must implement #\" + (\"process\") + \" method\")\n        }, TMP_BlockProcessor_process_34.$$arity = 3), nil) && 'process';\n      })($nesting[0], $$($nesting, 'Processor'), $nesting);\n      (function($base, $parent_nesting) {\n        var $BlockProcessorDsl, self = $BlockProcessorDsl = $module($base, 'BlockProcessorDsl');\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_BlockProcessorDsl_contexts_35;\n\n        \n        self.$include($$($nesting, 'SyntaxDsl'));\n        \n        Opal.def(self, '$contexts', TMP_BlockProcessorDsl_contexts_35 = function $$contexts($a_rest) {\n          var self = this, value;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          value = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            value[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          return self.$option(\"contexts\", value.$flatten().$to_set())\n        }, TMP_BlockProcessorDsl_contexts_35.$$arity = -1);\n        Opal.alias(self, \"on_contexts\", \"contexts\");\n        Opal.alias(self, \"on_context\", \"contexts\");\n        Opal.alias(self, \"bound_to\", \"contexts\");\n      })($nesting[0], $nesting);\n      Opal.const_set($$($nesting, 'BlockProcessor'), 'DSL', $$($nesting, 'BlockProcessorDsl'));\n      (function($base, $super, $parent_nesting) {\n        function $MacroProcessor(){};\n        var self = $MacroProcessor = $klass($base, $super, 'MacroProcessor', $MacroProcessor);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_MacroProcessor_initialize_36, TMP_MacroProcessor_process_37;\n\n        def.config = nil;\n        \n        self.$attr_accessor(\"name\");\n        \n        Opal.def(self, '$initialize', TMP_MacroProcessor_initialize_36 = function $$initialize(name, config) {\n          var $a, self = this, $iter = TMP_MacroProcessor_initialize_36.$$p, $yield = $iter || nil, $writer = nil;\n\n          if (name == null) {\n            name = nil;\n          }\n          if (config == null) {\n            config = $hash2([], {});\n          }\n          if ($iter) TMP_MacroProcessor_initialize_36.$$p = null;\n          \n          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_MacroProcessor_initialize_36, false), [config], null);\n          self.name = ($truthy($a = name) ? $a : self.config['$[]'](\"name\"));\n          return ($truthy($a = self.config['$[]'](\"content_model\")) ? $a : (($writer = [\"content_model\", \"attributes\"]), $send(self.config, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n        }, TMP_MacroProcessor_initialize_36.$$arity = -1);\n        return (Opal.def(self, '$process', TMP_MacroProcessor_process_37 = function $$process(parent, target, attributes) {\n          var self = this;\n\n          return self.$raise($$$('::', 'NotImplementedError'), \"\" + \"Asciidoctor::Extensions::MacroProcessor subclass must implement #\" + (\"process\") + \" method\")\n        }, TMP_MacroProcessor_process_37.$$arity = 3), nil) && 'process';\n      })($nesting[0], $$($nesting, 'Processor'), $nesting);\n      (function($base, $parent_nesting) {\n        var $MacroProcessorDsl, self = $MacroProcessorDsl = $module($base, 'MacroProcessorDsl');\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_MacroProcessorDsl_resolves_attributes_38;\n\n        \n        self.$include($$($nesting, 'SyntaxDsl'));\n        \n        Opal.def(self, '$resolves_attributes', TMP_MacroProcessorDsl_resolves_attributes_38 = function $$resolves_attributes($a_rest) {\n          var $b, self = this, args, $iter = TMP_MacroProcessorDsl_resolves_attributes_38.$$p, $yield = $iter || nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          if ($iter) TMP_MacroProcessorDsl_resolves_attributes_38.$$p = null;\n          // Prepare super implicit arguments\n          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {\n            $zuper[$zuper_i] = arguments[$zuper_i];\n          }\n          \n          if ($truthy((($b = args.$size()['$=='](1)) ? args['$[]'](0)['$!']() : args.$size()['$=='](1)))) {\n            \n            self.$option(\"content_model\", \"text\");\n            return nil;};\n          $send(self, Opal.find_super_dispatcher(self, 'resolves_attributes', TMP_MacroProcessorDsl_resolves_attributes_38, false), $zuper, $iter);\n          return self.$option(\"content_model\", \"attributes\");\n        }, TMP_MacroProcessorDsl_resolves_attributes_38.$$arity = -1);\n        Opal.alias(self, \"resolve_attributes\", \"resolves_attributes\");\n      })($nesting[0], $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $BlockMacroProcessor(){};\n        var self = $BlockMacroProcessor = $klass($base, $super, 'BlockMacroProcessor', $BlockMacroProcessor);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return nil\n      })($nesting[0], $$($nesting, 'MacroProcessor'), $nesting);\n      Opal.const_set($$($nesting, 'BlockMacroProcessor'), 'DSL', $$($nesting, 'MacroProcessorDsl'));\n      (function($base, $super, $parent_nesting) {\n        function $InlineMacroProcessor(){};\n        var self = $InlineMacroProcessor = $klass($base, $super, 'InlineMacroProcessor', $InlineMacroProcessor);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_InlineMacroProcessor_regexp_39, TMP_InlineMacroProcessor_resolve_regexp_40;\n\n        def.config = def.name = nil;\n        \n        (Opal.class_variable_set($InlineMacroProcessor, '@@rx_cache', $hash2([], {})));\n        \n        Opal.def(self, '$regexp', TMP_InlineMacroProcessor_regexp_39 = function $$regexp() {\n          var $a, self = this, $writer = nil;\n\n          return ($truthy($a = self.config['$[]'](\"regexp\")) ? $a : (($writer = [\"regexp\", self.$resolve_regexp(self.name.$to_s(), self.config['$[]'](\"format\"))]), $send(self.config, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))\n        }, TMP_InlineMacroProcessor_regexp_39.$$arity = 0);\n        return (Opal.def(self, '$resolve_regexp', TMP_InlineMacroProcessor_resolve_regexp_40 = function $$resolve_regexp(name, format) {\n          var $a, $b, self = this, $writer = nil;\n\n          \n          if ($truthy($$($nesting, 'MacroNameRx')['$match?'](name))) {\n          } else {\n            self.$raise($$$('::', 'ArgumentError'), \"\" + \"invalid name for inline macro: \" + (name))\n          };\n          return ($truthy($a = (($b = $InlineMacroProcessor.$$cvars['@@rx_cache']) == null ? nil : $b)['$[]']([name, format])) ? $a : (($writer = [[name, format], new RegExp(\"\" + \"\\\\\\\\?\" + (name) + \":\" + ((function() {if (format['$=='](\"short\")) {\n            return \"(){0}\"\n          } else {\n            return \"(\\\\S+?)\"\n          }; return nil; })()) + \"\\\\[(|.*?[^\\\\\\\\])\\\\]\")]), $send((($b = $InlineMacroProcessor.$$cvars['@@rx_cache']) == null ? nil : $b), '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n        }, TMP_InlineMacroProcessor_resolve_regexp_40.$$arity = 2), nil) && 'resolve_regexp';\n      })($nesting[0], $$($nesting, 'MacroProcessor'), $nesting);\n      (function($base, $parent_nesting) {\n        var $InlineMacroProcessorDsl, self = $InlineMacroProcessorDsl = $module($base, 'InlineMacroProcessorDsl');\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_InlineMacroProcessorDsl_with_format_41, TMP_InlineMacroProcessorDsl_matches_42;\n\n        \n        self.$include($$($nesting, 'MacroProcessorDsl'));\n        \n        Opal.def(self, '$with_format', TMP_InlineMacroProcessorDsl_with_format_41 = function $$with_format(value) {\n          var self = this;\n\n          return self.$option(\"format\", value)\n        }, TMP_InlineMacroProcessorDsl_with_format_41.$$arity = 1);\n        Opal.alias(self, \"using_format\", \"with_format\");\n        \n        Opal.def(self, '$matches', TMP_InlineMacroProcessorDsl_matches_42 = function $$matches(value) {\n          var self = this;\n\n          return self.$option(\"regexp\", value)\n        }, TMP_InlineMacroProcessorDsl_matches_42.$$arity = 1);\n        Opal.alias(self, \"match\", \"matches\");\n        Opal.alias(self, \"matching\", \"matches\");\n      })($nesting[0], $nesting);\n      Opal.const_set($$($nesting, 'InlineMacroProcessor'), 'DSL', $$($nesting, 'InlineMacroProcessorDsl'));\n      (function($base, $super, $parent_nesting) {\n        function $Extension(){};\n        var self = $Extension = $klass($base, $super, 'Extension', $Extension);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Extension_initialize_43;\n\n        \n        self.$attr_reader(\"kind\");\n        self.$attr_reader(\"config\");\n        self.$attr_reader(\"instance\");\n        return (Opal.def(self, '$initialize', TMP_Extension_initialize_43 = function $$initialize(kind, instance, config) {\n          var self = this;\n\n          \n          self.kind = kind;\n          self.instance = instance;\n          return (self.config = config);\n        }, TMP_Extension_initialize_43.$$arity = 3), nil) && 'initialize';\n      })($nesting[0], null, $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $ProcessorExtension(){};\n        var self = $ProcessorExtension = $klass($base, $super, 'ProcessorExtension', $ProcessorExtension);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_ProcessorExtension_initialize_44;\n\n        \n        self.$attr_reader(\"process_method\");\n        return (Opal.def(self, '$initialize', TMP_ProcessorExtension_initialize_44 = function $$initialize(kind, instance, process_method) {\n          var $a, self = this, $iter = TMP_ProcessorExtension_initialize_44.$$p, $yield = $iter || nil;\n\n          if (process_method == null) {\n            process_method = nil;\n          }\n          if ($iter) TMP_ProcessorExtension_initialize_44.$$p = null;\n          \n          $send(self, Opal.find_super_dispatcher(self, 'initialize', TMP_ProcessorExtension_initialize_44, false), [kind, instance, instance.$config()], null);\n          return (self.process_method = ($truthy($a = process_method) ? $a : instance.$method(\"process\")));\n        }, TMP_ProcessorExtension_initialize_44.$$arity = -3), nil) && 'initialize';\n      })($nesting[0], $$($nesting, 'Extension'), $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $Group(){};\n        var self = $Group = $klass($base, $super, 'Group', $Group);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Group_activate_46;\n\n        \n        (function(self, $parent_nesting) {\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_register_45;\n\n          return (Opal.def(self, '$register', TMP_register_45 = function $$register(name) {\n            var self = this;\n\n            if (name == null) {\n              name = nil;\n            }\n            return $$($nesting, 'Extensions').$register(name, self)\n          }, TMP_register_45.$$arity = -1), nil) && 'register'\n        })(Opal.get_singleton_class(self), $nesting);\n        return (Opal.def(self, '$activate', TMP_Group_activate_46 = function $$activate(registry) {\n          var self = this;\n\n          return self.$raise($$$('::', 'NotImplementedError'))\n        }, TMP_Group_activate_46.$$arity = 1), nil) && 'activate';\n      })($nesting[0], null, $nesting);\n      (function($base, $super, $parent_nesting) {\n        function $Registry(){};\n        var self = $Registry = $klass($base, $super, 'Registry', $Registry);\n\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Registry_initialize_47, TMP_Registry_activate_49, TMP_Registry_preprocessor_50, TMP_Registry_preprocessors$q_51, TMP_Registry_preprocessors_52, TMP_Registry_tree_processor_53, TMP_Registry_tree_processors$q_54, TMP_Registry_tree_processors_55, TMP_Registry_postprocessor_56, TMP_Registry_postprocessors$q_57, TMP_Registry_postprocessors_58, TMP_Registry_include_processor_59, TMP_Registry_include_processors$q_60, TMP_Registry_include_processors_61, TMP_Registry_docinfo_processor_62, TMP_Registry_docinfo_processors$q_64, TMP_Registry_docinfo_processors_66, TMP_Registry_block_67, TMP_Registry_blocks$q_68, TMP_Registry_registered_for_block$q_69, TMP_Registry_find_block_extension_70, TMP_Registry_block_macro_71, TMP_Registry_block_macros$q_72, TMP_Registry_registered_for_block_macro$q_73, TMP_Registry_find_block_macro_extension_74, TMP_Registry_inline_macro_75, TMP_Registry_inline_macros$q_76, TMP_Registry_registered_for_inline_macro$q_77, TMP_Registry_find_inline_macro_extension_78, TMP_Registry_inline_macros_79, TMP_Registry_add_document_processor_80, TMP_Registry_add_syntax_processor_82, TMP_Registry_resolve_args_84, TMP_Registry_as_symbol_85;\n\n        def.groups = def.preprocessor_extensions = def.tree_processor_extensions = def.postprocessor_extensions = def.include_processor_extensions = def.docinfo_processor_extensions = def.block_extensions = def.block_macro_extensions = def.inline_macro_extensions = nil;\n        \n        self.$attr_reader(\"document\");\n        self.$attr_reader(\"groups\");\n        \n        Opal.def(self, '$initialize', TMP_Registry_initialize_47 = function $$initialize(groups) {\n          var self = this;\n\n          if (groups == null) {\n            groups = $hash2([], {});\n          }\n          \n          self.groups = groups;\n          self.preprocessor_extensions = (self.tree_processor_extensions = (self.postprocessor_extensions = (self.include_processor_extensions = (self.docinfo_processor_extensions = nil))));\n          self.block_extensions = (self.block_macro_extensions = (self.inline_macro_extensions = nil));\n          return (self.document = nil);\n        }, TMP_Registry_initialize_47.$$arity = -1);\n        \n        Opal.def(self, '$activate', TMP_Registry_activate_49 = function $$activate(document) {\n          var TMP_48, self = this;\n\n          \n          self.document = document;\n          $send($rb_plus($$($nesting, 'Extensions').$groups().$values(), self.groups.$values()), 'each', [], (TMP_48 = function(group){var self = TMP_48.$$s || this, $case = nil;\nif (group == null) group = nil;\n          return (function() {$case = group;\n            if ($$$('::', 'Proc')['$===']($case)) {return (function() {$case = group.$arity();\n            if ((0)['$===']($case) || (-1)['$===']($case)) {return $send(self, 'instance_exec', [], group.$to_proc())}\n            else if ((1)['$===']($case)) {return group.$call(self)}\n            else { return nil }})()}\n            else if ($$$('::', 'Class')['$===']($case)) {return group.$new().$activate(self)}\n            else {return group.$activate(self)}})()}, TMP_48.$$s = self, TMP_48.$$arity = 1, TMP_48));\n          return self;\n        }, TMP_Registry_activate_49.$$arity = 1);\n        \n        Opal.def(self, '$preprocessor', TMP_Registry_preprocessor_50 = function $$preprocessor($a_rest) {\n          var self = this, args, $iter = TMP_Registry_preprocessor_50.$$p, block = $iter || nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          if ($iter) TMP_Registry_preprocessor_50.$$p = null;\n          return $send(self, 'add_document_processor', [\"preprocessor\", args], block.$to_proc())\n        }, TMP_Registry_preprocessor_50.$$arity = -1);\n        \n        Opal.def(self, '$preprocessors?', TMP_Registry_preprocessors$q_51 = function() {\n          var self = this;\n\n          return self.preprocessor_extensions['$!']()['$!']()\n        }, TMP_Registry_preprocessors$q_51.$$arity = 0);\n        \n        Opal.def(self, '$preprocessors', TMP_Registry_preprocessors_52 = function $$preprocessors() {\n          var self = this;\n\n          return self.preprocessor_extensions\n        }, TMP_Registry_preprocessors_52.$$arity = 0);\n        \n        Opal.def(self, '$tree_processor', TMP_Registry_tree_processor_53 = function $$tree_processor($a_rest) {\n          var self = this, args, $iter = TMP_Registry_tree_processor_53.$$p, block = $iter || nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          if ($iter) TMP_Registry_tree_processor_53.$$p = null;\n          return $send(self, 'add_document_processor', [\"tree_processor\", args], block.$to_proc())\n        }, TMP_Registry_tree_processor_53.$$arity = -1);\n        \n        Opal.def(self, '$tree_processors?', TMP_Registry_tree_processors$q_54 = function() {\n          var self = this;\n\n          return self.tree_processor_extensions['$!']()['$!']()\n        }, TMP_Registry_tree_processors$q_54.$$arity = 0);\n        \n        Opal.def(self, '$tree_processors', TMP_Registry_tree_processors_55 = function $$tree_processors() {\n          var self = this;\n\n          return self.tree_processor_extensions\n        }, TMP_Registry_tree_processors_55.$$arity = 0);\n        Opal.alias(self, \"treeprocessor\", \"tree_processor\");\n        Opal.alias(self, \"treeprocessors?\", \"tree_processors?\");\n        Opal.alias(self, \"treeprocessors\", \"tree_processors\");\n        \n        Opal.def(self, '$postprocessor', TMP_Registry_postprocessor_56 = function $$postprocessor($a_rest) {\n          var self = this, args, $iter = TMP_Registry_postprocessor_56.$$p, block = $iter || nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          if ($iter) TMP_Registry_postprocessor_56.$$p = null;\n          return $send(self, 'add_document_processor', [\"postprocessor\", args], block.$to_proc())\n        }, TMP_Registry_postprocessor_56.$$arity = -1);\n        \n        Opal.def(self, '$postprocessors?', TMP_Registry_postprocessors$q_57 = function() {\n          var self = this;\n\n          return self.postprocessor_extensions['$!']()['$!']()\n        }, TMP_Registry_postprocessors$q_57.$$arity = 0);\n        \n        Opal.def(self, '$postprocessors', TMP_Registry_postprocessors_58 = function $$postprocessors() {\n          var self = this;\n\n          return self.postprocessor_extensions\n        }, TMP_Registry_postprocessors_58.$$arity = 0);\n        \n        Opal.def(self, '$include_processor', TMP_Registry_include_processor_59 = function $$include_processor($a_rest) {\n          var self = this, args, $iter = TMP_Registry_include_processor_59.$$p, block = $iter || nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          if ($iter) TMP_Registry_include_processor_59.$$p = null;\n          return $send(self, 'add_document_processor', [\"include_processor\", args], block.$to_proc())\n        }, TMP_Registry_include_processor_59.$$arity = -1);\n        \n        Opal.def(self, '$include_processors?', TMP_Registry_include_processors$q_60 = function() {\n          var self = this;\n\n          return self.include_processor_extensions['$!']()['$!']()\n        }, TMP_Registry_include_processors$q_60.$$arity = 0);\n        \n        Opal.def(self, '$include_processors', TMP_Registry_include_processors_61 = function $$include_processors() {\n          var self = this;\n\n          return self.include_processor_extensions\n        }, TMP_Registry_include_processors_61.$$arity = 0);\n        \n        Opal.def(self, '$docinfo_processor', TMP_Registry_docinfo_processor_62 = function $$docinfo_processor($a_rest) {\n          var self = this, args, $iter = TMP_Registry_docinfo_processor_62.$$p, block = $iter || nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          if ($iter) TMP_Registry_docinfo_processor_62.$$p = null;\n          return $send(self, 'add_document_processor', [\"docinfo_processor\", args], block.$to_proc())\n        }, TMP_Registry_docinfo_processor_62.$$arity = -1);\n        \n        Opal.def(self, '$docinfo_processors?', TMP_Registry_docinfo_processors$q_64 = function(location) {\n          var TMP_63, self = this;\n\n          if (location == null) {\n            location = nil;\n          }\n          if ($truthy(self.docinfo_processor_extensions)) {\n            if ($truthy(location)) {\n              return $send(self.docinfo_processor_extensions, 'any?', [], (TMP_63 = function(ext){var self = TMP_63.$$s || this;\nif (ext == null) ext = nil;\n              return ext.$config()['$[]'](\"location\")['$=='](location)}, TMP_63.$$s = self, TMP_63.$$arity = 1, TMP_63))\n            } else {\n              return true\n            }\n          } else {\n            return false\n          }\n        }, TMP_Registry_docinfo_processors$q_64.$$arity = -1);\n        \n        Opal.def(self, '$docinfo_processors', TMP_Registry_docinfo_processors_66 = function $$docinfo_processors(location) {\n          var TMP_65, self = this;\n\n          if (location == null) {\n            location = nil;\n          }\n          if ($truthy(self.docinfo_processor_extensions)) {\n            if ($truthy(location)) {\n              return $send(self.docinfo_processor_extensions, 'select', [], (TMP_65 = function(ext){var self = TMP_65.$$s || this;\nif (ext == null) ext = nil;\n              return ext.$config()['$[]'](\"location\")['$=='](location)}, TMP_65.$$s = self, TMP_65.$$arity = 1, TMP_65))\n            } else {\n              return self.docinfo_processor_extensions\n            }\n          } else {\n            return nil\n          }\n        }, TMP_Registry_docinfo_processors_66.$$arity = -1);\n        \n        Opal.def(self, '$block', TMP_Registry_block_67 = function $$block($a_rest) {\n          var self = this, args, $iter = TMP_Registry_block_67.$$p, block = $iter || nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          if ($iter) TMP_Registry_block_67.$$p = null;\n          return $send(self, 'add_syntax_processor', [\"block\", args], block.$to_proc())\n        }, TMP_Registry_block_67.$$arity = -1);\n        \n        Opal.def(self, '$blocks?', TMP_Registry_blocks$q_68 = function() {\n          var self = this;\n\n          return self.block_extensions['$!']()['$!']()\n        }, TMP_Registry_blocks$q_68.$$arity = 0);\n        \n        Opal.def(self, '$registered_for_block?', TMP_Registry_registered_for_block$q_69 = function(name, context) {\n          var self = this, ext = nil;\n\n          if ($truthy((ext = self.block_extensions['$[]'](name.$to_sym())))) {\n            if ($truthy(ext.$config()['$[]'](\"contexts\")['$include?'](context))) {\n              return ext\n            } else {\n              return false\n            }\n          } else {\n            return false\n          }\n        }, TMP_Registry_registered_for_block$q_69.$$arity = 2);\n        \n        Opal.def(self, '$find_block_extension', TMP_Registry_find_block_extension_70 = function $$find_block_extension(name) {\n          var self = this;\n\n          return self.block_extensions['$[]'](name.$to_sym())\n        }, TMP_Registry_find_block_extension_70.$$arity = 1);\n        \n        Opal.def(self, '$block_macro', TMP_Registry_block_macro_71 = function $$block_macro($a_rest) {\n          var self = this, args, $iter = TMP_Registry_block_macro_71.$$p, block = $iter || nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          if ($iter) TMP_Registry_block_macro_71.$$p = null;\n          return $send(self, 'add_syntax_processor', [\"block_macro\", args], block.$to_proc())\n        }, TMP_Registry_block_macro_71.$$arity = -1);\n        \n        Opal.def(self, '$block_macros?', TMP_Registry_block_macros$q_72 = function() {\n          var self = this;\n\n          return self.block_macro_extensions['$!']()['$!']()\n        }, TMP_Registry_block_macros$q_72.$$arity = 0);\n        \n        Opal.def(self, '$registered_for_block_macro?', TMP_Registry_registered_for_block_macro$q_73 = function(name) {\n          var self = this, ext = nil;\n\n          if ($truthy((ext = self.block_macro_extensions['$[]'](name.$to_sym())))) {\n            return ext\n          } else {\n            return false\n          }\n        }, TMP_Registry_registered_for_block_macro$q_73.$$arity = 1);\n        \n        Opal.def(self, '$find_block_macro_extension', TMP_Registry_find_block_macro_extension_74 = function $$find_block_macro_extension(name) {\n          var self = this;\n\n          return self.block_macro_extensions['$[]'](name.$to_sym())\n        }, TMP_Registry_find_block_macro_extension_74.$$arity = 1);\n        \n        Opal.def(self, '$inline_macro', TMP_Registry_inline_macro_75 = function $$inline_macro($a_rest) {\n          var self = this, args, $iter = TMP_Registry_inline_macro_75.$$p, block = $iter || nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          if ($iter) TMP_Registry_inline_macro_75.$$p = null;\n          return $send(self, 'add_syntax_processor', [\"inline_macro\", args], block.$to_proc())\n        }, TMP_Registry_inline_macro_75.$$arity = -1);\n        \n        Opal.def(self, '$inline_macros?', TMP_Registry_inline_macros$q_76 = function() {\n          var self = this;\n\n          return self.inline_macro_extensions['$!']()['$!']()\n        }, TMP_Registry_inline_macros$q_76.$$arity = 0);\n        \n        Opal.def(self, '$registered_for_inline_macro?', TMP_Registry_registered_for_inline_macro$q_77 = function(name) {\n          var self = this, ext = nil;\n\n          if ($truthy((ext = self.inline_macro_extensions['$[]'](name.$to_sym())))) {\n            return ext\n          } else {\n            return false\n          }\n        }, TMP_Registry_registered_for_inline_macro$q_77.$$arity = 1);\n        \n        Opal.def(self, '$find_inline_macro_extension', TMP_Registry_find_inline_macro_extension_78 = function $$find_inline_macro_extension(name) {\n          var self = this;\n\n          return self.inline_macro_extensions['$[]'](name.$to_sym())\n        }, TMP_Registry_find_inline_macro_extension_78.$$arity = 1);\n        \n        Opal.def(self, '$inline_macros', TMP_Registry_inline_macros_79 = function $$inline_macros() {\n          var self = this;\n\n          return self.inline_macro_extensions.$values()\n        }, TMP_Registry_inline_macros_79.$$arity = 0);\n        self.$private();\n        \n        Opal.def(self, '$add_document_processor', TMP_Registry_add_document_processor_80 = function $$add_document_processor(kind, args) {\n          var TMP_81, $a, $b, $c, self = this, $iter = TMP_Registry_add_document_processor_80.$$p, block = $iter || nil, kind_name = nil, kind_class_symbol = nil, kind_class = nil, kind_java_class = nil, kind_store = nil, extension = nil, config = nil, processor = nil, processor_class = nil, processor_instance = nil;\n\n          if ($iter) TMP_Registry_add_document_processor_80.$$p = null;\n          \n          kind_name = kind.$to_s().$tr(\"_\", \" \");\n          kind_class_symbol = $send(kind_name.$split(), 'map', [], (TMP_81 = function(it){var self = TMP_81.$$s || this;\nif (it == null) it = nil;\n          return it.$capitalize()}, TMP_81.$$s = self, TMP_81.$$arity = 1, TMP_81)).$join().$to_sym();\n          kind_class = $$($nesting, 'Extensions').$const_get(kind_class_symbol);\n          kind_java_class = (function() {if ($truthy((($a = $$$('::', 'AsciidoctorJ', 'skip_raise')) ? 'constant' : nil))) {\n            \n            return $$$($$$('::', 'AsciidoctorJ'), 'Extensions').$const_get(kind_class_symbol);\n          } else {\n            return nil\n          }; return nil; })();\n          kind_store = ($truthy($b = self.$instance_variable_get((((\"\" + \"@\") + (kind)) + \"_extensions\").$to_sym())) ? $b : self.$instance_variable_set((((\"\" + \"@\") + (kind)) + \"_extensions\").$to_sym(), []));\n          extension = (function() {if ((block !== nil)) {\n            \n            config = self.$resolve_args(args, 1);\n            processor = kind_class.$new(config);\n            if ($truthy(kind_class.$constants().$grep(\"DSL\"))) {\n              processor.$extend(kind_class.$const_get(\"DSL\"))};\n            $send(processor, 'instance_exec', [], block.$to_proc());\n            processor.$freeze();\n            if ($truthy(processor['$process_block_given?']())) {\n            } else {\n              self.$raise($$$('::', 'ArgumentError'), \"\" + \"No block specified to process \" + (kind_name) + \" extension at \" + (block.$source_location()))\n            };\n            return $$($nesting, 'ProcessorExtension').$new(kind, processor);\n          } else {\n            \n            $c = self.$resolve_args(args, 2), $b = Opal.to_ary($c), (processor = ($b[0] == null ? nil : $b[0])), (config = ($b[1] == null ? nil : $b[1])), $c;\n            if ($truthy((processor_class = $$($nesting, 'Extensions').$resolve_class(processor)))) {\n              \n              if ($truthy(($truthy($b = $rb_lt(processor_class, kind_class)) ? $b : ($truthy($c = kind_java_class) ? $rb_lt(processor_class, kind_java_class) : $c)))) {\n              } else {\n                self.$raise($$$('::', 'ArgumentError'), \"\" + \"Invalid type for \" + (kind_name) + \" extension: \" + (processor))\n              };\n              processor_instance = processor_class.$new(config);\n              processor_instance.$freeze();\n              return $$($nesting, 'ProcessorExtension').$new(kind, processor_instance);\n            } else if ($truthy(($truthy($b = kind_class['$==='](processor)) ? $b : ($truthy($c = kind_java_class) ? kind_java_class['$==='](processor) : $c)))) {\n              \n              processor.$update_config(config);\n              processor.$freeze();\n              return $$($nesting, 'ProcessorExtension').$new(kind, processor);\n            } else {\n              return self.$raise($$$('::', 'ArgumentError'), \"\" + \"Invalid arguments specified for registering \" + (kind_name) + \" extension: \" + (args))\n            };\n          }; return nil; })();\n          if (extension.$config()['$[]'](\"position\")['$=='](\">>\")) {\n            return kind_store.$unshift(extension)\n          } else {\n            return kind_store['$<<'](extension)\n          };\n        }, TMP_Registry_add_document_processor_80.$$arity = 2);\n        \n        Opal.def(self, '$add_syntax_processor', TMP_Registry_add_syntax_processor_82 = function $$add_syntax_processor(kind, args) {\n          var TMP_83, $a, $b, $c, self = this, $iter = TMP_Registry_add_syntax_processor_82.$$p, block = $iter || nil, kind_name = nil, kind_class_symbol = nil, kind_class = nil, kind_java_class = nil, kind_store = nil, name = nil, config = nil, processor = nil, $writer = nil, processor_class = nil, processor_instance = nil;\n\n          if ($iter) TMP_Registry_add_syntax_processor_82.$$p = null;\n          \n          kind_name = kind.$to_s().$tr(\"_\", \" \");\n          kind_class_symbol = $send(kind_name.$split(), 'map', [], (TMP_83 = function(it){var self = TMP_83.$$s || this;\nif (it == null) it = nil;\n          return it.$capitalize()}, TMP_83.$$s = self, TMP_83.$$arity = 1, TMP_83)).$push(\"Processor\").$join().$to_sym();\n          kind_class = $$($nesting, 'Extensions').$const_get(kind_class_symbol);\n          kind_java_class = (function() {if ($truthy((($a = $$$('::', 'AsciidoctorJ', 'skip_raise')) ? 'constant' : nil))) {\n            \n            return $$$($$$('::', 'AsciidoctorJ'), 'Extensions').$const_get(kind_class_symbol);\n          } else {\n            return nil\n          }; return nil; })();\n          kind_store = ($truthy($b = self.$instance_variable_get((((\"\" + \"@\") + (kind)) + \"_extensions\").$to_sym())) ? $b : self.$instance_variable_set((((\"\" + \"@\") + (kind)) + \"_extensions\").$to_sym(), $hash2([], {})));\n          if ((block !== nil)) {\n            \n            $c = self.$resolve_args(args, 2), $b = Opal.to_ary($c), (name = ($b[0] == null ? nil : $b[0])), (config = ($b[1] == null ? nil : $b[1])), $c;\n            processor = kind_class.$new(self.$as_symbol(name), config);\n            if ($truthy(kind_class.$constants().$grep(\"DSL\"))) {\n              processor.$extend(kind_class.$const_get(\"DSL\"))};\n            if (block.$arity()['$=='](1)) {\n              Opal.yield1(block, processor)\n            } else {\n              $send(processor, 'instance_exec', [], block.$to_proc())\n            };\n            if ($truthy((name = self.$as_symbol(processor.$name())))) {\n            } else {\n              self.$raise($$$('::', 'ArgumentError'), \"\" + \"No name specified for \" + (kind_name) + \" extension at \" + (block.$source_location()))\n            };\n            if ($truthy(processor['$process_block_given?']())) {\n            } else {\n              self.$raise($$$('::', 'NoMethodError'), \"\" + \"No block specified to process \" + (kind_name) + \" extension at \" + (block.$source_location()))\n            };\n            processor.$freeze();\n            \n            $writer = [name, $$($nesting, 'ProcessorExtension').$new(kind, processor)];\n            $send(kind_store, '[]=', Opal.to_a($writer));\n            return $writer[$rb_minus($writer[\"length\"], 1)];;\n          } else {\n            \n            $c = self.$resolve_args(args, 3), $b = Opal.to_ary($c), (processor = ($b[0] == null ? nil : $b[0])), (name = ($b[1] == null ? nil : $b[1])), (config = ($b[2] == null ? nil : $b[2])), $c;\n            if ($truthy((processor_class = $$($nesting, 'Extensions').$resolve_class(processor)))) {\n              \n              if ($truthy(($truthy($b = $rb_lt(processor_class, kind_class)) ? $b : ($truthy($c = kind_java_class) ? $rb_lt(processor_class, kind_java_class) : $c)))) {\n              } else {\n                self.$raise($$$('::', 'ArgumentError'), \"\" + \"Class specified for \" + (kind_name) + \" extension does not inherit from \" + (kind_class) + \": \" + (processor))\n              };\n              processor_instance = processor_class.$new(self.$as_symbol(name), config);\n              if ($truthy((name = self.$as_symbol(processor_instance.$name())))) {\n              } else {\n                self.$raise($$$('::', 'ArgumentError'), \"\" + \"No name specified for \" + (kind_name) + \" extension: \" + (processor))\n              };\n              processor_instance.$freeze();\n              \n              $writer = [name, $$($nesting, 'ProcessorExtension').$new(kind, processor_instance)];\n              $send(kind_store, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];;\n            } else if ($truthy(($truthy($b = kind_class['$==='](processor)) ? $b : ($truthy($c = kind_java_class) ? kind_java_class['$==='](processor) : $c)))) {\n              \n              processor.$update_config(config);\n              if ($truthy((name = (function() {if ($truthy(name)) {\n                \n                \n                $writer = [self.$as_symbol(name)];\n                $send(processor, 'name=', Opal.to_a($writer));\n                return $writer[$rb_minus($writer[\"length\"], 1)];;\n              } else {\n                \n                return self.$as_symbol(processor.$name());\n              }; return nil; })()))) {\n              } else {\n                self.$raise($$$('::', 'ArgumentError'), \"\" + \"No name specified for \" + (kind_name) + \" extension: \" + (processor))\n              };\n              processor.$freeze();\n              \n              $writer = [name, $$($nesting, 'ProcessorExtension').$new(kind, processor)];\n              $send(kind_store, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];;\n            } else {\n              return self.$raise($$$('::', 'ArgumentError'), \"\" + \"Invalid arguments specified for registering \" + (kind_name) + \" extension: \" + (args))\n            };\n          };\n        }, TMP_Registry_add_syntax_processor_82.$$arity = 2);\n        \n        Opal.def(self, '$resolve_args', TMP_Registry_resolve_args_84 = function $$resolve_args(args, expect) {\n          var self = this, opts = nil, missing = nil;\n\n          \n          opts = (function() {if ($truthy($$$('::', 'Hash')['$==='](args['$[]'](-1)))) {\n            return args.$pop()\n          } else {\n            return $hash2([], {})\n          }; return nil; })();\n          if (expect['$=='](1)) {\n            return opts};\n          if ($truthy($rb_gt((missing = $rb_minus($rb_minus(expect, 1), args.$size())), 0))) {\n            args = $rb_plus(args, $$$('::', 'Array').$new(missing))\n          } else if ($truthy($rb_lt(missing, 0))) {\n            args.$pop(missing['$-@']())};\n          args['$<<'](opts);\n          return args;\n        }, TMP_Registry_resolve_args_84.$$arity = 2);\n        return (Opal.def(self, '$as_symbol', TMP_Registry_as_symbol_85 = function $$as_symbol(name) {\n          var self = this;\n\n          if ($truthy(name)) {\n            return name.$to_sym()\n          } else {\n            return nil\n          }\n        }, TMP_Registry_as_symbol_85.$$arity = 1), nil) && 'as_symbol';\n      })($nesting[0], null, $nesting);\n      (function(self, $parent_nesting) {\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_generate_name_86, TMP_next_auto_id_87, TMP_groups_88, TMP_create_89, TMP_register_90, TMP_unregister_all_91, TMP_unregister_93, TMP_resolve_class_94, TMP_class_for_name_96;\n\n        \n        \n        Opal.def(self, '$generate_name', TMP_generate_name_86 = function $$generate_name() {\n          var self = this;\n\n          return \"\" + \"extgrp\" + (self.$next_auto_id())\n        }, TMP_generate_name_86.$$arity = 0);\n        \n        Opal.def(self, '$next_auto_id', TMP_next_auto_id_87 = function $$next_auto_id() {\n          var $a, self = this;\n          if (self.auto_id == null) self.auto_id = nil;\n\n          \n          self.auto_id = ($truthy($a = self.auto_id) ? $a : -1);\n          return (self.auto_id = $rb_plus(self.auto_id, 1));\n        }, TMP_next_auto_id_87.$$arity = 0);\n        \n        Opal.def(self, '$groups', TMP_groups_88 = function $$groups() {\n          var $a, self = this;\n          if (self.groups == null) self.groups = nil;\n\n          return (self.groups = ($truthy($a = self.groups) ? $a : $hash2([], {})))\n        }, TMP_groups_88.$$arity = 0);\n        \n        Opal.def(self, '$create', TMP_create_89 = function $$create(name) {\n          var $a, self = this, $iter = TMP_create_89.$$p, block = $iter || nil;\n\n          if (name == null) {\n            name = nil;\n          }\n          if ($iter) TMP_create_89.$$p = null;\n          if ((block !== nil)) {\n            return $$($nesting, 'Registry').$new($hash(($truthy($a = name) ? $a : self.$generate_name()), block))\n          } else {\n            return $$($nesting, 'Registry').$new()\n          }\n        }, TMP_create_89.$$arity = -1);\n        Opal.alias(self, \"build_registry\", \"create\");\n        \n        Opal.def(self, '$register', TMP_register_90 = function $$register($a_rest) {\n          var $b, self = this, args, $iter = TMP_register_90.$$p, block = $iter || nil, argc = nil, resolved_group = nil, group = nil, name = nil, $writer = nil;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          args = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            args[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          if ($iter) TMP_register_90.$$p = null;\n          \n          argc = args.$size();\n          if ((block !== nil)) {\n            resolved_group = block\n          } else if ($truthy((group = args.$pop()))) {\n            resolved_group = ($truthy($b = self.$resolve_class(group)) ? $b : group)\n          } else {\n            self.$raise($$$('::', 'ArgumentError'), \"Extension group to register not specified\")\n          };\n          name = ($truthy($b = args.$pop()) ? $b : self.$generate_name());\n          if ($truthy(args['$empty?']())) {\n          } else {\n            self.$raise($$$('::', 'ArgumentError'), \"\" + \"Wrong number of arguments (\" + (argc) + \" for 1..2)\")\n          };\n          \n          $writer = [name.$to_sym(), resolved_group];\n          $send(self.$groups(), '[]=', Opal.to_a($writer));\n          return $writer[$rb_minus($writer[\"length\"], 1)];;\n        }, TMP_register_90.$$arity = -1);\n        \n        Opal.def(self, '$unregister_all', TMP_unregister_all_91 = function $$unregister_all() {\n          var self = this;\n\n          \n          self.groups = $hash2([], {});\n          return nil;\n        }, TMP_unregister_all_91.$$arity = 0);\n        \n        Opal.def(self, '$unregister', TMP_unregister_93 = function $$unregister($a_rest) {\n          var TMP_92, self = this, names;\n\n          var $args_len = arguments.length, $rest_len = $args_len - 0;\n          if ($rest_len < 0) { $rest_len = 0; }\n          names = new Array($rest_len);\n          for (var $arg_idx = 0; $arg_idx < $args_len; $arg_idx++) {\n            names[$arg_idx - 0] = arguments[$arg_idx];\n          }\n          \n          $send(names, 'each', [], (TMP_92 = function(group){var self = TMP_92.$$s || this;\n            if (self.groups == null) self.groups = nil;\nif (group == null) group = nil;\n          return self.groups.$delete(group.$to_sym())}, TMP_92.$$s = self, TMP_92.$$arity = 1, TMP_92));\n          return nil;\n        }, TMP_unregister_93.$$arity = -1);\n        \n        Opal.def(self, '$resolve_class', TMP_resolve_class_94 = function $$resolve_class(object) {\n          var self = this, $case = nil;\n\n          return (function() {$case = object;\n          if ($$$('::', 'Class')['$===']($case)) {return object}\n          else if ($$$('::', 'String')['$===']($case)) {return self.$class_for_name(object)}\n          else { return nil }})()\n        }, TMP_resolve_class_94.$$arity = 1);\n        return (Opal.def(self, '$class_for_name', TMP_class_for_name_96 = function $$class_for_name(qualified_name) {\n          var TMP_95, self = this, resolved = nil;\n\n          \n          resolved = $$$('::', 'Object');\n          $send(qualified_name.$split(\"::\"), 'each', [], (TMP_95 = function(name){var self = TMP_95.$$s || this, $a, $b;\nif (name == null) name = nil;\n          if ($truthy(($truthy($a = name['$empty?']()) ? $a : ($truthy($b = resolved['$const_defined?'](name)) ? $$$('::', 'Module')['$===']((resolved = resolved.$const_get(name))) : $b)))) {\n              return nil\n            } else {\n              return self.$raise($$$('::', 'NameError'), \"\" + \"Could not resolve class for name: \" + (qualified_name))\n            }}, TMP_95.$$s = self, TMP_95.$$arity = 1, TMP_95));\n          if ($truthy($$$('::', 'Class')['$==='](resolved))) {\n          } else {\n            self.$raise($$$('::', 'NameError'), \"\" + \"Could not resolve class for name: \" + (qualified_name))\n          };\n          return resolved;\n        }, TMP_class_for_name_96.$$arity = 1), nil) && 'class_for_name';\n      })(Opal.get_singleton_class(self), $nesting);\n    })($nesting[0], $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/js/opal_ext/browser/reader\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;\n\n  Opal.add_stubs(['$posixify', '$new', '$base_dir', '$start_with?', '$uriish?', '$descends_from?', '$key?', '$attributes', '$replace_next_line', '$absolute_path?', '$==', '$empty?', '$!', '$slice', '$length']);\n  return (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n    (function($base, $super, $parent_nesting) {\n      function $PreprocessorReader(){};\n      var self = $PreprocessorReader = $klass($base, $super, 'PreprocessorReader', $PreprocessorReader);\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_PreprocessorReader_resolve_include_path_1;\n\n      def.path_resolver = def.document = def.include_stack = def.dir = nil;\n      return (Opal.def(self, '$resolve_include_path', TMP_PreprocessorReader_resolve_include_path_1 = function $$resolve_include_path(target, attrlist, attributes) {\n        var $a, self = this, p_target = nil, target_type = nil, base_dir = nil, inc_path = nil, relpath = nil, ctx_dir = nil, top_level = nil, offset = nil;\n\n        \n        p_target = (self.path_resolver = ($truthy($a = self.path_resolver) ? $a : $$($nesting, 'PathResolver').$new(\"\\\\\"))).$posixify(target);\n        $a = [\"file\", self.document.$base_dir()], (target_type = $a[0]), (base_dir = $a[1]), $a;\n        if ($truthy(p_target['$start_with?'](\"file://\"))) {\n          inc_path = (relpath = p_target)\n        } else if ($truthy($$($nesting, 'Helpers')['$uriish?'](p_target))) {\n          \n          if ($truthy(($truthy($a = self.path_resolver['$descends_from?'](p_target, base_dir)) ? $a : self.document.$attributes()['$key?'](\"allow-uri-read\")))) {\n          } else {\n            return self.$replace_next_line(\"\" + \"link:\" + (target) + \"[\" + (attrlist) + \"]\")\n          };\n          inc_path = (relpath = p_target);\n        } else if ($truthy(self.path_resolver['$absolute_path?'](p_target))) {\n          inc_path = (relpath = \"\" + \"file://\" + ((function() {if ($truthy(p_target['$start_with?'](\"/\"))) {\n            return \"\"\n          } else {\n            return \"/\"\n          }; return nil; })()) + (p_target))\n        } else if ((ctx_dir = (function() {if ($truthy((top_level = self.include_stack['$empty?']()))) {\n          return base_dir\n        } else {\n          return self.dir\n        }; return nil; })())['$=='](\".\")) {\n          inc_path = (relpath = p_target)\n        } else if ($truthy(($truthy($a = ctx_dir['$start_with?'](\"file://\")) ? $a : $$($nesting, 'Helpers')['$uriish?'](ctx_dir)['$!']()))) {\n          \n          inc_path = \"\" + (ctx_dir) + \"/\" + (p_target);\n          if ($truthy(top_level)) {\n            relpath = p_target\n          } else if ($truthy(($truthy($a = base_dir['$=='](\".\")) ? $a : (offset = self.path_resolver['$descends_from?'](inc_path, base_dir))['$!']()))) {\n            relpath = inc_path\n          } else {\n            relpath = inc_path.$slice(offset, inc_path.$length())\n          };\n        } else if ($truthy(top_level)) {\n          inc_path = \"\" + (ctx_dir) + \"/\" + ((relpath = p_target))\n        } else if ($truthy(($truthy($a = (offset = self.path_resolver['$descends_from?'](ctx_dir, base_dir))) ? $a : self.document.$attributes()['$key?'](\"allow-uri-read\")))) {\n          \n          inc_path = \"\" + (ctx_dir) + \"/\" + (p_target);\n          relpath = (function() {if ($truthy(offset)) {\n            \n            return inc_path.$slice(offset, inc_path.$length());\n          } else {\n            return p_target\n          }; return nil; })();\n        } else {\n          return self.$replace_next_line(\"\" + \"link:\" + (target) + \"[\" + (attrlist) + \"]\")\n        };\n        return [inc_path, \"file\", relpath];\n      }, TMP_PreprocessorReader_resolve_include_path_1.$$arity = 3), nil) && 'resolve_include_path'\n    })($nesting[0], $$($nesting, 'Reader'), $nesting)\n  })($nesting[0], $nesting)\n};\n\n/* Generated by Opal 0.11.1.dev */\nOpal.modules[\"asciidoctor/js/postscript\"] = function(Opal) {\n  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;\n\n  Opal.add_stubs(['$require', '$==']);\n  \n  self.$require(\"asciidoctor/converter/composite\");\n  self.$require(\"asciidoctor/converter/html5\");\n  self.$require(\"asciidoctor/extensions\");\n  if ($$($nesting, 'JAVASCRIPT_IO_MODULE')['$=='](\"xmlhttprequest\")) {\n    return self.$require(\"asciidoctor/js/opal_ext/browser/reader\")\n  } else {\n    return nil\n  };\n};\n\n/* Generated by Opal 0.11.1.dev */\n(function(Opal) {\n  function $rb_ge(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);\n  }\n  function $rb_minus(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);\n  }\n  function $rb_times(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);\n  }\n  function $rb_lt(lhs, rhs) {\n    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);\n  }\n  var $a, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $truthy = Opal.truthy, $gvars = Opal.gvars, $module = Opal.module, $hash2 = Opal.hash2, $send = Opal.send, $hash = Opal.hash;\n  if ($gvars[\":\"] == null) $gvars[\":\"] = nil;\n\n  Opal.add_stubs(['$==', '$>=', '$require', '$unshift', '$dirname', '$each', '$constants', '$const_get', '$downcase', '$to_s', '$[]=', '$-', '$upcase', '$[]', '$values', '$new', '$attr_reader', '$instance_variable_set', '$send', '$<<', '$define', '$expand_path', '$join', '$home', '$pwd', '$!', '$!=', '$default_external', '$to_set', '$map', '$keys', '$slice', '$merge', '$inject', '$*', '$to_a', '$dup', '$insert', '$start', '$===', '$split', '$gsub', '$respond_to?', '$raise', '$ancestors', '$class', '$path', '$utc', '$at', '$Integer', '$mtime', '$readlines', '$basename', '$extname', '$index', '$strftime', '$year', '$rewind', '$lines', '$each_line', '$record', '$parse', '$exception', '$message', '$set_backtrace', '$backtrace', '$stack_trace', '$stack_trace=', '$open', '$load', '$delete', '$key?', '$attributes', '$outfilesuffix', '$safe', '$normalize_system_path', '$directory?', '$mkdir_p', '$convert', '$write', '$<', '$attr?', '$attr', '$uriish?', '$include?', '$write_primary_stylesheet', '$instance', '$empty?', '$read_asset', '$file?', '$write_coderay_stylesheet', '$write_pygments_stylesheet']);\n  \n  if ($truthy((($a = $$($nesting, 'RUBY_ENGINE', 'skip_raise')) ? 'constant' : nil))) {\n  } else {\n    Opal.const_set($nesting[0], 'RUBY_ENGINE', \"unknown\")\n  };\n  Opal.const_set($nesting[0], 'RUBY_ENGINE_OPAL', $$($nesting, 'RUBY_ENGINE')['$=='](\"opal\"));\n  Opal.const_set($nesting[0], 'RUBY_ENGINE_JRUBY', $$($nesting, 'RUBY_ENGINE')['$=='](\"jruby\"));\n  Opal.const_set($nesting[0], 'RUBY_MIN_VERSION_1_9', $rb_ge($$($nesting, 'RUBY_VERSION'), \"1.9\"));\n  Opal.const_set($nesting[0], 'RUBY_MIN_VERSION_2', $rb_ge($$($nesting, 'RUBY_VERSION'), \"2\"));\n  self.$require(\"set\");\n  if ($$($nesting, 'RUBY_ENGINE')['$=='](\"opal\")) {\n    self.$require(\"asciidoctor/js\")\n  } else {\n    nil\n  };\n  $gvars[\":\"].$unshift($$($nesting, 'File').$dirname(\"asciidoctor\"));\n  (function($base, $parent_nesting) {\n    var $Asciidoctor, self = $Asciidoctor = $module($base, 'Asciidoctor');\n\n    var def = self.$$proto, $nesting = [self].concat($parent_nesting), $a, TMP_Asciidoctor_6, TMP_Asciidoctor_7, quote_subs = nil, compat_quote_subs = nil, $writer = nil;\n\n    \n    Opal.const_set($nesting[0], 'RUBY_ENGINE', $$$('::', 'RUBY_ENGINE'));\n    (function($base, $parent_nesting) {\n      var $SafeMode, self = $SafeMode = $module($base, 'SafeMode');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_SafeMode_1, TMP_SafeMode_value_for_name_2, TMP_SafeMode_name_for_value_3, TMP_SafeMode_names_4, rec = nil;\n\n      \n      Opal.const_set($nesting[0], 'UNSAFE', 0);\n      Opal.const_set($nesting[0], 'SAFE', 1);\n      Opal.const_set($nesting[0], 'SERVER', 10);\n      Opal.const_set($nesting[0], 'SECURE', 20);\n      rec = $hash2([], {});\n      $send((Opal.Module.$$nesting = $nesting, self.$constants()), 'each', [], (TMP_SafeMode_1 = function(sym){var self = TMP_SafeMode_1.$$s || this, $writer = nil;\nif (sym == null) sym = nil;\n      \n        $writer = [self.$const_get(sym), sym.$to_s().$downcase()];\n        $send(rec, '[]=', Opal.to_a($writer));\n        return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_SafeMode_1.$$s = self, TMP_SafeMode_1.$$arity = 1, TMP_SafeMode_1));\n      self.names_by_value = rec;\n      Opal.defs(self, '$value_for_name', TMP_SafeMode_value_for_name_2 = function $$value_for_name(name) {\n        var self = this;\n\n        return self.$const_get(name.$upcase())\n      }, TMP_SafeMode_value_for_name_2.$$arity = 1);\n      Opal.defs(self, '$name_for_value', TMP_SafeMode_name_for_value_3 = function $$name_for_value(value) {\n        var self = this;\n        if (self.names_by_value == null) self.names_by_value = nil;\n\n        return self.names_by_value['$[]'](value)\n      }, TMP_SafeMode_name_for_value_3.$$arity = 1);\n      Opal.defs(self, '$names', TMP_SafeMode_names_4 = function $$names() {\n        var self = this;\n        if (self.names_by_value == null) self.names_by_value = nil;\n\n        return self.names_by_value.$values()\n      }, TMP_SafeMode_names_4.$$arity = 0);\n    })($nesting[0], $nesting);\n    (function($base, $parent_nesting) {\n      var $Compliance, self = $Compliance = $module($base, 'Compliance');\n\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_Compliance_define_5;\n\n      \n      self.keys = $$$('::', 'Set').$new();\n      (function(self, $parent_nesting) {\n        var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n        return self.$attr_reader(\"keys\")\n      })(Opal.get_singleton_class(self), $nesting);\n      Opal.defs(self, '$define', TMP_Compliance_define_5 = function $$define(key, value) {\n        var self = this;\n        if (self.keys == null) self.keys = nil;\n\n        \n        self.$instance_variable_set(\"\" + \"@\" + (key), value);\n        (function(self, $parent_nesting) {\n          var def = self.$$proto, $nesting = [self].concat($parent_nesting);\n\n          return self\n        })(Opal.get_singleton_class(self), $nesting).$send(\"attr_accessor\", key);\n        self.keys['$<<'](key);\n        return nil;\n      }, TMP_Compliance_define_5.$$arity = 2);\n      self.$define(\"block_terminates_paragraph\", true);\n      self.$define(\"strict_verbatim_paragraphs\", true);\n      self.$define(\"underline_style_section_titles\", true);\n      self.$define(\"unwrap_standalone_preamble\", true);\n      self.$define(\"attribute_missing\", \"skip\");\n      self.$define(\"attribute_undefined\", \"drop-line\");\n      self.$define(\"shorthand_property_syntax\", true);\n      self.$define(\"unique_id_start_index\", 2);\n      self.$define(\"markdown_syntax\", true);\n    })($nesting[0], $nesting);\n    Opal.const_set($nesting[0], 'ROOT_PATH', $$$('::', 'File').$dirname($$$('::', 'File').$dirname($$$('::', 'File').$expand_path(\"asciidoctor\"))));\n    Opal.const_set($nesting[0], 'DATA_PATH', $$$('::', 'File').$join($$($nesting, 'ROOT_PATH'), \"data\"));\n    \n    try {\n      Opal.const_set($nesting[0], 'USER_HOME', $$$('::', 'Dir').$home())\n    } catch ($err) {\n      if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {\n        try {\n          Opal.const_set($nesting[0], 'USER_HOME', ($truthy($a = $$$('::', 'ENV')['$[]'](\"HOME\")) ? $a : $$$('::', 'Dir').$pwd()))\n        } finally { Opal.pop_exception() }\n      } else { throw $err; }\n    };;\n    Opal.const_set($nesting[0], 'COERCE_ENCODING', ($truthy($a = $$$('::', 'RUBY_ENGINE_OPAL')['$!']()) ? $$$('::', 'RUBY_MIN_VERSION_1_9') : $a));\n    Opal.const_set($nesting[0], 'FORCE_ENCODING', ($truthy($a = $$($nesting, 'COERCE_ENCODING')) ? $$$('::', 'Encoding').$default_external()['$!=']($$$($$$('::', 'Encoding'), 'UTF_8')) : $a));\n    Opal.const_set($nesting[0], 'BOM_BYTES_UTF_8', [239, 187, 191]);\n    Opal.const_set($nesting[0], 'BOM_BYTES_UTF_16LE', [255, 254]);\n    Opal.const_set($nesting[0], 'BOM_BYTES_UTF_16BE', [254, 255]);\n    Opal.const_set($nesting[0], 'FORCE_UNICODE_LINE_LENGTH', $$$('::', 'RUBY_MIN_VERSION_1_9')['$!']());\n    Opal.const_set($nesting[0], 'LF', Opal.const_set($nesting[0], 'EOL', \"\\n\"));\n    Opal.const_set($nesting[0], 'NULL', \"\\u0000\");\n    Opal.const_set($nesting[0], 'TAB', \"\\t\");\n    Opal.const_set($nesting[0], 'DEFAULT_DOCTYPE', \"article\");\n    Opal.const_set($nesting[0], 'DEFAULT_BACKEND', \"html5\");\n    Opal.const_set($nesting[0], 'DEFAULT_STYLESHEET_KEYS', [\"\", \"DEFAULT\"].$to_set());\n    Opal.const_set($nesting[0], 'DEFAULT_STYLESHEET_NAME', \"asciidoctor.css\");\n    Opal.const_set($nesting[0], 'BACKEND_ALIASES', $hash2([\"html\", \"docbook\"], {\"html\": \"html5\", \"docbook\": \"docbook5\"}));\n    Opal.const_set($nesting[0], 'DEFAULT_PAGE_WIDTHS', $hash2([\"docbook\"], {\"docbook\": 425}));\n    Opal.const_set($nesting[0], 'DEFAULT_EXTENSIONS', $hash2([\"html\", \"docbook\", \"pdf\", \"epub\", \"manpage\", \"asciidoc\"], {\"html\": \".html\", \"docbook\": \".xml\", \"pdf\": \".pdf\", \"epub\": \".epub\", \"manpage\": \".man\", \"asciidoc\": \".adoc\"}));\n    Opal.const_set($nesting[0], 'ASCIIDOC_EXTENSIONS', $hash2([\".asciidoc\", \".adoc\", \".ad\", \".asc\", \".txt\"], {\".asciidoc\": true, \".adoc\": true, \".ad\": true, \".asc\": true, \".txt\": true}));\n    Opal.const_set($nesting[0], 'SETEXT_SECTION_LEVELS', $hash2([\"=\", \"-\", \"~\", \"^\", \"+\"], {\"=\": 0, \"-\": 1, \"~\": 2, \"^\": 3, \"+\": 4}));\n    Opal.const_set($nesting[0], 'ADMONITION_STYLES', [\"NOTE\", \"TIP\", \"IMPORTANT\", \"WARNING\", \"CAUTION\"].$to_set());\n    Opal.const_set($nesting[0], 'ADMONITION_STYLE_HEADS', [\"N\", \"T\", \"I\", \"W\", \"C\"].$to_set());\n    Opal.const_set($nesting[0], 'CALLOUT_LIST_HEADS', [\"<\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"0\"].$to_set());\n    Opal.const_set($nesting[0], 'PARAGRAPH_STYLES', [\"comment\", \"example\", \"literal\", \"listing\", \"normal\", \"pass\", \"quote\", \"sidebar\", \"source\", \"verse\", \"abstract\", \"partintro\"].$to_set());\n    Opal.const_set($nesting[0], 'VERBATIM_STYLES', [\"literal\", \"listing\", \"source\", \"verse\"].$to_set());\n    Opal.const_set($nesting[0], 'DELIMITED_BLOCKS', $hash2([\"--\", \"----\", \"....\", \"====\", \"****\", \"____\", \"\\\"\\\"\", \"++++\", \"|===\", \",===\", \":===\", \"!===\", \"////\", \"```\"], {\"--\": [\"open\", [\"comment\", \"example\", \"literal\", \"listing\", \"pass\", \"quote\", \"sidebar\", \"source\", \"verse\", \"admonition\", \"abstract\", \"partintro\"].$to_set()], \"----\": [\"listing\", [\"literal\", \"source\"].$to_set()], \"....\": [\"literal\", [\"listing\", \"source\"].$to_set()], \"====\": [\"example\", [\"admonition\"].$to_set()], \"****\": [\"sidebar\", $$$('::', 'Set').$new()], \"____\": [\"quote\", [\"verse\"].$to_set()], \"\\\"\\\"\": [\"quote\", [\"verse\"].$to_set()], \"++++\": [\"pass\", [\"stem\", \"latexmath\", \"asciimath\"].$to_set()], \"|===\": [\"table\", $$$('::', 'Set').$new()], \",===\": [\"table\", $$$('::', 'Set').$new()], \":===\": [\"table\", $$$('::', 'Set').$new()], \"!===\": [\"table\", $$$('::', 'Set').$new()], \"////\": [\"comment\", $$$('::', 'Set').$new()], \"```\": [\"fenced_code\", $$$('::', 'Set').$new()]}));\n    Opal.const_set($nesting[0], 'DELIMITED_BLOCK_HEADS', $send($$($nesting, 'DELIMITED_BLOCKS').$keys(), 'map', [], (TMP_Asciidoctor_6 = function(key){var self = TMP_Asciidoctor_6.$$s || this;\nif (key == null) key = nil;\n    return key.$slice(0, 2)}, TMP_Asciidoctor_6.$$s = self, TMP_Asciidoctor_6.$$arity = 1, TMP_Asciidoctor_6)).$to_set());\n    Opal.const_set($nesting[0], 'LAYOUT_BREAK_CHARS', $hash2([\"'\", \"<\"], {\"'\": \"thematic_break\", \"<\": \"page_break\"}));\n    Opal.const_set($nesting[0], 'MARKDOWN_THEMATIC_BREAK_CHARS', $hash2([\"-\", \"*\", \"_\"], {\"-\": \"thematic_break\", \"*\": \"thematic_break\", \"_\": \"thematic_break\"}));\n    Opal.const_set($nesting[0], 'HYBRID_LAYOUT_BREAK_CHARS', $$($nesting, 'LAYOUT_BREAK_CHARS').$merge($$($nesting, 'MARKDOWN_THEMATIC_BREAK_CHARS')));\n    Opal.const_set($nesting[0], 'NESTABLE_LIST_CONTEXTS', [\"ulist\", \"olist\", \"dlist\"]);\n    Opal.const_set($nesting[0], 'ORDERED_LIST_STYLES', [\"arabic\", \"loweralpha\", \"lowerroman\", \"upperalpha\", \"upperroman\"]);\n    Opal.const_set($nesting[0], 'ORDERED_LIST_KEYWORDS', $hash2([\"loweralpha\", \"lowerroman\", \"upperalpha\", \"upperroman\"], {\"loweralpha\": \"a\", \"lowerroman\": \"i\", \"upperalpha\": \"A\", \"upperroman\": \"I\"}));\n    Opal.const_set($nesting[0], 'ATTR_REF_HEAD', \"{\");\n    Opal.const_set($nesting[0], 'LIST_CONTINUATION', \"+\");\n    Opal.const_set($nesting[0], 'HARD_LINE_BREAK', \" +\");\n    Opal.const_set($nesting[0], 'LINE_CONTINUATION', \" \\\\\");\n    Opal.const_set($nesting[0], 'LINE_CONTINUATION_LEGACY', \" +\");\n    Opal.const_set($nesting[0], 'BLOCK_MATH_DELIMITERS', $hash2([\"asciimath\", \"latexmath\"], {\"asciimath\": [\"\\\\$\", \"\\\\$\"], \"latexmath\": [\"\\\\[\", \"\\\\]\"]}));\n    Opal.const_set($nesting[0], 'INLINE_MATH_DELIMITERS', $hash2([\"asciimath\", \"latexmath\"], {\"asciimath\": [\"\\\\$\", \"\\\\$\"], \"latexmath\": [\"\\\\(\", \"\\\\)\"]}));\n    Opal.const_set($nesting[0], 'FLEXIBLE_ATTRIBUTES', [\"sectnums\"]);\n    Opal.const_set($nesting[0], 'CIRCUMFIX_COMMENTS', $send($hash([\"/*\", \"*/\"], [\".css\"], [\"(*\", \"*)\"], [\".ml\", \".mli\", \".nb\"], [\"<!--\", \"-->\"], [\".html\", \".xhtml\", \".xml\", \".xsl\"], [\"<%--\", \"--%>\"], [\".asp\", \".jsp\"]), 'inject', [$hash2([], {})], (TMP_Asciidoctor_7 = function(accum, $b){var self = TMP_Asciidoctor_7.$$s || this, $b_args, affixes, exts, TMP_8;\n\n      if ($b == null) {\n        $b = nil;\n      }\n      $b = Opal.to_ary($b);\n      $b_args = Opal.slice.call($b, 0, $b.length);\n      affixes = $b_args.splice(0,1)[0];\n      if (affixes == null) {\n        affixes = nil;\n      }\n      exts = $b_args.splice(0,1)[0];\n      if (exts == null) {\n        exts = nil;\n      }if (accum == null) accum = nil;\n    \n      $send(exts, 'each', [], (TMP_8 = function(ext){var self = TMP_8.$$s || this, $writer = nil;\nif (ext == null) ext = nil;\n      \n        $writer = [ext, $hash2([\"prefix\", \"suffix\"], {\"prefix\": affixes['$[]'](0), \"suffix\": affixes['$[]'](-1)})];\n        $send(accum, '[]=', Opal.to_a($writer));\n        return $writer[$rb_minus($writer[\"length\"], 1)];}, TMP_8.$$s = self, TMP_8.$$arity = 1, TMP_8));\n      return accum;}, TMP_Asciidoctor_7.$$s = self, TMP_Asciidoctor_7.$$arity = 2, TMP_Asciidoctor_7.$$has_top_level_mlhs_arg = true, TMP_Asciidoctor_7)));\n    if ($$($nesting, 'RUBY_ENGINE')['$=='](\"opal\")) {\n    } else {\n      nil\n    };\n    Opal.const_set($nesting[0], 'AuthorInfoLineRx', new RegExp(\"\" + \"^(\" + ($$($nesting, 'CG_WORD')) + \"[\" + ($$($nesting, 'CC_WORD')) + \"\\\\-'.]*)(?: +(\" + ($$($nesting, 'CG_WORD')) + \"[\" + ($$($nesting, 'CC_WORD')) + \"\\\\-'.]*))?(?: +(\" + ($$($nesting, 'CG_WORD')) + \"[\" + ($$($nesting, 'CC_WORD')) + \"\\\\-'.]*))?(?: +<([^>]+)>)?$\"));\n    Opal.const_set($nesting[0], 'RevisionInfoLineRx', /^(?:\\D*([^\\n]*?),)? *(?!:)([^\\n]*?)(?: *(?!^),?: *([^\\n]*))?$/);\n    Opal.const_set($nesting[0], 'ManpageTitleVolnumRx', /^([^\\n]+?) *\\( *([^\\n]+?) *\\)$/);\n    Opal.const_set($nesting[0], 'ManpageNamePurposeRx', /^([^\\n]+?) +- +([^\\n]+)$/);\n    Opal.const_set($nesting[0], 'ConditionalDirectiveRx', /^(\\\\)?(ifdef|ifndef|ifeval|endif)::(\\S*?(?:([,+])\\S*?)?)\\[([^\\n]+)?\\]$/);\n    Opal.const_set($nesting[0], 'EvalExpressionRx', /^([^\\n]+?) *([=!><]=|[><]) *([^\\n]+)$/);\n    Opal.const_set($nesting[0], 'IncludeDirectiveRx', /^(\\\\)?include::([^\\[][^\\[]*)\\[([^\\n]*)\\]$/);\n    Opal.const_set($nesting[0], 'TagDirectiveRx', /\\b(?:tag|(end))::(\\S+)\\[\\]$/);\n    Opal.const_set($nesting[0], 'AttributeEntryRx', /^:(!?\\w[^\\n]*?):(?:[ \\t]+([^\\n]*))?$/);\n    Opal.const_set($nesting[0], 'InvalidAttributeNameCharsRx', /[^\\w\\-]/);\n    if ($$($nesting, 'RUBY_ENGINE')['$=='](\"opal\")) {\n      Opal.const_set($nesting[0], 'AttributeEntryPassMacroRx', /^pass:([a-z]+(?:,[a-z]+)*)?\\[([\\S\\s]*)\\]$/)\n    } else {\n      nil\n    };\n    Opal.const_set($nesting[0], 'AttributeReferenceRx', /(\\\\)?\\{(\\w+[-\\w]*|(set|counter2?):[^\\n]+?)(\\\\)?\\}/);\n    Opal.const_set($nesting[0], 'BlockAnchorRx', new RegExp(\"\" + \"^\\\\[\\\\[(?:|([\" + ($$($nesting, 'CC_ALPHA')) + \"_:][\" + ($$($nesting, 'CC_WORD')) + \":.-]*)(?:, *(.+))?)\\\\]\\\\]$\"));\n    Opal.const_set($nesting[0], 'BlockAttributeListRx', new RegExp(\"\" + \"^\\\\[(|[\" + ($$($nesting, 'CC_WORD')) + \".#%{,\\\"'].*)\\\\]$\"));\n    Opal.const_set($nesting[0], 'BlockAttributeLineRx', new RegExp(\"\" + \"^\\\\[(?:|[\" + ($$($nesting, 'CC_WORD')) + \".#%{,\\\"'].*|\\\\[(?:|[\" + ($$($nesting, 'CC_ALPHA')) + \"_:][\" + ($$($nesting, 'CC_WORD')) + \":.-]*(?:, *.+)?)\\\\])\\\\]$\"));\n    Opal.const_set($nesting[0], 'BlockTitleRx', /^\\.([^ \\t.][^\\n]*)$/);\n    Opal.const_set($nesting[0], 'AdmonitionParagraphRx', new RegExp(\"\" + \"^(\" + ($rb_times($$($nesting, 'ADMONITION_STYLES').$to_a(), \"|\")) + \"):[ \\\\t]+\"));\n    Opal.const_set($nesting[0], 'LiteralParagraphRx', /^([ \\t]+[^\\n]*)$/);\n    Opal.const_set($nesting[0], 'AtxSectionTitleRx', /^(=={0,5})[ \\t]+([^\\n]+?)(?:[ \\t]+\\1)?$/);\n    Opal.const_set($nesting[0], 'ExtAtxSectionTitleRx', /^(=={0,5}|#\\#{0,5})[ \\t]+([^\\n]+?)(?:[ \\t]+\\1)?$/);\n    Opal.const_set($nesting[0], 'SetextSectionTitleRx', new RegExp(\"\" + \"^((?=.*\" + ($$($nesting, 'CG_WORD')) + \"+.*)[^.].*?)$\"));\n    Opal.const_set($nesting[0], 'InlineSectionAnchorRx', new RegExp(\"\" + \" (\\\\\\\\)?\\\\[\\\\[([\" + ($$($nesting, 'CC_ALPHA')) + \"_:][\" + ($$($nesting, 'CC_WORD')) + \":.-]*)(?:, *(.+))?\\\\]\\\\]$\"));\n    Opal.const_set($nesting[0], 'InvalidSectionIdCharsRx', new RegExp(\"\" + \"&(?:[a-z][a-z]+\\\\d{0,2}|#\\\\d\\\\d\\\\d{0,4}|#x[\\\\da-f][\\\\da-f][\\\\da-f]{0,3});|[^\" + ($$($nesting, 'CC_WORD')) + \"]+?\"));\n    Opal.const_set($nesting[0], 'DiscreteHeadingStyleRx', /^(?:discrete|float)\\b/);\n    Opal.const_set($nesting[0], 'AnyListRx', /^(?:[ \\t]*(?:-|\\*\\*{0,4}|\\.\\.{0,4}|\\u2022\\u2022{0,4}|\\d+\\.|[a-zA-Z]\\.|[IVXivx]+\\))[ \\t]|[ \\t]*[^\\n]*?(?::{2,4}|;;)(?:$|[ \\t])|<?\\d+>[ \\t])/);\n    Opal.const_set($nesting[0], 'UnorderedListRx', /^[ \\t]*(-|\\*\\*{0,4}|\\u2022\\u2022{0,4})[ \\t]+([^\\n]*)$/);\n    Opal.const_set($nesting[0], 'OrderedListRx', /^[ \\t]*(\\.\\.{0,4}|\\d+\\.|[a-zA-Z]\\.|[IVXivx]+\\))[ \\t]+([^\\n]*)$/);\n    Opal.const_set($nesting[0], 'OrderedListMarkerRxMap', $hash2([\"arabic\", \"loweralpha\", \"lowerroman\", \"upperalpha\", \"upperroman\"], {\"arabic\": /\\d+\\./, \"loweralpha\": /[a-z]\\./, \"lowerroman\": /[ivx]+\\)/, \"upperalpha\": /[A-Z]\\./, \"upperroman\": /[IVX]+\\)/}));\n    Opal.const_set($nesting[0], 'DescriptionListRx', /^(?!\\/\\/)[ \\t]*([^\\n]*?)(:{2,4}|;;)(?:[ \\t]+([^\\n]*))?$/);\n    Opal.const_set($nesting[0], 'DescriptionListSiblingRx', $hash2([\"::\", \":::\", \"::::\", \";;\"], {\"::\": /^(?!\\/\\/)[ \\t]*((?:.*[^:])?)(::)(?:[ \\t]+(.*))?$/, \":::\": /^(?!\\/\\/)[ \\t]*((?:.*[^:])?)(:::)(?:[ \\t]+(.*))?$/, \"::::\": /^(?!\\/\\/)[ \\t]*((?:.*[^:])?)(::::)(?:[ \\t]+(.*))?$/, \";;\": /^(?!\\/\\/)[ \\t]*(.*)(;;)(?:[ \\t]+(.*))?$/}));\n    Opal.const_set($nesting[0], 'CalloutListRx', /^<?(\\d+)>[ \\t]+([^\\n]*)$/);\n    Opal.const_set($nesting[0], 'CalloutListSniffRx', /^<?\\d+>/);\n    Opal.const_set($nesting[0], 'CalloutExtractRx', /(?:(?:\\/\\/|#|--|;;) ?)?(\\\\)?<!?(|--)(\\d+)\\2>(?=(?: ?\\\\?<!?\\2\\d+\\2>)*$)/);\n    Opal.const_set($nesting[0], 'CalloutExtractRxt', \"(\\\\\\\\)?<()(\\\\d+)>(?=(?: ?\\\\\\\\?<\\\\d+>)*$)\");\n    Opal.const_set($nesting[0], 'CalloutScanRx', new RegExp(\"\" + \"\\\\\\\\?<!?(|--)(\\\\d+)\\\\1>(?=(?: ?\\\\\\\\?<!?\\\\1\\\\d+\\\\1>)*\" + ($$($nesting, 'CC_EOL')) + \")\"));\n    Opal.const_set($nesting[0], 'CalloutSourceRx', new RegExp(\"\" + \"(?:(?://|#|--|;;) ?)?(\\\\\\\\)?&lt;!?(|--)(\\\\d+)\\\\2&gt;(?=(?: ?\\\\\\\\?&lt;!?\\\\2\\\\d+\\\\2&gt;)*\" + ($$($nesting, 'CC_EOL')) + \")\"));\n    Opal.const_set($nesting[0], 'CalloutSourceRxt', \"\" + \"(\\\\\\\\)?&lt;()(\\\\d+)&gt;(?=(?: ?\\\\\\\\?&lt;\\\\d+&gt;)*\" + ($$($nesting, 'CC_EOL')) + \")\");\n    Opal.const_set($nesting[0], 'ListRxMap', $hash2([\"ulist\", \"olist\", \"dlist\", \"colist\"], {\"ulist\": $$($nesting, 'UnorderedListRx'), \"olist\": $$($nesting, 'OrderedListRx'), \"dlist\": $$($nesting, 'DescriptionListRx'), \"colist\": $$($nesting, 'CalloutListRx')}));\n    Opal.const_set($nesting[0], 'ColumnSpecRx', /^(?:(\\d+)\\*)?([<^>](?:\\.[<^>]?)?|(?:[<^>]?\\.)?[<^>])?(\\d+%?)?([a-z])?$/);\n    Opal.const_set($nesting[0], 'CellSpecStartRx', /^[ \\t]*(?:(\\d+(?:\\.\\d*)?|(?:\\d*\\.)?\\d+)([*+]))?([<^>](?:\\.[<^>]?)?|(?:[<^>]?\\.)?[<^>])?([a-z])?$/);\n    Opal.const_set($nesting[0], 'CellSpecEndRx', /[ \\t]+(?:(\\d+(?:\\.\\d*)?|(?:\\d*\\.)?\\d+)([*+]))?([<^>](?:\\.[<^>]?)?|(?:[<^>]?\\.)?[<^>])?([a-z])?$/);\n    Opal.const_set($nesting[0], 'CustomBlockMacroRx', new RegExp(\"\" + \"^(\" + ($$($nesting, 'CG_WORD')) + \"+)::(|\\\\S|\\\\S.*?\\\\S)\\\\[(.*)\\\\]$\"));\n    Opal.const_set($nesting[0], 'BlockMediaMacroRx', /^(image|video|audio)::(\\S|\\S[^\\n]*?\\S)\\[([^\\n]*)\\]$/);\n    Opal.const_set($nesting[0], 'BlockTocMacroRx', /^toc::\\[([^\\n]*)\\]$/);\n    Opal.const_set($nesting[0], 'InlineAnchorRx', new RegExp(\"\" + \"(\\\\\\\\)?(?:\\\\[\\\\[([\" + ($$($nesting, 'CC_ALPHA')) + \"_:][\" + ($$($nesting, 'CC_WORD')) + \":.-]*)(?:, *(.+?))?\\\\]\\\\]|anchor:([\" + ($$($nesting, 'CC_ALPHA')) + \"_:][\" + ($$($nesting, 'CC_WORD')) + \":.-]*)\\\\[(?:\\\\]|(.*?[^\\\\\\\\])\\\\]))\"));\n    Opal.const_set($nesting[0], 'InlineAnchorScanRx', new RegExp(\"\" + \"(?:^|[^\\\\\\\\\\\\[])\\\\[\\\\[([\" + ($$($nesting, 'CC_ALPHA')) + \"_:][\" + ($$($nesting, 'CC_WORD')) + \":.-]*)(?:, *(.+?))?\\\\]\\\\]|(?:^|[^\\\\\\\\])anchor:([\" + ($$($nesting, 'CC_ALPHA')) + \"_:][\" + ($$($nesting, 'CC_WORD')) + \":.-]*)\\\\[(?:\\\\]|(.*?[^\\\\\\\\])\\\\])\"));\n    Opal.const_set($nesting[0], 'InlineBiblioAnchorRx', new RegExp(\"\" + \"^\\\\[\\\\[\\\\[([\" + ($$($nesting, 'CC_ALPHA')) + \"_:][\" + ($$($nesting, 'CC_WORD')) + \":.-]*)(?:, *(.+?))?\\\\]\\\\]\\\\]\"));\n    Opal.const_set($nesting[0], 'EmailInlineRx', new RegExp(\"\" + \"([\\\\\\\\>:/])?\" + ($$($nesting, 'CG_WORD')) + \"[\" + ($$($nesting, 'CC_WORD')) + \".%+-]*@\" + ($$($nesting, 'CG_ALNUM')) + \"[\" + ($$($nesting, 'CC_ALNUM')) + \".-]*\\\\.\" + ($$($nesting, 'CG_ALPHA')) + \"{2,4}\\\\b\"));\n    Opal.const_set($nesting[0], 'InlineFootnoteMacroRx', new RegExp(\"\" + \"\\\\\\\\?(footnote(?:ref)?):\\\\[(\" + ($$($nesting, 'CC_ALL')) + \"*?[^\\\\\\\\])\\\\]\", 'm'));\n    Opal.const_set($nesting[0], 'InlineImageMacroRx', new RegExp(\"\" + \"\\\\\\\\?i(?:mage|con):([^:\\\\s\\\\[](?:[^\\\\n\\\\[]*[^\\\\s\\\\[])?)\\\\[(|\" + ($$($nesting, 'CC_ALL')) + \"*?[^\\\\\\\\])\\\\]\", 'm'));\n    Opal.const_set($nesting[0], 'InlineIndextermMacroRx', new RegExp(\"\" + \"\\\\\\\\?(?:(indexterm2?):\\\\[(\" + ($$($nesting, 'CC_ALL')) + \"*?[^\\\\\\\\])\\\\]|\\\\(\\\\((\" + ($$($nesting, 'CC_ALL')) + \"+?)\\\\)\\\\)(?!\\\\)))\", 'm'));\n    Opal.const_set($nesting[0], 'InlineKbdBtnMacroRx', new RegExp(\"\" + \"(\\\\\\\\)?(kbd|btn):\\\\[(\" + ($$($nesting, 'CC_ALL')) + \"*?[^\\\\\\\\])\\\\]\", 'm'));\n    Opal.const_set($nesting[0], 'LinkInlineRx', new RegExp(\"\" + \"(^|link:|\" + ($$($nesting, 'CG_BLANK')) + \"|&lt;|[>\\\\(\\\\)\\\\[\\\\];])(\\\\\\\\?(?:https?|file|ftp|irc)://[^\\\\s\\\\[\\\\]<]*[^\\\\s.,\\\\[\\\\]<])(?:\\\\[(|\" + ($$($nesting, 'CC_ALL')) + \"*?[^\\\\\\\\])\\\\])?\", 'm'));\n    Opal.const_set($nesting[0], 'InlineLinkMacroRx', new RegExp(\"\" + \"\\\\\\\\?(?:link|(mailto)):(|[^:\\\\s\\\\[][^\\\\s\\\\[]*)\\\\[(|\" + ($$($nesting, 'CC_ALL')) + \"*?[^\\\\\\\\])\\\\]\", 'm'));\n    Opal.const_set($nesting[0], 'MacroNameRx', new RegExp(\"\" + \"^\" + ($$($nesting, 'CG_WORD')) + \"+$\"));\n    Opal.const_set($nesting[0], 'InlineStemMacroRx', new RegExp(\"\" + \"\\\\\\\\?(stem|(?:latex|ascii)math):([a-z]+(?:,[a-z]+)*)?\\\\[(\" + ($$($nesting, 'CC_ALL')) + \"*?[^\\\\\\\\])\\\\]\", 'm'));\n    Opal.const_set($nesting[0], 'InlineMenuMacroRx', new RegExp(\"\" + \"\\\\\\\\?menu:(\" + ($$($nesting, 'CG_WORD')) + \"|[\" + ($$($nesting, 'CC_WORD')) + \"&][^\\\\n\\\\[]*[^\\\\s\\\\[])\\\\[ *(\" + ($$($nesting, 'CC_ALL')) + \"*?[^\\\\\\\\])?\\\\]\", 'm'));\n    Opal.const_set($nesting[0], 'MenuInlineRx', new RegExp(\"\" + \"\\\\\\\\?\\\"([\" + ($$($nesting, 'CC_WORD')) + \"&][^\\\"]*?[ \\\\n]+&gt;[ \\\\n]+[^\\\"]*)\\\"\"));\n    Opal.const_set($nesting[0], 'PassInlineRx', $hash(false, [\"+\", \"`\", new RegExp(\"\" + \"(^|[^\" + ($$($nesting, 'CC_WORD')) + \";:])(?:\\\\[([^\\\\]]+)\\\\])?(\\\\\\\\?(\\\\+|`)(\\\\S|\\\\S\" + ($$($nesting, 'CC_ALL')) + \"*?\\\\S)\\\\4)(?!\" + ($$($nesting, 'CG_WORD')) + \")\", 'm')], true, [\"`\", nil, new RegExp(\"\" + \"(^|[^`\" + ($$($nesting, 'CC_WORD')) + \"])(?:\\\\[([^\\\\]]+)\\\\])?(\\\\\\\\?(`)([^`\\\\s]|[^`\\\\s]\" + ($$($nesting, 'CC_ALL')) + \"*?\\\\S)\\\\4)(?![`\" + ($$($nesting, 'CC_WORD')) + \"])\", 'm')]));\n    Opal.const_set($nesting[0], 'InlinePassMacroRx', new RegExp(\"\" + \"(?:(?:(\\\\\\\\?)\\\\[([^\\\\]]+)\\\\])?(\\\\\\\\{0,2})(\\\\+\\\\+\\\\+?|\\\\$\\\\$)(\" + ($$($nesting, 'CC_ALL')) + \"*?)\\\\4|(\\\\\\\\?)pass:([a-z]+(?:,[a-z]+)*)?\\\\[(|\" + ($$($nesting, 'CC_ALL')) + \"*?[^\\\\\\\\])\\\\])\", 'm'));\n    Opal.const_set($nesting[0], 'InlineXrefMacroRx', new RegExp(\"\" + \"\\\\\\\\?(?:&lt;&lt;([\" + ($$($nesting, 'CC_WORD')) + \"#/.:{]\" + ($$($nesting, 'CC_ALL')) + \"*?)&gt;&gt;|xref:([\" + ($$($nesting, 'CC_WORD')) + \"#/.:{]\" + ($$($nesting, 'CC_ALL')) + \"*?)\\\\[(?:\\\\]|(\" + ($$($nesting, 'CC_ALL')) + \"*?[^\\\\\\\\])\\\\]))\", 'm'));\n    if ($$($nesting, 'RUBY_ENGINE')['$=='](\"opal\")) {\n      Opal.const_set($nesting[0], 'HardLineBreakRx', /^(.*) \\+$/m)\n    } else {\n      nil\n    };\n    Opal.const_set($nesting[0], 'MarkdownThematicBreakRx', /^ {0,3}([-*_])( *)\\1\\2\\1$/);\n    Opal.const_set($nesting[0], 'ExtLayoutBreakRx', /^(?:'{3,}|<{3,}|([-*_])( *)\\1\\2\\1)$/);\n    Opal.const_set($nesting[0], 'BlankLineRx', /\\n{2,}/);\n    Opal.const_set($nesting[0], 'DataDelimiterRx', /[,;]/);\n    Opal.const_set($nesting[0], 'TrailingDigitsRx', /\\d+$/);\n    Opal.const_set($nesting[0], 'EscapedSpaceRx', /\\\\([ \\t\\n])/);\n    Opal.const_set($nesting[0], 'ReplaceableTextRx', /[&']|--|\\.\\.\\.|\\([CRT]M?\\)/);\n    Opal.const_set($nesting[0], 'SpaceDelimiterRx', /([^\\\\])[ \\t\\n]+/);\n    Opal.const_set($nesting[0], 'SubModifierSniffRx', /[+-]/);\n    if ($$($nesting, 'RUBY_ENGINE')['$=='](\"opal\")) {\n    } else {\n      nil\n    };\n    Opal.const_set($nesting[0], 'UriSniffRx', new RegExp(\"\" + \"^\" + ($$($nesting, 'CG_ALPHA')) + \"[\" + ($$($nesting, 'CC_ALNUM')) + \".+-]+:/{0,2}\"));\n    Opal.const_set($nesting[0], 'UriTerminatorRx', /[);:]$/);\n    Opal.const_set($nesting[0], 'XmlSanitizeRx', /<[^>]+>/);\n    Opal.const_set($nesting[0], 'INTRINSIC_ATTRIBUTES', $hash2([\"startsb\", \"endsb\", \"vbar\", \"caret\", \"asterisk\", \"tilde\", \"plus\", \"backslash\", \"backtick\", \"blank\", \"empty\", \"sp\", \"two-colons\", \"two-semicolons\", \"nbsp\", \"deg\", \"zwsp\", \"quot\", \"apos\", \"lsquo\", \"rsquo\", \"ldquo\", \"rdquo\", \"wj\", \"brvbar\", \"cpp\", \"amp\", \"lt\", \"gt\"], {\"startsb\": \"[\", \"endsb\": \"]\", \"vbar\": \"|\", \"caret\": \"^\", \"asterisk\": \"*\", \"tilde\": \"~\", \"plus\": \"&#43;\", \"backslash\": \"\\\\\", \"backtick\": \"`\", \"blank\": \"\", \"empty\": \"\", \"sp\": \" \", \"two-colons\": \"::\", \"two-semicolons\": \";;\", \"nbsp\": \"&#160;\", \"deg\": \"&#176;\", \"zwsp\": \"&#8203;\", \"quot\": \"&#34;\", \"apos\": \"&#39;\", \"lsquo\": \"&#8216;\", \"rsquo\": \"&#8217;\", \"ldquo\": \"&#8220;\", \"rdquo\": \"&#8221;\", \"wj\": \"&#8288;\", \"brvbar\": \"&#166;\", \"cpp\": \"C++\", \"amp\": \"&\", \"lt\": \"<\", \"gt\": \">\"}));\n    quote_subs = [[\"strong\", \"unconstrained\", new RegExp(\"\" + \"\\\\\\\\?(?:\\\\[([^\\\\]]+)\\\\])?\\\\*\\\\*(\" + ($$($nesting, 'CC_ALL')) + \"+?)\\\\*\\\\*\", 'm')], [\"strong\", \"constrained\", new RegExp(\"\" + \"(^|[^\" + ($$($nesting, 'CC_WORD')) + \";:}])(?:\\\\[([^\\\\]]+)\\\\])?\\\\*(\\\\S|\\\\S\" + ($$($nesting, 'CC_ALL')) + \"*?\\\\S)\\\\*(?!\" + ($$($nesting, 'CG_WORD')) + \")\", 'm')], [\"double\", \"constrained\", new RegExp(\"\" + \"(^|[^\" + ($$($nesting, 'CC_WORD')) + \";:}])(?:\\\\[([^\\\\]]+)\\\\])?\\\"`(\\\\S|\\\\S\" + ($$($nesting, 'CC_ALL')) + \"*?\\\\S)`\\\"(?!\" + ($$($nesting, 'CG_WORD')) + \")\", 'm')], [\"single\", \"constrained\", new RegExp(\"\" + \"(^|[^\" + ($$($nesting, 'CC_WORD')) + \";:`}])(?:\\\\[([^\\\\]]+)\\\\])?'`(\\\\S|\\\\S\" + ($$($nesting, 'CC_ALL')) + \"*?\\\\S)`'(?!\" + ($$($nesting, 'CG_WORD')) + \")\", 'm')], [\"monospaced\", \"unconstrained\", new RegExp(\"\" + \"\\\\\\\\?(?:\\\\[([^\\\\]]+)\\\\])?``(\" + ($$($nesting, 'CC_ALL')) + \"+?)``\", 'm')], [\"monospaced\", \"constrained\", new RegExp(\"\" + \"(^|[^\" + ($$($nesting, 'CC_WORD')) + \";:\\\"'`}])(?:\\\\[([^\\\\]]+)\\\\])?`(\\\\S|\\\\S\" + ($$($nesting, 'CC_ALL')) + \"*?\\\\S)`(?![\" + ($$($nesting, 'CC_WORD')) + \"\\\"'`])\", 'm')], [\"emphasis\", \"unconstrained\", new RegExp(\"\" + \"\\\\\\\\?(?:\\\\[([^\\\\]]+)\\\\])?__(\" + ($$($nesting, 'CC_ALL')) + \"+?)__\", 'm')], [\"emphasis\", \"constrained\", new RegExp(\"\" + \"(^|[^\" + ($$($nesting, 'CC_WORD')) + \";:}])(?:\\\\[([^\\\\]]+)\\\\])?_(\\\\S|\\\\S\" + ($$($nesting, 'CC_ALL')) + \"*?\\\\S)_(?!\" + ($$($nesting, 'CG_WORD')) + \")\", 'm')], [\"mark\", \"unconstrained\", new RegExp(\"\" + \"\\\\\\\\?(?:\\\\[([^\\\\]]+)\\\\])?##(\" + ($$($nesting, 'CC_ALL')) + \"+?)##\", 'm')], [\"mark\", \"constrained\", new RegExp(\"\" + \"(^|[^\" + ($$($nesting, 'CC_WORD')) + \"&;:}])(?:\\\\[([^\\\\]]+)\\\\])?#(\\\\S|\\\\S\" + ($$($nesting, 'CC_ALL')) + \"*?\\\\S)#(?!\" + ($$($nesting, 'CG_WORD')) + \")\", 'm')], [\"superscript\", \"unconstrained\", /\\\\?(?:\\[([^\\]]+)\\])?\\^(\\S+?)\\^/], [\"subscript\", \"unconstrained\", /\\\\?(?:\\[([^\\]]+)\\])?~(\\S+?)~/]];\n    compat_quote_subs = quote_subs.$dup();\n    \n    $writer = [2, [\"double\", \"constrained\", new RegExp(\"\" + \"(^|[^\" + ($$($nesting, 'CC_WORD')) + \";:}])(?:\\\\[([^\\\\]]+)\\\\])?``(\\\\S|\\\\S\" + ($$($nesting, 'CC_ALL')) + \"*?\\\\S)''(?!\" + ($$($nesting, 'CG_WORD')) + \")\", 'm')]];\n    $send(compat_quote_subs, '[]=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    \n    $writer = [3, [\"single\", \"constrained\", new RegExp(\"\" + \"(^|[^\" + ($$($nesting, 'CC_WORD')) + \";:}])(?:\\\\[([^\\\\]]+)\\\\])?`(\\\\S|\\\\S\" + ($$($nesting, 'CC_ALL')) + \"*?\\\\S)'(?!\" + ($$($nesting, 'CG_WORD')) + \")\", 'm')]];\n    $send(compat_quote_subs, '[]=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    \n    $writer = [4, [\"monospaced\", \"unconstrained\", new RegExp(\"\" + \"\\\\\\\\?(?:\\\\[([^\\\\]]+)\\\\])?\\\\+\\\\+(\" + ($$($nesting, 'CC_ALL')) + \"+?)\\\\+\\\\+\", 'm')]];\n    $send(compat_quote_subs, '[]=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    \n    $writer = [5, [\"monospaced\", \"constrained\", new RegExp(\"\" + \"(^|[^\" + ($$($nesting, 'CC_WORD')) + \";:}])(?:\\\\[([^\\\\]]+)\\\\])?\\\\+(\\\\S|\\\\S\" + ($$($nesting, 'CC_ALL')) + \"*?\\\\S)\\\\+(?!\" + ($$($nesting, 'CG_WORD')) + \")\", 'm')]];\n    $send(compat_quote_subs, '[]=', Opal.to_a($writer));\n    $writer[$rb_minus($writer[\"length\"], 1)];;\n    compat_quote_subs.$insert(3, [\"emphasis\", \"constrained\", new RegExp(\"\" + \"(^|[^\" + ($$($nesting, 'CC_WORD')) + \";:}])(?:\\\\[([^\\\\]]+)\\\\])?'(\\\\S|\\\\S\" + ($$($nesting, 'CC_ALL')) + \"*?\\\\S)'(?!\" + ($$($nesting, 'CG_WORD')) + \")\", 'm')]);\n    Opal.const_set($nesting[0], 'QUOTE_SUBS', $hash(false, quote_subs, true, compat_quote_subs));\n    quote_subs = nil;\n    compat_quote_subs = nil;\n    Opal.const_set($nesting[0], 'REPLACEMENTS', [[/\\\\?\\(C\\)/, \"&#169;\", \"none\"], [/\\\\?\\(R\\)/, \"&#174;\", \"none\"], [/\\\\?\\(TM\\)/, \"&#8482;\", \"none\"], [/(^|\\n| |\\\\)--( |\\n|$)/, \"&#8201;&#8212;&#8201;\", \"none\"], [new RegExp(\"\" + \"(\" + ($$($nesting, 'CG_WORD')) + \")\\\\\\\\?--(?=\" + ($$($nesting, 'CG_WORD')) + \")\"), \"&#8212;&#8203;\", \"leading\"], [/\\\\?\\.\\.\\./, \"&#8230;&#8203;\", \"leading\"], [/\\\\?`'/, \"&#8217;\", \"none\"], [new RegExp(\"\" + \"(\" + ($$($nesting, 'CG_ALNUM')) + \")\\\\\\\\?'(?=\" + ($$($nesting, 'CG_ALPHA')) + \")\"), \"&#8217;\", \"leading\"], [/\\\\?-&gt;/, \"&#8594;\", \"none\"], [/\\\\?=&gt;/, \"&#8658;\", \"none\"], [/\\\\?&lt;-/, \"&#8592;\", \"none\"], [/\\\\?&lt;=/, \"&#8656;\", \"none\"], [/\\\\?(&)amp;((?:[a-zA-Z][a-zA-Z]+\\d{0,2}|#\\d\\d\\d{0,4}|#x[\\da-fA-F][\\da-fA-F][\\da-fA-F]{0,3});)/, \"\", \"bounding\"]]);\n    (function(self, $parent_nesting) {\n      var def = self.$$proto, $nesting = [self].concat($parent_nesting), TMP_load_12, TMP_load_file_14, TMP_convert_15, TMP_convert_file_17;\n\n      \n      \n      Opal.def(self, '$load', TMP_load_12 = function $$load(input, options) {\n        var $a, $b, TMP_9, TMP_10, TMP_11, self = this, timings = nil, attrs = nil, attrs_arr = nil, lines = nil, input_path = nil, input_mtime = nil, $writer = nil, docdate = nil, doctime = nil, doc = nil, ex = nil, context = nil, wrapped_ex = nil;\n\n        if (options == null) {\n          options = $hash2([], {});\n        }\n        try {\n          \n          options = options.$dup();\n          if ($truthy((timings = options['$[]'](\"timings\")))) {\n            timings.$start(\"read\")};\n          if ($truthy((attrs = options['$[]'](\"attributes\"))['$!']())) {\n            attrs = $hash2([], {})\n          } else if ($truthy(($truthy($a = $$$('::', 'Hash')['$==='](attrs)) ? $a : ($truthy($b = $$$('::', 'RUBY_ENGINE_JRUBY')) ? $$$($$$($$$('::', 'Java'), 'JavaUtil'), 'Map')['$==='](attrs) : $b)))) {\n            attrs = attrs.$dup()\n          } else if ($truthy($$$('::', 'Array')['$==='](attrs))) {\n            \n            $a = [$hash2([], {}), attrs], (attrs = $a[0]), (attrs_arr = $a[1]), $a;\n            $send(attrs_arr, 'each', [], (TMP_9 = function(entry){var self = TMP_9.$$s || this, $c, $d, k = nil, v = nil, $writer = nil;\nif (entry == null) entry = nil;\n            \n              $d = entry.$split(\"=\", 2), $c = Opal.to_ary($d), (k = ($c[0] == null ? nil : $c[0])), (v = ($c[1] == null ? nil : $c[1])), $d;\n              \n              $writer = [k, ($truthy($c = v) ? $c : \"\")];\n              $send(attrs, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];;}, TMP_9.$$s = self, TMP_9.$$arity = 1, TMP_9));\n          } else if ($truthy($$$('::', 'String')['$==='](attrs))) {\n            \n            $a = [$hash2([], {}), attrs.$gsub($$($nesting, 'SpaceDelimiterRx'), \"\" + \"\\\\1\" + ($$($nesting, 'NULL'))).$gsub($$($nesting, 'EscapedSpaceRx'), \"\\\\1\").$split($$($nesting, 'NULL'))], (attrs = $a[0]), (attrs_arr = $a[1]), $a;\n            $send(attrs_arr, 'each', [], (TMP_10 = function(entry){var self = TMP_10.$$s || this, $c, $d, k = nil, v = nil, $writer = nil;\nif (entry == null) entry = nil;\n            \n              $d = entry.$split(\"=\", 2), $c = Opal.to_ary($d), (k = ($c[0] == null ? nil : $c[0])), (v = ($c[1] == null ? nil : $c[1])), $d;\n              \n              $writer = [k, ($truthy($c = v) ? $c : \"\")];\n              $send(attrs, '[]=', Opal.to_a($writer));\n              return $writer[$rb_minus($writer[\"length\"], 1)];;}, TMP_10.$$s = self, TMP_10.$$arity = 1, TMP_10));\n          } else if ($truthy(($truthy($a = attrs['$respond_to?'](\"keys\")) ? attrs['$respond_to?'](\"[]\") : $a))) {\n            attrs = $$$('::', 'Hash')['$[]']($send(attrs.$keys(), 'map', [], (TMP_11 = function(k){var self = TMP_11.$$s || this;\nif (k == null) k = nil;\n            return [k, attrs['$[]'](k)]}, TMP_11.$$s = self, TMP_11.$$arity = 1, TMP_11)))\n          } else {\n            self.$raise($$$('::', 'ArgumentError'), \"\" + \"illegal type for attributes option: \" + ($rb_times(attrs.$class().$ancestors(), \" < \")))\n          };\n          lines = nil;\n          if ($truthy($$$('::', 'File')['$==='](input))) {\n            \n            input_path = $$$('::', 'File').$expand_path(input.$path());\n            input_mtime = (function() {if ($truthy($$$('::', 'ENV')['$[]'](\"SOURCE_DATE_EPOCH\"))) {\n              return $$$('::', 'Time').$at(self.$Integer($$$('::', 'ENV')['$[]'](\"SOURCE_DATE_EPOCH\"))).$utc()\n            } else {\n              return input.$mtime()\n            }; return nil; })();\n            lines = input.$readlines();\n            \n            $writer = [\"docfile\", input_path];\n            $send(attrs, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            \n            $writer = [\"docdir\", $$$('::', 'File').$dirname(input_path)];\n            $send(attrs, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            \n            $writer = [\"docname\", $$($nesting, 'Helpers').$basename(input_path, (($writer = [\"docfilesuffix\", $$$('::', 'File').$extname(input_path)]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))];\n            $send(attrs, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n            if ($truthy((docdate = attrs['$[]'](\"docdate\")))) {\n              ($truthy($a = attrs['$[]'](\"docyear\")) ? $a : (($writer = [\"docyear\", (function() {if (docdate.$index(\"-\")['$=='](4)) {\n                \n                return docdate.$slice(0, 4);\n              } else {\n                return nil\n              }; return nil; })()]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]))\n            } else {\n              \n              docdate = (($writer = [\"docdate\", input_mtime.$strftime(\"%Y-%m-%d\")]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]);\n              ($truthy($a = attrs['$[]'](\"docyear\")) ? $a : (($writer = [\"docyear\", input_mtime.$year().$to_s()]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n            };\n            doctime = ($truthy($a = attrs['$[]'](\"doctime\")) ? $a : (($writer = [\"doctime\", input_mtime.$strftime(\"%H:%M:%S %Z\")]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer[\"length\"], 1)]));\n            \n            $writer = [\"docdatetime\", \"\" + (docdate) + \" \" + (doctime)];\n            $send(attrs, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];;\n          } else if ($truthy(input['$respond_to?'](\"readlines\"))) {\n            \n            \n            try {\n              input.$rewind()\n            } catch ($err) {\n              if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {\n                try {\n                  nil\n                } finally { Opal.pop_exception() }\n              } else { throw $err; }\n            };;\n            lines = input.$readlines();\n          } else if ($truthy($$$('::', 'String')['$==='](input))) {\n            lines = (function() {if ($truthy($$$('::', 'RUBY_MIN_VERSION_2'))) {\n              return input.$lines()\n            } else {\n              return input.$each_line().$to_a()\n            }; return nil; })()\n          } else if ($truthy($$$('::', 'Array')['$==='](input))) {\n            lines = input.$dup()\n          } else {\n            self.$raise($$$('::', 'ArgumentError'), \"\" + \"unsupported input type: \" + (input.$class()))\n          };\n          if ($truthy(timings)) {\n            \n            timings.$record(\"read\");\n            timings.$start(\"parse\");};\n          \n          $writer = [\"attributes\", attrs];\n          $send(options, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n          doc = (function() {if (options['$[]'](\"parse\")['$=='](false)) {\n            \n            return $$($nesting, 'Document').$new(lines, options);\n          } else {\n            return $$($nesting, 'Document').$new(lines, options).$parse()\n          }; return nil; })();\n          if ($truthy(timings)) {\n            timings.$record(\"parse\")};\n          return doc;\n        } catch ($err) {\n          if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {ex = $err;\n            try {\n              \n              \n              try {\n                \n                context = \"\" + \"asciidoctor: FAILED: \" + (($truthy($a = attrs['$[]'](\"docfile\")) ? $a : \"<stdin>\")) + \": Failed to load AsciiDoc document\";\n                if ($truthy(ex['$respond_to?'](\"exception\"))) {\n                  \n                  wrapped_ex = ex.$exception(\"\" + (context) + \" - \" + (ex.$message()));\n                  wrapped_ex.$set_backtrace(ex.$backtrace());\n                } else {\n                  \n                  wrapped_ex = ex.$class().$new(context, ex);\n                  \n                  $writer = [ex.$stack_trace()];\n                  $send(wrapped_ex, 'stack_trace=', Opal.to_a($writer));\n                  $writer[$rb_minus($writer[\"length\"], 1)];;\n                };\n              } catch ($err) {\n                if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {\n                  try {\n                    wrapped_ex = ex\n                  } finally { Opal.pop_exception() }\n                } else { throw $err; }\n              };;\n              return self.$raise(wrapped_ex);\n            } finally { Opal.pop_exception() }\n          } else { throw $err; }\n        }\n      }, TMP_load_12.$$arity = -2);\n      \n      Opal.def(self, '$load_file', TMP_load_file_14 = function $$load_file(filename, options) {\n        var TMP_13, self = this;\n\n        if (options == null) {\n          options = $hash2([], {});\n        }\n        return $send($$$('::', 'File'), 'open', [filename], (TMP_13 = function(file){var self = TMP_13.$$s || this;\nif (file == null) file = nil;\n        return self.$load(file, options)}, TMP_13.$$s = self, TMP_13.$$arity = 1, TMP_13))\n      }, TMP_load_file_14.$$arity = -2);\n      \n      Opal.def(self, '$convert', TMP_convert_15 = function $$convert(input, options) {\n        var $a, $b, $c, $d, $e, self = this, to_file = nil, to_dir = nil, mkdirs = nil, timings = nil, $case = nil, write_to_same_dir = nil, stream_output = nil, write_to_target = nil, $writer = nil, input_path = nil, outdir = nil, doc = nil, outfile = nil, working_dir = nil, jail = nil, opts = nil, output = nil, stylesdir = nil, copy_asciidoctor_stylesheet = nil, copy_user_stylesheet = nil, stylesheet = nil, copy_coderay_stylesheet = nil, copy_pygments_stylesheet = nil, stylesoutdir = nil, stylesheet_src = nil, stylesheet_dest = nil, stylesheet_data = nil;\n\n        if (options == null) {\n          options = $hash2([], {});\n        }\n        \n        options = options.$dup();\n        options.$delete(\"parse\");\n        to_file = options.$delete(\"to_file\");\n        to_dir = options.$delete(\"to_dir\");\n        mkdirs = ($truthy($a = options.$delete(\"mkdirs\")) ? $a : false);\n        timings = options['$[]'](\"timings\");\n        $case = to_file;\n        if (true['$===']($case) || nil['$===']($case)) {\n        write_to_same_dir = ($truthy($a = to_dir['$!']()) ? $$$('::', 'File')['$==='](input) : $a);\n        stream_output = false;\n        write_to_target = to_dir;\n        to_file = nil;}\n        else if (false['$===']($case)) {\n        write_to_same_dir = false;\n        stream_output = false;\n        write_to_target = false;\n        to_file = nil;}\n        else if (\"/dev/null\"['$===']($case)) {return self.$load(input, options)}\n        else {\n        write_to_same_dir = false;\n        write_to_target = (function() {if ($truthy((stream_output = to_file['$respond_to?'](\"write\")))) {\n          return false\n        } else {\n          return to_file\n        }; return nil; })();};\n        if ($truthy(options['$key?'](\"header_footer\"))) {\n        } else if ($truthy(($truthy($a = write_to_same_dir) ? $a : write_to_target))) {\n          \n          $writer = [\"header_footer\", true];\n          $send(options, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];};\n        if ($truthy(write_to_same_dir)) {\n          \n          input_path = $$$('::', 'File').$expand_path(input.$path());\n          \n          $writer = [\"to_dir\", (outdir = $$$('::', 'File').$dirname(input_path))];\n          $send(options, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];;\n        } else if ($truthy(write_to_target)) {\n          if ($truthy(to_dir)) {\n            if ($truthy(to_file)) {\n              \n              $writer = [\"to_dir\", $$$('::', 'File').$expand_path($$$('::', 'File').$join(to_dir, to_file, \"..\"))];\n              $send(options, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];\n            } else {\n              \n              $writer = [\"to_dir\", $$$('::', 'File').$expand_path(to_dir)];\n              $send(options, '[]=', Opal.to_a($writer));\n              $writer[$rb_minus($writer[\"length\"], 1)];\n            }\n          } else if ($truthy(to_file)) {\n            \n            $writer = [\"to_dir\", $$$('::', 'File').$expand_path(to_file, \"..\")];\n            $send(options, '[]=', Opal.to_a($writer));\n            $writer[$rb_minus($writer[\"length\"], 1)];}\n        } else {\n          \n          $writer = [\"to_dir\", nil];\n          $send(options, '[]=', Opal.to_a($writer));\n          $writer[$rb_minus($writer[\"length\"], 1)];\n        };\n        doc = self.$load(input, options);\n        if ($truthy(write_to_same_dir)) {\n          \n          outfile = $$$('::', 'File').$join(outdir, \"\" + (doc.$attributes()['$[]'](\"docname\")) + (doc.$outfilesuffix()));\n          if (outfile['$=='](input_path)) {\n            self.$raise($$$('::', 'IOError'), \"\" + \"input file and output file cannot be the same: \" + (outfile))};\n        } else if ($truthy(write_to_target)) {\n          \n          working_dir = (function() {if ($truthy(options['$key?'](\"base_dir\"))) {\n            \n            return $$$('::', 'File').$expand_path(options['$[]'](\"base_dir\"));\n          } else {\n            \n            return $$$('::', 'File').$expand_path($$$('::', 'Dir').$pwd());\n          }; return nil; })();\n          jail = (function() {if ($truthy($rb_ge(doc.$safe(), $$$($$($nesting, 'SafeMode'), 'SAFE')))) {\n            return working_dir\n          } else {\n            return nil\n          }; return nil; })();\n          if ($truthy(to_dir)) {\n            \n            outdir = doc.$normalize_system_path(to_dir, working_dir, jail, $hash2([\"target_name\", \"recover\"], {\"target_name\": \"to_dir\", \"recover\": false}));\n            if ($truthy(to_file)) {\n              \n              outfile = doc.$normalize_system_path(to_file, outdir, nil, $hash2([\"target_name\", \"recover\"], {\"target_name\": \"to_dir\", \"recover\": false}));\n              outdir = $$$('::', 'File').$dirname(outfile);\n            } else {\n              outfile = $$$('::', 'File').$join(outdir, \"\" + (doc.$attributes()['$[]'](\"docname\")) + (doc.$outfilesuffix()))\n            };\n          } else if ($truthy(to_file)) {\n            \n            outfile = doc.$normalize_system_path(to_file, working_dir, jail, $hash2([\"target_name\", \"recover\"], {\"target_name\": \"to_dir\", \"recover\": false}));\n            outdir = $$$('::', 'File').$dirname(outfile);};\n          if ($truthy(($truthy($a = $$$('::', 'File')['$==='](input)) ? outfile['$==']($$$('::', 'File').$expand_path(input.$path())) : $a))) {\n            self.$raise($$$('::', 'IOError'), \"\" + \"input file and output file cannot be the same: \" + (outfile))};\n          if ($truthy($$$('::', 'File')['$directory?'](outdir))) {\n          } else if ($truthy(mkdirs)) {\n            $$($nesting, 'Helpers').$mkdir_p(outdir)\n          } else {\n            self.$raise($$$('::', 'IOError'), \"\" + \"target directory does not exist: \" + (to_dir))\n          };\n        } else {\n          \n          outfile = to_file;\n          outdir = nil;\n        };\n        if ($truthy(timings)) {\n          timings.$start(\"convert\")};\n        opts = (function() {if ($truthy(($truthy($a = outfile) ? stream_output['$!']() : $a))) {\n          return $hash2([\"outfile\", \"outdir\"], {\"outfile\": outfile, \"outdir\": outdir})\n        } else {\n          return $hash2([], {})\n        }; return nil; })();\n        output = doc.$convert(opts);\n        if ($truthy(timings)) {\n          timings.$record(\"convert\")};\n        if ($truthy(outfile)) {\n          \n          if ($truthy(timings)) {\n            timings.$start(\"write\")};\n          doc.$write(output, outfile);\n          if ($truthy(timings)) {\n            timings.$record(\"write\")};\n          if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = ($truthy($e = stream_output['$!']()) ? $rb_lt(doc.$safe(), $$$($$($nesting, 'SafeMode'), 'SECURE')) : $e)) ? doc['$attr?'](\"linkcss\") : $d)) ? doc['$attr?'](\"copycss\") : $c)) ? doc['$attr?'](\"basebackend-html\") : $b)) ? ($truthy($b = (stylesdir = doc.$attr(\"stylesdir\"))) ? $$($nesting, 'Helpers')['$uriish?'](stylesdir) : $b)['$!']() : $a))) {\n            \n            copy_asciidoctor_stylesheet = false;\n            copy_user_stylesheet = false;\n            if ($truthy((stylesheet = doc.$attr(\"stylesheet\")))) {\n              if ($truthy($$($nesting, 'DEFAULT_STYLESHEET_KEYS')['$include?'](stylesheet))) {\n                copy_asciidoctor_stylesheet = true\n              } else if ($truthy($$($nesting, 'Helpers')['$uriish?'](stylesheet)['$!']())) {\n                copy_user_stylesheet = true}};\n            copy_coderay_stylesheet = ($truthy($a = doc['$attr?'](\"source-highlighter\", \"coderay\")) ? doc.$attr(\"coderay-css\", \"class\")['$=='](\"class\") : $a);\n            copy_pygments_stylesheet = ($truthy($a = doc['$attr?'](\"source-highlighter\", \"pygments\")) ? doc.$attr(\"pygments-css\", \"class\")['$=='](\"class\") : $a);\n            if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = copy_asciidoctor_stylesheet) ? $c : copy_user_stylesheet)) ? $b : copy_coderay_stylesheet)) ? $a : copy_pygments_stylesheet))) {\n              \n              stylesoutdir = doc.$normalize_system_path(stylesdir, outdir, (function() {if ($truthy($rb_ge(doc.$safe(), $$$($$($nesting, 'SafeMode'), 'SAFE')))) {\n                return outdir\n              } else {\n                return nil\n              }; return nil; })());\n              if ($truthy(mkdirs)) {\n                $$($nesting, 'Helpers').$mkdir_p(stylesoutdir)};\n              if ($truthy(copy_asciidoctor_stylesheet)) {\n                $$($nesting, 'Stylesheets').$instance().$write_primary_stylesheet(stylesoutdir)\n              } else if ($truthy(copy_user_stylesheet)) {\n                \n                if ($truthy((stylesheet_src = doc.$attr(\"copycss\"))['$empty?']())) {\n                  stylesheet_src = doc.$normalize_system_path(stylesheet)\n                } else {\n                  stylesheet_src = doc.$normalize_system_path(stylesheet_src)\n                };\n                stylesheet_dest = doc.$normalize_system_path(stylesheet, stylesoutdir, (function() {if ($truthy($rb_ge(doc.$safe(), $$$($$($nesting, 'SafeMode'), 'SAFE')))) {\n                  return outdir\n                } else {\n                  return nil\n                }; return nil; })());\n                if ($truthy(($truthy($a = stylesheet_src['$!='](stylesheet_dest)) ? (stylesheet_data = doc.$read_asset(stylesheet_src, $hash2([\"warn_on_failure\", \"label\"], {\"warn_on_failure\": $$$('::', 'File')['$file?'](stylesheet_dest)['$!'](), \"label\": \"stylesheet\"}))) : $a))) {\n                  $$$('::', 'IO').$write(stylesheet_dest, stylesheet_data)};};\n              if ($truthy(copy_coderay_stylesheet)) {\n                $$($nesting, 'Stylesheets').$instance().$write_coderay_stylesheet(stylesoutdir)\n              } else if ($truthy(copy_pygments_stylesheet)) {\n                $$($nesting, 'Stylesheets').$instance().$write_pygments_stylesheet(stylesoutdir, doc.$attr(\"pygments-style\"))};};};\n          return doc;\n        } else {\n          return output\n        };\n      }, TMP_convert_15.$$arity = -2);\n      Opal.alias(self, \"render\", \"convert\");\n      \n      Opal.def(self, '$convert_file', TMP_convert_file_17 = function $$convert_file(filename, options) {\n        var TMP_16, self = this;\n\n        if (options == null) {\n          options = $hash2([], {});\n        }\n        return $send($$$('::', 'File'), 'open', [filename], (TMP_16 = function(file){var self = TMP_16.$$s || this;\nif (file == null) file = nil;\n        return self.$convert(file, options)}, TMP_16.$$s = self, TMP_16.$$arity = 1, TMP_16))\n      }, TMP_convert_file_17.$$arity = -2);\n      Opal.alias(self, \"render_file\", \"convert_file\");\n      if ($$($nesting, 'RUBY_ENGINE')['$=='](\"opal\")) {\n        return nil\n      } else {\n        return nil\n      };\n    })(Opal.get_singleton_class(self), $nesting);\n    if ($$($nesting, 'RUBY_ENGINE')['$=='](\"opal\")) {\n      \n      self.$require(\"asciidoctor/timings\");\n      self.$require(\"asciidoctor/version\");\n    } else {\n      nil\n    };\n  })($nesting[0], $nesting);\n  self.$require(\"asciidoctor/core_ext\");\n  self.$require(\"asciidoctor/helpers\");\n  self.$require(\"asciidoctor/substitutors\");\n  self.$require(\"asciidoctor/abstract_node\");\n  self.$require(\"asciidoctor/abstract_block\");\n  self.$require(\"asciidoctor/attribute_list\");\n  self.$require(\"asciidoctor/block\");\n  self.$require(\"asciidoctor/callouts\");\n  self.$require(\"asciidoctor/converter\");\n  self.$require(\"asciidoctor/document\");\n  self.$require(\"asciidoctor/inline\");\n  self.$require(\"asciidoctor/list\");\n  self.$require(\"asciidoctor/parser\");\n  self.$require(\"asciidoctor/path_resolver\");\n  self.$require(\"asciidoctor/reader\");\n  self.$require(\"asciidoctor/section\");\n  self.$require(\"asciidoctor/stylesheets\");\n  self.$require(\"asciidoctor/table\");\n  if ($$($nesting, 'RUBY_ENGINE')['$=='](\"opal\")) {\n    return self.$require(\"asciidoctor/js/postscript\")\n  } else {\n    return nil\n  };\n})(Opal);\n\n\n/**\n * Convert a JSON to an (Opal) Hash.\n * @private\n */\nvar toHash = function (object) {\n  return object && !('$$smap' in object) ? Opal.hash(object) : object;\n};\n\n/**\n * Convert an (Opal) Hash to JSON.\n * @private\n */\nvar fromHash = function (hash) {\n  var object = {};\n  for (var i = 0, keys = hash.$$keys, data = hash.$$smap, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    object[key] = data[key];\n  }\n  return object;\n};\n\n/**\n * @private\n */\nvar prepareOptions = function (options) {\n  if (options = toHash(options)) {\n    var attrs = options['$[]']('attributes');\n    if (attrs && typeof attrs === 'object' && attrs.constructor.name === 'Object') {\n      options = options.$dup();\n      options['$[]=']('attributes', toHash(attrs));\n    }\n  }\n  return options;\n};\n\n// Asciidoctor API\n\n/**\n * @namespace\n * @description\n * Methods for parsing AsciiDoc input files and converting documents.\n *\n * AsciiDoc documents comprise a header followed by zero or more sections.\n * Sections are composed of blocks of content. For example:\n * <pre>\n *   = Doc Title\n *\n *   == Section 1\n *\n *   This is a paragraph block in the first section.\n *\n *   == Section 2\n *\n *   This section has a paragraph block and an olist block.\n *\n *   . Item 1\n *   . Item 2\n * </pre>\n *\n * @example\n * asciidoctor.convertFile('sample.adoc');\n */\nvar Asciidoctor = Opal.Asciidoctor['$$class'];\n\n/**\n * Get Asciidoctor core version number.\n *\n * @memberof Asciidoctor\n * @returns {string} - returns the version number of Asciidoctor core.\n */\nAsciidoctor.$$proto.getCoreVersion = function () {\n  return this.$$const.VERSION;\n};\n\n/**\n * Parse the AsciiDoc source input into an {@link Document} and convert it to the specified backend format.\n *\n * Accepts input as a Buffer or String.\n *\n * @param {string|Buffer} input - AsciiDoc input as String or Buffer\n * @param {Object} options - a JSON of options to control processing (default: {})\n * @returns {string|Document} - returns the {@link Document} object if the converted String is written to a file,\n * otherwise the converted String\n * @memberof Asciidoctor\n * @example\n * var input = '= Hello, AsciiDoc!\\n' +\n *   'Guillaume Grossetie <ggrossetie@example.com>\\n\\n' +\n *   'An introduction to http://asciidoc.org[AsciiDoc].\\n\\n' +\n *   '== First Section\\n\\n' +\n *   '* item 1\\n' +\n *   '* item 2\\n';\n *\n * var html = asciidoctor.convert(input);\n */\nAsciidoctor.$$proto.convert = function (input, options) {\n  if (typeof input === 'object' && input.constructor.name === 'Buffer') {\n    input = input.toString('utf8');\n  }\n  var result = this.$convert(input, prepareOptions(options));\n  return result === Opal.nil ? '' : result;\n};\n\n/**\n * Parse the AsciiDoc source input into an {@link Document} and convert it to the specified backend format.\n *\n * @param {string} filename - source filename\n * @param {Object} options - a JSON of options to control processing (default: {})\n * @returns {string|Document} - returns the {@link Document} object if the converted String is written to a file,\n * otherwise the converted String\n * @memberof Asciidoctor\n * @example\n * var html = asciidoctor.convertFile('./document.adoc');\n */\nAsciidoctor.$$proto.convertFile = function (filename, options) {\n  return this.$convert_file(filename, prepareOptions(options));\n};\n\n/**\n * Parse the AsciiDoc source input into an {@link Document}\n *\n * Accepts input as a Buffer or String.\n *\n * @param {string|Buffer} input - AsciiDoc input as String or Buffer\n * @param {Object} options - a JSON of options to control processing (default: {})\n * @returns {Document} - returns the {@link Document} object\n * @memberof Asciidoctor\n */\nAsciidoctor.$$proto.load = function (input, options) {\n  if (typeof input === 'object' && input.constructor.name === 'Buffer') {\n    input = input.toString('utf8');\n  }\n  return this.$load(input, prepareOptions(options));\n};\n\n/**\n * Parse the contents of the AsciiDoc source file into an {@link Document}\n *\n * @param {string} filename - source filename\n * @param {Object} options - a JSON of options to control processing (default: {})\n * @returns {Document} - returns the {@link Document} object\n * @memberof Asciidoctor\n */\nAsciidoctor.$$proto.loadFile = function (filename, options) {\n  return this.$load_file(filename, prepareOptions(options));\n};\n\n// AbstractBlock API\n\n/**\n * @namespace\n * @extends AbstractNode\n */\nvar AbstractBlock = Opal.Asciidoctor.AbstractBlock;\n\n/**\n * Get the String title of this Block with title substitions applied\n *\n * The following substitutions are applied to block and section titles:\n *\n * <code>specialcharacters</code>, <code>quotes</code>, <code>replacements</code>, <code>macros</code>, <code>attributes</code> and <code>post_replacements</code>\n *\n * @memberof AbstractBlock\n * @returns {string} - returns the converted String title for this Block, or undefined if the title is not set.\n * @example\n * block.title // \"Foo 3^ # {two-colons} Bar(1)\"\n * block.getTitle(); // \"Foo 3^ # :: Bar(1)\"\n */\nAbstractBlock.$$proto.getTitle = function () {\n  var title = this.$title();\n  return title === Opal.nil ? undefined : title;\n};\n\n/**\n * Convenience method that returns the interpreted title of the Block\n * with the caption prepended.\n * Concatenates the value of this Block's caption instance variable and the\n * return value of this Block's title method. No space is added between the\n * two values. If the Block does not have a caption, the interpreted title is\n * returned.\n *\n * @memberof AbstractBlock\n * @returns {string} - the converted String title prefixed with the caption, or just the\n * converted String title if no caption is set\n */\nAbstractBlock.$$proto.getCaptionedTitle = function () {\n  return this.$captioned_title();\n};\n\n/**\n * Get the style (block type qualifier) for this block.\n * @memberof AbstractBlock\n * @returns {string} - returns the style for this block\n */\nAbstractBlock.$$proto.getStyle = function () {\n  return this.style;\n};\n\n/**\n * Get the caption for this block.\n * @memberof AbstractBlock\n * @returns {string} - returns the caption for this block\n */\nAbstractBlock.$$proto.getCaption = function () {\n  return this.$caption();\n};\n\n/**\n * Set the caption for this block.\n * @param {string} caption - Caption\n * @memberof AbstractBlock\n */\nAbstractBlock.$$proto.setCaption = function (caption) {\n  this.caption = caption;\n};\n\n/**\n * Get the level of this section or the section level in which this block resides.\n * @memberof AbstractBlock\n * @returns {number} - returns the level of this section\n */\nAbstractBlock.$$proto.getLevel = function () {\n  return this.level;\n};\n\n/**\n * Get the substitution keywords to be applied to the contents of this block.\n *\n * @memberof AbstractBlock\n * @returns {Array} - the list of {string} substitution keywords associated with this block.\n */\nAbstractBlock.$$proto.getSubstitutions = function () {\n  return this.subs;\n};\n\n/**\n * Check whether a given substitution keyword is present in the substitutions for this block.\n *\n * @memberof AbstractBlock\n * @returns {boolean} - whether the substitution is present on this block.\n */\nAbstractBlock.$$proto.hasSubstitution = function (substitution) {\n  return this['$sub?'](substitution);\n};\n\n/**\n * Remove the specified substitution keyword from the list of substitutions for this block.\n *\n * @memberof AbstractBlock\n * @returns undefined\n */\nAbstractBlock.$$proto.removeSubstitution = function (substitution) {\n  this.$remove_sub(substitution);\n};\n\n/**\n * Get the list of {@link AbstractBlock} sub-blocks for this block.\n * @memberof AbstractBlock\n * @returns {Array} - returns a list of {@link AbstractBlock} sub-blocks\n */\nAbstractBlock.$$proto.getBlocks = function () {\n  return this.blocks;\n};\n\n/**\n * Get the converted result of the child blocks by converting the children appropriate to content model that this block supports.\n * @memberof AbstractBlock\n * @returns {string} - returns the converted result of the child blocks\n */\nAbstractBlock.$$proto.getContent = function () {\n  return this.$content();\n};\n\n/**\n * Get the converted content for this block.\n * If the block has child blocks, the content method should cause them to be converted\n * and returned as content that can be included in the parent block's template.\n * @memberof AbstractBlock\n * @returns {string} - returns the converted String content for this block\n */\nAbstractBlock.$$proto.convert = function () {\n  return this.$convert();\n};\n\n/**\n * Query for all descendant block-level nodes in the document tree\n * that match the specified selector (context, style, id, and/or role).\n * If a function block is given, it's used as an additional filter.\n * If no selector or function block is supplied, all block-level nodes in the tree are returned.\n * @param {Object} [selector]\n * @param {function} [block]\n * @example\n * doc.findBy({'context': 'section'});\n * // => { level: 0, title: \"Hello, AsciiDoc!\", blocks: 0 }\n * // => { level: 1, title: \"First Section\", blocks: 1 }\n *\n * doc.findBy({'context': 'section'}, function (section) { return section.getLevel() === 1; });\n * // => { level: 1, title: \"First Section\", blocks: 1 }\n *\n * doc.findBy({'context': 'listing', 'style': 'source'});\n * // => { context: :listing, content_model: :verbatim, style: \"source\", lines: 1 }\n *\n * @memberof AbstractBlock\n * @returns {Array} - returns a list of block-level nodes that match the filter or an empty list if no matches are found\n */\nAbstractBlock.$$proto.findBy = function (selector, block) {\n  if (typeof block === 'undefined' && typeof selector === 'function') {\n    return Opal.send(this, 'find_by', null, selector);\n  }\n  else if (typeof block === 'function') {\n    return Opal.send(this, 'find_by', [toHash(selector)], block);\n  }\n  else {\n    return this.$find_by(toHash(selector));\n  }\n};\n\n/**\n * Get the source line number where this block started.\n * @memberof AbstractBlock\n * @returns {number} - returns the source line number where this block started\n */\nAbstractBlock.$$proto.getLineNumber = function () {\n  var lineno = this.$lineno();\n  return lineno === Opal.nil ? undefined : lineno;\n};\n\n/**\n * @namespace\n */\nvar Block = Opal.Asciidoctor.Block;\n\n/**\n * Get the source of this block.\n * @memberof Block\n * @returns {string} - returns the String source of this block.\n */\nBlock.$$proto.getSource = function () {\n  return this.$source();\n};\n\n/**\n * Get the source lines of this block.\n * @memberof Block\n * @returns {Array} - returns the String {Array} of source lines for this block.\n */\nBlock.$$proto.getSourceLines = function () {\n  return this.lines;\n};\n\n// AbstractNode API\n\n/**\n * @namespace\n */\nvar AbstractNode = Opal.Asciidoctor.AbstractNode;\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.getAttributes = function () {\n  return fromHash(this.attributes);\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.getAttribute = function (name, defaultValue, inherit) {\n  var value = this.$attr(name, defaultValue, inherit);\n  return value === Opal.nil ? undefined : value;\n};\n\n/**\n * Check whether the specified attribute is present on this node.\n *\n * @memberof AbstractNode\n * @returns {boolean} true if the attribute is present, otherwise false\n */\nAbstractNode.$$proto.hasAttribute = function (name) {\n  return name in this.attributes.$$smap;\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.isAttribute = function (name, expectedValue, inherit) {\n  var result = this['$attr?'](name, expectedValue, inherit);\n  return result === Opal.nil ? false : result;\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.setAttribute = function (name, value, overwrite) {\n  if (typeof overwrite === 'undefined') overwrite = true;\n  return this.$set_attr(name, value, overwrite);\n};\n\n/**\n * Remove the attribute from the current node.\n * @param {string} name - The String attribute name to remove\n * @returns {string} - returns the previous {String} value, or undefined if the attribute was not present.\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.removeAttribute = function (name) {\n  var value = this.$remove_attr(name);\n  return value === Opal.nil ? undefined : value;\n};\n\n/**\n * Get the {@link Document} to which this node belongs.\n *\n * @memberof AbstractNode\n * @returns {Document} - returns the {@link Document} object to which this node belongs.\n */\nAbstractNode.$$proto.getDocument = function () {\n  return this.document;\n};\n\n/**\n * Get the {@link AbstractNode} to which this node is attached.\n *\n * @memberof AbstractNode\n * @returns {AbstractNode} - returns the {@link AbstractNode} object to which this node is attached,\n * or undefined if this node has no parent.\n */\nAbstractNode.$$proto.getParent = function () {\n  var parent = this.parent;\n  return parent === Opal.nil ? undefined : parent;\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.isInline = function () {\n  return this['$inline?']();\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.isBlock = function () {\n  return this['$block?']();\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.isRole = function (expected) {\n  return this['$role?'](expected);\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.getRole = function () {\n  return this.$role();\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.hasRole = function (name) {\n  return this['$has_role?'](name);\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.getRoles = function () {\n  return this.$roles();\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.addRole = function (name) {\n  return this.$add_role(name);\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.removeRole = function (name) {\n  return this.$remove_role(name);\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.isReftext = function () {\n  return this['$reftext?']();\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.getReftext = function () {\n  return this.$reftext();\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.getContext = function () {\n  var context = this.context;\n  // Automatically convert Opal pseudo-symbol to String\n  return typeof context === 'string' ? context : context.toString();\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.getId = function () {\n  return this.id;\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.isOption = function (name) {\n  return this['$option?'](name);\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.setOption = function (name) {\n  return this.$set_option(name);\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.getIconUri = function (name) {\n  return this.$icon_uri(name);\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.getMediaUri = function (target, assetDirKey) {\n  return this.$media_uri(target, assetDirKey);\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.getImageUri = function (targetImage, assetDirKey) {\n  return this.$image_uri(targetImage, assetDirKey);\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.getConverter = function () {\n  return this.$converter();\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.readContents = function (target, options) {\n  return this.$read_contents(target, toHash(options));\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.readAsset = function (path, options) {\n  return this.$read_asset(path, toHash(options));\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.normalizeWebPath = function (target, start, preserveTargetUri) {\n  return this.$normalize_web_path(target, start, preserveTargetUri);\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.normalizeSystemPath = function (target, start, jail, options) {\n  return this.$normalize_system_path(target, start, jail, toHash(options));\n};\n\n/**\n * @memberof AbstractNode\n */\nAbstractNode.$$proto.normalizeAssetPath = function (assetRef, assetName, autoCorrect) {\n  return this.$normalize_asset_path(assetRef, assetName, autoCorrect);\n};\n\n// Document API\n\n/**\n * @namespace\n * @extends AbstractBlock\n */\nvar Document = Opal.Asciidoctor.Document;\n\n/**\n * @returns {string} - returns the level-0 section\n * @memberof Document\n */\nDocument.$$proto.getHeader = function () {\n  return this.header;\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.setAttribute = function (name, value) {\n  return this.$set_attribute(name, value);\n};\n\n/**\n\n * @memberof Document\n */\nDocument.$$proto.removeAttribute = function (name) {\n  this.attributes.$delete(name);\n  this.attribute_overrides.$delete(name);\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.convert = function (options) {\n  var result = this.$convert(toHash(options));\n  return result === Opal.nil ? '' : result;\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.write = function (output, target) {\n  return this.$write(output, target);\n};\n\n/**\n * @returns {string} - returns the full name of the author as a String\n * @memberof Document\n */\nDocument.$$proto.getAuthor = function () {\n  return this.$author();\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getSource = function () {\n  return this.$source();\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getSourceLines = function () {\n  return this.$source_lines();\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.isNested = function () {\n  return this['$nested?']();\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.hasFootnotes = function () {\n  return this['$footnotes?']();\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getFootnotes = function () {\n  return this.$footnotes();\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.isEmbedded = function () {\n  return this['$embedded?']();\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.hasExtensions = function () {\n  return this['$extensions?']();\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getDoctype = function () {\n  return this.doctype;\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getBackend = function () {\n  return this.backend;\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.isBasebackend = function (base) {\n  return this['$basebackend?'](base);\n};\n\n/**\n * Get the title explicitly defined in the document attributes.\n * @returns {string}\n * @see {@link AbstractNode#getAttributes}\n * @memberof Document\n */\nDocument.$$proto.getTitle = function () {\n  var title = this.$title();\n  return title === Opal.nil ? undefined : title;\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.setTitle = function (title) {\n  return this['$title='](title);\n};\n\n/**\n * @memberof Document\n * @returns {Document/Title} - returns a {@link Document/Title}\n */\nDocument.$$proto.getDocumentTitle = function (options) {\n  var doctitle = this.$doctitle(toHash(options));\n  return doctitle === Opal.nil ? undefined : doctitle;\n};\n\n/**\n * @memberof Document\n * @see {@link Document#getDocumentTitle}\n */\nDocument.$$proto.getDoctitle = Document.$$proto.getDocumentTitle;\n\n/**\n * Get the document catalog Hash.\n * @memberof Document\n */\nDocument.$$proto.getCatalog = function () {\n  return fromHash(this.catalog);\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getReferences = Document.$$proto.getCatalog;\n\n/**\n * Get the document revision date from document header (document attribute <code>revdate</code>).\n * @memberof Document\n */\nDocument.$$proto.getRevisionDate = function () {\n  return this.getAttribute('revdate');\n};\n\n/**\n * @memberof Document\n * @see Document#getRevisionDate\n */\nDocument.$$proto.getRevdate = function () {\n  return this.getRevisionDate();\n};\n\n/**\n * Get the document revision number from document header (document attribute <code>revnumber</code>).\n * @memberof Document\n */\nDocument.$$proto.getRevisionNumber = function () {\n  return this.getAttribute('revnumber');\n};\n\n/**\n * Get the document revision remark from document header (document attribute <code>revremark</code>).\n * @memberof Document\n */\nDocument.$$proto.getRevisionRemark = function () {\n  return this.getAttribute('revremark');\n};\n\n// private constructor\nDocument.RevisionInfo = function (date, number, remark) {\n  this.date = date;\n  this.number = number;\n  this.remark = remark;\n};\n\n/**\n * @class\n * @namespace\n * @module Document/RevisionInfo\n */\nvar RevisionInfo = Document.RevisionInfo;\n\n/**\n * Get the document revision date from document header (document attribute <code>revdate</code>).\n * @memberof Document/RevisionInfo\n */\nRevisionInfo.prototype.getDate = function () {\n  return this.date;\n};\n\n/**\n * Get the document revision number from document header (document attribute <code>revnumber</code>).\n * @memberof Document/RevisionInfo\n */\nRevisionInfo.prototype.getNumber = function () {\n  return this.number;\n};\n\n/**\n * Get the document revision remark from document header (document attribute <code>revremark</code>).\n * A short summary of changes in this document revision.\n * @memberof Document/RevisionInfo\n */\nRevisionInfo.prototype.getRemark = function () {\n  return this.remark;\n};\n\n/**\n * @memberof Document/RevisionInfo\n * @returns {boolean} - returns true if the revision info is empty (ie. not defined), otherwise false\n */\nRevisionInfo.prototype.isEmpty = function () {\n  return this.date === undefined && this.number === undefined && this.remark === undefined;\n};\n\n/**\n * @memberof Document\n * @returns {Document/RevisionInfo} - returns a {@link Document/RevisionInfo}\n */\nDocument.$$proto.getRevisionInfo = function () {\n  return new Document.RevisionInfo(this.getRevisionDate(), this.getRevisionNumber(), this.getRevisionRemark());\n};\n\n/**\n * @memberof Document\n * @returns {boolean} - returns true if the document contains revision info, otherwise false\n */\nDocument.$$proto.hasRevisionInfo = function () {\n  var revisionInfo = this.getRevisionInfo();\n  return !revisionInfo.isEmpty();\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getNotitle = function () {\n  return this.$notitle();\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getNoheader = function () {\n  return this.$noheader();\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getNofooter = function () {\n  return this.$nofooter();\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.hasHeader = function () {\n  return this['$header?']();\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.deleteAttribute = function (name) {\n  return this.$delete_attribute(name);\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.isAttributeLocked = function (name) {\n  return this['$attribute_locked?'](name);\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.parse = function (data) {\n  return this.$parse(data);\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getDocinfo = function (docinfoLocation, suffix) {\n  return this.$docinfo(docinfoLocation, suffix);\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.hasDocinfoProcessors = function (docinfoLocation) {\n  return this['$docinfo_processors?'](docinfoLocation);\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.counterIncrement = function (counterName, block) {\n  return this.$counter_increment(counterName, block);\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.counter = function (name, seed) {\n  return this.$counter(name, seed);\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getSafe = function () {\n  return this.safe;\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getCompatMode = function () {\n  return this.compat_mode;\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getSourcemap = function () {\n  return this.sourcemap;\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getCounters = function () {\n  return fromHash(this.counters);\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getCallouts = function () {\n  return this.$callouts();\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getBaseDir = function () {\n  return this.base_dir;\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getOptions = function () {\n  return fromHash(this.options);\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getOutfilesuffix = function () {\n  return this.outfilesuffix;\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getParentDocument = function () {\n  return this.parent_document;\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getReader = function () {\n  return this.reader;\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getConverter = function () {\n  return this.converter;\n};\n\n/**\n * @memberof Document\n */\nDocument.$$proto.getExtensions = function () {\n  return this.extensions;\n};\n\n// Document.Title API\n\n/**\n * @namespace\n * @module Document/Title\n */\nvar Title = Document.Title;\n\n/**\n * @memberof Document/Title\n */\nTitle.$$proto.getMain = function () {\n  return this.main;\n};\n\n/**\n * @memberof Document/Title\n */\nTitle.$$proto.getCombined = function () {\n  return this.combined;\n};\n\n/**\n * @memberof Document/Title\n */\nTitle.$$proto.getSubtitle = function () {\n  var subtitle = this.subtitle;\n  return subtitle === Opal.nil ? undefined : subtitle;\n};\n\n/**\n * @memberof Document/Title\n */\nTitle.$$proto.isSanitized = function () {\n  var sanitized = this['$sanitized?']();\n  return sanitized === Opal.nil ? false : sanitized;\n};\n\n/**\n * @memberof Document/Title\n */\nTitle.$$proto.hasSubtitle = function () {\n  return this['$subtitle?']();\n};\n\n// Inline API\n\n/**\n * @namespace\n * @extends AbstractNode\n */\nvar Inline = Opal.Asciidoctor.Inline;\n\n/**\n * Get the converted content for this inline node.\n *\n * @memberof Inline\n * @returns {string} - returns the converted String content for this inline node\n */\nInline.$$proto.convert = function () {\n  return this.$convert();\n};\n\n/**\n * Get the converted String text of this Inline node, if applicable.\n *\n * @memberof Inline\n * @returns {string} - returns the converted String text for this Inline node, or undefined if not applicable for this node.\n */\nInline.$$proto.getText = function () {\n  var text = this.$text();\n  return text === Opal.nil ? undefined : text;\n};\n\n/**\n * Get the String sub-type (aka qualifier) of this Inline node.\n *\n * This value is used to distinguish different variations of the same node\n * category, such as different types of anchors.\n *\n * @memberof Inline\n * @returns {string} - returns the string sub-type of this Inline node.\n */\nInline.$$proto.getType = function () {\n  return this.$type();\n};\n\n/**\n * Get the primary String target of this Inline node.\n *\n * @memberof Inline\n * @returns {string} - returns the string target of this Inline node.\n */\nInline.$$proto.getTarget = function () {\n  var target = this.$target();\n  return target === Opal.nil ? undefined : target;\n};\n\n// List API\n\n/** @namespace */\nvar List = Opal.Asciidoctor.List;\n\n/**\n * Get the Array of {@link ListItem} nodes for this {@link List}.\n *\n * @memberof List\n * @returns {Array} - returns an Array of {@link ListItem} nodes.\n */\nList.$$proto.getItems = function () {\n  return this.blocks;\n};\n\n// ListItem API\n\n/** @namespace */\nvar ListItem = Opal.Asciidoctor.ListItem;\n\n/**\n * Get the converted String text of this ListItem node.\n *\n * @memberof ListItem\n * @returns {string} - returns the converted String text for this ListItem node.\n */\nListItem.$$proto.getText = function () {\n  return this.$text();\n};\n\n// Reader API\n\n/** @namespace */\nvar Reader = Opal.Asciidoctor.Reader;\n\n/**\n * @memberof Reader\n */\nReader.$$proto.pushInclude = function (data, file, path, lineno, attributes) {\n  return this.$push_include(data, file, path, lineno, attributes);\n};\n\n/**\n * Get the current location of the reader's cursor, which encapsulates the\n * file, dir, path, and lineno of the file being read.\n *\n * @memberof Reader\n */\nReader.$$proto.getCursor = function () {\n  return this.$cursor();\n};\n\n/**\n * Get a copy of the remaining {Array} of String lines managed by this Reader.\n *\n * @memberof Reader\n * @returns {Array} - returns A copy of the String {Array} of lines remaining in this Reader.\n */\nReader.$$proto.getLines = function () {\n  return this.$lines();\n};\n\n/**\n * Get the remaining lines managed by this Reader as a String.\n *\n * @memberof Reader\n * @returns {string} - returns The remaining lines managed by this Reader as a String (joined by linefeed characters).\n */\nReader.$$proto.getString = function () {\n  return this.$string();\n};\n\n// Cursor API\n\n/** @namespace */\nvar Cursor = Opal.Asciidoctor.Reader.Cursor;\n\n/**\n * Get the file associated to the cursor.\n * @memberof Cursor\n */\nCursor.$$proto.getFile = function () {\n  var file = this.file;\n  return file === Opal.nil ? undefined : file;\n};\n\n/**\n * Get the directory associated to the cursor.\n * @memberof Cursor\n * @returns {string} - returns the directory associated to the cursor\n */\nCursor.$$proto.getDirectory = function () {\n  var dir = this.dir;\n  return dir === Opal.nil ? undefined : dir;\n};\n\n/**\n * Get the path associated to the cursor.\n * @memberof Cursor\n * @returns {string} - returns the path associated to the cursor (or '<stdin>')\n */\nCursor.$$proto.getPath = function () {\n  var path = this.path;\n  return path === Opal.nil ? undefined : path;\n};\n\n/**\n * Get the line number of the cursor.\n * @memberof Cursor\n * @returns {number} - returns the line number of the cursor\n */\nCursor.$$proto.getLineNumber = function () {\n  return this.lineno;\n};\n\n// Logger API (available in Asciidoctor 1.5.7+)\n// REMIND: we are using \"skip_missing\" because this API is only available starting with Asciidoctor 1.5.7\n\n/**\n * @namespace\n */\nvar LoggerManager = Opal.const_get_qualified(Opal.Asciidoctor, 'LoggerManager', true);\n\n// Alias\nOpal.Asciidoctor.LoggerManager = LoggerManager;\n\nif (LoggerManager) {\n  LoggerManager.getLogger = function () {\n    return this.$logger();\n  };\n\n  LoggerManager.setLogger = function (logger) {\n    this.logger = logger;\n  };\n}\n\n/**\n * @namespace\n */\nvar MemoryLogger = Opal.const_get_qualified(Opal.Asciidoctor, 'MemoryLogger', true);\n\n// Alias\nOpal.Asciidoctor.MemoryLogger = MemoryLogger;\n\nif (MemoryLogger) {\n  MemoryLogger.$$proto.getMessages = function () {\n    var messages = this.messages;\n    var result = [];\n    for (var i = 0; i < messages.length; i++) {\n      var message = messages[i];\n      var messageObject = fromHash(message);\n      // also convert the message attribute\n      messageObject.message = fromHash(messageObject.message);\n      result.push(messageObject);\n    }\n    return result;\n  };\n}\n\n// Extensions API\n\n/**\n * @private\n */\nvar toBlock = function (block) {\n  // arity is a mandatory field\n  block.$$arity = block.length;\n  return block;\n};\n\nvar registerExtension = function (registry, type, processor, name) {\n  if (typeof processor === 'function') {\n    return Opal.send(registry, type, name && [name], toBlock(processor));\n  } else {\n    return registry['$' + type](processor, name);\n  }\n};\n\n/**\n * @namespace\n * @description\n * Extensions provide a way to participate in the parsing and converting\n * phases of the AsciiDoc processor or extend the AsciiDoc syntax.\n *\n * The various extensions participate in AsciiDoc processing as follows:\n *\n * 1. After the source lines are normalized, {{@link Extensions/Preprocessor}}s modify or replace\n *    the source lines before parsing begins. {{@link Extensions/IncludeProcessor}}s are used to\n *    process include directives for targets which they claim to handle.\n * 2. The Parser parses the block-level content into an abstract syntax tree.\n *    Custom blocks and block macros are processed by associated {{@link Extensions/BlockProcessor}}s\n *    and {{@link Extensions/BlockMacroProcessor}}s, respectively.\n * 3. {{@link Extensions/TreeProcessor}}s are run on the abstract syntax tree.\n * 4. Conversion of the document begins, at which point inline markup is processed\n *    and converted. Custom inline macros are processed by associated {InlineMacroProcessor}s.\n * 5. {{@link Extensions/Postprocessor}}s modify or replace the converted document.\n * 6. The output is written to the output stream.\n *\n * Extensions may be registered globally using the {Extensions.register} method\n * or added to a custom {Registry} instance and passed as an option to a single\n * Asciidoctor processor.\n *\n * @example\n * Opal.Asciidoctor.Extensions.register(function () {\n *   this.block(function () {\n *     var self = this;\n *     self.named('shout');\n *     self.onContext('paragraph');\n *     self.process(function (parent, reader) {\n *       var lines = reader.getLines().map(function (l) { return l.toUpperCase(); });\n *       return self.createBlock(parent, 'paragraph', lines);\n *     });\n *   });\n * });\n */\nvar Extensions = Opal.const_get_qualified(Opal.Asciidoctor, 'Extensions');\n\n// Alias\nOpal.Asciidoctor.Extensions = Extensions;\n\n/**\n * Create a new {@link Extensions/Registry}.\n * @param {string} name\n * @param {function} block\n * @memberof Extensions\n * @returns {Extensions/Registry} - returns a {@link Extensions/Registry}\n */\nExtensions.create = function (name, block) {\n  if (typeof name === 'function' && typeof block === 'undefined') {\n    return Opal.send(this, 'build_registry', null, toBlock(name));\n  } else if (typeof block === 'function') {\n    return Opal.send(this, 'build_registry', [name], toBlock(block));\n  } else {\n    return this.$build_registry();\n  }\n};\n\n/**\n * @memberof Extensions\n */\nExtensions.register = function (name, block) {\n  if (typeof name === 'function' && typeof block === 'undefined') {\n    return Opal.send(this, 'register', null, toBlock(name));\n  } else {\n    return Opal.send(this, 'register', [name], toBlock(block));\n  }\n};\n\n/**\n * Get statically-registerd extension groups.\n * @memberof Extensions\n */\nExtensions.getGroups = function () {\n  return fromHash(this.$groups());\n};\n\n/**\n * Unregister all statically-registered extension groups.\n * @memberof Extensions\n */\nExtensions.unregisterAll = function () {\n  this.$unregister_all();\n};\n\n/**\n * Unregister the specified statically-registered extension groups.\n *\n * NOTE Opal cannot delete an entry from a Hash that is indexed by symbol, so\n * we have to resort to using low-level operations in this method.\n *\n * @memberof Extensions\n */\nExtensions.unregister = function () {\n  var names = Array.prototype.concat.apply([], arguments);\n  var groups = this.$groups();\n  var groupNameIdx = {};\n  for (var i = 0, groupSymbolNames = groups.$$keys; i < groupSymbolNames.length; i++) {\n    var groupSymbolName = groupSymbolNames[i];\n    groupNameIdx[groupSymbolName.toString()] = groupSymbolName;\n  }\n  for (var j = 0; j < names.length; j++) {\n    var groupStringName = names[j];\n    if (groupStringName in groupNameIdx) Opal.hash_delete(groups, groupNameIdx[groupStringName]);\n  }\n};\n\n/**\n * @namespace\n * @module Extensions/Registry\n */\nvar Registry = Extensions.Registry;\n\n/**\n * @memberof Extensions/Registry\n */\nRegistry.$$proto.getGroups = Extensions.getGroups;\n\n/**\n * @memberof Extensions/Registry\n */\nRegistry.$$proto.unregisterAll = function () {\n  this.groups = Opal.hash();\n};\n\n/**\n * @memberof Extensions/Registry\n */\nRegistry.$$proto.unregister = Extensions.unregister;\n\n/**\n * @memberof Extensions/Registry\n */\nRegistry.$$proto.block = function (name, processor) {\n  if (arguments.length === 1) {\n    processor = name;\n    name = null;\n  }\n  return registerExtension(this, 'block', processor, name);\n};\n\n/**\n * @memberof Extensions/Registry\n */\nRegistry.$$proto.inlineMacro = function (name, processor) {\n  if (arguments.length === 1) {\n    processor = name;\n    name = null;\n  }\n  return registerExtension(this, 'inline_macro', processor, name);\n};\n\n/**\n * @memberof Extensions/Registry\n */\nRegistry.$$proto.includeProcessor = function (processor) {\n  return registerExtension(this, 'include_processor', processor);\n};\n\n/**\n * @memberof Extensions/Registry\n */\nRegistry.$$proto.blockMacro = function (name, processor) {\n  if (arguments.length === 1) {\n    processor = name;\n    name = null;\n  }\n  return registerExtension(this, 'block_macro', processor, name);\n};\n\n/**\n * @memberof Extensions/Registry\n */\nRegistry.$$proto.treeProcessor = function (name, processor) {\n  if (arguments.length === 1) {\n    processor = name;\n    name = null;\n  }\n  return registerExtension(this, 'tree_processor', processor, name);\n};\n\n/**\n * @memberof Extensions/Registry\n */\nRegistry.$$proto.postprocessor = function (name, processor) {\n  if (arguments.length === 1) {\n    processor = name;\n    name = null;\n  }\n  return registerExtension(this, 'postprocessor', processor, name);\n};\n\n/**\n * @memberof Extensions/Registry\n */\nRegistry.$$proto.preprocessor = function (name, processor) {\n  if (arguments.length === 1) {\n    processor = name;\n    name = null;\n  }\n  return registerExtension(this, 'preprocessor', processor, name);\n};\n\n/**\n * @memberof Extensions/Registry\n */\n\nRegistry.$$proto.docinfoProcessor = function (name, processor) {\n  if (arguments.length === 1) {\n    processor = name;\n    name = null;\n  }\n  return registerExtension(this, 'docinfo_processor', processor, name);\n};\n\n/**\n * @namespace\n * @module Extensions/Processor\n */\nvar Processor = Extensions.Processor;\n\n/**\n * @memberof Extensions/Processor\n */\nProcessor.$$proto.process = function (block) {\n  return Opal.send(this, 'process', null, toBlock(block));\n};\n\n/**\n * @memberof Extensions/Processor\n */\nProcessor.$$proto.named = function (name) {\n  return this.$named(name);\n};\n\n/**\n * @memberof Extensions/Processor\n */\nProcessor.$$proto.createBlock = function (parent, context, source, attrs, opts) {\n  return this.$create_block(parent, context, source, toHash(attrs), toHash(opts));\n};\n\n/**\n * @memberof Extensions/Processor\n */\nProcessor.$$proto.createImageBlock = function (parent, attrs, opts) {\n  return this.$create_image_block(parent, toHash(attrs), toHash(opts));\n};\n\n/**\n * @memberof Extensions/Processor\n */\nProcessor.$$proto.createInline = function (parent, context, text, opts) {\n  return this.$create_inline(parent, context, text, toHash(opts));\n};\n\n/**\n * @memberof Extensions/Processor\n */\nProcessor.$$proto.parseContent = function (parent, content, attrs) {\n  return this.$parse_content(parent, content, attrs);\n};\n\n/**\n * @memberof Extensions/Processor\n */\nProcessor.$$proto.positionalAttributes = function (value) {\n  return this.$positional_attrs(value);\n};\n\n/**\n * @namespace\n * @module Extensions/BlockProcessor\n */\nvar BlockProcessor = Extensions.BlockProcessor;\n\n/**\n * @memberof Extensions/BlockProcessor\n */\nBlockProcessor.$$proto.onContext = function (context) {\n  return this.$on_context(context);\n};\n\n/**\n * @memberof Extensions/BlockProcessor\n */\nBlockProcessor.$$proto.onContexts = function () {\n  return this.$on_contexts(Array.prototype.slice.call(arguments));\n};\n\n/**\n * @namespace\n * @module Extensions/BlockMacroProcessor\n */\n// eslint-disable-next-line no-unused-vars\nvar BlockMacroProcessor = Extensions.BlockMacroProcessor;\n\n/**\n * @namespace\n * @module Extensions/IncludeProcessor\n */\nvar IncludeProcessor = Extensions.IncludeProcessor;\n\n/**\n * @memberof Extensions/IncludeProcessor\n */\nIncludeProcessor.$$proto.handles = function (block) {\n  return Opal.send(this, 'handles?', null, toBlock(block));\n};\n\n/**\n * @namespace\n * @module Extensions/TreeProcessor\n */\n// eslint-disable-next-line no-unused-vars\nvar TreeProcessor = Extensions.TreeProcessor;\n\n/**\n * @namespace\n * @module Extensions/Postprocessor\n */\n// eslint-disable-next-line no-unused-vars\nvar Postprocessor = Extensions.Postprocessor;\n\n/**\n * @namespace\n * @module Extensions/Preprocessor\n */\n// eslint-disable-next-line no-unused-vars\nvar Preprocessor = Extensions.Preprocessor;\n\n/**\n * @namespace\n * @module Extensions/DocinfoProcessor\n */\nvar DocinfoProcessor = Extensions.DocinfoProcessor;\n\n/**\n * @memberof Extensions/DocinfoProcessor\n */\nDocinfoProcessor.$$proto.atLocation = function (value) {\n  this.$at_location(value);\n};\n\n// Converter API\n\n/**\n * @namespace\n * @module Converter\n */\nvar Converter = Opal.const_get_qualified(Opal.Asciidoctor, 'Converter');\n\n// Alias\nOpal.Asciidoctor.Converter = Converter;\n\n/**\n * Convert the specified node.\n *\n * @param {AbstractNode} node - the AbstractNode to convert\n * @param {string} transform - an optional String transform that hints at\n * which transformation should be applied to this node.\n * @param {Object} opts - a JSON of options that provide additional hints about\n * how to convert the node (default: {})\n * @returns the {Object} result of the conversion, typically a {string}.\n * @memberof Converter\n */\nConverter.$$proto.convert = function (node, transform, opts) {\n  return this.$convert(node, transform, toHash(opts));\n};\n\n// The built-in converter doesn't include Converter, so we have to force it\nConverter.BuiltIn.$$proto.convert = Converter.$$proto.convert;\n\n// Converter Factory API\n\n/**\n * @namespace\n * @module Converter/Factory\n */\nvar ConverterFactory = Opal.Asciidoctor.Converter.Factory;\n\n/**\n * Retrieves the singleton instance of the converter factory.\n *\n * @param {boolean} initialize - instantiate the singleton if it has not yet\n * been instantiated. If this value is false and the singleton has not yet been\n * instantiated, this method returns a fresh instance.\n * @returns {Converter/Factory} an instance of the converter factory.\n * @memberof Converter/Factory\n */\nConverterFactory.getDefault = function (initialize) {\n  return this.$default(initialize);\n};\n\n/**\n * Create an instance of the converter bound to the specified backend.\n *\n * @param {string} backend - look for a converter bound to this keyword.\n * @param {Object} opts - a JSON of options to pass to the converter (default: {})\n * @returns {Converter} - a converter instance for converting nodes in an Asciidoctor AST.\n * @memberof Converter/Factory\n */\nConverterFactory.$$proto.create = function (backend, opts) {\n  return this.$create(backend, toHash(opts));\n};\n\n\nvar ASCIIDOCTOR_JS_VERSION = '1.5.6';\n\n  /**\n   * Get Asciidoctor.js version number.\n   *\n   * @memberof Asciidoctor\n   * @returns {string} - returns the version number of Asciidoctor.js.\n   */\n  Asciidoctor.$$proto.getVersion = function () {\n    return ASCIIDOCTOR_JS_VERSION;\n  };\n  return Opal.Asciidoctor;\n}));\n",
            "type": "application/javascript",
            "title": "$:/plugins/bimlas/asciidoctor/asciidoctor.js",
            "module-type": "library"
        },
        "$:/plugins/bimlas/asciidoctor/jsonml-dom.js": {
            "text": "/*\njsonml-dom.js\nHTML to JsonML utility\n\nCreated: 2007-02-15-2235\nModified: 2012-11-03-2051\n\nCopyright (c)2006-2012 Stephen M. McKamey\nDistributed under The MIT License: http://jsonml.org/license\n\nhttps://github.com/mckamey/jsonml/blob/master/jsonml-dom.js\n*/\n\n(function(){\n    var JsonML = JsonML || {};\n\n    'use strict';\n\n    var addChildren = function(/*DOM*/ elem, /*function*/ filter, /*JsonML*/ jml) {\n        if (elem.hasChildNodes()) {\n            for (var i=0; i<elem.childNodes.length; i++) {\n                var child = elem.childNodes[i];\n                child = fromHTML(child, filter);\n                if (child) {\n                    jml.push(child);\n                }\n            }\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * @param {Node} elem\n     * @param {function} filter\n     * @return {array} JsonML\n     */\n    var fromHTML = JsonML.fromHTML = function(elem, filter) {\n        if (!elem || !elem.nodeType) {\n            // free references\n            return (elem = null);\n        }\n\n        var i, jml;\n        switch (elem.nodeType) {\n            case 1:  // element\n            case 9:  // document\n            case 11: // documentFragment\n                jml = [elem.tagName.toLowerCase()||''];\n\n                var attr = elem.attributes,\n                    props = {},\n                    hasAttrib = false;\n\n                for (i=0; attr && i<attr.length; i++) {\n                    if (attr[i].specified) {\n                        if (attr[i].name === 'style') {\n                            props.style = elem.style.cssText || attr[i].value;\n                        } else if ('string' === typeof attr[i].value) {\n                            props[attr[i].name] = attr[i].value;\n                        }\n                        hasAttrib = true;\n                    }\n                }\n                if (hasAttrib) {\n                    jml.push(props);\n                }\n\n                var child;\n                switch (jml[0].toLowerCase()) {\n                    case 'frame':\n                    case 'iframe':\n                        try {\n                            if ('undefined' !== typeof elem.contentDocument) {\n                                // W3C\n                                child = elem.contentDocument;\n                            } else if ('undefined' !== typeof elem.contentWindow) {\n                                // Microsoft\n                                child = elem.contentWindow.document;\n                            } else if ('undefined' !== typeof elem.document) {\n                                // deprecated\n                                child = elem.document;\n                            }\n\n                            child = fromHTML(child, filter);\n                            if (child) {\n                                jml.push(child);\n                            }\n                        } catch (ex) {}\n                        break;\n                    case 'style':\n                        child = elem.styleSheet && elem.styleSheet.cssText;\n                        if (child && 'string' === typeof child) {\n                            // unwrap comment blocks\n                            child = child.replace('<!--', '').replace('-->', '');\n                            jml.push(child);\n                        } else if (elem.hasChildNodes()) {\n                            for (i=0; i<elem.childNodes.length; i++) {\n                                child = elem.childNodes[i];\n                                child = fromHTML(child, filter);\n                                if (child && 'string' === typeof child) {\n                                    // unwrap comment blocks\n                                    child = child.replace('<!--', '').replace('-->', '');\n                                    jml.push(child);\n                                }\n                            }\n                        }\n                        break;\n                    case 'input':\n                        addChildren(elem, filter, jml);\n                        child = (elem.type !== 'password') && elem.value;\n                        if (child) {\n                            if (!hasAttrib) {\n                                // need to add an attribute object\n                                jml.shift();\n                                props = {};\n                                jml.unshift(props);\n                                jml.unshift(elem.tagName||'');\n                            }\n                            props.value = child;\n                        }\n                        break;\n                    case 'textarea':\n                        if (!addChildren(elem, filter, jml)) {\n                            child = elem.value || elem.innerHTML;\n                            if (child && 'string' === typeof child) {\n                                jml.push(child);\n                            }\n                        }\n                        break;\n                    default:\n                        addChildren(elem, filter, jml);\n                        break;\n                }\n\n                // filter result\n                if ('function' === typeof filter) {\n                    jml = filter(jml, elem);\n                }\n\n                // free references\n                elem = null;\n                return jml;\n            case 3: // text node, or a simple newline in the case of Asciidoctor\n                    // See the .childNodes of a <div> element\n                    // https://stackoverflow.com/a/18850683\n            case 4: // CDATA node\n                var str = String(elem.nodeValue.replace(/^\\n$/, ''));\n                // free references\n                elem = null;\n                return str;\n            case 10: // doctype\n                jml = ['!'];\n\n                var type = ['DOCTYPE', (elem.name || 'html').toLowerCase()];\n\n                if (elem.publicId) {\n                    type.push('PUBLIC', '\"' + elem.publicId + '\"');\n                }\n\n                if (elem.systemId) {\n                    type.push('\"' + elem.systemId + '\"');\n                }\n\n                jml.push(type.join(' '));\n\n                // filter result\n                if ('function' === typeof filter) {\n                    jml = filter(jml, elem);\n                }\n\n                // free references\n                elem = null;\n                return jml;\n            case 8: // comment node\n                if ((elem.nodeValue||'').indexOf('DOCTYPE') !== 0) {\n                    // free references\n                    elem = null;\n                    return null;\n                }\n\n                jml = ['!',\n                    elem.nodeValue];\n\n                // filter result\n                if ('function' === typeof filter) {\n                    jml = filter(jml, elem);\n                }\n\n                // free references\n                elem = null;\n                return jml;\n            default: // etc.\n                // free references\n                return (elem = null);\n        }\n    };\n\n    /**\n     * @param {string} html HTML text\n     * @param {function} filter\n     * @return {array} JsonML\n     */\n    var fromHTMLText = JsonML.fromHTMLText = function(html, filter) {\n        var elem = document.createElement('div');\n        elem.innerHTML = html;\n\n        var jml = fromHTML(elem, filter);\n\n        // free references\n        elem = null;\n\n        // make wrapper a document fragment\n        jml.shift();\n        return jml;\n    };\n\n    module.exports = JsonML;\n})();\n",
            "type": "application/javascript",
            "title": "$:/plugins/bimlas/asciidoctor/jsonml-dom.js",
            "module-type": "library"
        },
        "$:/plugins/bimlas/asciidoctor/images/new-asciidoctor-button": {
            "title": "$:/plugins/bimlas/asciidoctor/images/new-asciidoctor-button",
            "tags": "$:/tags/Image",
            "text": "<svg class=\"tc-image-new-asciidoctor-button tc-image-button\" viewBox=\"0 0 128 128\" width=\"22pt\" height=\"22pt\">\n    <g fill-rule=\"evenodd\">\n        <path d=\" M 72.449 0.001 C 70.69 0.034 69.118 1.062 68.441 2.621 L 41.941 63.824 C 41.291 65.237 41.488 66.876 42.456 68.109 C 43.423 69.342 45.01 69.975 46.603 69.764 C 48.196 69.553 49.545 68.531 50.129 67.093 L 72.503 15.414 L 119.43 125.282 C 120.011 126.718 121.354 127.742 122.943 127.958 C 124.532 128.174 126.119 127.549 127.092 126.323 C 128.065 125.098 128.273 123.464 127.635 122.049 L 76.635 2.642 C 75.941 1.017 74.278 -0.032 72.449 0.001 L 72.449 0.001 Z \" />\n        <path d=\" M 34.884 86.813 C 33.104 86.849 31.519 87.904 30.858 89.491 L 16.773 122.03 C 16.145 123.438 16.353 125.062 17.318 126.282 C 18.283 127.502 19.857 128.13 21.438 127.927 C 23.02 127.723 24.365 126.72 24.962 125.299 L 39.048 92.76 C 39.647 91.43 39.5 89.898 38.658 88.694 C 37.815 87.491 36.393 86.782 34.884 86.813 L 34.884 86.813 Z \" />\n        <path d=\" M 4.523 84.132 C 2.918 84.102 1.421 84.906 0.609 86.236 C -0.203 87.566 -0.203 89.214 0.609 90.543 C 1.421 91.873 2.918 92.678 4.523 92.647 L 55.733 92.647 C 57.339 92.678 58.836 91.873 59.648 90.543 C 60.46 89.214 60.46 87.566 59.648 86.236 C 58.836 84.906 57.339 84.102 55.733 84.132 L 4.523 84.132 Z \" />\n        <path d=\" M 13.898 63.918 C 12.292 63.887 10.795 64.691 9.983 66.021 C 9.17 67.351 9.17 68.999 9.983 70.329 C 10.795 71.659 12.292 72.464 13.898 72.432 L 65.103 72.432 C 66.708 72.464 68.206 71.659 69.018 70.329 C 69.83 68.999 69.83 67.351 69.018 66.021 C 68.206 64.691 66.708 63.887 65.103 63.918 L 13.898 63.918 Z \" />\n    </g>\n</svg>\n"
        },
        "$:/plugins/bimlas/asciidoctor/new-asciidoctor-button": {
            "title": "$:/plugins/bimlas/asciidoctor/new-asciidoctor-button",
            "tags": "$:/tags/PageControls",
            "caption": "{{$:/plugins/bimlas/asciidoctor/images/new-asciidoctor-button}} {{$:/language/Buttons/NewAsciidoctor/Caption}}",
            "description": "{{$:/language/Buttons/NewAsciidoctor/Hint}}",
            "list-after": "$:/core/ui/Buttons/new-tiddler",
            "text": "<$button tooltip={{$:/language/Buttons/NewAsciidoctor/Hint}} aria-label={{$:/language/Buttons/NewAsciidoctor/Caption}} class=<<tv-config-toolbar-class>>>\n<$action-sendmessage $message=\"tm-new-tiddler\" type=\"text/asciidoc\"/>\n<$list filter=\"[<tv-config-toolbar-icons>prefix[yes]]\">\n{{$:/plugins/bimlas/asciidoctor/images/new-asciidoctor-button}}\n</$list>\n<$list filter=\"[<tv-config-toolbar-text>prefix[yes]]\">\n<span class=\"tc-btn-text\"><$text text={{$:/language/Buttons/NewAsciidoctor/Caption}}/></span>\n</$list>\n</$button>\n"
        },
        "$:/plugins/bimlas/asciidoctor/readme": {
            "title": "$:/plugins/bimlas/asciidoctor/readme",
            "text": "This is a TiddlyWiki plugin for parsing Asciidoctor text, based on the [[Asciidoctor.js|https://github.com/asciidoctor/asciidoctor.js]] project from Asciidoctor Project.\n\nIt is completely self-contained, and doesn't need an Internet connection in order to work. It works both in the browser and under Node.js.\n\n[[Source code|https://gitlab.com/bimlas/tw5-asciidoctor]]\n\n! Installation\n\nTo add the plugin to your own TiddlyWiki5, just drag this link to the browser window:\n\n[[$:/plugins/bimlas/asciidoctor]]\n"
        },
        "$:/plugins/bimlas/asciidoctor/usage": {
            "title": "$:/plugins/bimlas/asciidoctor/usage",
            "text": "! Asciidoctor reference\n\n* Asciidoctor quick reference: https://asciidoctor.org/docs/asciidoc-syntax-quick-reference/\n* Asciidoctor manual: https://asciidoctor.org/docs/user-manual/\n\n! Creating WikiLinks\n\nCreate wiki links with the usual Asciidoctor link syntax targeting `#` and the target tiddler title:\n\n```\nlink:#TiddlerTitle[link text]\n```\n\n! Include (transclusion)\n\nI cannot found a solution to transclude tiddlers in to Asciidoctor documents\n\n```\ninclude::TiddlerTitle[]\n```\n\nbut embedding Asciidoctor tiddlers in general ones works normally.\n\n```\n{{AsciidoctorTiddler}}\n```\n\n! Internal links\n\nThe dynamically generated intra-tiddler links does not work, try out the footnote\nin the example: TiddlyWiki interprets it as a link to another tiddler.\n\n! Drag-n-drop files\n\nAsciidoc mime type is [[not registered yet|https://github.com/asciidoctor/asciidoctor/issues/2502]], thus drag-n-drop the files does not set filetype automatically, you have to do it manually.\n"
        },
        "$:/plugins/bimlas/asciidoctor/wrapper.js": {
            "title": "$:/plugins/bimlas/asciidoctor/wrapper.js",
            "text": "/*\\\ntitle: $:/plugins/bimlas/asciidoctor/wrapper.js\ntype: application/javascript\nmodule-type: parser\n\nWraps up the Asciidoctor.js parser for use in TiddlyWiki5\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar asciidoctor_parser = require(\"$:/plugins/bimlas/asciidoctor/asciidoctor\")({\n  runtime: {\n    ioModule: 'xmlhttprequest'\n  }\n});\nvar jsonml = require(\"$:/plugins/bimlas/asciidoctor/jsonml-dom\");\n\nfunction transformNodes(nodes) {\n\tvar results = [];\n\tfor(var index=0; index<nodes.length; index++) {\n\t\tresults.push(transformNode(nodes[index]));\n\t}\n\treturn results;\n}\n\nfunction transformNode(node) {\n\tif($tw.utils.isArray(node)) {\n\t\tvar p = 0,\n\t\t\twidget = {type: \"element\", tag: node[p++]};\n\t\tif(!$tw.utils.isArray(node[p]) && typeof(node[p]) === \"object\") {\n\t\t\twidget.attributes = {};\n\t\t\t$tw.utils.each(node[p++],function(value,name) {\n\t\t\t\twidget.attributes[name] = {type: \"string\", value: value};\n\t\t\t});\n\t\t}\n\t\twidget.children = transformNodes(node.slice(p++));\n\t\t// Massage images into the image widget\n\t\tif(widget.tag === \"img\") {\n\t\t\twidget.type = \"image\";\n\t\t\tif(widget.attributes.alt) {\n\t\t\t\twidget.attributes.tooltip = widget.attributes.alt;\n\t\t\t\tdelete widget.attributes.alt;\n\t\t\t}\n\t\t\tif(widget.attributes.src) {\n\t\t\t\twidget.attributes.source = widget.attributes.src;\n\t\t\t\tdelete widget.attributes.src;\n\t\t\t}\n\t\t}\n\t\t// Convert internal links to proper wikilinks\n\t\tif (widget.tag === \"a\" && widget.attributes.href.value[0] === \"#\") {\n\t\t\twidget.type = \"link\";\n\t\t\twidget.attributes.to = widget.attributes.href;\n\t\t\tif (widget.attributes.to.type === \"string\") {\n\t\t\t\t//Remove '#' before conversion to wikilink\n\t\t\t\twidget.attributes.to.value = widget.attributes.to.value.substr(1);\n\t\t\t}\n\t\t\t//Children is fine\n\t\t\tdelete widget.tag;\n\t\t\tdelete widget.attributes.href;\n\t\t}\n\t\treturn widget;\n\t} else {\n\t\treturn {type: \"text\", text: node};\n\t}\n}\n\nvar AsciidoctorParser = function(type,text,options) {\n\tvar html_text = asciidoctor_parser.convert(text),\n\t\tnode_tree = jsonml.fromHTMLText(html_text, null),\n\t\ttiddler_tree = transformNodes(node_tree);\n\tthis.tree = tiddler_tree;\n};\n\nexports[\"text/asciidoc\"] = AsciidoctorParser;\n\n})();\n",
            "type": "application/javascript",
            "module-type": "parser"
        }
    }
}